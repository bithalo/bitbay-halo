# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Halo.ui'
#
# Created: Thu Apr 03 03:55:04 2014
#      by: PyQt4 UI code generator 4.10.4
#
# WARNING! All changes made in this file will be lost!

import sip
from PyQt4.QtNetwork import *
from PyQt4.QtWebKit import QWebView,QWebPage

from PyQt4 import QtCore, QtGui, QtWebKit, uic, Qt
from PyQt4.QtGui import QSizePolicy
import sys, os, inspect
import traceback
import os
from SimpleXMLRPCServer import SimpleXMLRPCServer
from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler

#To check for memory leaks
#import pympler

# Restrict to a particular path. This is for RPC
class RequestHandler(SimpleXMLRPCRequestHandler):
    rpc_paths = ('/RPC2',)

#This tells Halo to try and run as admin
import types

#def isUserAdmin():
#    if os.name == 'nt':
#        import ctypes
#        # WARNING: requires Windows XP SP2 or higher!
#        try:
#            return ctypes.windll.shell32.IsUserAnAdmin()
#        except:
#            traceback.print_exc()
#            print "Admin check failed, assuming not an admin."
#            return False
#    return True

#def runAsAdmin():
#    if os.name=='nt':
#        import win32com.shell.shell as shell
#        ASADMIN = 'asadmin'
#        if sys.argv[-1] != ASADMIN:
#            script = os.path.abspath(sys.argv[0])
#            params = ' '.join([script] + sys.argv[1:] + [ASADMIN])
#            shell.ShellExecuteEx(lpVerb='runas', lpFile=sys.executable, lpParameters=params)

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName(_fromUtf8("MainWindow"))
        MainWindow.resize(809, 620)
        MainWindow.setStyleSheet(_fromUtf8("font: 11px \"Arial Unicode MS\";"))

def getPythonFileLocation():
    """  returns the location of where the python file is located. """
    if os.path.dirname(sys.argv[0]) !="":
        return os.path.dirname(sys.argv[0])
    if os.path.dirname(__file__) != "":
        return os.path.dirname(__file__)
    elif os.path.dirname(os.path.abspath(__file__)) != "":
        return os.path.dirname(os.path.abspath(__file__))
    elif os.path.dirname(os.getcwd()) != "":
        return os.path.dirname(os.getcwd())
    else:
        from inspect import getsourcefile
        return os.path.dirname(os.path.abspath(getsourcefile(lambda _:None)))
application_path=getPythonFileLocation()

#For muting some warnings or redirecting them, we install a custom message handler
def Qhandler(msgtype, message):
    if "libpng warning: iCCP: known incorrect sRGB profile" not in str(message):
        print str(message)
    pass
try:
    QtCore.qInstallMsgHandler(Qhandler)
except:
    pass

try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s

try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig=None):
        _encoding = QtGui.QApplication.UnicodeUTF8
        if window.language!="DEFAULT" and window.language!="en":
            if window.language not in window.translations:
                window.translations[window.language]={}
            if text not in window.translations[window.language]:
                if text=="":
                    return ""
                window.translist.append(text)
            else:
                translateThis=ast.literal_eval(window.translations[window.language][text])
                return QtCore.QString.fromUtf8(translateThis)
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig=None):
        return QtGui.QApplication.translate(context, text, disambig)
###################
import subprocess

IS_WIN32 = 'win32' in str(sys.platform).lower()

global CoinSelect
CoinSelect = {}

def subprocess_call(*args, **kwargs):
    #also works for Popen. It creates a new *hidden* window, so it will work in frozen apps (.exe).
    if IS_WIN32:
        startupinfo = subprocess.STARTUPINFO()
        startupinfo.dwFlags = subprocess.CREATE_NEW_CONSOLE | subprocess.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = subprocess.SW_HIDE
        kwargs['startupinfo'] = startupinfo
    retcode = subprocess.call(*args, **kwargs)
    return retcode


###########################################################
from threading import Thread
import random, json, sys, ast, time, ast, subprocess
from pyblackcointools import *
import pyblackcointools
import pybitcointools as pybit
import pybitcoincashtools as pybit2
import electrumaccessor as ea #Electrum synchronization
if os.name == 'nt':
    import msvcrt as m #getch for testing
else:
    import curses as m
import re #Regex for pattern matching and cfg file
import shutil #For copying files
import urllib2 #For checking internet
import urllib
import socket
import Crypto #Just in case we need more crypto functions
import base64
import base58
from Crypto.Hash import SHA256
import password #The file used to password protect private key strings/files
from decimal import * #Useful for avoiding errors since floats are not accurate
from collections import Counter #For filtering lists and duplicates
from highlevelcrypto import * #Used for public key encryption
import highlevelcrypto
from binascii import hexlify, unhexlify #Changing from hex values
from Crypto.Cipher import AES #AES Encryption
import binascii #Used for converting strings
import rpyc #For communication between the server and BitMessage functions.
import testblock #the api for blockchain requests
import datetime #For comparing dates to get difference in hours.
from bitcoinrpc.authproxy import AuthServiceProxy#Blackcoin stuff
#Email authenitcation
import imaplib
import smtplib
import email
from email.parser import HeaderParser
import requests#An additional method for internet checking
import ANewBitHalo
import gui.mainwindow
from PIL import Image#For Steganography
from PIL.ImageQt import ImageQt
import stepic
from io import BytesIO
import StringIO
import copy
import csv
import xmlrpclib #RPC
import ATemplates
import quopri
import goslate
import platform
import gc
#Requesocks is not compatible with mechnanize, will use pysocks instead
#Installing html5-parser may help the packages work together: https://html5-parser.readthedocs.io/en/latest/
#import requesocks
import socks
import hashlib
from yandex_translate import YandexTranslate
import gtranslate as gtranslate2
import struct
import bsonjs
#import numpy as np
import ujson
import mechanize
from selenium import webdriver
from selenium.webdriver.firefox.options import Options

try:
    from requests.adapters import HTTPAdapter
    from requests.packages.urllib3.poolmanager import PoolManager
    import ssl

    class MyAdapter(HTTPAdapter):
        def init_poolmanager(self, connections, maxsize, block=False):
            self.poolmanager = PoolManager(num_pools=connections,
                                           maxsize=maxsize,
                                           block=block,
                                           ssl_version=ssl.PROTOCOL_TLSv1)
except:
    traceback.print_exc()
#import zlib

#Global Variables
#defaultcfg = {'PrivKeyFilename1':" ",'PrivKeyFilename2':" ",'PrivKeyFiledir1':" ",'PrivKeyFiledir2':" ",'keysconnected':"0",'prevbalance':" ",'BitMessage':" ",'BackupPath':" ",'CoinSelect':"BTC",'EnableBM':" ",'EnableEmail':" ",'Notify':"0",'Market':"1",'Spam':"1",'Wizard':"1",'CloseEvent':"0",'ExitDuringContracts':"0"}
defaultcfg = '#PrivKeyFilename1# #PrivKeyFilename2# #PrivKeyFiledir1# #PrivKeyFiledir2# #keysconnected#0#prevbalance#0#BitMessage# #BackupPath# #CoinSelect#BTC#EnableBM# #EnableEmail# #Notify#0#Market#1#Spam#1#Wizard#1#CloseEvent#0#ExitDuringContracts#0#accounttype#0#language#0#Debug#0#'
global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected
global updatesomething
global Spendable  #Spendable is the list of confirmed dictionary outputs
global OnOrders   #On orders is the list of txid/vouts that are being spent on future contracts
global MyContracts  #Its a good idea to have this as its own list
global isdownloading, interneton, globaltxh, globaltx, globalargs #A bunch of variables to bounce around from the download thread
global HideMyTips
global CurrentBlock
global HaloTime
global TxidLookup
global BitQueue
global MyMessages
global DontRepopulate #This is a list of all the cleared transactions to keep from contantly adding them. As temping as this is  to keep that data in contracts, that database may get bloated.
global PendingSelected
global NewUser #There is a lot of locking going on so its good to hold any new loaded information until threads are done with their work...
global NewBitAddr
global skipthis
global ContactSelected
global ContractSelected
global EscrowResults
global lockdownload
global BlackUnspent
global globperc
global globcount
global timestamp
global MyMessages3
global BitAddrGlob
global UpdateMessage
global EmailPassword
global MyEmail
global AuthError
global BitmessageStatus
global BitHaloClient
global downloadThread
global bitmessThread
global blackcoindThread
global UniversalTimeStamp
global sdir
global rescanning
global clientversion
global versioncheck
global changearray
global minedarray
global Biteasy
global SKIN
global HistoryDetail
global GlobalImage
global AdvanceArray
global Coins
global Markets
global publicaddress
global masterpublic
global ModeratorKey
global ModeratorPublicKey
global ModeratorPrivateKey
global CoinMarketCap
global DontExit
global GlobalID
global checkpastebin
global SALT
global RPC
global FileSave
global RunPython
global TheBridgeThread
global ThePeg
global prevmsig
global accounttype
global checkbitmessage
global uploadnew
global unlockpasswords
global SilenceUI #For automating message boxes
global langlist
global gcodes
global mylang
global translations
global UIDS
global AuthTimeStamp
global debug
global NotForME
global LockTHIS
global EmailCheckTime
global disconnected
global dwindow
global addrlist
global MacWine
global Exiting
global ManualPassword
#global session
global BMHasPW
global MasterOrders
global CustomColumns
global stakelist
global AddNewOrders
global BitEasyPrev
global txsplash
global compresssplash
global lockforspending
global imagecache
global BMStartTime
global BitMRPC
global NEWTxidLookup
global NEWTxidLookup2
global NotifyEXOTIC
global exoticnotify
global spentinputs
global NotaryScripts
global reqsession
global BitcoinCASH
global calcpage
global calcbrowser
global calcmain_frame
global bestcalcrate
global CanStakeTime
global StakeTimeNotify
global window
global globfont
global connectioncount
global btcfeekb
global iswaiting
global ApprovedContracts
global myblockcount
global GlobalMaxInputs
global RunHalo
global lockdownload2
global loadtime
global totalstaked
global TestnetPeg
global voteforever
global githubrates
global thecoins
global noproxy
global mechurl
global internetcheck
global notDownloading
global coininfo
global OffSetNotify
global CoinGecko
global YandexAPI
global BridgeAdmin
global BridgeDriver
global MySettingsInfo
global merkleHashes

reqsession=""

#session = requesocks.session()
#session.proxies = {'http':  'socks5://127.0.0.1:9150','https': 'socks5://127.0.0.1:9150'}

def create_connection(address, timeout=None, source_address=None):
    sock = socks.socksocket()
    sock.connect(address)
    return sock

socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, "127.0.0.1", 9150)
#backup original method, since if proxy is requested we might monkey patch
socket_original = socket.socket
connection_original = socket.create_connection

import inspect #So you can run from command line

YandexAPI = ""
CoinGecko = 1
OffSetNotify = True
coininfo = {}
notDownloading = 0
internetcheck=0
mechurl={}
noproxy={}
thecoins=''
githubrates={}
voteforever=1
TestnetPeg=False
translations={}
mylang="DEFAULT"
langlist={}
gcodes={}
uploadnew={}
prevmsig={'ID':'','Dir':'','mscript':'','msigaddr':'','Halo':''}
checkbitmessage=0
accounttype="0"
SALT=""
GlobalImage=""
SKIN=ANewBitHalo.Ui_MainWindow
Biteasy={}
loadtime=time.time()
totalstaked=0
AuthTimeStamp=time.time()-600
AuthError=0
EmailPassword=""
BitmessageStatus={}
MyEmail=""
BitAddrGlob=""
try:
    timestamp=time.mktime(datetime.datetime.utcnow().timetuple())
except:
    timestamp=time.time()
UniversalTimeStamp=timestamp
BitQueue=[]
skipthis=""
keysconnected=""
PrivKeyFilename1=""
PrivKeyFilename2=""
PrivKeyFiledir1=""
PrivKeyFiledir2=""
PendingSelected=[]
NewBitAddr=[]
NewUser=[]
globalthx=[]
globalargs=[]
globaltx=[]
DontRepopulate=[]
MyMessages=[]
MyMessages3=[]
BitQueue=[]
TxidLookup=[]
lockdownload=0
CurrentBlock=0
HideMyTips=0
isdownloading=1
interneton=0
OnOrders = []
Spendable = []
MyContracts = []
EscrowResults = []
BlackUnspent=[]
BitARGS=[]
HistoryDetail={}
BitHaloClient=True
updatesomething=1
mycfg='default'
globperc=0
globcount=0
rescanning=0
clientversion="4.0"
UpdateMessage=clientversion
versioncheck=0#After we check, we set this to one
changearray=[]
minedarray=[]
AdvanceArray={}
Markets={}
publicaddress = "null"
#Master voluntary community public key
masterpublic = "04b55a7bb9c4fddf1d5d71e72556c0eb1674e82ac0c51dee57a5a51d66e00eb2fbd9940fdc9dc62cf1dd8a080b6ce19641e22ed4e23e4e5d26a9c57f31ed2e6236"
ModeratorKey = 0
#Moderator voluntary community public key
ModeratorPublicKey = "0406a38c0831f81563e1a4a6b3696866842ab8ddf441eb30f59a7eba0b27b74b48a38314e91dfdba7e3c183f3598eb3e4215f036a4bafc094fe52ff3a8615efdd9"
ModeratorPrivateKey = ""
CoinMarketCap=" "
DontExit=[0,0,0,0]
HaloTime=datetime.datetime(1970, 1, 1, 0, 0, 0, 0)
GlobalID=""
checkpastebin={}
unlockpasswords=["",""]
SilenceUI=0
NotForMe=[]
LockTHIS={}
EmailCheckTime=time.time()-180
disconnected=0
dwindow=""
addrlist=[]
MacWine=0
Exiting=0
ManualPassword="*"
BMHasPW=False
MasterOrders={}
CustomColumns=[]
stakelist=[]
AddNewOrders=[]
BitEasyPrev={}
lockforspending="1"
imagecache={}
NEWTxidLookup={}
NEWTxidLookup2={}
NotifyEXOTIC=False
exoticnotify=False
spentinputs={}
NotaryScripts={}
BitcoinCASH=False
bestcalcrate=[]
CanStakeTime=True
StakeTimeNotify=True
globfont='MS Shell Dlg 2'
connectioncount=""
btcfeekb=0
iswaiting=0
ApprovedContracts={}
myblockcount=0
GlobalMaxInputs=''
globliq=[]
RunHalo=True
lockdownload2=0
BridgeAdmin = False
BridgeDriver = ""
MySettingsInfo = ""
merkleHashes = False

#https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list
Coins=[]#Soon will need more variables like the minimum fee and magic byte
NewCoin={}
NewCoin1={}
NewCoin2={}
NewCoin['daemon']="blackmored"
NewCoin['datadir']="data"
NewCoin['config']="blackmore"
NewCoin['rpcuser']="blackcoinrpc"
NewCoin['rpcpassword']="32w54er56t7y89j8h34w5e6t7y8u9ik34sAs4"
NewCoin['rpcport']="15715"
NewCoin['port']="15714"
NewCoin['blocktime']="64"
NewCoin['6aLength']=40
NewCoin['staking']=True
NewCoin['checksequenceverify']=False
NewCoin['stakeconfirmations']=500
NewCoin['logo']="/images/BlackHalo.png"
NewCoin['name']="Blackcoin"
NewCoin['moderngui']=0
NewCoin['website']="https://BlackHalo.info/"
NewCoin['updatewindows']="https://bithalo.github.io/bithalo/downloads/BlackHaloUpdateWin.html"
NewCoin['TabText']="rgb(255, 255, 255)"
NewCoin['splash']="LoadingBlackHalo.png"
NewCoin['HaloName']="BlackHalo"
NewCoin['Background']="#70aee7"
NewCoin['LabelText']="rgb(251, 251, 251)"
NewCoin['BackgroundImage']="/images/bg_blackhalo.png"
NewCoin['BackgroundImage2']="/images/bg_blackhalo_2.png"
NewCoin['TabSelected']="#acb6c6"
NewCoin['QTabBackground']="rgba(0, 0, 34, 250)"
NewCoin['QFrameColor']="#00000"
NewCoin['FrameGradient']="qlineargradient(x1:1, y1:1, x2:0, y2:1, stop:0 #2f3339, stop: 0.4 rgba(0, 0, 34, 250), stop:0 rgb(50, 50, 50, 250)"
NewCoin['Symbol']="BLK"
NewCoin['CommandLinkColor']="#fbfbfb"
NewCoin['ProgressBarColor']="#545d6d"
NewCoin['TabGradient']="qlineargradient(x1:1, y1:1, x2:1, y2:0, stop:0 #009ee3, stop: 0.4 rgba(0, 90, 177, 250), stop:1 rgb(0, 50, 100, 250))"
NewCoin['NavBarIcon']="/images/navbar_arrow_bc.png"
NewCoin['default market']="Halo Market"
NewCoin['IRC']="https://webchat.oftc.net/?channels=%23BitHalo,%23BitBay&uio=d4"#"https://kiwiirc.com/client/irc.kiwiirc.com/#BitHalo,#Blackcoin" #http://webchat.freenode.net?channels=BitHalo,#Blackcoin&amp;uio=OT10cnVlJjExPTIzNg6b"
NewCoin['nodes']=["104.6.159.189","107.195.147.153","112.113.96.138","113.108.186.130","113.234.214.8","117.157.64.230","117.172.25.189","118.212.114.93","118.42.39.231","124.238.85.96","139.130.157.220","163.172.184.165","163.172.223.239","173.239.230.36","173.239.236.43","173.239.236.5","173.244.48.182","173.33.214.129","176.25.84.234","178.137.89.197","183.14.252.56","184.4.178.115","185.173.206.30","188.137.32.82","192.40.95.25","195.122.202.2","195.20.153.254","195.252.67.115","200.120.151.178","209.197.159.209","211.142.221.137","211.142.221.158","212.180.229.134","213.231.101.1","217.108.209.165","217.182.192.7","23.127.82.251","24.10.184.3","24.166.255.203","24.86.78.11","39.128.196.9","41.190.30.206","46.5.2.80","47.180.44.129","5.172.236.41","59.53.16.209","59.53.26.24","61.56.213.25","62.2.214.45","65.128.88.11","67.174.248.255","72.241.235.204","73.109.27.226","73.216.144.216","73.25.146.40","76.84.68.134","77.144.221.131","79.114.236.118","80.148.28.210","82.23.136.107","83.170.70.50","83.215.142.159","83.9.244.60","84.55.104.197","85.24.180.24","86.147.66.127","86.63.70.12","87.245.126.33","88.196.136.31","91.59.127.135","91.59.98.229","92.73.213.106","93.217.127.230","94.212.239.213","96.36.231.150","96.90.184.145"]
NewCoin['links']=""
NewCoin['Moderator']=0
Coins.append(NewCoin)

NewCoin1['daemon']="bitbayd"
NewCoin1['datadir']="bitbaydata"
NewCoin1['config']="bitbay"
NewCoin1['rpcuser']="bitbayrpc"
NewCoin1['rpcpassword']="32w54er56t7y89j8h34w5e6t7y8u9ik34sAs4"
NewCoin1['rpcport']="19915"
NewCoin1['port']="19914"
NewCoin1['blocktime']="64"
NewCoin1['6aLength']=248
NewCoin1['pegging']=True
NewCoin1['checksequenceverify']=False
NewCoin1['staking']=True
NewCoin1['stakeconfirmations']=120
NewCoin1['logo']="/images/BitBay.png"
NewCoin1['name']="BitBay"
NewCoin1['moderngui']=1
NewCoin1['website']="https://bitbay.market/"
NewCoin1['videolibrary']="https://www.youtube.com/watch?v=CIU4s2G8jU8&list=PL4MGGKJn4DizGw7oBXwzETMVLNCZ6G2_t"
NewCoin1['updatewindows']="https://bithalo.github.io/bithalo/downloads/BitBayUpdateWin.html"
NewCoin1['TabText']="rgb(255, 255, 255)"
NewCoin1['splash']="LoadingBitBay.png"
NewCoin1['HaloName']="BitBay"
NewCoin1['Background']="#70aee7"
NewCoin1['LabelText']="rgb(251, 251, 251)"
NewCoin1['BackgroundImage']="/images/bg_bitbay.png"
NewCoin1['BackgroundImage2']="/images/bg_bitbay_2.png"
NewCoin1['TabSelected']="#acb6c6"
NewCoin1['QTabBackground']="rgba(0, 0, 34, 250)"
NewCoin1['QFrameColor']="#00000"
NewCoin1['FrameGradient']="qlineargradient(x1:1, y1:1, x2:0, y2:1, stop:0 #2f3339, stop: 0.4 rgba(0, 0, 34, 250), stop:0 rgb(50, 50, 50, 250)"
NewCoin1['Symbol']="BAY"
NewCoin1['CommandLinkColor']="#fbfbfb"
NewCoin1['ProgressBarColor']="#a5d1e4"#545d6d
NewCoin1['TabGradient']="qlineargradient(x1:1, y1:1, x2:1, y2:0, stop:0 #009ee3, stop: 0.4 rgba(0, 90, 177, 250), stop:1 rgb(0, 50, 100, 250))"
NewCoin1['NavBarIcon']="/images/navbar_arrow_bay.png"
NewCoin1['default market']="BitBay"
NewCoin1['IRC']="https://webchat.oftc.net/?channels=%23BitHalo,%23BitBay&uio=d4"#"https://kiwiirc.com/client/irc.kiwiirc.com/#BitHalo,#BitBay" #https://webchat.freenode.net?channels=BitHalo,#BitBay&amp;uio=OT10cnVlJjExPTIzNg6b"
NewCoin1['nodes']=["195.181.242.206","151.236.221.10","108.61.163.182", "45.79.94.206","139.162.226.144","172.104.25.65","172.104.248.46","172.105.241.170","172.104.185.75","104.236.208.150","188.166.39.223","128.199.118.67","104.255.33.162","194.135.84.161","23.227.190.163","45.56.109.7","104.172.24.79","106.187.50.153","158.69.27.82","24.37.11.106","40.112.149.192","69.254.222.98","85.25.146.74","195.181.242.206","108.61.99.30","109.200.226.214","142.44.212.178","213.231.38.119","37.120.48.130","37.139.5.225","47.97.184.125","72.199.168.135","74.222.195.230","80.7.81.121","88.180.217.67","88.90.82.209","92.110.86.245","94.193.173.249","95.216.45.141","98.214.246.87","104.237.4.26","108.46.55.204","109.86.81.235","109.88.194.34","116.240.94.131","157.52.132.37","212.200.52.123","217.121.36.200","68.198.145.62","69.250.107.102","76.201.148.44","77.0.188.237","77.8.93.125","86.130.87.94","92.14.229.173","108.46.151.50","108.61.163.182","110.140.74.185","116.203.21.198","139.162.226.144","172.104.185.75","172.105.241.170","45.79.94.206","5.189.144.187","51.254.49.230","67.44.176.225","80.4.51.126","91.121.217.70","91.207.172.123","212.24.97.214","108.249.214.97","151.64.22.175","173.239.93.120","173.77.163.177","183.106.37.96","185.183.107.172","185.183.107.174","185.244.212.20","192.30.89.67","193.37.253.101","194.59.251.111","195.206.183.167","213.154.231.39","213.213.219.80","213.231.7.146","216.46.43.58","217.146.82.134","27.187.73.203","37.235.55.13","46.9.176.176","5.62.49.34","70.93.174.250","73.149.189.82","79.198.237.182","80.107.189.226","82.12.99.226","82.17.115.47","82.207.237.17","82.28.11.95","84.151.167.24","86.126.2.173","88.212.55.252","92.14.27.81","93.201.111.175","94.197.120.101"]
#NewCoin1['nodes']=["104.172.24.79","104.200.154.17","106.187.50.153","149.12.14.174","158.69.27.82","188.123.16.129","198.74.56.141","217.25.213.221","217.25.213.224","217.25.213.238","23.105.132.100","24.37.11.106","37.110.214.70","40.112.149.192","45.56.109.7","5.71.234.101","50.41.194.116","50.41.197.104","50.41.197.146","50.41.197.167","50.41.197.171","50.41.198.128","50.41.198.32","50.41.198.58","50.41.198.60","50.41.201.69","51.255.64.57","69.254.222.98","78.98.122.3","80.39.197.10","83.128.183.212","85.25.146.74","94.137.30.246","95.153.32.38","98.113.150.90","104.237.2.192","108.61.10.90","213.226.252.45","91.158.109.188","159.203.184.167","162.216.46.117","104.236.208.150", "195.181.242.206", "188.166.39.223","128.199.118.67", "104.255.33.162", "194.135.84.161", "23.227.190.163", "201.166.110.218", "100.15.228.230", "104.237.4.33", "104.238.169.110", "104.238.169.120", "104.245.111.33", "104.6.159.189", "107.132.230.195", "107.15.192.58", "107.218.48.181", "108.200.103.205", "108.213.70.198", "108.214.8.13", "108.241.58.211", "108.248.114.128", "109.173.159.100", "110.140.43.184", "113.59.202.53", "116.15.203.21", "120.147.146.11", "120.55.51.151", "121.221.56.199", "123.231.125.91", "124.178.155.6", "132.198.204.255", "135.23.125.66", "144.217.215.134", "146.255.175.131", "147.30.87.116", "151.80.186.24", "169.0.109.203", "173.170.105.150", "173.239.236.61", "173.239.236.94", "173.239.240.39", "173.54.212.190", "174.26.159.221", "174.79.110.140", "176.11.27.206", "176.11.93.220", "176.228.218.17", "178.63.60.137", "179.57.114.240", "184.64.97.156", "185.11.108.170", "185.156.173.238", "185.156.173.248", "185.9.19.122", "188.113.203.196", "188.113.215.180", "188.113.217.172", "188.163.104.86", "188.165.203.89", "188.192.142.76", "188.230.151.241", "190.192.28.46", "190.72.246.166", "193.1.218.163", "193.80.38.164", "195.181.242.206", "201.166.110.183", "201.247.142.137", "208.157.168.106", "209.146.252.226", "209.6.92.112", "213.152.161.117", "216.67.74.89", "216.67.81.213", "217.21.201.135", "217.238.19.76", "217.39.127.111", "217.64.127.165", "24.21.46.228", "24.45.24.83", "24.57.212.150", "31.204.150.109", "31.204.152.200", "31.204.152.221", "31.204.153.46", "37.201.224.214", "37.228.224.103", "40.112.149.192", "46.39.243.165", "46.46.205.96", "5.189.156.99", "5.56.189.65", "5.62.41.4", "5.63.151.76", "50.240.204.70", "50.27.176.50", "50.27.236.224", "50.41.205.218", "51.254.45.117", "51.7.236.38", "51.7.254.211", "52.232.33.38", "58.96.240.42", "60.242.23.7", "62.178.40.4", "67.173.120.250", "67.230.49.214", "67.240.19.66", "68.100.192.184", "68.149.125.18", "68.46.238.155", "70.64.11.206", "71.245.121.203", "71.84.137.92", "72.169.81.141", "72.207.104.55", "72.22.148.78", "72.22.150.82", "72.238.5.0", "72.239.0.57", "72.48.127.219", "73.143.247.58", "73.162.63.60", "73.172.109.27", "73.202.23.41", "73.203.20.134", "73.241.114.206", "73.241.24.24", "73.25.146.40", "73.254.226.126", "73.76.129.232", "75.83.248.12", "76.125.29.166", "76.169.57.92", "76.29.66.137", "77.255.88.179", "77.255.92.80", "77.68.215.200", "79.69.139.140", "79.74.70.117", "79.75.39.24", "79.75.61.162", "80.101.212.164", "80.180.42.224", "80.229.17.69", "81.184.121.12", "82.101.198.115", "82.129.122.26", "82.217.167.158", "82.240.188.161", "82.41.55.9", "83.8.64.20", "84.240.71.197", "84.250.171.240", "85.170.176.192", "85.241.113.249", "85.25.146.74", "86.150.38.55", "86.167.182.70", "86.176.147.48", "88.114.185.201", "90.191.207.180", "92.1.234.190", "92.237.123.47", "93.194.192.28", "93.242.44.146", "94.212.36.91", "94.46.175.222", "95.34.149.205", "96.246.242.21", "98.145.4.235", "98.242.37.243", "99.238.244.2", "99.66.221.203", "1.129.109.58","100.2.93.10","104.223.25.122","108.190.240.82","110.140.93.40","113.59.203.138","121.7.251.133","124.29.237.241","14.200.165.55","144.217.72.204","145.130.170.169","146.198.52.2","154.57.227.227","162.72.254.164","172.111.155.214","172.56.12.106","172.56.12.184","172.56.12.212","172.56.12.221","172.56.13.152","172.56.13.189","172.56.13.31","172.56.6.52","172.56.7.127","173.22.3.50","173.239.236.85","174.69.221.184","176.24.209.169","176.27.192.166","184.14.108.222","184.55.176.66","184.6.74.147","184.98.164.92","185.161.201.13","188.113.197.220","188.113.197.236","188.113.213.212","188.113.215.236","188.241.58.126","188.6.131.67","190.20.105.78","190.20.140.160","194.72.180.68","195.113.111.18","196.11.63.162","196.53.32.11","203.57.210.108","204.228.139.246","208.54.80.130","208.54.80.131","212.197.143.196","212.3.195.175","24.10.135.27","24.176.251.84","24.225.204.112","24.234.86.102","24.242.103.47","31.52.213.184","36.232.141.220","37.136.11.61","39.109.134.176","45.28.140.116","46.208.58.217","46.233.215.30","46.235.32.6","46.4.37.190","5.198.101.104","50.41.223.118","51.7.254.198","62.57.193.29","65.95.224.6","67.165.94.226","67.183.29.189","68.197.208.77","69.197.188.186","69.203.109.7","69.55.254.61","70.119.124.134","70.122.32.5","70.71.157.109","71.197.52.238","72.199.168.135","72.22.151.109","72.70.60.136","73.212.89.38","73.222.225.197","73.54.180.205","73.66.212.224","73.76.16.176","75.100.38.214","76.23.184.131","76.69.65.236","77.172.214.202","78.124.25.100","78.132.17.232","78.132.69.249","78.20.105.124","79.169.12.17","79.31.132.209","79.75.35.83","80.122.24.98","80.215.210.252","81.99.72.84","82.1.131.229","82.20.109.111","82.25.54.171","82.33.136.156","82.33.203.110","85.164.9.224","85.214.140.15","85.229.153.141","86.152.216.229","86.22.249.27","88.106.105.181","88.165.92.58","88.169.109.52","89.162.20.164","89.247.193.105","89.64.11.38","89.64.13.222","92.15.203.251","93.193.46.60","95.211.199.131","95.211.95.246","96.232.82.36","98.16.141.39","98.194.66.113","99.20.141.243","94.102.52.66","80.82.64.64","107.218.48.181","108.61.163.182","108.61.99.30","110.140.136.223","115.189.87.188","124.148.154.249","13.88.29.127","139.162.226.144","151.229.82.253","152.0.255.216","171.112.186.7","172.104.185.75","172.105.241.170","173.239.222.132","173.239.226.8","173.249.21.191","174.50.118.218","174.65.17.23","178.78.92.212","184.64.223.125","185.163.111.252","195.181.242.206","210.84.54.238","213.122.117.130","24.214.124.183","24.96.192.15","45.79.94.206","46.4.37.190","5.189.164.59","5.79.102.19","50.203.99.102","50.37.21.201","51.254.49.230","68.46.238.155","70.119.124.134","71.105.34.144","72.227.170.97","73.8.31.127","74.101.0.66","77.56.58.236","79.230.56.27","79.66.224.67","79.67.93.131","80.4.51.126","85.229.154.208","85.25.146.74","94.130.64.143","107.218.48.181","108.61.163.182","108.61.99.30","110.140.136.223","115.189.87.188","124.148.154.249","13.88.29.127","139.162.226.144","151.229.82.253","152.0.255.216","171.112.186.7","172.104.185.75","172.105.241.170","173.239.222.132","173.239.226.8","173.249.21.191","174.50.118.218","174.65.17.23","178.78.92.212","184.64.223.125","185.163.111.252","195.181.242.206","210.84.54.238","213.122.117.130","24.96.192.15","45.79.94.206","46.4.37.190","5.189.164.59","5.79.102.19","50.203.99.102","50.37.21.201","51.254.49.230","68.46.238.155","70.119.124.134","71.105.34.144","72.227.170.97","73.8.31.127","74.101.0.66","77.56.58.236","79.230.56.27","79.66.224.67","79.67.93.131","80.4.51.126","85.229.154.208","85.25.146.74","94.130.64.143"]#The last 6 up until 201.166.110.218 are original/expired seed nodes and home node appended afterwards is chainz nodes, the ones prior are also from chainz ##Reliable nodes are "40.112.149.192", "195.181.242.206"
NewCoin1['links']=("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'Arial\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:15px; font-weight:600;\">Links/Misc</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"https://bitbay.market/\"><span style=\" font-size:15px; text-decoration: underline; color:#0000ff;\">https://bitbay.market/</span></a><span style=\" font-size:15px;\">  The official BitBay website</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"https://www.reddit.com/r/bitbay/\"><span style=\" font-size:15px; text-decoration: underline; color:#0000ff;\">https://www.reddit.com/r/bitbay/</span></a><span style=\" font-size:15px;\">  BitBay community subreddit</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"www.Blackhalo.info\"><span style=\" font-size:15px; text-decoration: underline; color:#0000ff;\">www.Blackhalo.info</span></a><span style=\" font-size:15px;\">  BlackHalo, the worlds first contracting software</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"www.BitHalo.org\"><span style=\" font-size:15px; text-decoration: underline; color:#0000ff;\">www.BitHalo.org</span></a><span style=\" font-size:15px;\">  The original BitHalo Website</span></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"www.NightTrader.org\"><span style=\" font-size:15px; text-decoration: underline; color:#0000ff;\">www.NightTrader.org</span></a><span style=\" font-size:15px;\">  NightTrader decentralized exchange</span></p>\n"
"<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:15px;\"><br /></p>\n"
"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:15px;\">If you have any feedback or questions please contact us through the official website. Thank you.</span></p></body></html>")
NewCoin1['Moderator']=0

NewCoin1['pegging']=True
if os.path.exists(os.path.join(application_path,"whitelist.dat")):
    TestnetPeg=True
    #NewCoin1['pegging']=True

Coins.append(NewCoin1)

#print NewCoin1['links']

#NewCoin2['daemon']="bitcoind"
#NewCoin2['datadir']="bitcoindata"
#NewCoin2['rpcuser']="bitcoinrpc"
#NewCoin2['rpcpassword']="32w54er56t7y89j8h34w5e6t7y8u9ik34sAs4"
#NewCoin2['rpcport']="8332"
#NewCoin2['port']="8333"
NewCoin2['daemon']="blackmored"#Just in case Blackcoin disconnects during a BitHalo session we will use their data since we arent running Bitcoind
NewCoin2['datadir']="data"
NewCoin2['config']="blackmore"
NewCoin2['rpcuser']="blackcoinrpc"
NewCoin2['rpcpassword']="32w54er56t7y89j8h34w5e6t7y8u9ik34sAs4"
NewCoin2['rpcport']="15715"#Was 15717
NewCoin2['port']="15714"#Was 15716
NewCoin2['blocktime']="64"#We sync Blackcoins daemon here so its still 64 seconds
NewCoin2['6aLength']=40
NewCoin2['staking']=True#BitHalo is dual coin
NewCoin2['checksequenceverify']=False
NewCoin2['logo']="/images/BitHalo.png"
NewCoin2['name']="Bitcoin"
NewCoin2['moderngui']=0
NewCoin2['website']="https://BitHalo.org/"
NewCoin2['updatewindows']="https://bithalo.github.io/bithalo/downloads/BitHaloUpdateWin.html"
NewCoin2['TabText']="rgb(255, 255, 255)"
NewCoin2['splash']="LoadingBitHalo.png"
NewCoin2['HaloName']="BitHalo"
NewCoin2['Background']="#70aee7"
NewCoin2['LabelText']="rgb(251, 251, 251)"
NewCoin2['BackgroundImage']="/images/bg_bithalo.png"
NewCoin2['BackgroundImage2']="/images/bg_bithalo_2.png"
NewCoin2['TabSelected']="#acb6c6"
NewCoin2['QTabBackground']="rgba(0, 0, 34, 250)"
NewCoin2['QFrameColor']="#00000"
NewCoin2['FrameGradient']="qlineargradient(x1:1, y1:1, x2:0, y2:1, stop:0 #2f3339, stop: 0.4 rgba(0, 0, 34, 250), stop:0 rgb(50, 50, 50, 250)"
NewCoin2['Symbol']="BTC"
NewCoin2['CommandLinkColor']="#fbfbfb"
NewCoin2['ProgressBarColor']="#545d6d"
NewCoin2['TabGradient']="qlineargradient(x1:1, y1:1, x2:1, y2:0, stop:0 #009ee3, stop: 0.4 rgba(0, 90, 177, 250), stop:1 rgb(0, 50, 100, 250))"
NewCoin2['NavBarIcon']="/images/navbar_arrow.png"
NewCoin2['default market']="Halo Market"
NewCoin2['IRC']="https://webchat.oftc.net/?channels=%23BitHalo,%23BitBay&uio=d4"#"https://kiwiirc.com/client/irc.kiwiirc.com/#BitHalo,#Blackcoin"#https://webchat.freenode.net?channels=BitHalo,#Blackcoin&amp;uio=OT10cnVlJjExPTIzNg6b"
NewCoin2['nodes']=["104.6.159.189","107.195.147.153","112.113.96.138","113.108.186.130","113.234.214.8","117.157.64.230","117.172.25.189","118.212.114.93","118.42.39.231","124.238.85.96","139.130.157.220","163.172.184.165","163.172.223.239","173.239.230.36","173.239.236.43","173.239.236.5","173.244.48.182","173.33.214.129","176.25.84.234","178.137.89.197","183.14.252.56","184.4.178.115","185.173.206.30","188.137.32.82","192.40.95.25","195.122.202.2","195.20.153.254","195.252.67.115","200.120.151.178","209.197.159.209","211.142.221.137","211.142.221.158","212.180.229.134","213.231.101.1","217.108.209.165","217.182.192.7","23.127.82.251","24.10.184.3","24.166.255.203","24.86.78.11","39.128.196.9","41.190.30.206","46.5.2.80","47.180.44.129","5.172.236.41","59.53.16.209","59.53.26.24","61.56.213.25","62.2.214.45","65.128.88.11","67.174.248.255","72.241.235.204","73.109.27.226","73.216.144.216","73.25.146.40","76.84.68.134","77.144.221.131","79.114.236.118","80.148.28.210","82.23.136.107","83.170.70.50","83.215.142.159","83.9.244.60","84.55.104.197","85.24.180.24","86.147.66.127","86.63.70.12","87.245.126.33","88.196.136.31","91.59.127.135","91.59.98.229","92.73.213.106","93.217.127.230","94.212.239.213","96.36.231.150","96.90.184.145"]
NewCoin2['links']=""
NewCoin2['Moderator']=0
Coins.append(NewCoin2)

app = QtGui.QApplication(sys.argv)

#appfont = QtGui.QFont()
#appfont.setPixelSize(11)
#app.setFont(appfont)

#Google translate has now blocked goslate, Yandex is the new best package 10 million char limit per api key
#gstrans = goslate.Goslate()
#googlelanglist={u'gu': u'Gujarati', u'zh-TW': u'Chinese (Traditional)', u'ga': u'Irish', u'gl': u'Galician', u'la': u'Latin', u'lo': u'Lao', u'tr': u'Turkish', u'lv': u'Latvian', u'lt': u'Lithuanian', u'th': u'Thai', u'tg': u'Tajik', u'te': u'Telugu', u'ta': u'Tamil', u'yi': u'Yiddish', u'ceb': u'Cebuano', u'yo': u'Yoruba', u'de': u'German', u'da': u'Danish', u'el': u'Greek', u'eo': u'Esperanto', u'en': u'English', u'zh': u'Chinese', u'eu': u'Basque', u'et': u'Estonian', u'es': u'Spanish',u'ru': u'Russian', u'zh-CN': u'Chinese (Simplified)', u'ro': u'Romanian', u'be': u'Belarusian', u'bg': u'Bulgarian', u'ms': u'Malay', u'bn': u'Bengali', u'jw':u'Javanese', u'bs': u'Bosnian', u'ja': u'Japanese', u'ca': u'Catalan', u'cy': u'Welsh', u'cs': u'Czech', u'pt': u'Portuguese', u'tl': u'Filipino', u'pa': u'Punjabi', u'vi': u'Vietnamese', u'pl': u'Polish', u'hy': u'Armenian', u'hr': u'Croatian', u'ht': u'Haitian Creole', u'hu': u'Hungarian', u'hmn': u'Hmong', u'hi': u'Hindi', u'ha': u'Hausa', u'mg': u'Malagasy', u'uz': u'Uzbek', u'ml': u'Malayalam', u'mn': u'Mongolian', u'mi': u'Maori', u'mk': u'Macedonian', u'ur': u'Urdu', u'mt': u'Maltese', u'uk': u'Ukrainian', u'mr': u'Marathi', u'my': u'Myanmar (Burmese)', u'af': u'Afrikaans', u'sw': u'Swahili', u'is': u'Icelandic', u'it': u'Italian', u'iw': u'Hebrew', u'kn': u'Kannada', u'ar': u'Arabic', u'km': u'Khmer', u'zu': u'Zulu', u'az': u'Azerbaijani', u'id': u'Indonesian', u'ig': u'Igbo', u'nl': u'Dutch', u'no': u'Norwegian', u'ne': u'Nepali', u'ny': u'Chichewa', u'fr': u'French', u'fa': u'Persian', u'fi': u'Finnish', u'ka': u'Georgian', u'kk': u'Kazakh', u'sr': u'Serbian', u'sq': u'Albanian', u'ko': u'Korean', u'sv': u'Swedish', u'su': u'Sundanese', u'st': u'Sesotho', u'sk': u'Slovak', u'si': u'Sinhala', u'so': u'Somali', u'sl': u'Slovenian'}
#yandexlanglist2={'gu': 'Gujarati', 'gd': 'Scottish', 'ga': 'Irish', 'gl': 'Galician', 'lb': 'Luxembourgish', 'la': 'Latin', 'tt': 'Tatar', 'tr': 'Turkish', 'lv': 'Latvian', 'tl': 'Tagalog', 'th': 'Thai', 'tg': 'Tajik', 'te': 'Telugu', 'ta': 'Tamil', 'yi':'Yiddish', 'ceb': 'Cebuano', 'de': 'German', 'da': 'Danish', 'mhr': 'Mari', 'el': 'Greek', 'eo': 'Esperanto', 'en': 'English', 'zh': 'Chinese', 'eu': 'Basque','et': 'Estonian', 'es': 'Spanish', 'ru': 'Russian', 'ro': 'Romanian', 'jv': 'Javanese', 'be': 'Belarusian', 'bg': 'Bulgarian', 'ba': 'Bashkir', 'bn': 'Bengali','bs': 'Bosnian', 'ja': 'Japanese', 'ms': 'Malay', 'udm': 'Udmurt', 'xh': 'Xhosa', 'ca': 'Catalan', 'cy': 'Welsh', 'cs': 'Czech', 'pt': 'Portuguese', 'lt': 'Lithuanian', 'pa': 'Punjabi', 'pl': 'Polish', 'hy': 'Armenian', 'hr': 'Croatian', 'ht': 'Haitian(Creole)', 'hu': 'Hungarian', 'hi': 'Hindi', 'he': 'Hebrew', 'mg':'Malagasy', 'uz': 'Uzbek', 'ml': 'Malayalam', 'mn': 'Mongolian', 'mi': 'Maori','mk': 'Macedonian', 'ur': 'Urdu', 'mt': 'Maltese', 'uk': 'Ukrainian', 'mr': 'Marathi', 'af': 'Afrikaans', 'vi': 'Vietnamese', 'is': 'Icelandic', 'am': 'Amharic', 'it': 'Italian', 'sv': 'Swedish', 'ar': 'Arabic', 'az': 'Azerbaijan', 'id': 'Indonesian', 'pap': 'Papiamento', 'nl': 'Dutch', 'no': 'Norwegian', 'ne': 'Nepali', 'fr': 'French', 'fa': 'Persian', 'fi': 'Finnish', 'ka': 'Georgian', 'kk': 'Kazakh', 'sr': 'Serbian', 'sq': 'Albanian', 'ko': 'Korean', 'kn': 'Kannada', 'su':'Sundanese', 'sk': 'Slovakian', 'si': 'Sinhala', 'mrj': 'Hill-Mari', 'sl': 'Slovenian', 'ky': 'Kyrgyz', 'sw': 'Swahili'}

#Yandex now charges for API access. So now only if the user has a key should it be used. Otherwise google translate for translations that aren't bulk

gstrans = YandexTranslate('trnsl.1.1.20170227T075822Z.710cc070687ef49d.4773b96b2fa3e9cea7df423e9ab798c58d504036')
langlist={'en-nl': 'Dutch', 'en-no': 'Norwegian', 'en-th': 'Thai', 'en-ne': 'Nepali', 'en-af': 'Afrikaans', 'en-yi': 'Yiddish', 'en-ar': 'Arabic', 'en-jv': 'Javanese', 'en-pt': 'Portuguese', 'en-pl': 'Polish', 'en-id': 'Indonesian', 'en-pa': 'Punjabi', 'en-it': 'Italian', 'en-is': 'Icelandic', 'en-uk': 'Ukrainian', 'en-lv': 'Latvian', 'en-lt': 'Lithuanian', 'en-la': 'Latin', 'en-ga': 'Irish', 'en-ka': 'Georgian', 'en-gl': 'Galician', 'en-gu': 'Gujarati', 'en-kk': 'Kazakh', 'en-vi': 'Vietnamese', 'en-fa': 'Persian', 'en-fi': 'Finnish', 'en-fr': 'French', 'en-uz': 'Uzbek', 'en-ja': 'Japanese', 'en-ur': 'Urdu', 'en-bs': 'Bosnian', 'en-bn': 'Bengali', 'en-be': 'Belarusian', 'en-bg': 'Bulgarian', 'en-el': 'Greek','en': 'English', 'en-eo': 'Esperanto', 'en-ca': 'Catalan', 'en-et': 'Estonian', 'en-eu': 'Basque', 'en-mr': 'Marathi', 'en-ms': 'Malay', 'en-mt': 'Maltese', 'en-tr': 'Turkish', 'en-mg': 'Malagasy', 'en-tg': 'Tajik', 'en-mi': 'Maori', 'en-te': 'Telugu', 'en-mk': 'Macedonian', 'en-ml': 'Malayalam', 'en-mn': 'Mongolian', 'en-es': 'Spanish', 'en-de': 'German','en-da': 'Danish', 'en-ceb': 'Cebuano', 'en-sl': 'Slovenian', 'en-he': 'Hebrew', 'en-si': 'Sinhala', 'en-hi': 'Hindi', 'en-hr': 'Croatian', 'en-hu': 'Hungarian', 'en-sv': 'Swedish', 'en-sw': 'Swahili', 'en-hy': 'Armenian', 'en-su': 'Sundanese', 'en-sr': 'Serbian', 'en-sq': 'Albanian', 'en-ro': 'Romanian', 'en-cy': 'Welsh', 'en-kn': 'Kannada', 'en-ko': 'Korean', 'en-cs': 'Czech', 'en-ru': 'Russian', 'en-ta': 'Tamil', 'en-zh': 'Chinese'}
gcodes={'Turkish': u'tr', 'Swedish': u'sv', 'Icelandic': u'is', 'Estonian': u'et', 'Telugu': u'te', 'Vietnamese': u'vi', 'Marathi': u'mr', 'Javanese': u'jw', 'Slovenian': u'sl', 'Gujarati': u'gu', 'Catalan': u'ca', 'Hindi': u'hi', 'Dutch': u'nl','Russian': u'ru', 'Korean': u'ko', 'Swahili': u'sw', 'Malagasy': u'mg', 'Danish': u'da', 'Indonesian': u'id', 'Latin': u'la', 'Croatian': u'hr', 'Ukrainian': u'uk', 'Welsh': u'cy', 'Bosnian': u'bs', 'Georgian': u'ka', 'Lithuanian': u'lt', 'Malay': u'ms', 'French': u'fr', 'Norwegian': u'no', 'Bengali': u'bn', 'Armenian': u'hy', 'Romanian': u'ro', 'Maltese': u'mt', 'Thai': u'th', 'Afrikaans': u'af','Kazakh': u'kk', 'Albanian': u'sq', 'Cebuano': u'ceb', 'Mongolian': u'mn', 'Nepali': u'ne', 'Finnish': u'fi', 'Uzbek': u'uz', 'Sundanese': u'su', 'Punjabi': u'pa', 'Spanish': u'es', 'Bulgarian': u'bg', 'Greek': u'el', 'Maori': u'mi', 'Latvian': u'lv', 'English': u'en', 'Malayalam': u'ml', 'Serbian': u'sr', 'Esperanto': u'eo', 'Italian': u'it', 'Portuguese': u'pt', 'Irish': u'ga', 'Czech': u'cs','Hungarian': u'hu', 'Chinese': u'zh', 'German': u'de', 'Tamil': u'ta', 'Japanese': u'ja', 'Belarusian': u'be', 'Kannada': u'kn', 'Galician': u'gl', 'Macedonian': u'mk', 'Persian': u'fa', 'Tajik': u'tg', 'Yiddish': u'yi', 'Hebrew': u'iw', 'Basque': u'eu', 'Urdu': u'ur', 'Polish': u'pl', 'Arabic': u'ar', 'Sinhala': u'si'}
#Languages that are in Yandex but not Google:
#extras={'en-am': 'Amharic','en-az': 'Azerbaijan','en-xh': 'Xhosa','en-lb': 'Luxembourgish','en-gd': 'Scottish','en-pap': 'Papiamento','en-ba': 'Bashkir','en-mhr': 'Mari','en-tt': 'Tatar','en-tl': 'Tagalog','en-sk': 'Slovakian','en-ht': 'Haitian(Creole)','en-ky': 'Kyrgyz','en-udm': 'Udmurt','en-mrj': 'Hill-Mari'}

#Some systems have trouble loading Qt4 jpg plugin, so the workaround for now is to convert them to PNG using PIL
def ConvertImage(img,filetype="base64",returnpixmap=True):
    try:
        if filetype=="base64":
            im = Image.open(BytesIO(base64.b64decode(img)))
        if filetype=="file":
            im = Image.open(img)
        output = StringIO.StringIO()
        im.save(output,"PNG")
        pm = QtGui.QPixmap()
        x=base64.b64encode(output.getvalue())
        pm.loadFromData(base64.b64decode(x))
        if returnpixmap:
            return pm
        else:
            return x
    except:
        pass        
    return ""

try:
    with open(os.path.join(application_path,"MASTER.private"),'r') as f:
        line=f.readline().strip()
        line=f.readline().strip()
        line=f.readline().strip()
        if line==masterpublic:
            ModeratorKey=2 #They are a super moderator
        if line==ModeratorPublicKey:
            ModeratorKey=1
        line=f.readline().strip()
        ModeratorPrivateKey=line
        ModeratorPrivateKey=ModeratorPrivateKey.replace("KEY: ","")
        x=0
        for co in Coins:
            Coins[x]['Moderator']=1
            x+=1
        f.close()
except:
    pass
notifybuild = 0
try:
    with open(os.path.join(application_path,"Halo.cfg"),'r') as f:
        line=f.readline().strip()
        if "#Approved#" not in line:
            notifybuild = line
        try:
            debug=int(line.split('#Debug#')[1].split('#')[0])
        except:
            debug=0
        line=line.split('#CoinSelect#')[1].split('#')[0]
        f.close()
    if line=="BTC":
        CoinSelect=copy.deepcopy(Coins[2])
    if line=="BLK":
        CoinSelect=copy.deepcopy(Coins[0])
    if line=="BAY":
        CoinSelect=copy.deepcopy(Coins[1])
except Exception, e:
    debug=0
    CoinSelect=copy.deepcopy(Coins[2])

# Create and display the splash screen
if 'splash' in CoinSelect:
    splash_pix = QtGui.QPixmap(ConvertImage(application_path+'/images/'+CoinSelect['splash'],"file"))
    if CoinSelect['moderngui']==1 and CoinSelect['name']=="BitBay":
        splash_pix = QtGui.QPixmap(ConvertImage(application_path+'/images/'+'LoadingBitBayNew.png',"file"))
else:
    splash_pix = QtGui.QPixmap(ConvertImage(application_path+'/images/Loading.jpg',"file"))
splash = QtGui.QSplashScreen(splash_pix)
#splash.setWindowFlags(QtCore.Qt.FramelessWindowHint)
splash.setMask(splash_pix.mask())
splash.show()
splash.repaint()

#Create global tx splash
splash_px = QtGui.QPixmap(application_path+'/images/Process.png')
txsplash = QtGui.QSplashScreen(splash_px)
txsplash.setMask(splash_px.mask())    

#Create global compression splash
splash_px = QtGui.QPixmap(application_path+'/images/Compress.png')
compresssplash = QtGui.QSplashScreen(splash_px)
compresssplash.setMask(splash_px.mask())    

if CoinSelect['moderngui']==1:
    SKIN=gui.mainwindow.Ui_MainWindow

class Debugger:
    def __init__(self):
        self.content = []
    def write(self, string):
        self.content.append(string)
try:
    if debug==1:
        debug = Debugger()
        sys.stdout = debug
        sys.stderr = debug
except:
    traceback.print_exc()

def DataDirectory():
    global sdir
    global CoinSelect
    if os.name == 'nt':
        sdir=application_path+"\\"+CoinSelect['datadir']
    else:
        sdir=application_path+"/"+CoinSelect['datadir'] #Its probably Linux.

    if not os.path.exists(sdir): os.mkdir(sdir)
    with open(os.path.join(sdir,CoinSelect['config'].lower()+".conf"),'a+') as f:
        f.close()
    if os.stat(os.path.join(sdir,CoinSelect['config'].lower()+".conf"))[6]==0:
        with open(os.path.join(sdir,CoinSelect['config'].lower()+".conf"),'w') as f:
            f.write("server=1"+"\n")#It starts out as our turn
            f.write("rpcuser="+CoinSelect['rpcuser']+'\n')#The second line is for commands and lines
            CoinSelect['rpcpassword']=txhash(os.urandom(16))
            f.write("rpcpassword="+CoinSelect['rpcpassword']+'\n')
            f.write("rpcport="+CoinSelect['rpcport'])
            #f.write("rpctimeout=60"+'\n')
            #f.write("rpcthreads=8"+'\n')
            #f.write("dbcache=150")
            for node in CoinSelect['nodes']:
                f.write("\naddnode="+node)
            f.flush()
            os.fsync(f)
            f.close()
    else:
        with open(os.path.join(sdir,CoinSelect['config'].lower()+".conf"),'r') as f:
            lines=f.readlines()
            line=lines[2].replace("rpcpassword=","").strip()
            CoinSelect['rpcpassword']=line
            f.close()
        #Update nodes for old builds automatically
        addthis=[]
        for l in CoinSelect['nodes']:
            if "addnode="+l+"\n" not in lines and "addnode="+l not in lines:
                addthis.append(l)
        if addthis!=[]:
            for l in addthis:
                lines.append("\naddnode="+l)
            with open(os.path.join(sdir,CoinSelect['config'].lower()+".conf"),'w') as f:
                for l in lines:
                    f.write(l)
                f.flush()
                os.fsync(f)
                f.close()            
DataDirectory()
global BLK
global BitMHalo
global BlackHalo
global procs
procs = []

os.environ['no_proxy'] = '127.0.0.1,localhost'

global HaloRPC
xmlrpclib.Marshaller.dispatch[type(0L)] = lambda _, v, w: w("<value><i8>%d</i8></value>" % v)
try:#Test to see if its already running we can send it a command to show itself
    HaloRPC = xmlrpclib.ServerProxy('http://localhost:55779')
    socket.setdefaulttimeout(10)   
    HaloRPC.ShowHalo("password")
    sys.exit(1)
    #s.system.listMethods()
except Exception, e:
    try:
        socket.setdefaulttimeout(None) 
    except:
        pass
cntme=0
try:
    for directory in os.environ["PATH"].split(":"):
        cntme+=1
except:
    pass
if cntme==4:#It might be our Mac Wine build
    MacWine=1

if os.name == 'nt' and MacWine == 0:
    if os.path.isfile(os.path.join(application_path,"HaloTemp2.tmp")):
        try:#Python runs Halo twice because the interpreter, so this is the best way to do a clean exit on Halo
            os.remove(os.path.join(application_path,"HaloTemp2.tmp"))
        except:
            pass
        sys.exit(-1)
    if os.path.isfile(os.path.join(application_path,"HaloTemp.tmp")):#It wasn't a clean exit. Clear out old files.
        splash.hide()
        with open(os.path.join(application_path,"HaloTemp2.tmp"),'a+') as f:
            f.close()
        try:
            os.remove(os.path.join(application_path,"HaloTemp.tmp"))
        except:
            pass
        try:
            os.system('taskkill /f /im BitMHalo.exe')
        except:
            try:
                subprocess.call("c:\\windows\\system32\\taskkill.exe /im BitMHalo.exe /f")
            except:
                try:
                    os.system("tskill BitMHalo")
                except:
                    pass
        try:
            os.system('taskkill /f /im BitMHalo.exe')
        except:
            try:
                subprocess.call("c:\\windows\\system32\\taskkill.exe /im BitMHalo.exe /f")
            except:
                try:
                    os.system("tskill BitMHalo")
                except:
                    pass
        try:
            os.system('taskkill /f /im '+CoinSelect['daemon']+'.exe')
        except:
            try:
                subprocess.call("c:\\windows\\system32\\taskkill.exe /im "+CoinSelect['daemon']+".exe /f")
            except:
                try:
                    os.system("tskill "+CoinSelect['daemon'])
                except:
                    pass
        msbx=QtGui.QWidget()
        QtGui.QMessageBox.information(msbx, "Halo", "Halo was already running or it was not a clean exit. The software has now cleaned up from the previous run. Please restart the client.")
        sys.exit(-1)

if os.path.exists(os.path.join(application_path,"YandexAPI.txt")):
    with open(os.path.join(application_path,"YandexAPI.txt"),'r') as f:
        apikey=f.readline().strip()
        gstrans = YandexTranslate(apikey)
        YandexAPI = apikey
if os.path.exists(os.path.join(application_path,"cacert.pem")):
    os.environ['REQUESTS_CA_BUNDLE'] = os.path.join(application_path,"cacert.pem")

#if not isUserAdmin():
#    runAsAdmin()
#    from tendo import singleton
#    #singleton exits immediately... otherwise it notifies if twice. So to clean up on crashes we make a file that gets deleted on exit.
#    me = singleton.SingleInstance() # will sys.exit(-1) if other instance is running

def messagebox(text, text2, text3):
    msgBox = QtGui.QMessageBox()
    msgBox.setWindowTitle(CoinSelect['HaloName'])
    msgBox.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))

    if CoinSelect['moderngui']==1:
        qss_main = open(application_path+'/gui/styles/bay/messagebox.css', 'r')
        msgBox.setStyleSheet(qss_main.read()+"\nQMessageBox {background-color:#ffffff;}")
    msgBox.setText(text)
    msgBox.addButton(QtGui.QPushButton(text2), QtGui.QMessageBox.YesRole)
    msgBox.addButton(QtGui.QPushButton(text3), QtGui.QMessageBox.YesRole)
    response = msgBox.exec_()
    return response
res=0
pendingInstall = 0
if notifybuild!=0 and CoinSelect['name'] != "BitBay":
    if CoinSelect['name'] == "Bitcoin":
        res=1
    else:
        if CoinSelect['name'] == "Blackcoin":
            if not os.path.isfile(os.path.join(application_path,CoinSelect['daemon']+'.exe')):
                if not os.path.isfile(os.path.join(application_path,CoinSelect['daemon'])):
                    res=messagebox(CoinSelect['daemon'] + " was not included with Halo so it must be downloaded manually. Please visit https://github.com/CoinBlack/blackcoin-more/releases to get the most recent build and place it in the same directory as your Halo install. Then please restart the software.","Copy to clipboard and visit link","Exit Halo")
                    if res == 1:
                        sys.exit(-1)
                    pendingInstall=1
                    webbrowser.open("https://github.com/CoinBlack/blackcoin-more/releases")
                    clipboard = app.clipboard()
                    clipboard.setText("https://github.com/CoinBlack/blackcoin-more/releases") 
        if pendingInstall == 0:
            res=messagebox(CoinSelect['daemon'] + " was not built by the Halo dev. Instead, it was taken from the official project release page. For the best security you can build the software yourself. Would you like to launch " + CoinSelect['name'] + "?" + " If you cancel, you can compile your own build and restart the software.","Proceed","Cancel")
            if res==0:
                with open(os.path.join(application_path,"Halo.cfg"), 'a+') as f:
                    f.write("#Approved#")
                    f.flush()
                    os.fsync(f)
                    f.close()
#Windows
if os.name == 'nt':
    startupinfo = subprocess.STARTUPINFO()
    startupinfo.dwFlags = subprocess.CREATE_NEW_CONSOLE | subprocess._subprocess.STARTF_USESHOWWINDOW
    startupinfo.wShowWindow = subprocess._subprocess.SW_HIDE
    import win32process
    try:#We used to add the command -addnode=127.0.0.1 but got many instances of misbehaving
        if res==0:
            BlackHalo=subprocess.Popen(CoinSelect['daemon']+'.exe -port='+CoinSelect['port']+' -rpcport='+CoinSelect['rpcport']+' -datadir="'+sdir+'"',creationflags=win32process.CREATE_NO_WINDOW)#stdout=PIPE, stderr=PIPE
        else:
            BlackHalo=None
        BitMHalo=subprocess.Popen(("BitMHalo.exe path="+application_path),creationflags=win32process.CREATE_NO_WINDOW)# shell=True)#stdout=open(os.devnull, 'w'), stderr=open(os.devnull, 'w'))
        #BitMHalo=subprocess.Popen(("BitMHalo.py path="+application_path),shell=True)
    except:
        traceback.print_exc()
        print "Could not find necessary executables."
        print CoinSelect['daemon'], "\n", "BitMHalo"
        sys.exit(1)
else:
    #The frozen package can have issues finding the requests certificates so just fix it this way
    os.environ["REQUESTS_CA_BUNDLE"] = application_path + "/cacert.pem"
    try:
        if res==0:
            BlackHalo=subprocess.Popen([application_path+"/"+CoinSelect['daemon'], "-port="+CoinSelect['port'], "-rpcport="+CoinSelect['rpcport'], "-datadir="+sdir])
        else:
            BlackHalo=None
        BitMHalo=subprocess.Popen([application_path+"/BitMHalo", "path="+application_path])
    except:
        traceback.print_exc()
        print "Could not find necessary executables."
        print application_path+"/"+CoinSelect['daemon'], "\n", "BitMHalo"
        sys.exit(1)
procs.append(BitMHalo)
procs.append(BlackHalo)

class DecimalEncoder2(json.JSONEncoder):
  def default(self, myvar):
    if isinstance(myvar, Decimal):
      return float(myvar)
    return super(DecimalEncoder2, self).default(myvar)
class DecimalEncoder(json.JSONEncoder):
  def default(self, myvar):
    if isinstance(myvar, Decimal):
      return ('Decimal:' + str(myvar))
    return super(DecimalEncoder2, self).default(myvar)

def DecodeDecimal(thedata):
    for key in thedata:
        try:
            if ('Decimal' in thedata[key]):
                thedata[key] = Decimal(thedata[key].replace('Decimal:', ''))
        except:
            pass
    return thedata

try:
    if os.path.exists(os.path.join(application_path, 'liquiditydata.dat')):
        with open(os.path.join(application_path, 'liquiditydata.dat'), 'rb') as f:
            globliq = json.loads(bsonjs.dumps(f.read()), object_hook=DecodeDecimal)['1']
            f.close()
except:
    traceback.print_exc()
    globliq = []


#For hashing files
def checksum_sha256(filename):
    with open(filename, 'rb') as fh:
        h = hashlib.sha256()
        while True:
            data = fh.read(8192)
            if not data:
                break
            h.update(data)
        fh.close()
        return h.hexdigest()

#The method bitmessage uses for making unique icons for hashes
__all__ = ['render_identicon', 'IdenticonRendererBase']

class IdenticonRendererBase(object):
    PATH_SET = []
    
    def __init__(self, code):
        """
        @param code code for icon
        """
        if not isinstance(code, int):
            code = int(code)
        self.code = code
    
    def render(self, size, twoColor, opacity, penwidth):
        """
        render identicon to QPicture
        
        @param size identicon patchsize. (image size is 3 * [size])
        @return QPicture
        """
        
        # decode the code
        middle, corner, side, foreColor, secondColor, swap_cross = self.decode(self.code, twoColor)

        # make image
        image = QtGui.QPixmap(QtCore.QSize(size * 3 +penwidth, size * 3 +penwidth))
        
        # fill background
        backColor = QtGui.QColor(255,255,255,opacity)
        image.fill(backColor)
        
        kwds = {
            'image': image,
            'size': size,
            'foreColor': foreColor if swap_cross else secondColor,
            'penwidth': penwidth,
            'backColor': backColor}
            
        # middle patch
        image = self.drawPatchQt((1, 1), middle[2], middle[1], middle[0], **kwds)
        
        # side patch
        kwds['foreColor'] = foreColor
        kwds['type'] = side[0]
        for i in xrange(4):
            pos = [(1, 0), (2, 1), (1, 2), (0, 1)][i]
            image = self.drawPatchQt(pos, side[2] + 1 + i, side[1], **kwds)
            
        # corner patch
        kwds['foreColor'] = secondColor
        kwds['type'] = corner[0]
        for i in xrange(4):
            pos = [(0, 0), (2, 0), (2, 2), (0, 2)][i]
            image = self.drawPatchQt(pos, corner[2] + 1 + i, corner[1], **kwds)
        
        return image
                

    def drawPatchQt(self, pos, turn, invert, type, image, size, foreColor,
            backColor, penwidth):
        """
        @param size patch size
        """
        path = self.PATH_SET[type]
        if not path:
            # blank patch
            invert = not invert
            path = [(0., 0.), (1., 0.), (1., 1.), (0., 1.), (0., 0.)]

        
        polygon = QtGui.QPolygonF([QtCore.QPointF(x*size,y*size) for x,y in path])
        
        rot = turn % 4
        rect = [QtCore.QPointF(0.,0.), QtCore.QPointF(size, 0.), QtCore.QPointF(size, size), QtCore.QPointF(0., size)]
        rotation = [0,90,180,270]
        
        nopen = QtGui.QPen(foreColor, QtCore.Qt.NoPen)
        foreBrush = QtGui.QBrush(foreColor, QtCore.Qt.SolidPattern)
        if penwidth > 0:
            pen_color = QtGui.QColor(255, 255, 255)
            pen = QtGui.QPen(pen_color, QtCore.Qt.SolidPattern)
            pen.setWidth(penwidth)
        
        painter = QtGui.QPainter()
        painter.begin(image)
        painter.setPen(nopen)
        
        painter.translate(pos[0]*size +penwidth/2, pos[1]*size +penwidth/2)
        painter.translate(rect[rot])
        painter.rotate(rotation[rot])
        
        if invert:
            # subtract the actual polygon from a rectangle to invert it
            poly_rect = QtGui.QPolygonF(rect)
            polygon = poly_rect.subtracted(polygon)
        painter.setBrush(foreBrush)
        if penwidth > 0:
            # draw the borders
            painter.setPen(pen)
            painter.drawPolygon(polygon, QtCore.Qt.WindingFill)
        # draw the fill
        painter.setPen(nopen)
        painter.drawPolygon(polygon, QtCore.Qt.WindingFill)
        
        painter.end()
        
        return image

    ### virtual functions
    def decode(self, code):
        raise NotImplementedError        
class DonRenderer(IdenticonRendererBase):
    """
    Don Park's implementation of identicon
    see : https://www.docuverse.com/blog/donpark/2007/01/19/identicon-updated-and-source-released
    """
    
    PATH_SET = [
        #[0] full square:
        [(0, 0), (4, 0), (4, 4), (0, 4)],
        #[1] right-angled triangle pointing top-left:
        [(0, 0), (4, 0), (0, 4)],
        #[2] upwardy triangle:
        [(2, 0), (4, 4), (0, 4)],
        #[3] left half of square, standing rectangle:
        [(0, 0), (2, 0), (2, 4), (0, 4)],
        #[4] square standing on diagonale:
        [(2, 0), (4, 2), (2, 4), (0, 2)],
        #[5] kite pointing topleft:
        [(0, 0), (4, 2), (4, 4), (2, 4)],
        #[6] Sierpinski triangle, fractal triangles:
        [(2, 0), (4, 4), (2, 4), (3, 2), (1, 2), (2, 4), (0, 4)],
        #[7] sharp angled lefttop pointing triangle:
        [(0, 0), (4, 2), (2, 4)],
        #[8] small centered square:
        [(1, 1), (3, 1), (3, 3), (1, 3)],
        #[9] two small triangles:
        [(2, 0), (4, 0), (0, 4), (0, 2), (2, 2)],
        #[10] small topleft square:
        [(0, 0), (2, 0), (2, 2), (0, 2)],
        #[11] downpointing right-angled triangle on bottom:
        [(0, 2), (4, 2), (2, 4)],
        #[12] uppointing right-angled triangle on bottom:
        [(2, 2), (4, 4), (0, 4)],
        #[13] small rightbottom pointing right-angled triangle on topleft:
        [(2, 0), (2, 2), (0, 2)],
        #[14] small lefttop pointing right-angled triangle on topleft:
        [(0, 0), (2, 0), (0, 2)],
        #[15] empty:
        []]
    # get the [0] full square, [4] square standing on diagonale, [8] small centered square, or [15] empty tile:
    MIDDLE_PATCH_SET = [0, 4, 8, 15]
    
    # modify path set
    for idx in xrange(len(PATH_SET)):
        if PATH_SET[idx]:
            p = map(lambda vec: (vec[0] / 4.0, vec[1] / 4.0), PATH_SET[idx])
            PATH_SET[idx] = p + p[:1]
    
    def decode(self, code, twoColor):
        # decode the code
        shift  = 0; middleType  = (code >> shift) & 0x03
        shift += 2; middleInvert= (code >> shift) & 0x01
        shift += 1; cornerType  = (code >> shift) & 0x0F
        shift += 4; cornerInvert= (code >> shift) & 0x01
        shift += 1; cornerTurn  = (code >> shift) & 0x03
        shift += 2; sideType    = (code >> shift) & 0x0F
        shift += 4; sideInvert  = (code >> shift) & 0x01
        shift += 1; sideTurn    = (code >> shift) & 0x03
        shift += 2; blue        = (code >> shift) & 0x1F
        shift += 5; green       = (code >> shift) & 0x1F
        shift += 5; red         = (code >> shift) & 0x1F
        shift += 5; second_blue = (code >> shift) & 0x1F
        shift += 5; second_green= (code >> shift) & 0x1F
        shift += 5; second_red  = (code >> shift) & 0x1F
        shift += 1; swap_cross  = (code >> shift) & 0x01
        
        middleType = self.MIDDLE_PATCH_SET[middleType]
        
        foreColor = (red << 3, green << 3, blue << 3)
        foreColor = QtGui.QColor(*foreColor)
        
        if twoColor:
            secondColor = (second_blue << 3, second_green << 3, second_red << 3)
            secondColor = QtGui.QColor(*secondColor)
        else:
            secondColor = foreColor
        
        return (middleType, middleInvert, 0),\
               (cornerType, cornerInvert, cornerTurn),\
               (sideType, sideInvert, sideTurn),\
               foreColor, secondColor, swap_cross
def render_identicon(code, size, twoColor=False, opacity=255, penwidth=0, renderer=None):
    if not renderer:
        renderer = DonRenderer
    return renderer(code).render(size, twoColor, opacity, penwidth)

def DataIcon(datatohash, PixmapIcon=0):
    hashy=txhash(str(datatohash))
    image = render_identicon(int(hashy, 16), 8, True, 255, 0)
    pixmap = QtGui.QPixmap(image)
    if PixmapIcon==1:
        icon = QtGui.QIcon()
        icon.addPixmap(pixmap)
        return icon
    else:
        return pixmap

#For manual Garbage Collection if needed
class GarbageCollector(QtCore.QObject):
    '''
    Disable automatic garbage collection and instead collect manually
    every INTERVAL milliseconds.

    This is done to ensure that garbage collection only happens in the GUI
    thread, as otherwise Qt can crash.
    '''

    INTERVAL = 10000

    def __init__(self, parent, debug=False):
        QtCore.QObject.__init__(self, parent)
        self.debug = debug

        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.check)

        self.threshold = gc.get_threshold()
        gc.disable()
        self.timer.start(self.INTERVAL)

    def check(self):
        #return self.debug_cycles() # uncomment to just debug cycles
        l0, l1, l2 = gc.get_count()
        if self.debug:
            print ('gc_check called:', l0, l1, l2)
        if l0 > self.threshold[0]:
            num = gc.collect(0)
            if self.debug:
                print ('collecting gen 0, found:', num, 'unreachable')
            if l1 > self.threshold[1]:
                num = gc.collect(1)
                if self.debug:
                    print ('collecting gen 1, found:', num, 'unreachable')
                if l2 > self.threshold[2]:
                    num = gc.collect(2)
                    if self.debug:
                        print ('collecting gen 2, found:', num, 'unreachable')

    def debug_cycles(self):
        gc.set_debug(gc.DEBUG_SAVEALL)
        gc.collect()
        for obj in gc.garbage:
            print (obj, repr(obj), type(obj))

#For loading numpy objects
#json.loads(json.dumps(data, cls=NumpyEncoder), object_hook=json_numpy_obj_hook)
#class NumpyEncoder(json.JSONEncoder):
#
#    def default(self, obj):
#        """If input object is an ndarray it will be converted into a dict 
#        holding dtype, shape and the data, base64 encoded.
#        """
#        if isinstance(obj, np.ndarray):
#            if obj.flags['C_CONTIGUOUS']:
#                obj_data = obj.data
#            else:
#                cont_obj = np.ascontiguousarray(obj)
#                assert(cont_obj.flags['C_CONTIGUOUS'])
#                obj_data = cont_obj.data
#            data_b64 = base64.b64encode(obj_data)
#            return dict(__ndarray__=data_b64,
#                        dtype=str(obj.dtype),
#                        shape=obj.shape)
#        # Let the base class default method raise the TypeError
#        super(JsonNumpy, self).default(obj)
#class DecimalEncoder(json.JSONEncoder):
#    def default(self, o):
#        if isinstance(o, Decimal):
#            return float(o)
#        return super(DecimalEncoder, self).default(o)
#def json_numpy_obj_hook(dct):
#    """Decodes a previously encoded numpy ndarray with proper shape and dtype.
#
#    :param dct: (dict) json encoded ndarray
#    :return: (ndarray) if input was an encoded ndarray
#    """
#    if isinstance(dct, dict) and '__ndarray__' in dct:
#        data = base64.b64decode(dct['__ndarray__'])
#        return np.frombuffer(data, dct['dtype']).reshape(dct['shape'])
#    return dct
def update_dict(data_copy, data):
    for k, v in data_copy.iteritems():
        if v != data[k]:
            if isinstance(v, dict):
                update_dict(v, data[k])
            elif isinstance(v, list):
                update_list(v, data[k])
            elif isinstance(v, float):
                data_copy[k] = data[k]
def update_list(data_copy, data):
    for i, value in enumerate(data_copy):
        if value != data[i]:
            if isinstance(value, dict):
                update_dict(value, data[i])
            elif isinstance(value, list):
                update_list(value, data[i])
            elif isinstance(value, float):
                data_copy[i] = data[i]
def json_deep_copy(data, useast=0):
    if data is None:
        return data
    if useast==1:#If there are tuples then we must do this
        data_copy = ast.literal_eval(str(data))
        return data_copy
    #  precise_float is slower, but we get more reports of diffs
    #  without it (floats being floats)
    try:
        data_copy = ujson.loads(
            ujson.dumps(data, double_precision=15),
            precise_float=True)
        if isinstance(data_copy, list):
            update_list(data_copy, data)
        else:
            update_dict(data_copy, data)
    except OverflowError:
        data_copy = json.loads(json.dumps(data))
    except Exception:
        print ("non-json safe object passed. falling back to deepcopy")
        try:
            data_copy = copy.deepcopy(data)
        except:
            data_copy = ast.literal_eval(str(data))
    return data_copy

def retranslateUi2():
    global translations, globfont
    #window.Tabs.setStyleSheet(_fromUtf8("QTabWidget::pane { /* The tab widget frame */\nborder-top: 6px solid #000000;\nborder-right: 2px solid #000000;\nborder-left: 2px solid #000000;\nborder-bottom: 6px solid #000000;\nmargin-top:0px;\nbackground-color:#ececec;\nbackground: qlineargradient(x1:0, y1:1, x2:1, y2:0, stop:0 #c0c0c0, stop: 0.4 rgba(236, 236, 236, 200), stop:1 rgb(236, 236, 236, 200));\n    background-image: url(:/Images/images/bg_blackhalo.png);\n  background-position: top right;\n  background-repeat: no-repeat;\n\n}\nQTabWidget::tab-bar {\nleft: 0px; /* move to the right by 5px */\n\n}\n/* Style the tab using the tab sub-control. Note that it reads QTabBar _not_ QTabWidget */\nQTabBar::tab {\ncolor: #222222;\nopacity: 0.6;\ntext-align: center;\nbackground-color: #e8b100;\n\nbackground: qlineargradient(x1:1, y1:1, x2:1, y2:0, stop:0 #ffc300, stop: 0.4 rgba(232, 177, 0, 250), stop:1 rgb(232, 177, 0, 250));\n\npadding: 20px 5px 20px 5px;\n/*padding: 40px 10px 10px 10px; */\nborder-right: 1px dotted #222222;\n}\nQTabBar::tab:selected, QTabBar::tab:hover {\ncolor: #fbfbfb;\n}\nQTabBar::tab:selected {\nbackground: #000000;\ncolor: #fbfbfb;\nopacity: 1;\n}\nQTabBar::tab:!selected {\nmargin-top: 0px; /* make non-selected tabs look smaller */\n\n}"))
    #window.frame_2.setStyleSheet(_fromUtf8("QFrame#frame_2 {\n/*your qss properties here*/\nbackground: qlineargradient(x1:1, y1:1, x2:0, y2:1, stop:0 #202020, stop: 0.4 rgba(34, 34, 34, 250), stop:0 rgb(50, 50, 50, 250));\n    background-image: url(:/Images/images/bg_blackhalo_2.png);\n  background-position: top right;\n  background-repeat: no-repeat;\n\n}"))
    #window.label_2.setStyleSheet(_fromUtf8("font: bold 24px \"Arial\";\ncolor: #e8b100;\n\n"))
    #window = MyApp()
    window.translations=translations
    if CoinSelect['name'] == "Bitcoin":
        window.NewCoin=copy.deepcopy(Coins[2])
        window.BitHalo(window)
    if CoinSelect['name'] == "Blackcoin":
        window.NewCoin=copy.deepcopy(Coins[0])
        window.BLKHalo(window)
        res=window.GTranslate()#Check to see if we have translations
        if res==True:
            window.BLKHalo(window)
        window.resize(window.Tabs.minimumSizeHint())
        #window.adjustSize()
    if CoinSelect['name'] == "BitBay":
        window.NewCoin=Coins[1]
        if CoinSelect['moderngui']==0:
            globfont='MS Shell Dlg 2'
            window.OtherCoin(window)
        else:
            globfont='Roboto'
            window.BayHalo(window)
        res=window.GTranslate()#Check to see if we have translations
        if res==True:
            if CoinSelect['moderngui']==0:
                window.OtherCoin(window)
            else:
                window.BayHalo(window)
        window.resize(window.Tabs.minimumSizeHint())
        #window.adjustSize()
        if CoinSelect['moderngui']==0:
            window.switchcoin.hide()
    window.MyBalance_3.setText("")
    window.MyBalance_7.setText("")
    window.MyBalance.setText("")
    AdvancedWindow.retranslateUi(AdvancedWindow)
    WinContracts.retranslateUi(WinContracts)
    WinContacts.retranslateUi(WinContacts)
    WindowHandshake.retranslateUi(WindowHandshake)
    WindowSent.retranslateUi(WindowSent)
    WindowReceived.retranslateUi(WindowReceived)
    WChangeList.retranslateUi(WChangeList)
    WStakeList.retranslateUi(WStakeList)
    ExplanationWindow.retranslateUi(ExplanationWindow)
    OutboxWindow.retranslateUi(OutboxWindow)
    SetupWizard.retranslateUi(SetupWizard)
    CustomForm.retranslateUi(CustomForm)
    P2MWindow.retranslateUi(P2MWindow)
    MySettings.retranslateUi(MySettings)

    Templates.retranslateUi()

    res=window.GTranslate()#Check to see if we have translations
    if res==True:
        AdvancedWindow.retranslateUi(AdvancedWindow)
        WinContracts.retranslateUi(WinContracts)
        WinContacts.retranslateUi(WinContacts)
        WindowHandshake.retranslateUi(WindowHandshake)
        WindowSent.retranslateUi(WindowSent)
        WindowReceived.retranslateUi(WindowReceived)
        WChangeList.retranslateUi(WChangeList)
        WStakeList.retranslateUi(WStakeList)
        ExplanationWindow.retranslateUi(ExplanationWindow)
        OutboxWindow.retranslateUi(OutboxWindow)
        SetupWizard.retranslateUi(SetupWizard)
        CustomForm.retranslateUi(CustomForm)
        P2MWindow.retranslateUi(P2MWindow)
        MySettings.retranslateUi(MySettings)

    translations=window.translations
    SaveTranslations()

    window.EnableIRC.hide()
    icon = QtGui.QIcon()
    icon.addPixmap(QtGui.QPixmap(_fromUtf8(application_path+"/images/BitHalo.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    icon2 = QtGui.QIcon()
    icon2.addPixmap(QtGui.QPixmap(_fromUtf8(application_path+CoinSelect['logo'])), QtGui.QIcon.Normal, QtGui.QIcon.Off)
    if CoinSelect['name'] == "Bitcoin":
        if CoinSelect['moderngui']==0:
            window.HaloContactsIcon_2.setIcon(icon)
            window.HaloContactsIcon.setIcon(icon)
            window.switchcoin.setText("")
        window.Rescan.hide()
        window.progressBar.hide()
        window.labelProgress.hide()
        if CoinSelect['moderngui']==0:
            window.Rescan2.hide()
            window.progressBar2.hide()
            window.labelProgress2.hide()
    else:
        if CoinSelect['moderngui']==0:
            window.HaloContactsIcon_2.setIcon(icon2)
            window.HaloContactsIcon.setIcon(icon2)
            window.switchcoin.setText("")
        window.Rescan.show()
        window.progressBar.show()
        window.labelProgress.show()
        if CoinSelect['moderngui']==0:
            window.Rescan2.show()
            window.progressBar2.show()
            window.labelProgress2.show()
    #Some features are only exclusive to BitBay before completion of Halo
    if CoinSelect['name'] != "BitBay":
        #window.actionEncrypt_Decrypt.setVisible(False)
        #window.actionSign_Verify.setVisible(False)
        window.actionEncrypt_Decrypt.setVisible(True)
        window.actionSign_Verify.setVisible(True)
        MySettings.ProxyLabel.hide()
        MySettings.ProxyEdit.hide()
        MySettings.Info.hide()
        MySettings.ActivateAntiKeylogger.hide()
        MySettings.DonateStake.hide()
        MySettings.PeggingVote.hide()
    else:
        window.actionEncrypt_Decrypt.setVisible(True)
        window.actionSign_Verify.setVisible(True)
        MySettings.ProxyLabel.show()
        MySettings.ProxyEdit.show()
        MySettings.Info.show()
        MySettings.ActivateAntiKeylogger.show()
        MySettings.DonateStake.show()
        MySettings.PeggingVote.show()
    window.Symbol_1.setText(CoinSelect['Symbol'])
    window.Symbol_2.setText(CoinSelect['Symbol'])
    window.Symbol_3.setText(CoinSelect['Symbol'])
    window.Symbol_4.setText(CoinSelect['Symbol'])
    window.Symbol_5.setText(CoinSelect['Symbol'])
    if CoinSelect['moderngui']==0:
        window.MyAddress_7.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: "))
        window.MyAddress_2.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: "))
        window.MyAddress.setText(CoinSelect['name'].upper()+ ": ")
    else:
        window.tab.myAddressLineEdit.setText("")
        window.History.le_myAddress.setText("")
        window.ReceiveBitcoins.receiveCoinAddressLineEdit.setText("")

def Reconnect(rescan=0):#Sometimes the daemon disconnects after a while. The cause is currently unknown so for now, we reconnect
    global procs
    global BlackHalo
    global sdir
    global rescanning
    global disconnected
    if BlackHalo != None:
        byebye=procs[1]    
        try:#clean exit if we can
            if os.name == 'nt':
                subprocess.Popen(CoinSelect['daemon']+'.exe -port='+CoinSelect['port']+' -rpcport='+CoinSelect['rpcport']+' -datadir="'+sdir+'"'+' stop',creationflags=win32process.CREATE_NO_WINDOW)#stdout=PIPE, stderr=PIPE
            else:
                subprocess.Popen([application_path+"/"+CoinSelect['daemon'], "-port="+CoinSelect['port'], "-rpcport="+CoinSelect['rpcport'], "-datadir="+sdir], " stop")
        except:
            pass
        time.sleep(3)
        try:
            byebye.terminate()
            time.sleep(.1)
            byebye.kill()
        except:
            pass
        time.sleep(3)
    if disconnected == 1:#If its an RPC thing lets give it more time
        time.sleep(30)
    try:
        if os.name == 'nt':
            if rescan==0:
                BlackHalo=subprocess.Popen(CoinSelect['daemon']+'.exe -port='+CoinSelect['port']+' -rpcport='+CoinSelect['rpcport']+' -datadir="'+sdir+'"',creationflags=win32process.CREATE_NO_WINDOW)#stdout=PIPE, stderr=PIPE
            else:
                if rescan==9:
                    BlackHalo=subprocess.Popen(CoinSelect['daemon']+'.exe -reindex -port='+CoinSelect['port']+' -rpcport='+CoinSelect['rpcport']+' -datadir="'+sdir+'"',creationflags=win32process.CREATE_NO_WINDOW)#stdout=PIPE, stderr=PIPE
                else:
                    BlackHalo=subprocess.Popen(CoinSelect['daemon']+'.exe -rescan -port='+CoinSelect['port']+' -rpcport='+CoinSelect['rpcport']+' -datadir="'+sdir+'"',creationflags=win32process.CREATE_NO_WINDOW)#stdout=PIPE, stderr=PIPE
        else:
            if rescan==0:
                BlackHalo=subprocess.Popen([application_path+"/"+CoinSelect['daemon'], "-port="+CoinSelect['port'], "-rpcport="+CoinSelect['rpcport'], "-datadir="+sdir])
            else:
                if rescan==9:
                    BlackHalo=subprocess.Popen([application_path+"/"+CoinSelect['daemon'], "-reindex", "-port="+CoinSelect['port'], "-rpcport="+CoinSelect['rpcport'], "-datadir="+sdir])
                else:                
                    BlackHalo=subprocess.Popen([application_path+"/"+CoinSelect['daemon'], "-rescan", "-port="+CoinSelect['port'], "-rpcport="+CoinSelect['rpcport'], "-datadir="+sdir])
        procs[1]=BlackHalo
        rescanning=0
    except:
        print "Connection error!"
        return False
        #Should I exit here?
    return True
def ResetBitMHalo():
    global procs
    global BitMHalo
    global sdir
    byebye=procs[0]
    try:
        byebye.terminate()
        time.sleep(.1)
        byebye.kill()
    except:
        pass
    time.sleep(.3)
    try:
        if os.name == 'nt':
            try:
                os.system('taskkill /f /im BitMHalo.exe')
            except:
                try:
                    subprocess.call("c:\\windows\\system32\\taskkill.exe /im BitMHalo.exe /f")
                except:
                    try:
                        os.system("tskill BitMHalo")
                    except:
                        pass
            time.sleep(.3)
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags = subprocess.CREATE_NEW_CONSOLE | subprocess._subprocess.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = subprocess._subprocess.SW_HIDE
            BitMHalo=subprocess.Popen(("BitMHalo.exe path="+application_path),creationflags=win32process.CREATE_NO_WINDOW)# shell=True)#stdout=open(os.devnull, 'w'), stderr=open(os.devnull, 'w'))
        else:
            BitMHalo=subprocess.Popen([application_path+"/BitMHalo", "path="+application_path])
        procs[0]=BitMHalo
    except:
        print "BitMHalo error!"
        return False
        #Should I exit here?
    return True
import atexit, platform
@atexit.register
def kill_subprocesses():
    global sdir
    try:#clean exit if we can
        if os.name == 'nt':
            subprocess.Popen(CoinSelect['daemon']+'.exe -port='+CoinSelect['port']+' -rpcport='+CoinSelect['rpcport']+' -datadir="'+sdir+'"'+' stop',creationflags=win32process.CREATE_NO_WINDOW)#stdout=PIPE, stderr=PIPE
        else:
            subprocess.Popen([application_path+"/"+CoinSelect['daemon'], "-port="+CoinSelect['port'], "-rpcport="+CoinSelect['rpcport'], "-datadir="+sdir], " stop")
    except:
        pass
    for proc in procs:
        try:
            proc.terminate()
        except:
            pass

    time.sleep(0.3)
    for proc in procs:
        try:
            if proc.poll() == None:
                proc.kill()
        except:
            pass
#IRCMHalo=subprocess.Popen("IRCMHalo.py", shell=True)

#Custom Main program loop... I'm old school like that
def Loop():
    global MyContracts, OnOrders, Spendable, BitHaloClient, downloadThread, bitmessThread, blackcoindThread, RPC, FileSave, RunPython, ThePeg
    global updatesomething, Markets, SALT, AdvanceArray, CoinSelect, addrlist, MasterOrders, MyEmail, ApprovedContracts, globliq
    global window, merkleHashes
    #Just for extra security, salt all random numbers.
    SALT = str(time.time())
    SALT+=str(QtGui.QCursor.pos())
    Notification(0, "")
    if keysconnected != "0":
        updatesomething = 1
    #Load threads
    RPC = RPCThread("RPCThread")
    RPC.start()
    downloadThread = DownloadThread("Hello world")
    downloadThread.start()
    bitmessThread = BitMessageThread("My BitMessage")
    bitmessThread.start()
    blackcoindThread = BlackCoinThread("BlackCoin")
    blackcoindThread.start()
    Select=GetfromCfg("#CoinSelect#")
    if Select=="BTC":
        CoinSelect=copy.deepcopy(Coins[2])
    if Select=="BLK":
        CoinSelect=copy.deepcopy(Coins[0])
    if Select=="BAY":
        CoinSelect=copy.deepcopy(Coins[1])
    DataDirectory()
    retranslateUi2()
    IsWizard=GetfromCfg("#Wizard#")
    if IsWizard=="1":
        SetupWizard.retranslateUi(SetupWizard)
        SetupWizard.show()
        window.icon.show()
        window.hide()
    BM=GetfromCfg("#EnableBM#")
    EM=GetfromCfg("#EnableEmail#")
    NM=GetfromCfg("#Notify#")
    MM=GetfromCfg("#Market#")
    SM=GetfromCfg("#Spam#")
    if NM=="1":
        window.checkBox.setCheckState(2)
    else:
        window.checkBox.setCheckState(0)
    if MM=="0":
        window.FilterCustom.setCheckState(2)
    else:
        window.FilterCustom.setCheckState(0)
    if SM=="0":
        window.DisableSpamFilter.setCheckState(0)
    else:
        window.DisableSpamFilter.setCheckState(2)

    if BM==" " and EM==" ":#Its default
        window.EnableBitmessage.setCheckState(2)
        window.EnableEmail.setCheckState(2)
    if BM=="Y":
        window.EnableBitmessage.setCheckState(2)
    if BM=="N":
        window.EnableBitmessage.setCheckState(0)
    if EM=="Y":
        window.EnableEmail.setCheckState(2)
    if EM=="N":
        window.EnableEmail.setCheckState(0)

    if CoinSelect['Symbol'] == "BTC":
        BitHaloClient=True
        window.ContractFee.setText("0.0007")
        window.BitFee.setText("0.0007")
    else:
        BitHaloClient=False
        window.ContractFee.setText("0.02")
        window.BitFee.setText("0.02")
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    PopulateHistory()
    if CoinSelect['moderngui']==0:
        window.MyAddress_7.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multisig)
        window.MyAddress_2.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multisig)
        window.MyAddress.setText(Gtranslate(CoinSelect['name'].upper()+": ")+ multisig)
    else:
        window.tab.myAddressLineEdit.setText(multisig)
        window.History.le_myAddress.setText(multisig)
        window.ReceiveBitcoins.receiveCoinAddressLineEdit.setText(multisig)
    backup=strOUT(GetfromCfg("#BackupPath#"))
    if backup != " ":
        window.TxBackupPath.setText(backup)
    #Main loop initialization and other wallet stuff
    ticker=0
    ticker2=0
    try:
        if os.name == 'nt':
            adir=application_path+"\\"+'custom'
        else:
            adir=application_path+"/"+'custom' #Its probably Linux.

        if not os.path.exists(adir): os.mkdir(adir)
        with open(os.path.join(adir,"Approved.dat"),'a+') as f:
            f.close()
        with open(os.path.join(adir,"Approved.dat"),'r') as f:
            ApprovedContracts=ast.literal_eval(f.readline())
            f.close()
    except:
        ApprovedContracts={}
    try:
        if os.path.exists(os.path.join(application_path,"liquidity.dat")):
            os.remove(os.path.join(application_path, 'liquidity.dat'))
    except:
        traceback.print_exc()
    #Before we loop,lets load the contract and order data
    i=0
    data=[]
    with open(os.path.join(application_path,"Contracts.dat"),'a+') as f:
        f.close()
    with open(os.path.join(application_path,"Contracts.dat"),'r') as f:
        data=f.readlines()
        f.close()
    for d in data:
        if d[0]=="#":
            #Here we look for our data and see if there was any orders in it under our name.
            try:
                addrlist.append(data[i+1].strip())
                if data[i+1].strip()==multisig:
                    if d[1]=="$":
                        MyContracts=ast.literal_eval(data[i+2].strip())
                    if d[2]=="%":
                        try:
                            OnOrders=ast.literal_eval(data[i+3].strip())
                        except:
                            traceback.print_exc()
                else:#For staking we will build a master list of pending orders in other accounts to prevent double spend
                    try:
                        if d[2]=="%":
                            orderlist=ast.literal_eval(data[i+3].strip())
                            pos=-1
                            for x in orderlist:
                                pos+=1
                                if x['type']=="Spendable" or x['type']=="History":
                                    orderlist.pop(pos)
                                    break
                            pos=-1
                            for x in orderlist:
                                pos+=1
                                if x['type']=="Spendable" or x['type']=="History":
                                    orderlist.pop(pos)
                                    break
                            for o in orderlist:
                                for inp in o['inputs']:
                                    MasterOrders[inp['output']]=''
                    except:
                        pass
            except Exception, e:
                print "Exception loading contracts/orders."#It's worth noting that brand new accounts throw an exception
        i+=1
    avail=0
    mbl=0
    for o in OnOrders:
        if o['type']=="Spendable":
            Spendable=o['Spendable']
        if o['type']=="History":
            if 'balance' in o:
                window.MyBalance.setText(str(o['balance']))
                mbl=o['balance']
            myhis=o['myhistory']
            for i in myhis:
                window.HistorylistWidget.addItem(str(i))
        if o['type']=="CONTRACT" or o['type']=="2STEP" or o['type']=="SPENT" or o['type']=="PAY TO EMAIL":
            avail=1
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        if mbl!=0:
            mbl=" (not up to date)"
    #See if the balance is available or actual
    if mbl!=0:
        if avail==0:
            window.MyBalance_4.hide()
            window.WelcomeActualBalance.setText(Gtranslate("Actual Balance:"))
            window.MyBalance_3.setText(str(mbl))
            window.MyBalance_8.hide()
            window.Symbol_2.hide()
            window.Symbol_4.hide()
            window.SendActualBalance.setText(Gtranslate("Actual Balance:"))
            window.MyBalance_7.setText(str(mbl))
        else:
            window.MyBalance_4.show()
            window.WelcomeAvailableBalance.setText(Gtranslate("Available Balance:"))
            window.MyBalance_4.setText(str(mbl))
            window.MyBalance_8.show()
            window.Symbol_2.show()
            window.Symbol_4.show()
            window.SendAvailableBalance.setText(Gtranslate("Available Balance:"))
            window.MyBalance_8.setText(str(mbl))
    BitAddr=GetfromCfg("#BitMessage#")
    if CoinSelect['moderngui']==0:
        window.MyAddress_3.setText(Gtranslate("BITMESSAGE: ")+ BitAddr)
    else:
        window.ReceiveBitcoins.receiveBitMessageAddressLineEdit.setText(BitAddr)
    if 'InboxCleanTime' not in AdvanceArray:
        AdvanceArray['InboxCleanTime']=time.time()
    if 'MySettings' not in AdvanceArray:
        AdvanceArray['MySettings']={'Proxy':'', 'AntiLogger':False, 'ManualLogin':False, 'ClearLocation':False, 'FilterOther':False, 'CreateDebug':False, 'Staking':False, 'ColdStake':'', 'PeggingVote':0, 'Voting':[]}
    if 'bridgedb' not in AdvanceArray:
        AdvanceArray['bridgedb']=ThePeg.Pegdatabase['bridgedb']
    MySettings.Load()
    AdvanceArray['clearnotxid']=1
    if 'StakingAccounts' not in AdvanceArray:
        AdvanceArray['StakingAccounts']={}
    if 'StakedOrders' not in AdvanceArray:
        AdvanceArray['StakedOrders']={}
    #This is for custom loops that run outside of Qt.
    app.processEvents()
    SaveTranslations()
    if Markets=={}:
        Markets={"MyMarkets":{CoinSelect['default market']:""},"Current":CoinSelect['default market'],"Banlist":[],"Enable":1,'Orders':[],'Sort':[0,0],'Flags':[0,time.time()],'U':os.urandom(16).encode('hex')[:10],'Reputation':{}}
        AddMarket(CoinSelect['default market'])
    else:
        UpdateMarketList()
    updatesomething=1
    Update()
    #Check to see if we have changed emails within contracts. Our counterparties must be able to contact us.
    GetEmailGlobals()
    if AdvanceArray['MySettings']['ManualLogin']:
        GetEmailPassword()
        GetEmailGlobals()
    showonce=0
    if MyContracts != []:
        for c in MyContracts:
            if 'MyBMAddress' in c:
                if "BM-" in c['MyBMAddress'] and BitAddr != c['MyBMAddress']:
                        res=QuestionBox(Gtranslate("Your current Bitmessage address is different from the one listed in one of your contracts. Please make sure the correct address is listed/loaded. Is it possible that your address changes depending on the order in which you load your keys because it was set up as a joint account. Joint and Two Step accounts sometimes use different Bitmessage addresses for the same keypair. Normal accounts use the same address regardless of which key is loaded. If you are involved in any open contracts, please alert your effected counter-parties so you both can manually import/export messages.\n\n"+"Bitmessage listed: ") + c['MyBMAddress'] + "\n" + Gtranslate("Current Bitmessage: ") + BitAddr, Gtranslate("Change the order of loaded keys(may not fix the issue)"), Gtranslate("Update Later"),1)
                        if res==0:
                            OpenWallet()
                if "@" in c['MyBMAddress'] and MyEmail != c['MyBMAddress']:
                    if showonce==0:
                        res=QuestionBox(Gtranslate("Your current email is different from the one listed in one of your contracts. Please make sure the email address is listed/loaded. It's recommended you don't change emails during negotiations so your parties can contact you.\n\n"+"Email listed: ") + c['MyBMAddress'] + "\n" + Gtranslate("Current Email: ") + MyEmail, Gtranslate("Update Email"), Gtranslate("Update Later"),1)
                        if res==0:
                            window.NewEmail()
                    showonce=1
    PopulateMarkets()
    global LockTHIS, notDownloading
    while True:
        try:
            if 'BM' not in LockTHIS and 'DL' not in LockTHIS and 'BL' not in LockTHIS:
                LockTHIS['AP']=1
                app.processEvents()
                LockTHIS.pop('AP', None)
        except:
            LockTHIS.pop('AP', None)
            print "Error in Application EVENT"
            traceback.print_exc()
        ticker+=1
        ticker2+=1
        time.sleep(0.01)
        #If the ticker reaches a certain time refresh the application
        if ticker == 50 or notDownloading == 1:
            Update()
            ticker=0
        if ticker2 == 100:
            PopulateContracts()
            ticker2=0
#This code still doesn't do a giant liquidity pool for all liquid users. That method is to have all liquid users share same distribution chart.
#That way, the exchange doesn't have to query each liquid trade. The exchange must keep individual user peg data at all costs though to avoid
#an eventual normal distribution which would unfairly impact equity and custody. So user reserves are unique. However, to cut down on API 
#calls further, all reserve balances on exchanges database can be compared before/after an interval. Then all users who participated in reserve trades 
#can share in the redistribution of reserves based on those individual users charts. That also makes for a smooth trading experience with less 
#guess work as it's pool based trading. It is also of theorertical curiousity if a blockchain can be approached in the same way based on active trades.
class PegThread(QtCore.QThread):
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        i=0
        l=[float('.99')]
        self.rate=100 #1%
        if TestnetPeg:
            self.amountofsteps=1199
            while i < self.amountofsteps-1:
                l.append(float(str((Decimal(l[i])*Decimal('.99')).quantize(Decimal('.0000000001')))))
                i+=1
        else:
            self.amountofsteps=1200
            while i < self.amountofsteps-1:
                l.append(float(str((Decimal(l[i])*Decimal('.99')).quantize(Decimal('.0000000001')))))
                i+=1
        #self.newpool=np.array(l)
        self.steps=l
        self.Pegdatabase={}
        #Starting block should have a factor of the interval
        self.Pegdatabase['startingblock']=1807400#1684900
        self.Pegdatabase['blockcount']=self.Pegdatabase['startingblock']#The count is for the block we don't have yet
        self.Pegdatabase['votesblockcount']=self.Pegdatabase['startingblock']#The count is for the block we don't have yet
        self.Pegdatabase['votesblockcount2']=self.Pegdatabase['startingblock']
        self.Pegdatabase['supply']=0 #Measured in steps of 1% away from 100%
        self.Pegdatabase['votedata']={}#{'1684900':[0,0,0]}
        self.Pegdatabase['votedata2']={}
        self.Pegdatabase['votecycle']=0
        self.Pegdatabase['prevhashes']=[]#Holds data about previous hashes
        #If needed, special accounts for exchanges can be activated
        self.Pegdatabase['specialaccounts']={}
        self.writing=0
        self.interval=200
        self.votealgo=''
        self.amrunning=True
        self.queue=[]
        self.ignorelist={'bNyZrPeFFNP6GFJZCkE82DDN7JC4K5Vrkk':'','bNyZrP2SbrV6v5HqeBoXZXZDE2e4fe6STo':'','bNyZrPLQAMPvYedrVLDcBSd8fbLdNgnRPz':'','bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3':''}
        self.whitelist={'bTuZboysrngsaqJvRj4db4CV2Qa21Q5Jcb':'','bNgmCcxPKgQQqUe6rhNtbGWowMJFCuxjZ3':''}#,'bbiUkiqFUsTciMsBdnYETgE2DMg4k3fMdP':'','bMkmLGdNxbr4wpbZUr1k67Tdq5yYLE9jV2':'', 'bNfFbrFau9upJ69VQrmSV3EsDwShKpb2pw':''}
        self.memaccountpools={}
        self.pegfeeperinput=5000
        self.subpremiumrating=200
        self.whitelistoutputs=1
        self.contractbuffer=21 #We tend to buffer transactions with 7 blocks of voting intervals.
        self.prunetopools=0#for now prune frequency for pools is every three intervals. 
        self.accounts={}
        self.accounts2={'users':{}}
        self.queuenonce=0
        self.queuenonce2=0
        self.queuecount=0
        self.queuecount2=0
        self.queuecount3=0
        self.queuecount4=0
        self.exchangeconfirmations=7
        self.exchangebuffer=1
        self.startexchange=0
        self.stopexchange=0
        self.exchangerunning=False
        self.exchangepassword=''
        self.ExchangeBalance={'liquid':0,'reserve':0,'subpremium':0,'frozen':0}
        self.apipassword=''
        #Exchange setting 1 is the most precise grabbing from all liquidities directly from trade partners.
        #Exchange setting 2 is less precise, deposits are still split however trades are estimated based on supply during time of trade
        #The priority for redemption (there are several strategies) is to grab balance of the most liquid users first. Then on
        #the last liquid key simply make a ratio the the remainder and split it among all users who share it.
        self.exchangesetting=1
        self.exchangebusy=1
        self.exchangeready=0
        self.updatingbalance=0
        self.highkeyimport=0
        self.Spendable={}
        self.exchange={}
        self.exchangecycle=0
        self.reservewithdrawcount={}
        self.liquidwithdrawcount={}
        self.reservelimit=45
        self.liquidlimit=300
        self.clearID={}
        #Eventually consider stronger defense for exhausting mempools
        #If the account pools becomes activated, then the software needs to have protocols to adjust liquidity every time something is deducted from a pool.
        #Also the system should prepare to check transactions planned in advance such as double deposit being aware that orders can become expired on liquidity change.
        
        #Bridge and voting system:
        #To add a bridge the address will refer to the BitBay data contract
        self.testthis=0
        self.Pegdatabase['bridgedb'] = {'TrustedStakers1':["bNgmCcxPKgQQqUe6rhNtbGWowMJFCuxjZ3", "bEfg9bMLSgmjB5TDiur9FscZij4XXrd8C5", "bTuZboysrngsaqJvRj4db4CV2Qa21Q5Jcb", "bMvqdtSZtxDDBEj6NBHAg38iCdvmFwALix", "bJvBcHh45A6mjfKhy8Qg9AagbWfHWB1abC", "bN2NGi2bF1cpcQcsxmY4daCpi2tQqW5tnS", "bS4MGJKwN3vWCSgmsmYfXoJzS3QHPCRtcB", "BJLZ29gAk9aGW9HoAnsEzqmWp6BX7tZEN8", "bP66u6L53PmFppSszfDnUN7dBh6jeNw1uJ", "BAaGqLMM8sFRvAzPAReAxDFbAwzBMQuTni", "B8FqutWoHU6ixFxceZDkqvWARLERuTc4DL", "bKu6ZW9QhaURfanGs66VW78LnHHfThbsJK"],'TrustedStakers2':["bZ8sJgk1VsgbNcqUqBY5hNR9kMaJ5kksEG","bYf1uCCEc4Ge5juuHntYpJvuZ6L6fkqc9w","bYCwwHbSGo85k86Bd5S7drLQ2m1EnUcqTq","bURCwQiJhTSX2JA72LmPwCG3vF9zCpPB6J","bUjrA5QmFntnGABYfeaHbSf5QKF1ptmztr","bJMBgyS6u4SPFwJKGpcgWnPSRcuXF8iTme","bFEEzRWNWKGxFmjAkT1SmjNs8VTD9eTYje","bCqaStDHVoU89DWDjRxrsGbVFBWhxBFdP3","bbn4mJawLC8C26gfw4TVAcfRftiRvb6hZz","bamTjYPT5R822PLgVXUUUdYG6mQTnwmLtj","bbaeKoaSbH23JP1PHM7Fa3oPAfDLQjA9fr","bbbVueUaexGJgxkh2o2Eicd7nKDkuygGoc","bE2sWfTAKR556uFwFjkeQcgMQTFZU2c5c6","bG5WbMoXhMYEVa52ucZWjnidsqTidH7XoV","bHcSb6MC3dxAZbyBSMtSfq81WUF8odrfs6","bLRmZWd5mhE8H5AeSdXuRgwsdXAfEPRdDD","bSg6gu7nH8aHwz2FTqfNF3h6TBExozfkMc","bU7Fr7yrYJWgx6dTqpLW7Xs2Ztc7DBShNC","bWVt3Qp1M2m3qNc2JgBcis6v2fu2ARoBzh","bZT1vZsC123vFHpxwiXYTAt9k9kpfmhD9Y","BGGVksKTGoemBpDTUJw9tVw9M2t7EtFfzz","BKmirMrh6b5ku5scpc7AcJiTh8GSbc3aHR","BRHq9ae4FGD2sgDjqhbJj1K5iszWxZsju8","BEvukYqnXVw9Bj6q613igbBzeu7L8qydfZ","BScLEZPVsLZHeHjciV9boq5j1i8VtcJNkV","BGLCn3mQ4y8eMqm12cZmNtHohag2FvW5oc","BNV91VFGsRHPSepK4WAS9Bg7ghK9T179mM","BEpKZUcf7xCChU1xUgy9cCkou5Ujda1FTe","BEdhKEgAT1TvF3NBpTHmnXDPTrxG8SqvPj","BADnKcGJCFrvjhGxNjNgLw4pWmMLZTPDHm","BAvARoTNQa4e3pZcpso9JMwJbDgLRV3kaG","B9MWeWrJei6UCfeMN4yVnGSsjXR2fzPE7S","BJq1ChAvpqMPQ35PA12T6cAvwksGW2zNMa","B87SXHvyT1nco2ufyQjSfgDM8aCjutnqcJ","BNWtRUezdG26bn3AKNwvG4He1X6tLbrqQj","B8xvFpfLfLSadfmAv87JhqyGMjB86MD6Kz","B5ERP1AVtwa7BrjSyw9saqWp2dVzypgmDX","BF2o4AHkviLxH1ksxfMJr9PUY4mq94nXAe","B6B7QJwDBCBnumDdVCusNaX9FecKMdeEPM","BT8Kbtrqq9EWGAADGUKkrvFDN4GLoAZ5Xu","BLwT7rbNPBDVqMLnBTfbt4ARpdexjM1U34","BGLu8AzqiapcbufCabop4VWCzqZbYP2wJ8","BNuv6rfyadJ8HjCGgBbYuE1AcNQZFQBuKs","BHGUmQJZVN2vGjKCup2rBw6xn9b24FQaPh","BBoGzB9UpLHP8XLNJNAm7iG7f3SgvCYGJa","BTWKXR8Mi3s64bUaGVYnwL1XqmP6aTMWC3","B6q2EoNLbDDabWoDawaZBwtAS3FURncaHq","B515mPDfT4rTiLRUJFid2zrFRiGySxgj4Z","BSmBt2aNscgogCShoetG9aiRbtLznD4HEU","BNz1ZmfSaZwS2pduJ5QaVeBeUVnqwRPC1p","B6mh9dJi5zVYH2coYeyEFbutWrt7389159","BAuzwad1RErngpU4vs4TGoN61otqDq9eKE","BMPh6mYvDcUrLxHJDxqopuNejZPYwz5C1s","B8oTydfgHLZvA8n5UijXiht3f8mX3cSYEj","BCfVrB6Wrec9H3LTuy6PunUXAwJEHBXbka","B6dNMw2yd4LAiefePu7FaHGY3ALNZuMk3h","BLaqBwjuvytkE1HYDCCKWsvJ9gPxNypPAf","BAnifB1UKBMqV4hu9DtTZ7Qj4JBAEm8dKB","BByxgD9v6YbxvmauuPdgqa8Yk2o5pekVPW","BAJfus7iFaQ4rFSke5KzE367qzvf5R9thM","BNFFzvTApN8JtFcWgjQHKCezKthuu6bDdv","BCJxZgskT61557Jf2DmtwYvHJVaeRrwok6","B6QNEmPwd3ZDdqWRp1o6cTXaDGnXwevkjA","BDAXuYqpAjvP6P1rCQmvcBabbXhkg9KPSb"],'N':[4,0,0],'T':[4,0,0],'X':[4,0,0],'B':[4,0,0],'M':[4,0,0],'exchanges':{},'bridges':[]} #0x8F093DBB0b56d99abBCD6fc8d283262641e12cA0 is prior Goerli contract #{'n':'Goerli Testnet','s':'ETH','l':['https://rpc.ankr.com/eth_goerli'],'i':5,'c':'0xE0e7A345D509Cb2CA4fF06802A1dedF689d1d1C1','p':30,'m':8}
        self.Pegdatabase['publishedmessages'] = {}
        self.Pegdatabase['bridgeactive'] = True
        self.Pegdatabase['bridgepool'] = {}
        self.Pegdatabase['merklenonce'] = 0 #Current one being processed(after merklenonceTX advances)
        self.Pegdatabase['merklenonceTX'] = 0 #Nonce where transactions are added        
        self.Pegdatabase['merkleTimelimit'] = 86400 #One day
        self.Pegdatabase['BridgeProcessBlock'] = {}
        self.Pegdatabase['merklelist'] = {'0':{'timestamp':0,'transactions':[],'supply':0}}
        self.Pegdatabase['txidreference'] = {}
        self.Pegdatabase['fundsout'] = {}
        self.Pegdatabase['netdata'] = {}
        #Mint to BAY network merkles
        #Some of the processing and storage may be in JavaScript for python testing
        #We don't keep this persistent for testing because JavaScript recalculates it when it loads
        self.Pegdatabase['merkles'] = {}
        self.Pegdatabase['mints'] = {}
        self.noncesync = {} #Stored temporarily. In production it's permanent based on merkle root processing.
    def stop(self):
        self.amrunning=False
    def run(self):
        global RunHalo
        global TestnetPeg
        try:
            while self.amrunning:
                time.sleep(.5)
                if TestnetPeg==False:
                    continue
                if ThePeg.Pegdatabase['blockcount']<myblockcount-1 or myblockcount==0:
                    insync=False
                else:
                    insync=True
                if self.stopexchange==1:
                    self.startexchange=0
                    self.amrunning=False
                if 'pegging' in CoinSelect and CoinSelect['pegging'] and insync:
                    if self.startexchange==1:
                        RunHalo=False
                        self.exchangecycle=self.Pegdatabase['votecycle']
                        print "Loading exchange"
                        res=self.LoadExchange()
                        if not res:#Database not written properly and may need manual recovery.
                            print "Loading error!"
                            self.stopexchange=1
                            self.amrunning=False
                            self.startexchange=0
                            break
                        busy=1
                        while busy==1:
                            print "Waiting..."
                            busy=NetSplash(1, checkwait=1, nogui=1, ld2=1)
                            print str(lockdownload)
                            print str(iswaiting)
                        time.sleep(1)
                        addresses=BLK.listreceivedbyaddress(0, True)
                        for i in addresses:
                            if i['address'][:1]=="B":
                                self.exchange['addresses'][i['address']]=1
                        print "Loading spendable"
                        self.LoadSpendable()
                        print "Getting balances"
                        self.ExchangeBalance,self.Spendable=self.GetBalance(self.Spendable)
                        res=self.ExchangeQueue(1)
                        res2=self.ExchangeQueue(2)
                        if res or res2:
                            print "Reloading exchange"
                            self.LoadExchange()
                            self.LoadSpendable()
                            self.ExchangeQueue(1)
                            self.ExchangeBalance,self.Spendable=self.GetBalance(self.Spendable)
                        busy=NetSplash(0, ld2=1)
                        self.SaveExchange('exchange')
                        self.exchangebusy=0
                        self.exchangeready=1
                        firstrun=0
                        while self.amrunning:
                            time.sleep(.5)
                            if self.stopexchange==1:
                                self.startexchange=0
                                self.amrunning=False
                                break
                            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                                insync=False
                            else:
                                insync=True
                            if insync:
                                if self.Pegdatabase['votecycle']>self.exchangecycle:
                                    busy=NetSplash(1, checkwait=1, nogui=1, ld2=1)
                                    if busy!=1:
                                        try:
                                            print "Updating balances..."
                                            self.exchangebusy=1
                                            time.sleep(.5)
                                            self.ExchangeQueue(2)
                                            self.LoadSpendable()
                                            self.ExchangeQueue(1)
                                            self.ExchangeBalance,self.Spendable=self.GetBalance(self.Spendable)
                                            self.exchangebusy=0
                                            self.exchangecycle=self.Pegdatabase['votecycle']
                                            time.sleep(.5)
                                            firstrun=1
                                        except:
                                            traceback.print_exc()
                                    busy=NetSplash(0, ld2=1)
                                self.ExchangeQueue()
                                if myblockcount-self.exchange['withdrawtime']>25:
                                    busy=NetSplash(1, checkwait=1, nogui=1, ld2=1)
                                    if busy!=1:
                                        try:
                                            res=True
                                            self.LoadSpendable('',1)
                                            if myblockcount % ThePeg.interval>10 and myblockcount % ThePeg.interval<75:
                                                res=self.ProcessWithdraws()
                                                print "Withdraw Liquid:",str(res)
                                            if myblockcount % ThePeg.interval>=75 and myblockcount % ThePeg.interval<120:
                                                res=self.ProcessWithdraws('reserve')
                                                print "Withdraw Reserve:",str(res)
                                            if myblockcount % ThePeg.interval>=120 and myblockcount % ThePeg.interval<145:
                                                res=self.AccountMaintenance()
                                                print "Account Maintenance:",str(res)
                                            if myblockcount % ThePeg.interval>=145 and myblockcount % ThePeg.interval<175:
                                                res=self.ProcessWithdraws(checkonly=1)
                                                print "Checking Transactions:",str(res)
                                            print res
                                            self.exchange['withdrawtime']=myblockcount
                                        except:
                                            traceback.print_exc()
                                        self.SaveExchange('exchange')
                                    busy=NetSplash(0, ld2=1)
        except:
            self.amrunning=False
            traceback.print_exc()
    def scanblocks(self, blocks, blockcount=0):
        global BLK, timestamp
        inflate=MakeCipherOutputs('peginflate')[0]
        deflate=MakeCipherOutputs('pegdeflate')[0]
        nochange=MakeCipherOutputs('pegnochange')[0]
        #It's possible to call the function below before returning if client doesn't call it
        try:#NOTE1
            if blockcount==0:
                blockcount=BLK.getblockcount()
            if blockcount<self.Pegdatabase['startingblock']:
                return True
            if self.Pegdatabase['blockcount']==self.Pegdatabase['startingblock']:
                hsh=BLK.getblockhash(self.Pegdatabase['blockcount'])
                block=BLK.getblock(hsh)
                self.Pegdatabase['prevhashes'].append(block['previousblockhash'])
                prevhash=block['previousblockhash']
                x=0
                while x<200:#get previous 200 hashes when starting
                    block2=BLK.getblock(prevhash)
                    prevhash=block2['previousblockhash']
                    self.Pegdatabase['prevhashes'].insert(0,prevhash)
                    x+=1
                self.Pegdatabase['startblocktime']=block['time']
            x=0
            print "Scanning blocks..."
            scantime=time.time()
            while x < blocks:
                if self.queue!=[]:
                    break
                if time.time()-scantime>120:
                    break
                if self.Pegdatabase['blockcount']==blockcount+1:
                    break
                if self.Pegdatabase['votesblockcount2']<=self.Pegdatabase['blockcount']-(self.interval*4):#More than the MAX orphans
                    blockrange=(((self.Pegdatabase['votesblockcount2'] - self.Pegdatabase['startingblock']) / self.interval) * self.interval) + self.Pegdatabase['startingblock']
                    if str(blockrange) not in self.Pegdatabase['votedata2']:
                        self.Pegdatabase['votedata2'][str(blockrange)]={'proposals':{}}
                    if str(blockrange-(self.interval*25)) in self.Pegdatabase['votedata2']:#prune old data
                        self.Pegdatabase['votedata2'].pop(str(blockrange-(self.interval*25)))
                    hsh=BLK.getblockhash(self.Pegdatabase['votesblockcount2'])
                    block=BLK.getblock(hsh)
                    trans=deserialize(BLK.getrawtransaction(block['tx'][1]))
                    sender=script_to_address2(deserialize(BLK.getrawtransaction(trans['ins'][0]['outpoint']['hash']))['outs'][trans['ins'][0]['outpoint']['index']]['script'],85)
                    rank=0
                    if sender not in self.Pegdatabase['bridgedb']['TrustedStakers1']:
                        rank=1
                        if sender not in self.Pegdatabase['bridgedb']['TrustedStakers2']:
                            rank=2
                    rank2=rank
                    try:
                        outpos=0
                        for out in trans['outs']:                            
                            rank=rank2
                            thesender=sender
                            meaning=translate_script(out['script'])                            
                            if meaning!={} and meaning['type']=="Notary/Burn":
                                theproposal = txhash(meaning['message'])                                
                                if meaning['message'][:5]=="**S**":#This staker is publishing on someones behalf, which can be useful in some circumstances
                                    try:
                                        if meaning['message'][5]=="#":#They used multiple outputs to communicate links
                                                try:
                                                    xpos=0
                                                    remstr=""
                                                    while meaning['message'][xpos+5]=="#":
                                                        remstr+="#"
                                                        xpos+=1
                                                        meaning['message']+=translate_script(trans['outs'][outpos+xpos]['script'])['message']                                                
                                                        if xpos==4:#message is too long
                                                            float('a')
                                                    meaning['message']=meaning['message'].replace(remstr,"")                                                    
                                                except:
                                                    traceback.print_exc()
                                                    continue
                                        signaturedata=ast.literal_eval(meaning['message'][5:])
                                        #For now we only allow standard 2 of 2 p2sh and p2pkh type scripts to be verified
                                        #In 2 of 2 multisignature only the first key listed must sign
                                        #k=public keys, s=signature, m=message, n=nonce                                        
                                        if len(signaturedata['k'])==2:
                                            mscript = mk_multisig_script(signaturedata['k'],2,2)
                                            myaddy = scriptaddr(mscript.decode('hex'))
                                        else:
                                            myaddy = pubtoaddr(signaturedata['k'][0],25)
                                        rank=0
                                        if myaddy not in self.Pegdatabase['bridgedb']['TrustedStakers1']:
                                            rank=1
                                            if myaddy not in self.Pegdatabase['bridgedb']['TrustedStakers2']:
                                                rank=2
                                        thesender=myaddy
                                        if rank<2:
                                            res=highlevelcrypto.verify(txhash(signaturedata['m']+str(signaturedata['n'])),base64.b64decode(signaturedata['s']),signaturedata['k'][0])
                                            if res:
                                                if txhash(signaturedata['m']+str(signaturedata['n'])) not in self.Pegdatabase['publishedmessages']:
                                                    self.Pegdatabase['publishedmessages'][txhash(signaturedata['m']+str(signaturedata['n']))]=1
                                                    meaning['message']=signaturedata['m']
                                                    theproposal = txhash(meaning['message'])
                                                else:
                                                    continue
                                        else:
                                            continue
                                    except:
                                        traceback.print_exc()
                                else:
                                    if meaning['message'][:5]=="**N**" or meaning['message'][:5]=="**T**" or meaning['message'][:5]=="**X**" or meaning['message'][:5]=="**B**" or meaning['message'][:5]=="**M**":
                                        if meaning['message'][5]=="#":#They used multiple outputs to communicate links
                                            try:
                                                xpos=0
                                                remstr=""
                                                while meaning['message'][xpos+5]=="#":
                                                    remstr+="#"
                                                    xpos+=1
                                                    meaning['message']+=translate_script(trans['outs'][outpos+xpos]['script'])['message']                                                
                                                    if xpos==4:#message is too long
                                                        float('a')
                                                meaning['message']=meaning['message'].replace(remstr,"")
                                                theproposal = txhash(meaning['message'])
                                            except:
                                                traceback.print_exc()
                                                continue
                                if meaning['message'][:5]=="**N**" or meaning['message'][:5]=="**T**" or meaning['message'][:5]=="**X**" or meaning['message'][:5]=="**B**" or meaning['message'][:5]=="**M**":
                                    if theproposal not in self.Pegdatabase['votedata2'][str(blockrange)]['proposals']:
                                        self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]={'voted':{},'counts':[0,0,0],'counted':0}
                                else:
                                    continue
                                if self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]['counts'][rank] == self.Pegdatabase['bridgedb'][meaning['message'][2]][rank]:
                                    continue #Maximum votes for this rank
                                if thesender in self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]['voted']:
                                    if rank < 2:
                                        continue#This person already voted. And the last tier is for anyone who wins a stake so they can vote multiple times
                                if self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]['counted'] == 1:
                                    continue
                                self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]['counts'][rank]+=1
                                if rank < 2:
                                    self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]['voted'][thesender]=1
                                if self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]['counts']==self.Pegdatabase['bridgedb'][meaning['message'][2]]:
                                    self.Pegdatabase['votedata2'][str(blockrange)]['proposals'][theproposal]['counted']=1
                                    if meaning['message'][:5]=="**N**":
                                        try:
                                            newlist=ast.literal_eval(meaning['message'][6:])
                                            if type(newlist) is list and len(newlist)==3:
                                                if not isinstance(newlist[0],int) and not isinstance(newlist[1],int) and not isinstance(newlist[2],int):
                                                    float('a')
                                                if int(newlist[0])>=0 and int(newlist[1])>=0 and int(newlist[2])>=0 and (int(newlist[0])+int(newlist[0])+int(newlist[0]))>0:
                                                    if int(newlist[0])<=50 and int(newlist[1])<=50 and int(newlist[2])<=100:#Set maximum votes and maximum increase or decrease per proposal
                                                        if newlist[0] < self.Pegdatabase['bridgedb'][meaning['message'][5]][0]-1 or newlist[0] > self.Pegdatabase['bridgedb'][meaning['message'][5]][0]+1:
                                                            float('a')
                                                        if newlist[1] < self.Pegdatabase['bridgedb'][meaning['message'][5]][1]-1 or newlist[1] > self.Pegdatabase['bridgedb'][meaning['message'][5]][1]+1:                                                            
                                                            float('a')
                                                        if newlist[2] < self.Pegdatabase['bridgedb'][meaning['message'][5]][2]-10 or newlist[2] > self.Pegdatabase['bridgedb'][meaning['message'][5]][2]+10:
                                                            float('a')
                                                        self.Pegdatabase['bridgedb'][meaning['message'][5]]=deepcopy(newlist)
                                        except:
                                            traceback.print_exc()
                                    if meaning['message'][:5]=="**T**":
                                        try:
                                            therank=int(meaning['message'][5])
                                            addremove=int(meaning['message'][6])
                                            addy=meaning['message'][7:]
                                            b58check_to_hex(addy)
                                            if addremove==1:
                                                if therank==1:
                                                    self.Pegdatabase['bridgedb']['TrustedStakers1'].append(addy)
                                                if therank==2:
                                                    self.Pegdatabase['bridgedb']['TrustedStakers2'].append(addy)
                                            if addremove==2:
                                                if therank==1:
                                                    self.Pegdatabase['bridgedb']['TrustedStakers1'].remove(addy)
                                                if therank==2:
                                                    self.Pegdatabase['bridgedb']['TrustedStakers2'].remove(addy)
                                        except:
                                            traceback.print_exc()
                                    if meaning['message'][:5]=="**X**":
                                        try:
                                            addremove=int(meaning['message'][5])
                                            publickey=meaning['message'][6:]
                                            get_pubkey_format(publickey)
                                            if addremove==1:
                                                    self.Pegdatabase['bridgedb']['exchanges'][publickey]=1
                                            if addremove==2:
                                                    self.Pegdatabase['bridgedb']['exchanges'].pop(publickey)
                                        except:
                                            traceback.print_exc()
                                    if meaning['message'][:5]=="**B**":
                                        try:
                                            addremove=int(meaning['message'][5])                                            
                                            bridgedata=ast.literal_eval(meaning['message'][6:])
                                            #FORMAT: {'n':'BSC Mainnet','s':'BNB','l':['https://bsc-dataseed.binance.org/'],'i':56,'c':'0x...'}
                                            #n=name,s=symbol,l=seed link,i=chainid,e=explorer                                            
                                            if len(bridgedata) == 5 and 'n' in bridgedata and 's' in bridgedata and 'l' in bridgedata and 'i' in bridgedata and 'c' in bridgedata and 'p' in bridgedata and 'm' in bridgedata:
                                                if isinstance(bridgedata['n'],str) and isinstance(bridgedata['s'],str) and isinstance(bridgedata['l'],list) and isinstance(bridgedata['i'],int) and isinstance(bridgedata['c'],str) and isinstance(bridgedata['p'],int) and isinstance(bridgedata['m'],int):
                                                    chainid=int(bridgedata['i'])
                                                    if addremove==1:
                                                        sharednode=0
                                                        lpos=0
                                                        foundthis=0
                                                        for thisnode in bridgedata['l'][lpos]:
                                                            if not isinstance(thisnode,str):
                                                                foundthis=1 #It's not a valid string
                                                            if 'https://' not in bridgedata['l'][lpos]:
                                                                bridgedata['l'][lpos]='https://'+bridgedata['l'][lpos]
                                                                #It's required to use SSL. If nodes want to do custom encrypted P2P then that should be added manually
                                                            lpos+=1
                                                        if foundthis==0:
                                                            bpos = 0
                                                            for bridged in self.Pegdatabase['bridgedb']['bridges']:
                                                                if bridged['n'] == bridgedata['n']:
                                                                    if int(bridged['i']) != chainid:
                                                                        foundthis = 2
                                                                        break
                                                                if int(bridged['i']) == chainid: #They want to update this bridge
                                                                    foundthis = 1
                                                                    break
                                                                bpos += 1
                                                            if foundthis==1:
                                                                self.Pegdatabase['bridgedb']['bridges'].pop(bpos)
                                                            if foundthis!=2:
                                                                self.Pegdatabase['bridgedb']['bridges'].append(bridgedata)
                                                                if bridgedata['n'] not in self.Pegdatabase['bridgepool']:
                                                                    self.Pegdatabase['bridgepool'][bridgedata['n']]=[0]*1200
                                                                if bridgedata['n'] not in self.Pegdatabase['fundsout']:
                                                                    self.Pegdatabase['fundsout'][bridgedata['n']]=0
                                                    if addremove==2:
                                                        xpos=0
                                                        for bridged in self.Pegdatabase['bridgedb']['bridges']:
                                                            if bridged['n'] == bridgedata['n']:
                                                                self.Pegdatabase['bridgedb']['bridges'].pop(xpos)
                                                                break
                                                            xpos+=1
                                        except:
                                            traceback.print_exc()
                                    if meaning['message'][:5]=="**M**":
                                        try:
                                            if meaning['message'][5:]=="899104002d6f8e009ec6dee6844cba6603d02dc351812e422c9e166e3e670506":#txhash("pause")
                                                self.Pegdatabase['bridgeactive'] = False                                                
                                            if meaning['message'][5:]=="b677f2790c4aabe172484a329694cfb54ec9cd93b38a3d2082b6d456f5e96f2d":#txhash("resume")
                                                self.Pegdatabase['bridgeactive'] = True
                                                if self.Pegdatabase['merklelist']['0']['timestamp']==0:
                                                    self.Pegdatabase['merklelist']['0']['timestamp']=block['time'] #Initiates
                                            if self.Pegdatabase['bridgeactive']:
                                                for bridged in self.Pegdatabase['bridgedb']['bridges']:
                                                    if txhash(bridged['n'])[:64]==meaning['message'][5:][:64]:
                                                        if bridged['n'] not in self.Pegdatabase['merkles']:
                                                            self.Pegdatabase['merkles'][bridged['n']]={}
                                                        themerkletree=meaning['message'][5:][64:]
                                                        self.Pegdatabase['merkles'][bridged['n']][themerkletree]=1
                                                        break
                                        except:
                                            traceback.print_exc()
                            outpos+=1
                        self.Pegdatabase['votesblockcount2']+=1
                    except:
                        traceback.print_exc()
                        print 'skipping block - ', str(self.Pegdatabase['votesblockcount2'])
                        return False
                #If the pruning point is beyond this check or account pools are used this needs to be revised
                if self.Pegdatabase['votesblockcount']<=self.Pegdatabase['blockcount']-(self.interval*2):
                    blockrange=(((self.Pegdatabase['votesblockcount'] - self.Pegdatabase['startingblock']) / self.interval) * self.interval) + self.Pegdatabase['startingblock']
                    if str(blockrange) not in self.Pegdatabase['votedata']:
                        self.Pegdatabase['votedata'][str(blockrange)]=[0,0,0]
                    hsh=BLK.getblockhash(self.Pegdatabase['votesblockcount'])
                    block=BLK.getblock(hsh)
                    trans=deserialize(BLK.getrawtransaction(block['tx'][1]))
                    try:
                        for inp in trans['ins']:
                            txid=inp['outpoint']['hash']+':'+str(inp['outpoint']['index'])
                            txin=self.readdatabase(txid)
                            break
                        voteweight=1
                        reserveweight=0
                        liquidweight=0
                        if txin!=False:
                            supply=self.CurrentSupply(block['height'])
                            for i in txin['pool']:
                                if i=='total' or i=='frozen':
                                    continue
                                if int(i) < supply:
                                    reserveweight+=txin['pool'][i]
                                else:
                                    liquidweight+=txin['pool'][i]
                            w1=(1-(float(supply)/float(self.amountofsteps)))
                            reserveweight=int(reserveweight*w1)
                            w=int(supply/120)+1                        
                            if liquidweight>reserveweight*4:
                                voteweight=4*w
                            elif liquidweight>reserveweight*3:
                                voteweight=3*w
                            elif liquidweight>reserveweight*2:
                                voteweight=2*w
                        for out in trans['outs']:
                            if address_to_script(inflate) == out['script']:
                                self.Pegdatabase['votedata'][str(blockrange)][0]+=voteweight
                                break
                            if address_to_script(deflate) == out['script']:
                                self.Pegdatabase['votedata'][str(blockrange)][1]+=voteweight
                                break
                            if address_to_script(nochange) == out['script']:
                                self.Pegdatabase['votedata'][str(blockrange)][2]+=voteweight
                                break
                        self.Pegdatabase['votesblockcount']+=1
                    except:
                        traceback.print_exc()
                        print 'skipping block - ', str(self.Pegdatabase['votesblockcount'])
                        return False
                ThePeg.scanforchange(self.Pegdatabase['blockcount'])
                hsh=BLK.getblockhash(self.Pegdatabase['blockcount'])
                block=BLK.getblock(hsh)
                res=self.checkblock(block)
                if res==False:
                    return False
                self.Pegdatabase['prevhashes'].append(hsh)
                self.Pegdatabase['blockcount']+=1
                x+=1
            if self.queue!=[]:
                self.writequeue()
        except:
            traceback.print_exc()
            return False
        return blocks
    def checkblock(self, block, checkonly=0):
        if len(self.Pegdatabase['prevhashes'])>self.interval*2:
            x=0
            while x<100:
                self.Pegdatabase['prevhashes'].pop(0)
                x+=1
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
        else:
            pegdir=application_path+"/"+'pegdatabase'
        #We need to coordinate bridge processing precisely with block time limits. On reorganization we would reverse this as well(logically all TX would be emptied if that happens)
        blkhash=BLK.getblockhash(block['height'])
        if self.Pegdatabase['merklelist'][str(self.Pegdatabase['merklenonceTX'])]['timestamp'] + self.Pegdatabase['merkleTimelimit'] < block['time']: #Enought time has passed, can now start to process bridge merkle
            self.Pegdatabase['merklelist'][str(self.Pegdatabase['merklenonceTX'])]['supply']=self.CurrentSupply(block['height'])
            self.Pegdatabase['merklenonceTX']+=1
            if str(self.Pegdatabase['merklenonceTX']) not in self.Pegdatabase['merklelist']:
                self.Pegdatabase['merklelist'][str(self.Pegdatabase['merklenonceTX'])]={'timestamp':block['time'],'transactions':[], 'supply':0} #Supply set after processing
            self.Pegdatabase['BridgeProcessBlock'][blkhash] = 1
        #Common keys:
        #inputs/outputs: known by txid and out, index(from output), pool, block
        #pool2(deduct on input), amount, frozen, ftype, stake, inputs(if pool), address
        #No change: bNyZrPeFFNP6GFJZCkE82DDN7JC4K5Vrkk, Deflate: bNyZrP2SbrV6v5HqeBoXZXZDE2e4fe6STo Inflate: bNyZrPLQAMPvYedrVLDcBSd8fbLdNgnRPz
        #For whitelist testing we skip stakes and transactions if we aren't involved.
        #Maybe switch to numpy for array calculations maybe numba, cython, ujson, etc
        #NOTE2
        sighashes=[1,2,3,80,129,130,131]
        skip=[]
        if block['previousblockhash'] != self.Pegdatabase['prevhashes'][-1] and checkonly==0:
            print "REORGANIZE!", block['previousblockhash'], self.Pegdatabase['prevhashes'][-1]
            reorganize=0
            elements={}
            if block['height']!=self.Pegdatabase['blockcount']:
                print 'The height is not the same somehow'
            while reorganize < self.interval-2:
                hsh=BLK.getblockhash(block['height']-reorganize)
                block2=BLK.getblock(hsh)
                if block2['previousblockhash'] == self.Pegdatabase['prevhashes'][-1]:
                    break
                blockname=str(block2['height']-1)+".dat"
                print str(blockname)
                if os.path.exists(os.path.join(pegdir,blockname)):
                    with open(os.path.join(pegdir,blockname),'rb') as f:
                        pruneblock=ujson.loads(bsonjs.dumps(f.read()))
                        f.close()
                for txid in pruneblock['deductions']:#Restore all that was taken from pools.
                    if pruneblock['deductions'][txid]['address'][:4][1:].lower() not in elements:
                        elements[pruneblock['deductions'][txid]['address'][:4][1:].lower()]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                    elements[pruneblock['deductions'][txid]['address'][:4][1:].lower()]['prune']['txin'][txid]={'address':pruneblock['deductions'][txid]['address'],'pool':pruneblock['deductions'][txid]['pool']}
                for txid in pruneblock['outputs']:#Remove all new outputs
                    if txid[:3] not in elements:
                        elements[txid[:3]]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}                
                    elements[txid[:3]]['prune']['txout'][txid]=''
                for txid in pruneblock['inputs']:#Mark input files unspent
                    if txid[:3] not in elements:
                        elements[txid[:3]]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}                
                    elements[txid[:3]]['txin'][txid]=''
                for el in elements:#instead of hashing the entire entry is it possible to use txid or address?!
                    txlist=[]
                    for txid in elements[el]['txin']:
                        txlist.append(txid)
                    for txid in elements[el]['txout']:
                        txlist.append(txid)
                    for txid in elements[el]['prune']['txin']:
                        txlist.append(txid)
                    for txid in elements[el]['prune']['txout']:
                        txlist.append(txid)
                    if 'txin2' in elements[el]['prune']:
                        for txid in elements[el]['prune']['txin2']:
                            txlist.append(txid)
                    txlist.sort()
                    uniquehash=txhash(str(txlist))
                    self.queue.append(['*'+uniquehash,{el:elements[el]}])
                for txid in pruneblock['6a']:                    
                    try:
                        thispos=0
                        for el in self.Pegdatabase['merklelist'][str(self.Pegdatabase['txidreference'][txid])]['transactions']:
                            if el['txid']==txid:
                                self.Pegdatabase['merklelist'][str(self.Pegdatabase['txidreference'][txid])]['transactions'].pop(thispos)
                                break
                            thispos+=1
                        self.Pegdatabase['txidreference'].pop(txid)
                    except:
                        traceback.print_exc()
                txidtemp=txid.split(":")[0]
                if txidtemp in self.Pegdatabase['mints']:
                    txidtemp2=self.Pegdatabase['mints'][txidtemp]['txid']
                    myname=self.Pegdatabase['mints'][txidtemp2]['network']
                    self.Pegdatabase['fundsout'][myname] += self.Pegdatabase['mints'][txidtemp2]['total']
                    xp=0
                    for val in self.Pegdatabase['mints'][txidtemp2]['reserve']:
                        self.Pegdatabase['bridgepool'][myname][xp] += val
                        xp+=1
                    self.Pegdatabase['mints'].pop(txidtemp2)
                    self.Pegdatabase['mints'].pop(txidtemp)
                if hsh in self.Pegdatabase['BridgeProcessBlock']:                    
                    self.Pegdatabase['merklelist'].pop(str(self.Pegdatabase['merklenonceTX']))
                    self.Pegdatabase['merklenonceTX']-=1
                    self.Pegdatabase['BridgeProcessBlock'].pop(hsh)
                commit=json_deep_copy(self.Pegdatabase)
                commit['blockcount']-=1  
                commit['prevhashes'].pop(-1)              
                self.queue.append(['pegdatabase',commit])
                self.queue.append(['prune',blockname])
                self.writequeue()
                self.Pegdatabase['blockcount']-=1
                self.Pegdatabase['prevhashes'].pop(-1)                
                reorganize+=1
            if reorganize==self.interval-2:
                self.DeleteDatabase()
                return False
            return False
        supply=self.CurrentSupply(block['height'])
        txtime=time.time()
        self.valid='1'
        try:
            #NOTE3
            newstuff={'txin':{}, 'txout':{}}
            txfees={'total':0}
            staketx={}
            usedinputs={}
            accountpools={}
            #Move the stake to the end because it's the last to withdraw from it's pool
            tx=block['tx'][0]
            block['tx'].pop(0)
            #block['tx'].append(tx)
            tx=block['tx'][0]
            block['tx'].pop(0)
            block['tx'].append(tx)
            for tx in block['tx']:#can maybe move this to it's own function CheckTransaction
                print tx
                print "TIME ELAPSED A: ", str(txtime-time.time())
                trans=deserialize(BLK.getrawtransaction(tx))
                whitelisted=0
                highestfrozen=0
                totalin=0
                bigliquiditypool={'total':0}
                liquiditypool={'total':0}
                reservepool={'total':0}
                frozenpool={}                
                txreservetotal=0
                txliquidtotal=0
                #Here the system should check for a mint. Also any signature verifications of course should happen.
                #The signed input should match the address in the output. Since this is a simulation, the signature
                #check would be done in bitbayd instead. This is just showing how to construct the input.
                #BitBay's bridge hard fork is able to natively support this feature.
                if len(trans['outs'])>0 and trans['outs'][1]['script'][:2]=="6a":
                    try:
                        thescript=translate_script(trans['outs'][1]['script'])
                        if '**Y**' in thescript['message'][:5]:
                            if not self.Pegdatabase['bridgeactive']:
                                print "Bridge is not currently active"
                                float('a')
                            message=thescript['message'][5:]
                            x=1
                            while(x<len(trans['outs'])):
                                if '6a' not in trans['outs'][x]['script'][:2]:
                                    break
                                message+=translate_script(trans['outs'][x]['script'])['message']
                                x+=1
                            message=ast.literal_eval(message)
                            thename=''
                            for bridged in self.Pegdatabase['bridgedb']['bridges']:                                
                                if message['w']==txhash(bridged['n'])[:64]:
                                    thename=bridged['n']
                                    break
                            if thename == '':
                                traceback.print_exc()
                            mysteps=int(self.Pegdatabase['netdata'][thename]['pegsteps'])+int(self.Pegdatabase['netdata'][thename]['microsteps'])
                            result = BridgeDriver.execute_script("return verifymint("+str(json.dumps(message))+","+str(mysteps)+");")
                            if result == True: #We construct the root TX that is used as the input and add it to the database
                                if len(trans['ins']) > 1:
                                    float('a')
                                recipientScript = deserialize_script(trans['ins'][0]['script']) #The new tx will match the spending inputs sig script
                                if message['a'][0] == 'b':
                                    if scriptaddr(recipientScript[-1].decode('hex')) != message['a']:
                                        float('a')
                                if message['a'][0] == 'B':
                                    try:
                                        if pubtoaddr(recipientScript[1],25) != message['a']:
                                            float('a')
                                    except: #It's a public key
                                        #You could in theory do a public key recover and narrow it down to a few possibilities and see if it matches the address
                                        #However for this example it's best to say that any address that isn't P2SH or P2PKH should just pay itself
                                        #IMPORTANT: During P2PK signature check you should verify that the users input signature matches the pubkey in output script
                                        #QT and bitbayd will need that information automatically. This just shows how it's done for the demo.
                                        #All address types that are supported by the interpreter should be checked to match the address that is minting
                                        found=0
                                        for testout in trans['outs']:
                                            if testout['script'][:2] != "6a":
                                                found=1
                                                mypubkey = deserialize_script(testout['script'])[0]
                                                if pubtoaddr(mypubkey,25) != message['a']:
                                                    float('a')
                                                else:
                                                    if verify_tx_input(tx,0,testout['script'],deserialize_script(trans['ins'][0]['script'])[0],mypubkey,1):
                                                        break
                                                    else:
                                                        float('a')
                                        if found==0:
                                            float('a')
                                mynewtotal = 0
                                vpos=0
                                for val in message['r']:
                                    message['r'][vpos]=int(val)
                                    mynewtotal+=int(val)
                                    vpos+=1
                                if len(message['r']) != mysteps:
                                    float('a')
                                if mynewtotal > self.Pegdatabase['fundsout'][thename]:
                                    float('a') #Too many funds incoming
                                self.Pegdatabase['fundsout'][thename] -= mynewtotal
                                mydeductions = DecompressFractions(message['r'],thename,message['s'],self.Pegdatabase['netdata'][thename]['pegsteps'],self.Pegdatabase['netdata'][thename]['microsteps'])
                                if mydeductions == False:
                                    float('a')
                                xp=0
                                for val in mydeductions:
                                    if val > self.Pegdatabase['bridgepool'][thename][xp]:
                                        float('a')
                                    self.Pegdatabase['bridgepool'][thename][xp] -= val
                                    xp+=1
                                #The TXID generated from the message should be the TXID in the input that is spent. Also check for double spend.
                                #Also to look up the generated TXID from getrawtransaction should point to the mint transaction ID
                                thetxid = txhash(str([message['w'],int(message['n']),message['f'],message['a'],int(message['s']),message['r']]))
                                if thetxid+":0" in self.Pegdatabase['mints']: #Already spent
                                    float('a')
                                if trans['ins'][0]['outpoint']['hash'] != thetxid or trans['ins'][0]['outpoint']['index'] != 0:
                                    float('a')
                                #During a lookup of the brand new TXID it is redirected to the minting transaction for reference
                                self.Pegdatabase['mints'][thetxid+":0"]={'reserve':mydeductions,'network':thename,'total':mynewtotal,'txid':txhash(tx),'address':message['a']}
                                self.Pegdatabase['mints'][txhash(tx)]={'txid':thetxid+":0"} #Cross reference for reorgs. Actual tx to find virtual txid
                    except:
                        traceback.print_exc()
                        float('a')
                pos=0
                for inp in trans['ins']:
                    pool={}
                    txid=inp['outpoint']['hash']+':'+str(inp['outpoint']['index'])
                    #CHECK TXIN2 MAY BE THE SELF REFERENCE ON A MINT!
                    if inp['outpoint']['hash']+":0" in self.Pegdatabase['mints']:
                        address=self.Pegdatabase['mints'][inp['outpoint']['hash']+":0"]['address']
                        txin2={'blocktime':block['time']}
                    else:
                        txin2=BLK.getrawtransaction(inp['outpoint']['hash'], 1)
                        if txin2['confirmations']<1:
                            self.valid="Can not spend zero confirmations"
                            float('a')
                        address=txin2['vout'][inp['outpoint']['index']]['scriptPubKey']['hex']
                        try:
                            address=script_to_address2(address,85)
                        except:
                            pass
                    txin=self.readdatabase(txid, address)#could return single input or entire liquidity pool
                    if address in self.whitelist and tx not in skip:
                        whitelisted=1
                    else:
                        if txin != False and self.whitelistoutputs == 1 and tx not in skip:
                            whitelisted=1
                    liquidtotal=0
                    reservetotal=0
                    if txin==False:#Didn't find it, either we should have had it or it's from before peg or it's a mint
                        #txin=copy.deepcopy(txin2)
                        #if txin['blocktime']>self.Pegdatabase['startblocktime']:
                        #    self.DeleteDatabase()#Critical information was missing, sync again
                        #    return False
                        newstuff['txin'][txid]={}
                        if inp['outpoint']['hash']+":0" in self.Pegdatabase['mints']:
                            address=self.Pegdatabase['mints'][inp['outpoint']['hash']+":0"]['address']
                            newstuff['txin'][txid]['address']=address
                            newstuff['txin'][txid]['amount']=self.Pegdatabase['mints'][inp['outpoint']['hash']+":0"]['total']
                            newstuff['txin'][txid]['pool']={}
                            xp = 0
                            for val in self.Pegdatabase['mints'][inp['outpoint']['hash']+":0"]['reserve']:
                                newstuff['txin'][txid]['pool'][str(xp)] = val
                                xp+=1
                        else:                        
                            newstuff['txin'][txid]['amount']=int(txin2['vout'][inp['outpoint']['index']]['value']*Decimal(1e8))
                            address=txin2['vout'][inp['outpoint']['index']]['scriptPubKey']['hex']
                            try:
                                address=script_to_address2(address,85)
                            except:
                                pass
                            newstuff['txin'][txid]['address']=address
                            stepindex=0
                            newstuff['txin'][txid]['pool']={}
                            print "TIME ELAPSED 0: ", str(txtime-time.time())
                            #Original technique
                            #Dif=float(1)
                            #for s in self.steps:
                            #    Dif2=(Dif-s)
                            #    amount=int(newstuff['txin'][txid]['amount']*Dif2)
                            #    if stepindex==len(self.steps)-1:
                            #        amount+=int(newstuff['txin'][txid]['amount']*s)
                            #    Dif=s
                            #    if amount!=0:
                            #        if stepindex<supply:
                            #            reservetotal+=amount
                            #        else:
                            #            liquidtotal+=amount
                            #        newstuff['txin'][txid]['pool'][str(stepindex)]=amount  
                            #    stepindex+=1
                            ##The remainder can be divided evenly until nothing is left
                            #amount=newstuff['txin'][txid]['amount']
                            #amount-=(liquidtotal+reservetotal)
                            #remain=0
                            #while remain < amount:
                            #    if str(remain) in newstuff['txin'][txid]['pool']:
                            #        newstuff['txin'][txid]['pool'][str(remain)]+=1
                            #    else:
                            #        newstuff['txin'][txid]['pool'][str(remain)]=1
                            #    if remain<supply:
                            #        reservetotal+=1
                            #    else:
                            #        liquidtotal+=1
                            #    remain+=1
                            txin_amount_left=newstuff['txin'][txid]['amount']
                            for s in self.steps:
                                if stepindex==len(self.steps)-1:
                                    amount=txin_amount_left
                                else:
                                    amount=txin_amount_left/self.rate
                                txin_amount_left-=amount
                                if amount!=0:
                                    if stepindex<supply:
                                        reservetotal+=amount
                                    else:
                                        liquidtotal+=amount
                                    newstuff['txin'][txid]['pool'][str(stepindex)]=amount
                                stepindex+=1
                    else:
                        newstuff['txin'][txid]=txin
                        if 'amount' not in newstuff['txin'][txid]:
                            newstuff['txin'][txid]['amount']=int(txin2['vout'][inp['outpoint']['index']]['value']*Decimal(1e8))
                        if 'address' not in newstuff['txin'][txid]:
                            newstuff['txin'][txid]['address']=address
                    print "TIME ELAPSED 1: ", str(txtime-time.time())
                    if 'frozen' in newstuff['txin'][txid]:#Sending 1 month lock funds
                        #check for whitelisted p2sh exchange key and if it's approved let it bypass the frozen timestamp
                        foundvalidsig=0
                        try:
                            mysigs=deserialize_script(inp['script'])
                            myscript=deserialize_script(mysigs[-1])
                            for myval in myscript:
                                if foundvalidsig==1:
                                    break
                                try:
                                    get_pubkey_format(myval)
                                    if myval in self.Pegdatabase['bridgedb']['exchanges']:#We found an exchange pubkey, however make sure it's involved in spending
                                        for thesig in mysigs:
                                            if foundvalidsig==1:
                                                break
                                            for sighash in sighashes:
                                                try:
                                                    if verify_tx_input(tx,pos,trans['ins'][0]['script'],thesig,myval,sighash):
                                                        foundvalidsig=1
                                                        newstuff['txin'][txid].pop('frozen')
                                                        newstuff['txin'][txid].pop('ftype')
                                                        break
                                                        #Consider an exchange only has to sign off on a transaction it wants to bypass a freeze
                                                        #Even if you were to check if the TX would have failed without it, an exchange could
                                                        #Set up time locked accounts in order to assist users to bypass the rules. However this
                                                        #is why exchange keys are voted on since it's only to be used for exchange operations.
                                                except:
                                                    pass
                                except:
                                    pass
                        except:
                            traceback.print_exc()
                        #Would a stake that spends a frozen of '1' maintain same number?! If we try to carry previous value
                        #However we want a fresh value if blocktime changes
                        if foundvalidsig==0:
                            if 'stake' not in newstuff['txin'][txid]:
                                if newstuff['txin'][txid]['ftype']=='F':
                                    newstuff['txin'][txid]['frozen']=txin2['blocktime']+2592000
                                if newstuff['txin'][txid]['ftype']=='V':
                                    newstuff['txin'][txid]['frozen']=txin2['blocktime']+(2592000*4)
                            if newstuff['txin'][txid]['frozen']>highestfrozen:
                                if newstuff['txin'][txid]['ftype']=='F':
                                    liquiditypool['frozen']=newstuff['txin'][txid]['frozen']
                                if newstuff['txin'][txid]['ftype']=='V':
                                    liquiditypool['frozen']=newstuff['txin'][txid]['frozen']
                                highestfrozen=newstuff['txin'][txid]['frozen']
                    #NOTE4
                    if txid in usedinputs:
                        pool=newstuff['txin'][usedinputs[txid]]['pool'].copy()
                    else:
                        usedinputs[txid]=txid
                        pool=newstuff['txin'][txid]['pool'].copy()
                    if 'inputs' in newstuff['txin'][txid]:#It's a big pool
                        print 'Found in pool'
                        for myinput in newstuff['txin'][txid]['inputs']:
                            if myinput not in usedinputs:
                                usedinputs[myinput]=txid
                        if newstuff['txin'][txid]['address'] not in accountpools:
                            accountpools[newstuff['txin'][txid]['address']]={'locktime':trans['locktime'], 'current':tx}
                        else:
                            if accountpools[newstuff['txin'][txid]['address']]['current']!=tx:
                                if trans['locktime']<=accountpools[newstuff['txin'][txid]['address']]['locktime']:
                                    self.valid='Trying to take from liquidity pool out of order.'
                                    float('a')
                                else:
                                    accountpools[newstuff['txin'][txid]['address']]={'locktime':trans['locktime'], 'current':tx}
                    #We shouldn't take more than we need from a pool otherwise it can get confusing as to what to select and when
                    #We could let a user take liquid without touching reserve but he may want to use reserve for a specific reason
                    #The user may end up with mixed liquidity anyways because of the size of the input. Therefore this is a simple
                    #rule to take an even mix of liquidity for each input seen deducted in the order they are seen in the block.
                    print newstuff['txin'][txid]['amount']
                    if 'inputs' in newstuff['txin'][txid]:
                        amttotake=newstuff['txin'][txid]['amount']                        
                        pool, pool2=self.CalculateOutput(pool,supply,amttotake,'Mixed', 1, 0, pool['total'])
                        newstuff['txin'][usedinputs[txid]]['pool']=pool.copy()
                        newstuff['txin'][txid]['pool2']=pool2.copy()
                        print 'POOL TOTALS:'                        
                        print pool2['total']
                        pool=pool2.copy()
                    try:
                        print pool['total']
                    except:
                        print reservetotal+liquidtotal
                    empty=0
                    if 'total' in pool and 'frozen' not in pool and len(pool)==1:
                        empty=1
                    if 'total' in pool and 'frozen' in pool and len(pool)==2:
                        empty=1
                    if pool!={} and empty!=1:
                        if reservetotal==0 and liquidtotal==0:
                            for i in pool:
                                if i=='total' or i == 'frozen':
                                    continue
                                if int(i)<supply:
                                    reservetotal+=pool[i]
                                else:
                                    liquidtotal+=pool[i]
                            print 'r', reservetotal
                            print 'l', liquidtotal
                    else:
                        #Depending on how transactions are ordered there may be something to draw from
                        try:
                            for i in reservepool[newstuff['txin'][txid]['address']]:
                                if i=='total' or i == 'frozen':
                                    continue
                                reservetotal+=reservepool[newstuff['txin'][txid]['address']][i]
                        except:
                            pass
                        try:
                            for i in liquiditypool[newstuff['txin'][txid]['address']]:
                                if i=='total' or i == 'frozen':
                                    continue
                                liquidtotal+=liquiditypool[newstuff['txin'][txid]['address']][i]
                        except:
                            pass
                    #NOTE5
                    try:                    
                        if len(trans['outs'])>pos and trans['outs'][pos]['script'][:2]=="6a":#see if they intend to transfer frozen funds
                            frozenindex=0
                            meaning=translate_script(trans['outs'][pos]['script'])
                            if meaning!={} and meaning['type']=="Notary/Burn":
                                if meaning['message'][:5]=="**F**" or meaning['message'][:5]=="**V**" or meaning['message'][:5]=="**L**":
                                    inx1=''
                                    if ':' in meaning['message'][5:]:
                                        inx3=meaning['message'][5:].split(':')
                                        if len(inx3)<2:
                                            float('a')
                                        inx1=int(inx3[0])
                                        inx2=int(inx3[1])
                                        if len(inx3)==2 and inx1==inx2:
                                            float('a')
                                        if inx1==pos or inx2==pos or inx1<0 or inx2<0 or inx1>len(trans['outs'])-1 or inx2>len(trans['outs'])-1:
                                            float('a')
                                        frozenindex=inx1
                                    else:
                                        frozenindex=int(meaning['message'][5:])
                                    if frozenindex==pos or frozenindex<0 or frozenindex>len(trans['outs'])-1:
                                        float('a')                                        
                                    if frozenindex in frozenpool:
                                        if frozenpool[frozenindex]['ftype']!=meaning['message'][:5].replace("*",""):
                                            float('a')
                                        if 'shared' in frozenpool[frozenindex]:
                                            if ':' in meaning['message'][5:] and len(inx3)==2 and sorted([inx1,inx2])==frozenpool[frozenindex]['shared']:
                                                pass
                                            else:
                                                float('a')
                                    frozenpool[frozenindex]={'amount':trans['outs'][frozenindex]['value'], 'address':newstuff['txin'][txid]['address']}
                                    if inx1!='' and len(inx3)==2:
                                        frozenpool[frozenindex]['shared']=[inx1,inx2]
                                        frozenpool[frozenindex]['shared'].sort()
                                    if meaning['message'][:5]=="**F**":
                                        frozenpool[frozenindex]['ftype']="F"
                                    if meaning['message'][:5]=="**V**":
                                        frozenpool[frozenindex]['ftype']="V"
                                    sharedfreeze=False
                                    if ':' in meaning['message'][5:] and len(inx3)==2:
                                        if inx2 in frozenpool:
                                            if frozenpool[inx2]['ftype']!=meaning['message'][:5].replace("*",""):
                                                float('a')
                                            if 'shared' in frozenpool[inx2]:
                                                if ':' in meaning['message'][5:] and len(inx3)==2 and sorted([inx1,inx2])==frozenpool[inx2]['shared']:
                                                    pass
                                                else:
                                                    float('a')
                                        frozenpool[inx2]={'amount':trans['outs'][inx2]['value'], 'address':newstuff['txin'][txid]['address']}
                                        frozenpool[inx2]['shared']=[inx1,inx2]
                                        frozenpool[inx2]['shared'].sort()
                                        if meaning['message'][:5]=="**F**":
                                            frozenpool[inx2]['ftype']="F"
                                        if meaning['message'][:5]=="**V**":
                                            frozenpool[inx2]['ftype']="V"
                                        sharedfreeze=True
                                        frozenpool['freezeall']=True
                                    if ':' in meaning['message'][5:] and len(inx3)>2:
                                        if len(inx3)>50:
                                            float('a')
                                        sharedfreeze=True
                                        frozenpool['freezeall']=True
                                        for inxes in inx3:                                            
                                            inxes=int(inxes)
                                            if inxes<0 or inxes>len(trans['outs'])-1 or inxes==pos:
                                                float('a')
                                            if inxes in frozenpool and frozenpool[inxes]['ftype']!=meaning['message'][:5].replace("*",""):
                                                float('a')
                                            if inxes in frozenpool and 'shared' in frozenpool[inxes]:
                                                float('a')
                                            frozenpool[inxes]={'amount':trans['outs'][inxes]['value'], 'address':newstuff['txin'][txid]['address'], 'split':1}
                                            if meaning['message'][:5]=="**F**":
                                                frozenpool[inxes]['ftype']="F"
                                            if meaning['message'][:5]=="**V**":
                                                frozenpool[inxes]['ftype']="V"
                                    if meaning['message'][:5]=="**F**" and reservetotal<trans['outs'][frozenindex]['value']:
                                        sharedfreeze=True
                                        frozenpool['freezeall']=True
                                    if meaning['message'][:5]=="**V**" and liquidtotal<trans['outs'][frozenindex]['value']:
                                        sharedfreeze=True
                                        frozenpool['freezeall']=True
                                    if meaning['message'][:5]=="**L**" and liquidtotal<trans['outs'][frozenindex]['value']:
                                        self.valid="Not enough liquidity"
                                        float('a')
                                    if not sharedfreeze:
                                        #If the freeze output is equal or greater than the totals then the user wants this input to freeze to this output
                                        if pool!={} and empty!=1:
                                            if meaning['message'][:5]=="**F**":
                                                pool, frozenpool[frozenindex]['liquidity']=self.CalculateOutput(pool,supply,trans['outs'][frozenindex]['value'],'Frozen', 1, reservetotal, liquidtotal)
                                                reservetotal-=trans['outs'][frozenindex]['value']
                                            if meaning['message'][:5]=="**V**":
                                                pool, frozenpool[frozenindex]['liquidity']=self.CalculateOutput(pool,supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                                liquidtotal-=trans['outs'][frozenindex]['value']
                                            if meaning['message'][:5]=="**L**":
                                                pool, frozenpool[frozenindex]['liquidity']=self.CalculateOutput(pool,supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                                liquidtotal-=trans['outs'][frozenindex]['value']
                                        else:
                                            if meaning['message'][:5]=="**F**":
                                                reservepool[newstuff['txin'][txid]['address']], frozenpool[frozenindex]['liquidity']=self.CalculateOutput(reservepool[newstuff['txin'][txid]['address']],supply,trans['outs'][frozenindex]['value'],'Frozen', 1, reservetotal, liquidtotal)
                                                reservetotal-=trans['outs'][frozenindex]['value']
                                                txreservetotal-=trans['outs'][frozenindex]['value']
                                            if meaning['message'][:5]=="**V**":
                                                liquiditypool[newstuff['txin'][txid]['address']], frozenpool[frozenindex]['liquidity']=self.CalculateOutput(liquiditypool[newstuff['txin'][txid]['address']],supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                                liquidtotal-=trans['outs'][frozenindex]['value']
                                                txliquidtotal-=trans['outs'][frozenindex]['value']
                                            if meaning['message'][:5]=="**L**":
                                                liquiditypool[newstuff['txin'][txid]['address']], frozenpool[frozenindex]['liquidity']=self.CalculateOutput(liquiditypool[newstuff['txin'][txid]['address']],supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                                liquidtotal-=trans['outs'][frozenindex]['value']
                                                txliquidtotal-=trans['outs'][frozenindex]['value']
                    except:
                        traceback.print_exc()
                        if self.valid=='1':
                            self.valid='Frozen burn script was not valid'
                            float('a')
                    #NOTE6
                    for i in pool:
                        if i=='total' or i == 'frozen':
                            continue
                        if int(i)<supply:
                            amount=pool[i]
                            txreservetotal+=amount
                            if newstuff['txin'][txid]['address'] not in reservepool:
                                reservepool[newstuff['txin'][txid]['address']]={'total':0}
                            if i not in reservepool[newstuff['txin'][txid]['address']]:
                                reservepool[newstuff['txin'][txid]['address']][i]=amount
                                reservepool[newstuff['txin'][txid]['address']]['total']+=amount
                            else:
                                reservepool[newstuff['txin'][txid]['address']][i]+=amount
                                reservepool[newstuff['txin'][txid]['address']]['total']+=amount
                        else:                        
                            amount=pool[i]
                            txliquidtotal+=amount
                            if newstuff['txin'][txid]['address'] not in liquiditypool:
                                liquiditypool[newstuff['txin'][txid]['address']]={'total':0}
                            if i not in liquiditypool[newstuff['txin'][txid]['address']]:
                                liquiditypool[newstuff['txin'][txid]['address']][i]=amount
                                liquiditypool[newstuff['txin'][txid]['address']]['total']+=amount
                            else:
                                liquiditypool[newstuff['txin'][txid]['address']][i]+=amount
                                liquiditypool[newstuff['txin'][txid]['address']]['total']+=amount
                    if 'inputs' not in newstuff['txin'][txid]:
                        newstuff['txin'][usedinputs[txid]]['pool']={} #The information was moved to liquidity pool
                    totalin+=newstuff['txin'][txid]['amount']
                    pos+=1
                if whitelisted==0:
                    continue
                print "TIME ELAPSED 2: ", str(txtime-time.time())
                stake=0
                pos=0
                totalout=0
                reservepool['total']=txreservetotal
                bigliquiditypool['total']=txliquidtotal
                if 'frozen' in liquiditypool:
                    bigliquiditypool['frozen']=liquiditypool['frozen']
                for acct in liquiditypool:
                    if acct=='total' or acct=='frozen':
                        continue
                    for i in liquiditypool[acct]:
                        if i=='total' or i == 'frozen':
                            continue
                        if i not in bigliquiditypool:
                            bigliquiditypool[i]=liquiditypool[acct][i]
                        else:
                            bigliquiditypool[i]+=liquiditypool[acct][i]
                print 'rtotal ', str(reservepool['total'])
                print 'ltotal', str(bigliquiditypool['total'])
                txid2=txid
                print txid2
                for out in trans['outs']:
                    if out['value']==0:
                        if out['script']!='':
                            pos+=1
                            continue
                        if len(trans['ins'])>1:
                            self.valid='Too many inputs to the stake'
                            float('a')
                        if len(trans['outs'])>8:
                            self.valid='Too many outputs to the stake'
                            float('a')
                        stake=json_deep_copy(newstuff['txin'][txid2])
                        stake['txidin']=txid2
                        stake['txid']=tx
                        stake['outs']=trans['outs']
                        stake['ltotal']=0
                        stake['rtotal']=0
                        if 'stake' in stake:
                            stake['prevstake']=1
                        if stake['address'] in reservepool:
                            stake['liquidity']=reservepool[stake['address']].copy()
                            stake['rtotal']+=stake['liquidity']['total']
                        else:
                            stake['liquidity']={'total':0}                            
                        for i in bigliquiditypool:
                            if i=='total' or i=='frozen':
                                continue
                            if i not in stake['liquidity']:
                                stake['liquidity'][i]=bigliquiditypool[i]
                                stake['liquidity']['total']+=bigliquiditypool[i]                                
                            else:
                                stake['liquidity'][i]+=bigliquiditypool[i]
                                stake['liquidity']['total']+=bigliquiditypool[i]
                            stake['ltotal']+=bigliquiditypool[i]
                        pos+=1
                        continue
                    #For burn we should designate which funds to burn however not save in database
                    if address_to_script(MakeCipherOutputs('peginflate')[0]) == out['script'] or address_to_script(MakeCipherOutputs('pegdeflate')[0]) == out['script'] or address_to_script(MakeCipherOutputs('pegnochange')[0]  ) == out['script']:
                        pass
                    address=out['script']
                    if address[:2]=="6a":
                        pass
                    else:
                        try:
                            address=script_to_address2(address,85)
                        except:
                            pass
                    txid=tx+":"+str(pos)
                    newstuff['txout'][txid]={'address':address, 'amount':out['value'], 'index':pos}
                    if stake!=0:
                        newstuff['txout'][txid]['stake']=1
                        if 'found' not in stake:
                            if stake['amount']>out['value']:
                                self.valid='Stakes must always return original funds to the staking address'
                                float('a')
                            if stake['address']!=address:
                                self.valid='Stakes must return to the staking address'
                                float('a')
                            if 'frozen' in stake:
                                newstuff['txout'][txid]['frozen']=stake['frozen']
                                newstuff['txout'][txid]['ftype']=stake['ftype']                                
                            stake['found']=1
                        else:
                            totalout+=out['value']
                            pos+=1
                            continue #Calculate the remaining inputs after we know fees, there is no voluntary freeze on stakes
                    print "TIME ELAPSED L: ", str(txtime-time.time())
                    newstuff['txout'][txid]['pool'], frozenpool, reservepool, bigliquiditypool=self.CalculateLiquid(totalin, newstuff['txout'][txid], frozenpool, reservepool, bigliquiditypool, trans['locktime'], supply, stake)
                    if pos in frozenpool and 'ftype' in frozenpool[pos]:
                        newstuff['txout'][txid]['frozen']=1
                        newstuff['txout'][txid]['ftype']=frozenpool[pos]['ftype']
                    print "TIME ELAPSED L1: ", str(txtime-time.time())
                    newstuff['txout'][txid]['block']=block['height']
                    totalout+=out['value']
                    pos+=1
                if stake!=0:#First we save the stake input, then we calculate after all tx fees collected. We must commit fees and outputs back as well.
                    staketx=stake
                    print 'We staked this'
                else:
                    print 'Someone staked us!'
                fees=0
                #We should allow fee payment in both liquid and reserve to accomodate all kinds of transactions
                for act in reservepool:
                    if act == 'total' or act=='frozen':
                        continue
                    for i in reservepool[act]:
                        if i == 'total' or i=='frozen':
                            continue
                        fees+=reservepool[act][i]
                        if i not in txfees:
                            txfees[i]=reservepool[act][i]
                            txfees['total']+=reservepool[act][i]
                        else:
                            txfees[i]+=reservepool[act][i]
                            txfees['total']+=reservepool[act][i]
                for i in bigliquiditypool:
                    if i == 'total' or i=='frozen':
                        continue
                    fees+=bigliquiditypool[i]
                    if i not in txfees:
                        txfees[i]=bigliquiditypool[i]
                        txfees['total']+=bigliquiditypool[i]
                    else:
                        txfees[i]+=bigliquiditypool[i]
                        txfees['total']+=bigliquiditypool[i]
                #Transactions are more expensive due to liquidity calculations
                if stake==0:
                    if fees<(len(trans['outs'])*self.pegfeeperinput)+(len(trans['ins'])*self.pegfeeperinput):
                        self.valid="Fees are below the " + str(self.pegfeeperinput) + " satoshis per input/output minimum."
                        float('a')
            stakethis=1
            if staketx=={}:                
                if newstuff['txin']=={}:
                    if checkonly==0:
                        print "TIME ELAPSED T: ", str(txtime-time.time())
                        res=self.writedatabase(newstuff, block)
                        print "TIME ELAPSED T1: ", str(txtime-time.time())
                    else:
                        res=True
                    return res
                stakethis=0
            if stakethis==1:
                print "TIME ELAPSED R: ", str(txtime-time.time())
                reward=self.CalculateReward(staketx,1, block['height'])
                print "TIME ELAPSED R1: ", str(txtime-time.time())
                for i in reward:
                    if i == 'total' or i == 'frozen':
                        continue
                    if i not in txfees:
                        txfees[i]=reward[i]
                        txfees['total']+=reward[i]
                    else:
                        txfees[i]+=reward[i]
                        txfees['total']+=reward[i]

                print "TIME ELAPSED 3: ", str(txtime-time.time())
                print str(stake['liquidity']['total'])
                if totalout>txfees['total']+stake['liquidity']['total']:
                    print "Adding new fees"
                    #If we are whitelisting and we stake and there are fees not in the whitelist this can happen
                    totalout-=(txfees['total']+stake['liquidity']['total'])
                    stepindex=0
                    for s in self.steps:
                        if stepindex==len(self.steps)-1:
                            amount=totalout
                        else:
                            amount=totalout/self.rate
                        totalout-=amount
                        ind=str(stepindex)
                        if amount!=0:
                            if ind not in txfees:
                                txfees[ind]=amount
                                txfees['total']+=amount
                            else:
                                txfees[ind]+=amount
                                txfees['total']+=amount
                        stepindex+=1
                pos=0
                for out in staketx['outs']:
                    if out['value']==0:
                        pos+=1
                        continue
                    address=out['script']
                    if address[:2]=="6a":
                        pass
                    try:
                        address=script_to_address2(address,85)
                    except:
                        pass
                    txid=tx+":"+str(pos)
                    if txid not in newstuff['txout']:
                        newstuff['txout'][txid]={'address':address, 'amount':out['value'], 'index':pos}
                    if 'pool' in newstuff['txout'][txid]:
                        print 'here'
                        print txid
                        print str(txfees['total'])
                        print str(newstuff['txout'][txid]['pool']['total'])
                        print str(out['value'])
                        if newstuff['txout'][txid]['pool']['total']<out['value']:
                            txfees, newstuff['txout'][txid]['pool'] = self.CalculateOutput(txfees, supply, out['value']-newstuff['txout'][txid]['pool']['total'], "Mixed", 1, 0, txfees['total'], 0, newstuff['txout'][txid]['pool'])
                    else:
                        print 'here2'
                        print str(txfees['total'])
                        txfees, newstuff['txout'][txid]['pool'] = self.CalculateOutput(txfees, supply, out['value'], "Mixed", 1, 0, txfees['total'], 0)
                    newstuff['txout'][txid]['block']=block['height']
                    pos+=1
                if txfees['total']!=0:
                    self.valid='Some fees were not distributed.'
                    float('a')            
            #SUCCESS!
            print "TIME ELAPSED 4: ", str(txtime-time.time())
            if checkonly==0:
                res=self.writedatabase(newstuff, block)
            else:
                res=True
            print "TIME ELAPSED 5: ", str(txtime-time.time())
            return res
        except:
            myexc=str(traceback.format_exc())
            if self.valid=='1':
                self.valid='Block not valid: ' + myexc
            print self.valid
        return False    
    def CalculateLiquid(self, amountin,myoutput,frozenpool,reservepool,liquiditypool,locktime, supply, stake=0):
        #frozenpool=json_deep_copy(frozenpool)
        #reservepool=json_deep_copy(reservepool)
        #NOTE7
        burnaddress=['bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3']
        liquiditypool=liquiditypool.copy()
        if 'frozen' in liquiditypool:
            if liquiditypool['frozen']>locktime and stake==0:#This doesn't apply to stake. New output should carry same properties
                self.valid='You can not send frozen funds before locktime'
                float('a')
        if 'freezeall' in frozenpool and myoutput['index'] in frozenpool:#Either F or V, reserve/liquid funds will be shared
            if 'liquidity' in frozenpool[myoutput['index']]:
                output=frozenpool[myoutput['index']]['liquidity']
            else:
                multipleout=0
                if stake!=0:
                    multipleout=1
                if frozenpool[myoutput['index']]['ftype']=="V":
                    liquiditypool, output = self.CalculateOutput(liquiditypool, supply, myoutput['amount'], "Liquid", 1, 0, liquiditypool['total'], multipleout)
                if frozenpool[myoutput['index']]['ftype']=="F":
                    output={'total':0}
                    addresses=[]
                    sharethis=0
                    if 'shared' in frozenpool[myoutput['index']] and frozenpool[myoutput['index']]['shared'][0]==myoutput['index']:
                        if len(frozenpool)<4:
                            val1=frozenpool[frozenpool[myoutput['index']]['shared'][0]]['amount']
                            val2=frozenpool[frozenpool[myoutput['index']]['shared'][1]]['amount']
                            sharethis=1
                            print "SHARED WITHDRAW!"
                    for addy in reservepool:
                        if addy == 'total' or addy=='frozen':
                            continue
                        addresses.append(addy)
                    addresses.sort()
                    if 'address' in frozenpool[myoutput['index']] and len(addresses)>0 and 'split' not in frozenpool[myoutput['index']]:
                        addresses.remove(frozenpool[myoutput['index']]['address'])
                        addresses.insert(0,frozenpool[myoutput['index']]['address'])
                    amt=myoutput['amount']
                    if sharethis==1:#This is useful for making an fair withdraw of reserve/liquid funds from escrow
                        if len(addresses)>0 and reservepool[addresses[0]]['total']<=val1+val2:
                            t=reservepool[addresses[0]]['total']
                            amt=int(t*(float(val1)/float(val1+val2)))
                            remain=t-(int(t*(float(val1)/float(val1+val2)))+int(t*(float(val2)/float(val1+val2))))
                            amt+=remain
                    for addy in addresses:
                        if reservepool[addy]['total']!=0 and output['total'] < myoutput['amount']:
                            reservepool[addy], output = self.CalculateOutput(reservepool[addy], supply, amt, "Frozen", 1, reservepool[addy]['total'], 0, 1, output)
                    if output['total'] < myoutput['amount']:
                        liquiditypool, output = self.CalculateOutput(liquiditypool, supply, myoutput['amount']-output['total'], "Liquid", 1, 0, liquiditypool['total'], multipleout, output)
        else:
            if myoutput['index'] not in frozenpool:
                if myoutput['address'] in reservepool:
                    reservepool[myoutput['address']], output = self.CalculateOutput(reservepool[myoutput['address']], supply, myoutput['amount'], "Frozen", 1, reservepool[myoutput['address']]['total'], 0, 1)
                    if output['total']!=myoutput['amount']:
                        multipleout=0
                        if stake!=0:
                            multipleout=1
                        liquiditypool, output = self.CalculateOutput(liquiditypool, supply, myoutput['amount']-output['total'], "Liquid", 1, 0, liquiditypool['total'], multipleout, output)
                else:
                    multipleout=0
                    if stake!=0:
                        multipleout=1                    
                    general6a=False
                    if myoutput['address'][:2]=='6a':
                        general6a=True
                        meaning=translate_script(myoutput['address'])
                        if meaning!={} and meaning['type']=="Notary/Burn":
                            if meaning['message'][:5]=="**Z**":
                                if self.Pegdatabase['bridgeactive']==False:
                                    print "Bridge is not currently active"
                                    float('a')
                                foundthis=0
                                for bridged in self.Pegdatabase['bridgedb']['bridges']:
                                    if txhash(bridged['n'])[:64]==meaning['message'][5:][:64]:
                                        foundthis=1
                                        general6a=False
                                        break
                                if foundthis==0:
                                    print "Bridge not found"
                                    float('a')
                    if myoutput['address'] in burnaddress or general6a:
                        #It's a burn so we can take from all pools
                        output={'total':0}
                        addresses=[]
                        for addy in reservepool:
                            if addy == 'total' or addy=='frozen':
                                continue
                            addresses.append(addy)
                        addresses.sort()
                        for addy in addresses:
                            if reservepool[addy]['total']!=0 and output['total'] < myoutput['amount']:
                                reservepool[addy], output = self.CalculateOutput(reservepool[addy], supply, myoutput['amount']-output['total'], "Frozen", 1, reservepool[addy]['total'], 0, 1, output)
                        if output['total'] < myoutput['amount']:
                            liquiditypool, output = self.CalculateOutput(liquiditypool, supply, myoutput['amount']-output['total'], "Liquid", 1, 0, liquiditypool['total'], multipleout, output)
                    else:
                        liquiditypool, output = self.CalculateOutput(liquiditypool, supply, myoutput['amount'], "Liquid", 1, 0, liquiditypool['total'], multipleout)
            else:                
                output=frozenpool[myoutput['index']]['liquidity']

        return output, frozenpool, reservepool, liquiditypool
    def CalculateOutput(self, liquidity, supply, amount, ltype="Mixed", deduct=1, reservetotal=0, liquidtotal=0, multipleout=0, output=''):
        #NOTE8
        if output=='':
            output={'total':0}
        else:
            output=output.copy()
        if reservetotal+liquidtotal==0:
            if multipleout==1 or amount==0:
                return liquidity, output
            else:
                self.valid="Not enough funds"
                float('a')
        total=0
        dliquid=liquidity.copy()
        if ltype=="Frozen":
            if reservetotal<amount and multipleout==0:
                self.valid="Not enough funds in reserve"
                float('a')
            if reservetotal<amount:
                amount=reservetotal
            for i in dliquid:
                if i == 'total' or i == 'frozen':
                    continue
                if int(i) < supply:
                    amt=int(amount*(float(dliquid[i])/float(reservetotal)))
                    if amt!=0:
                        dliquid[i]-=amt
                        total+=amt
                        if i not in output:
                            output[i]=amt
                        else:
                            output[i]+=amt
            pos=0
            while pos < self.amountofsteps:
                if total==amount:
                    break
                i=str(pos)
                if pos < supply:
                    if i in dliquid:
                        if dliquid[i]!=0:
                            dliquid[i]-=1
                            if i in output:
                                output[i]+=1
                            else:
                                output[i]=1
                            total+=1
                else:
                    break
                pos+=1
        if ltype=="Liquid":
            if liquidtotal<amount and multipleout==0:
                print str(liquidtotal)
                print str(amount)
                self.valid="Not enough liquid funds"
                float('a')
            if liquidtotal<amount:
                amount=liquidtotal
            for i in dliquid:
                if i == 'total' or i == 'frozen':
                    continue
                if int(i) >= supply:
                    amt=int(amount*(float(dliquid[i])/float(liquidtotal)))
                    if amt!=0:
                        dliquid[i]-=amt
                        total+=amt
                        if i not in output:
                            output[i]=amt
                        else:
                            output[i]+=amt
            pos=int(supply)
            while pos < self.amountofsteps:
                if total==amount:
                    break
                i=str(pos)
                if total==amount:
                    break
                if pos >= supply:
                    if i in dliquid:
                        if dliquid[i]!=0:
                            dliquid[i]-=1
                            if i in output:
                                output[i]+=1
                            else:
                                output[i]=1
                            total+=1
                pos+=1
        if ltype=="Mixed":
            if liquidtotal+reservetotal<amount and multipleout==0:
                self.valid="Not enough funds"
                float('a')
            if liquidtotal+reservetotal<amount:
                amount=liquidtotal+reservetotal          
            for i in dliquid:
                if i == 'total' or i == 'frozen':
                    continue
                amt=int(amount*(float(dliquid[i])/float(liquidtotal+reservetotal)))
                if amt!=0:
                    dliquid[i]-=amt
                    total+=amt
                    if i not in output:
                        output[i]=amt
                    else:
                        output[i]+=amt
            pos=0
            while pos < self.amountofsteps:
                if total==amount:
                    break
                i=str(pos)
                if total==amount:
                    break
                if i in dliquid:
                    if dliquid[i]!=0:
                        dliquid[i]-=1
                        if i in output:
                            output[i]+=1
                        else:
                            output[i]=1
                        total+=1
                pos+=1
        pos=0
        for x in self.steps:
            ps=str(pos)
            if ps in dliquid:
                if dliquid[ps]==0:
                    dliquid.pop(ps)
            pos+=1
        output['total']+=total
        if deduct==0:
            return liquidity, output
        else:
            if 'total' in dliquid:
                dliquid['total']-=total
            return dliquid, output
    def CalculateReward(self, tx, pool=0, block=0):
        #NOTE9
        if 'frozen' in tx:            
            if tx['ftype']=='F':
                reward=2000000000
            if tx['ftype']=='V':
                reward=4000000000
        else:
            if tx['ltotal']>tx['rtotal']:
                reward=500000000
            else:
                reward=1000000000
        #This is the reward until the fork!
        reward=2000000000
        if pool==0:
            return reward
        else:
            liquid={'total':reward}
            stepindex=0
            for s in self.steps:
                if stepindex==len(self.steps)-1:
                    amount=reward
                else:
                    amount=reward/self.rate
                reward-=amount
                if amount!=0:
                    liquid[str(stepindex)]=amount
                stepindex+=1
            return liquid
    def readdatabase(self, txid, address=''):
        #NOTE10
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase'
            fd="/"
        check=0
        if self.prunetopools==0:
            address=''
        if address=='':
            if os.path.exists(os.path.join(pegdir+fd+txid[:1],txid[:3][1:]+".dat")):
                with open(os.path.join(pegdir+fd+txid[:1],txid[:3][1:]+".dat"),'rb') as f:
                    data=ujson.loads(bsonjs.dumps(f.read()))
                    f.close()
                if txid in data:
                    return data[txid]
            txin=BLK.getrawtransaction(txid.split(':')[0], 1)
            address=txin['vout'][int(txid.split(':')[1])]['scriptPubKey']['hex']
            try:
                address=script_to_address2(address,85)
            except:
                pass
        else:
            check=1
        if self.prunetopools==0:
            return False
        if os.path.exists(os.path.join(pegdir+fd+address[:2][1:],address[:4][2:].lower()+".dat")):
            with open(os.path.join(pegdir+fd+address[:2][1:],address[:4][2:].lower()+".dat"),'rb') as f:
                data=ujson.loads(bsonjs.dumps(f.read()))
                f.close()
            if address in data:
                if txid in data[address]['inputs']:
                    return data[address]
        if check==1:
            if os.path.exists(os.path.join(pegdir+fd+txid[:1],txid[:3][1:]+".dat")):
                with open(os.path.join(pegdir+fd+txid[:1],txid[:3][1:]+".dat"),'rb') as f:
                    data=ujson.loads(bsonjs.dumps(f.read()))
                    f.close()
                if txid in data:
                    return data[txid]
        return False
    def writedatabase(self, newstuff, block2):
        #NOTE11
        global CoinSelect, timestamp
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase'
            fd="/"
        if not os.path.exists(pegdir):
            os.mkdir(pegdir)
            l=['1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
            for i in l:
                os.mkdir(pegdir+fd+i)
        with open(os.path.join(pegdir,"index.dat"),'a+') as f:
            f.close()        
        if os.stat(os.path.join(pegdir,"index.dat"))[6]==0:
            with open(os.path.join(pegdir,"index.dat"),'wb') as f:
                f.write(bsonjs.loads(ujson.dumps(ThePeg.Pegdatabase)))
                f.flush()
                os.fsync(f)
                f.close()        
        block={}
        block['deductions']={}
        block['outputs']=[]
        block['inputs']=[]
        block['height']=block2['height']
        block['hash']=block2['hash']
        block['6a']=[]
        elements={}
        pruneblock=''
        accountprune=0
        if block2['height']%(int(Decimal(self.interval)*Decimal(6)))==0 and self.prunetopools==1:
            accountprune=1
        if self.prunetopools==1 and accountprune==1:
            x=0
            while x<int(Decimal(self.interval)*Decimal(3)):
                blockname=str(block2['height']-int(Decimal(self.interval)*Decimal(6))+x)+".dat"
                if os.path.exists(os.path.join(pegdir,blockname)):
                    pruneblock=blockname
                    with open(os.path.join(pegdir,blockname),'rb') as f:
                        pruneblock=ujson.loads(bsonjs.dumps(f.read()))
                        f.close()
                if pruneblock!='':
                    for txid in pruneblock['deductions']:#Remove spent txid from pool list
                        if pruneblock['deductions'][txid]['address'][:4][1:].lower() not in elements:
                            elements[pruneblock['deductions'][txid]['address'][:4][1:].lower()]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                        elements[pruneblock['deductions'][txid]['address'][:4][1:].lower()]['prune']['txin'][txid]=pruneblock['deductions'][txid]['address']
                    for txid in pruneblock['outputs']:#Move output to an account pool or delete it if it was spent after we check it
                        if txid[:3] not in elements:
                            elements[txid[:3]]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                        tx=self.readdatabase(txid)
                        if 'frozen' not in tx:
                            elements[txid[:3]]['prune']['txout'][txid]=''
                            if 'spent' not in tx:
                                if tx['address'][:4][1:].lower() not in elements:
                                    elements[tx['address'][:4][1:].lower()]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                                tx['move']=1
                                elements[tx['address'][:4][1:].lower()]['prune']['txout'][txid]=tx
                        else:
                            if 'spent' in tx:
                                elements[txid[:3]]['prune']['txout'][txid]=''
                self.queue.append(['prune',blockname])
                x+=1
        if self.prunetopools==0:
            blockname=str(block2['height']-int(Decimal(self.interval)*Decimal(2.5)))+".dat"
            if os.path.exists(os.path.join(pegdir,blockname)):
                pruneblock=blockname
                with open(os.path.join(pegdir,blockname),'rb') as f:
                    pruneblock=ujson.loads(bsonjs.dumps(f.read()))
                    f.close()
            if pruneblock!='':
                for txid in pruneblock['inputs']:#Delete spent txids
                    if txid[:3] not in elements:
                        elements[txid[:3]]={'txin':{},'txout':{},'prune':{'txin2':{},'txin':{},'txout':{}}}
                    elements[txid[:3]]['prune']['txin2'][txid]=''
        for txid in newstuff['txin']:
            if 'inputs' in newstuff['txin'][txid]:#Deduct from pool, notate in block
                block['deductions'][txid]={'address':newstuff['txin'][txid]['address'],'pool':newstuff['txin'][txid]['pool2']}
                if newstuff['txin'][txid]['address'][:4][1:].lower() not in elements:
                    elements[newstuff['txin'][txid]['address'][:4][1:].lower()]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                elements[newstuff['txin'][txid]['address'][:4][1:].lower()]['txin'][txid]=newstuff['txin'][txid]
            else:#Mark input as spent and remember it
                block['inputs'].append(txid)
                if txid[:3] not in elements:
                    elements[txid[:3]]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                elements[txid[:3]]['txin'][txid]=''
        for txid in newstuff['txout']:#Add output to database
            if newstuff['txout'][txid]['address'] not in self.ignorelist and newstuff['txout'][txid]['address'][:2]!="6a":
                block['outputs'].append(txid)
                if txid[:3] not in elements:
                    elements[txid[:3]]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                elements[txid[:3]]['txout'][txid]=newstuff['txout'][txid]
            if newstuff['txout'][txid]['address'][:2]=="6a":                
                meaning=translate_script(newstuff['txout'][txid]['address'])
                if meaning!={} and meaning['type']=="Notary/Burn":
                    if meaning['message'][:5]=="**Z**":
                        for bridged in self.Pegdatabase['bridgedb']['bridges']:
                            if txhash(bridged['n'])[:64]==meaning['message'][5:][:64]:
                                mytx={'txid':txid,'network':bridged['n'],'to':meaning['message'][5:][64:],'pool':copy.deepcopy(newstuff['txout'][txid]['pool'])}
                                self.Pegdatabase['txidreference'][txid]=self.Pegdatabase['merklenonceTX'] #For easy reference finding a TX
                                self.Pegdatabase['merklelist'][str(self.Pegdatabase['merklenonceTX'])]['transactions'].append(mytx)
                                block['6a'].append(txid)
                                break
        for el in elements:
            txlist=[]
            for txid in elements[el]['txin']:
                txlist.append(txid)
            for txid in elements[el]['txout']:
                txlist.append(txid)
            for txid in elements[el]['prune']['txin']:
                txlist.append(txid)
            for txid in elements[el]['prune']['txout']:
                txlist.append(txid)
            if 'txin2' in elements[el]['prune']:
                for txid in elements[el]['prune']['txin2']:
                    txlist.append(txid)
            txlist.sort()
            #The other unique hashing methods are too slow
            #txhash(ujson.dumps({el:elements[el]}, sort_keys=True))
            uniquehash=txhash(str(txlist))
            self.queue.append([uniquehash,{el:elements[el]}])
        self.queue.append(['block',block])
        commit=json_deep_copy(self.Pegdatabase)
        commit['blockcount']+=1
        commit['prevhashes'].append(block['hash'])
        self.queue.append(['pegdatabase',commit])
        if pruneblock!='' and self.prunetopools==0:
            self.queue.append(['prune',blockname])
        with open(os.path.join(pegdir,"queue.dat"),'wb') as f:
            f.write(bsonjs.loads(ujson.dumps(self.queue)))
            f.flush()
            os.fsync(f)
            f.close()
        self.writequeue()
        return True
    def writequeue(self):
        #NOTE12
        global CoinSelect
        self.writing=1
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase'
            fd="/"
        if self.queue==[]:
            with open(os.path.join(pegdir,"queue.dat"),'a+') as f:
                f.close()        
            if os.stat(os.path.join(pegdir,"queue.dat"))[6]==0:
                with open(os.path.join(pegdir,"queue.dat"),'wb') as f:
                    f.write(bsonjs.loads(ujson.dumps([])))
                    f.flush()
                    os.fsync(f)
                    f.close()
        try:
            while self.queue!=[]:
                q=self.queue[0]
                if q[0]=='block':
                    blockname=str(q[1]['height'])+".dat"
                    with open(os.path.join(pegdir,blockname),'wb') as f:
                        f.write(bsonjs.loads(ujson.dumps(q[1])))
                        f.flush()
                        os.fsync(f)
                        f.close()
                elif q[0]=='pegdatabase':
                    with open(os.path.join(pegdir,'index.dat'),'wb') as f:
                        f.write(bsonjs.loads(ujson.dumps(q[1])))
                        f.flush()
                        os.fsync(f)
                        f.close()
                elif q[0]=='prune':
                    try:
                        os.remove(os.path.join(pegdir,q[1]))
                    except:
                        traceback.print_exc()
                elif '*' in q[0]:#Reorganize
                    skip=0
                    for el2 in q[1]:
                        if os.path.exists(os.path.join(pegdir+fd+el2[:1],el2[:3][1:]+".dat")):
                            with open(os.path.join(pegdir+fd+el2[:1],el2[:3][1:]+".dat"),'rb') as f:
                                data=ujson.loads(bsonjs.dumps(f.read()))
                                f.close()
                            if 'lastfilehash' in data:#avoid writing twice
                                if data['lastfilehash']==q[0]:
                                    skip=1
                                    break
                        else:
                            data={}
                        el=q[1][el2]
                        try:
                            for txid in el['txin']:
                                if txid in data:
                                    if 'spent' in data[txid]:
                                        data[txid].pop('spent')
                            for txid in el['prune']['txin']:
                                for i in el['prune']['txin'][txid]['pool']:
                                    if i == 'total' or i == 'frozen':
                                        continue
                                    if i not in data[el['prune']['txin'][txid]['address']]['pool']:
                                        data[el['prune']['txin'][txid]['address']]['pool'][i]=el['prune']['txin'][txid]['pool'][i]
                                        data[el['prune']['txin'][txid]['address']]['pool']['total']+=el['prune']['txin'][txid]['pool'][i]
                                    else:
                                        data[el['prune']['txin'][txid]['address']]['pool'][i]+=el['prune']['txin'][txid]['pool'][i]
                                        data[el['prune']['txin'][txid]['address']]['pool']['total']+=el['prune']['txin'][txid]['pool'][i]
                                if 'spent' in data[el['prune']['txin'][txid]['address']]['inputs'][txid]:
                                    data[el['prune']['txin'][txid]['address']]['inputs'][txid].pop('spent')
                            for txid in el['prune']['txout']:
                                data.pop(txid)
                        except:
                            traceback.print_exc()
                            float('a')                            
                        break
                    if skip==0:
                        data['lastfilehash']=q[0]
                        with open(os.path.join(pegdir+fd+el2[:1],el2[:3][1:]+".dat"),'wb') as f:
                            f.write(bsonjs.loads(ujson.dumps(data)))
                            f.flush()
                            os.fsync(f)
                            f.close()
                else:
                    #Organize by account or txid
                    #elements[txid[:3]]={'txin':{},'txout':{},'prune':{'txin':{},'txout':{}}}
                    skip=0
                    for el2 in q[1]:
                        if os.path.exists(os.path.join(pegdir+fd+el2[:1],el2[:3][1:]+".dat")):
                            with open(os.path.join(pegdir+fd+el2[:1],el2[:3][1:]+".dat"),'rb') as f:
                                data=ujson.loads(bsonjs.dumps(f.read()))
                                f.close()
                            if 'lastfilehash' in data:#avoid writing twice
                                if data['lastfilehash']==q[0]:
                                    skip=1
                                    break
                        else:
                            data={}
                        el=q[1][el2]
                        #we look for keys and modify accordingly
                        try:
                            for txid in el['txout']:
                                data[txid]=el['txout'][txid]
                            for txid in el['txin']:
                                if 'inputs' in el['txin'][txid]:
                                    data[el['txin'][txid]['address']]['inputs'][txid]['spent']=1
                                    poplist=[]
                                    for i in el['txin'][txid]['pool2']:
                                        if i=='total' or i=='frozen':
                                            continue
                                        data[el['txin'][txid]['address']]['pool'][i]-=el['txin'][txid]['pool2'][i]
                                        data[el['txin'][txid]['address']]['pool']['total']-=el['txin'][txid]['pool2'][i]
                                        if data[el['txin'][txid]['address']]['pool'][i]==0:
                                            poplist.append(i)
                                    for i in poplist:
                                        data[el['txin'][txid]['address']]['pool'].pop(i)
                                else:
                                    if txid in data:
                                        data[txid]['spent']=1
                                        if self.prunetopools==1:
                                            pass
                                            #if 'frozen' in data[txid]:
                                            #    data.pop(txid)
                            for txid in el['prune']['txin']:#Removes spent txid from address pool
                                if self.prunetopools==1:
                                    data[el['prune']['txin'][txid]]['inputs'].pop(txid)
                            if 'txin2' in el['prune']:
                                for txid in el['prune']['txin2']:
                                    if txid in data:
                                        data.pop(txid)
                            for txid in el['prune']['txout']:
                                if 'move' in el['prune']['txout'][txid]:
                                    if el['prune']['txout'][txid]['address'] not in data:
                                        data[el['prune']['txout'][txid]['address']]={'inputs':{txid:{}}, 'pool':{'total':0}}
                                    else:
                                        data[el['prune']['txout'][txid]['address']]['inputs'][txid]={}
                                    for i in el['prune']['txout'][txid]['pool']:
                                        if i == 'total' or i == 'frozen':
                                            continue
                                        if i not in data[el['prune']['txout'][txid]['address']]['pool']:
                                            data[el['prune']['txout'][txid]['address']]['pool'][i]=el['prune']['txout'][txid]['pool'][i]
                                            data[el['prune']['txout'][txid]['address']]['pool']['total']+=el['prune']['txout'][txid]['pool'][i]
                                        else:
                                            data[el['prune']['txout'][txid]['address']]['pool'][i]+=el['prune']['txout'][txid]['pool'][i]
                                            data[el['prune']['txout'][txid]['address']]['pool']['total']+=el['prune']['txout'][txid]['pool'][i]
                                else:
                                    data.pop(txid)                        
                        except:
                            traceback.print_exc()
                            #If coded correctly, we should not see exceptions. Consider deleting database and trying again.
                            float('a')
                        break
                    if skip==0:
                        data['lastfilehash']=q[0]
                        with open(os.path.join(pegdir+fd+el2[:1],el2[:3][1:]+".dat"),'wb') as f:
                            f.write(bsonjs.loads(ujson.dumps(data)))
                            f.flush()
                            os.fsync(f)
                            f.close()
                self.queue.pop(0)
                with open(os.path.join(pegdir,"queue.dat"),'wb') as f:
                    f.write(bsonjs.loads(ujson.dumps(self.queue)))
                    f.flush()
                    os.fsync(f)
                    f.close()
        except:
            traceback.print_exc()
            self.writing=0
            float('a')
        self.writing=0
    def LoadDatabase(self):
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
        else:
            pegdir=application_path+"/"+'pegdatabase'
        try:
            if os.path.exists(os.path.join(pegdir,"queue.dat")):
                if os.stat(os.path.join(pegdir,"queue.dat"))[6]==0:
                    print "Writing the queue failed, delete the database."
                    with open(os.path.join(pegdir,"queue.dat"),'wb') as f:
                        f.write(bsonjs.loads(ujson.dumps([])))
                        f.flush()
                        os.fsync(f)
                        f.close()
                    try:
                        self.DeleteDatabase()
                        return
                    except:
                        print 'Failed deleting database.'
                        return
                else:
                    with open(os.path.join(pegdir,"queue.dat"),'rb') as f:
                        self.queue=ujson.loads(bsonjs.dumps(f.read()))
                        f.close()
                    if self.queue=={}:#BSON saves blank lists as dictionaries
                        self.queue=[]
                    if self.queue!=[]:
                        print 'Will finish writing queue.'
                        self.writequeue()
            if os.path.exists(os.path.join(pegdir,"index.dat")):
                if os.stat(os.path.join(pegdir,"index.dat"))[6]==0:
                    print "Writing the index failed, delete the database."
                    with open(os.path.join(pegdir,"index.dat"),'wb') as f:
                        f.write(bsonjs.loads(ujson.dumps([])))
                        f.flush()
                        os.fsync(f)
                        f.close()
                    try:
                        self.DeleteDatabase()
                        return
                    except:
                        print 'Failed deleting database.'
                        return
                else:
                    with open(os.path.join(pegdir,"index.dat"),'rb') as f:
                        self.Pegdatabase=ujson.loads(bsonjs.dumps(f.read()))
                        f.close()
        except:
            traceback.print_exc()
            print 'Deleting database.'
            try:
                self.DeleteDatabase()
                return
            except:
                print 'Failed deleting database.'
                return
    def DeleteDatabase(self):
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
        else:
            pegdir=application_path+"/"+'pegdatabase'
        print "Deleting peg database in 30 seconds! Will need to sync again."
        time.sleep(30)
        startblock=self.Pegdatabase['startingblock']
        self.Pegdatabase={}
        self.Pegdatabase['startingblock']=startblock
        self.Pegdatabase['blockcount']=self.Pegdatabase['startingblock']
        self.Pegdatabase['votesblockcount']=self.Pegdatabase['startingblock']
        self.Pegdatabase['votesblockcount2']=self.Pegdatabase['startingblock']
        self.Pegdatabase['supply']=0 #Measured in steps of 1% away from 100%
        self.Pegdatabase['votedata']={}#{'1684900':[0,0,0]}
        self.Pegdatabase['votedata2']={}
        self.Pegdatabase['votecycle']=0
        self.Pegdatabase['prevhashes']=[]#Holds data about previous 400 hashes
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
        else:
            pegdir=application_path+"/"+'pegdatabase'        
        shutil.rmtree(pegdir)
    def checktransaction(self,tx,pos=0, blockheight=0, checkcount=0, txid2='', returnliquid=0):
        #This function is not fully updated with the newest changes of the fork. However, because it's just a simulation
        #function, it doens't currently effect anything during runtime. Also during testnets it only effects mints and exchanges.
        #It's worth mentioning that bitbayd also support the **C** notation which is the ability to skip a freeze under the
        #condition that the next transaction sends back to the original sender. This is not simulated here in the python build.
        #NOTE14
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
        else:
            pegdir=application_path+"/"+'pegdatabase'
        #Common keys:
        #inputs/outputs: known by txid and out, index(from output), pool, block
        #pool2(deduct on input), amount, frozen, ftype, stake, inputs(if pool), address
        #No change: bNyZrPeFFNP6GFJZCkE82DDN7JC4K5Vrkk, Deflate: bNyZrP2SbrV6v5HqeBoXZXZDE2e4fe6STo Inflate: bNyZrPLQAMPvYedrVLDcBSd8fbLdNgnRPz
        #For whitelist testing we skip stakes and transactions if we aren't involved.
        #Maybe switch to numpy for array calculations maybe numba, cython, ujson, etc
        supply=self.CurrentSupply(self.Pegdatabase['blockcount'])
        txtime=time.time()
        self.valid='1'
        if checkcount==1:
            #For the Python implementation we give a small amount of space since the databases are separate
            #However in production both will sync together
            if self.Pegdatabase['blockcount']<blockheight-1:
                self.valid='Peg database is not in sync.'
                float('a')
        try:#Remove instances of block, staketx
            checkliquidity=0
            newstuff={'txin':{}, 'txout':{}}
            txfees={'total':0}
            usedinputs={}
            #If account pruning is active then certain things must be coded first. Special transfers change the "proportion" 
            #of all inputs in a pool by deducting from the pool liquid or reserve specifically. For this reason, they are too
            #complex for the debut release of the peg. Once people get used to the peg and they are looking to scale account
            #pruning can be activated. Either that or the entire blockchain architecture could be changed. To solve this here,
            #mempools would need to store pool data for all users. They should remove transactions from blocks that aren't valid
            #without compromising the block. They should make sure user pools are saved with no data loss and adjusted immediately
            #during changes. This way, the mempool is completely up to date with the intentions of the users. Because we want
            #simplicity in advanced commitments and don't want it to be easy to have a transation be invalidated by reorganization
            #for now account pool pruning is not activated. The drawback is a larger blockchain. It's important to understand that
            #this system can be easily scaled down or up by reducing the number of steps or increasing them with the same rate.
            if self.prunetopools==1:
                if ':' not in tx and not isinstance(tx, dict):
                    mempool=BLK.getrawmempool()
                    for act in self.memaccountpools:
                        l=len(act['tx'])                
                        i=0
                        while i<l:
                            nxt=1
                            if act['tx'][i] not in mempool:
                                l-=1
                                nxt=0
                                self.memaccountpools.pop(act['tx'][i])
                                act['tx'].pop(i)
                                act['locktime'].pop(i)                        
                            if nxt==1:
                                i+=1
                    for m1 in mempool:
                        if m1 not in self.memaccountpools:
                            trans=deserialize(BLK.getrawtransaction(m1))
                            prevaddy=''
                            self.memaccountpools[m1]=''
                            for inp in trans['ins']:
                                mytx=BLK.getrawtransaction(inp['outpoint']['hash'], 1)
                                address=mytx['vout'][inp['outpoint']['index']]['scriptPubKey']['hex']
                                try:
                                    address=script_to_address2(address,85)
                                    if address!=prevaddy:
                                        prevaddy=address
                                    else:
                                        continue
                                except:
                                    pass
                                if address not in self.memaccountpools:
                                    self.memaccountpools[address]={'tx':[m1],'locktime':[trans['locktime']]}
                                else:
                                    x=0
                                    added=0
                                    for ltime in self.memaccountpools[address]['locktime']:
                                        if trans['locktime']>ltime:
                                            added=1
                                            self.memaccountpools[address]['tx'].insert(x,m1)
                                            self.memaccountpools[address]['locktime'].insert(x,trans['locktime'])
                                            break
                                        x+=1
                                    if added==0:
                                        self.memaccountpools[address]['tx'].append(m1)
                                        self.memaccountpools[address]['locktime'].append(trans['locktime'])
            #accountpools[newstuff['txin'][txid]['address']]['locktime']
            txorig=tx
            if ':' in tx:
                checkliquidity=1
                posx=int(tx.split(':')[1])
                txid2=tx.split(':')[0]
                trans=deserialize(BLK.getrawtransaction(tx.split(':')[0]))
            elif isinstance(tx, dict):
                checkliquidity=1
                trans=tx
                posx=pos
                tx=txhash(serialize(tx))
            else:
                txid2=txhash(tx)
                trans=deserialize(tx)
                tx=txhash(tx)
            whitelisted=0
            highestfrozen=0
            totalin=0
            bigliquiditypool={'total':0}
            liquiditypool={'total':0}
            reservepool={'total':0}
            frozenpool={}                
            txreservetotal=0
            txliquidtotal=0
            pos=0
            checkaddress=''
            print "TIME ELAPSED 0: ", str(txtime-time.time())
            #Near the block of a rate change we can check inputs and ask for more confirmations.
            #However for now, the software can require a bit more change or have users wait.
            for inp in trans['ins']:
                if checkliquidity==1:
                    #We are asking for a specific output however similar logic is used
                    pos=posx
                    if txid2=='':
                        txid2=txhash(serialize(trans))
                    txid=txid2+':'+str(pos)
                    address=trans['outs'][pos]['script']
                    try:
                        address=script_to_address2(address,85)
                    except:
                        pass
                else:
                    txid=inp['outpoint']['hash']+':'+str(inp['outpoint']['index'])
                pool={}
                if checkliquidity==1:
                    txin=self.readdatabase(txid, address)#could return single input or entire liquidity pool
                if checkliquidity==0:
                    txin2=BLK.getrawtransaction(inp['outpoint']['hash'], 1)
                    if txin2['confirmations']<1:
                        self.valid="Can not spend zero confirmations"
                        float('a')
                    address=txin2['vout'][inp['outpoint']['index']]['scriptPubKey']['hex']
                    try:
                        address=script_to_address2(address,85)
                    except:
                        pass
                    try:
                        txin=self.readdatabase(txid, address)#could return single input or entire liquidity pool
                    except:
                        traceback.print_exc()
                        txid=False
                checkaddress=address
                if address in self.whitelist or returnliquid==1:
                    whitelisted=1
                else:
                    if txin != False and self.whitelistoutputs == 1:
                        whitelisted=1
                    else:
                        if checkliquidity==1:
                            txliquidtotal=trans['outs'][pos]['value']
                            liquiditypool['total']=trans['outs'][pos]['value']
                        break
                liquidtotal=0
                reservetotal=0
                if txin==False:#Didn't find it, either we should have had it or it's from before peg
                    newstuff['txin'][txid]={}
                    if checkliquidity==0:
                        #txin=copy.deepcopy(txin2)                        
                        #if txin['blocktime']>self.Pegdatabase['startblocktime']:
                        #    self.DeleteDatabase()#Critical information was missing, sync again
                        #    return False                        
                        newstuff['txin'][txid]['amount']=int(txin2['vout'][inp['outpoint']['index']]['value']*Decimal(1e8))
                        address=txin2['vout'][inp['outpoint']['index']]['scriptPubKey']['hex']
                        try:
                            address=script_to_address2(address,85)
                        except:
                            pass
                    else:
                        newstuff['txin'][txid]['amount']=trans['outs'][pos]['value']
                    newstuff['txin'][txid]['address']=address
                    stepindex=0
                    newstuff['txin'][txid]['pool']={}                    
                    txin_amount_left=newstuff['txin'][txid]['amount']
                    if returnliquid==1:
                        fractions=BLK.getfractions(txid)
                        for f in fractions['values']:
                            newstuff['txin'][txid]['pool'][str(stepindex)]=f
                            stepindex+=1
                    else:
                        for s in self.steps:
                            if stepindex==len(self.steps)-1:
                                amount=txin_amount_left
                            else:
                                amount=txin_amount_left/self.rate
                            txin_amount_left-=amount
                            if amount!=0:
                                if stepindex<supply:
                                    reservetotal+=amount
                                else:
                                    liquidtotal+=amount
                                newstuff['txin'][txid]['pool'][str(stepindex)]=amount
                            stepindex+=1
                else:
                    newstuff['txin'][txid]=txin
                    if 'amount' not in newstuff['txin'][txid]:
                        if checkliquidity==1:
                            newstuff['txin'][txid]['amount']=trans['outs'][pos]['value']
                        else:
                            newstuff['txin'][txid]['amount']=int(txin2['vout'][inp['outpoint']['index']]['value']*Decimal(1e8))
                    if 'address' not in newstuff['txin'][txid]:
                        newstuff['txin'][txid]['address']=address
                #print "TIME ELAPSED 1: ", str(txtime-time.time())
                if 'frozen' in newstuff['txin'][txid]:#Sending 1 month lock funds
                    #Would a stake that spends a frozen of '1' maintain same number?! If we try to carry previous value
                    #However we want a fresh value if blocktime changes
                    if 'stake' not in newstuff['txin'][txid]:
                        if checkliquidity==1:
                            if txid2=='':
                                txin2=BLK.getrawtransaction(txhash(serialize(trans)), 1) 
                            else:
                                txin2=BLK.getrawtransaction(txid2, 1) 
                        if newstuff['txin'][txid]['ftype']=='F':
                            newstuff['txin'][txid]['frozen']=txin2['blocktime']+2592000
                        if newstuff['txin'][txid]['ftype']=='V':
                            newstuff['txin'][txid]['frozen']=txin2['blocktime']+(2592000*4)
                    if newstuff['txin'][txid]['frozen']>highestfrozen:
                        if newstuff['txin'][txid]['ftype']=='F':
                            liquiditypool['frozen']=newstuff['txin'][txid]['frozen']
                        if newstuff['txin'][txid]['ftype']=='V':
                            liquiditypool['frozen']=newstuff['txin'][txid]['frozen']
                        highestfrozen=newstuff['txin'][txid]['frozen']
                if txid in usedinputs:
                    pool=newstuff['txin'][usedinputs[txid]]['pool'].copy()
                else:
                    usedinputs[txid]=txid
                    pool=newstuff['txin'][txid]['pool'].copy()
                if 'inputs' in newstuff['txin'][txid]:#It's a big pool
                    #print 'Found in pool'
                    for myinput in newstuff['txin'][txid]['inputs']:
                        if myinput not in usedinputs:
                            usedinputs[myinput]=txid
                    if checkliquidity==0:
                        if newstuff['txin'][txid]['address'] in self.memaccountpools:                        
                            if tx not in self.memaccountpools[newstuff['txin'][txid]['address']]['tx']:
                                if self.memaccountpools[newstuff['txin'][txid]['address']]['locktime']!=[]:
                                    if trans['locktime']<=self.memaccountpools[newstuff['txin'][txid]['address']]['locktime'][0]:
                                        self.valid='Trying to take from liquidity pool out of order.'
                                        float('a')
                #We shouldn't take more than we need from a pool otherwise it can get confusing as to what to select and when
                #We could let a user take liquid without touching reserve but he may want to use reserve for a specific reason
                #The user may end up with mixed liquidity anyways because of the size of the input. Therefore this is a simple
                #rule to take an even mix of liquidity for each input seen deducted in the order they are seen in the block.
                
                #print newstuff['txin'][txid]['amount']
                if 'inputs' in newstuff['txin'][txid]:
                    amttotake=newstuff['txin'][txid]['amount']                        
                    pool, pool2=self.CalculateOutput(pool,supply,amttotake,'Mixed', 1, 0, pool['total'])
                    newstuff['txin'][usedinputs[txid]]['pool']=pool.copy()
                    newstuff['txin'][txid]['pool2']=pool2.copy()
                    #print 'POOL TOTALS:'                        
                    #print pool2['total']
                    pool=pool2.copy()
                try:
                    pass
                    #print pool['total']
                except:
                    pass
                    #print reservetotal+liquidtotal
                empty=0
                if 'total' in pool and 'frozen' not in pool and len(pool)==1:
                    empty=1
                if 'total' in pool and 'frozen' in pool and len(pool)==2:
                    empty=1
                if pool!={} and empty!=1:
                    if reservetotal==0 and liquidtotal==0:
                        for i in pool:
                            if i=='total' or i == 'frozen':
                                continue
                            if int(i)<supply:
                                reservetotal+=pool[i]
                            else:
                                liquidtotal+=pool[i]
                        #print 'r', reservetotal
                        #print 'l', liquidtotal
                else:
                    #Depending on how transactions are ordered there may be something to draw from
                    try:
                        for i in reservepool[newstuff['txin'][txid]['address']]:
                            if i=='total' or i == 'frozen':
                                continue
                            reservetotal+=reservepool[newstuff['txin'][txid]['address']][i]
                    except:
                        pass
                    try:
                        for i in liquiditypool[newstuff['txin'][txid]['address']]:
                            if i=='total' or i == 'frozen':
                                continue
                            liquidtotal+=liquiditypool[newstuff['txin'][txid]['address']][i]
                    except:
                        pass
                try:                    
                    if len(trans['outs'])>pos and trans['outs'][pos]['script'][:2]=="6a" and checkliquidity==0:#see if they intend to transfer frozen funds
                        frozenindex=0
                        meaning=translate_script(trans['outs'][pos]['script'])
                        if meaning!={} and meaning['type']=="Notary/Burn":
                            if meaning['message'][:5]=="**F**" or meaning['message'][:5]=="**V**" or meaning['message'][:5]=="**L**":
                                inx1=''
                                if ':' in meaning['message'][5:]:
                                    inx3=meaning['message'][5:].split(':')
                                    if len(inx3)<2:
                                        float('a')
                                    inx1=int(inx3[0])
                                    inx2=int(inx3[1])
                                    if len(inx3)==2 and inx1==inx2:
                                        float('a')
                                    if inx1==pos or inx2==pos or inx1<0 or inx2<0 or inx1>len(trans['outs'])-1 or inx2>len(trans['outs'])-1:
                                        float('a')
                                    frozenindex=inx1
                                else:
                                    frozenindex=int(meaning['message'][5:])
                                if frozenindex==pos or frozenindex<0 or frozenindex>len(trans['outs'])-1:
                                    float('a')
                                if frozenindex in frozenpool:
                                    if frozenpool[frozenindex]['ftype']!=meaning['message'][:5].replace("*",""):
                                        float('a')
                                    if 'shared' in frozenpool[frozenindex]:
                                        if ':' in meaning['message'][5:] and len(inx3)==2 and sorted([inx1,inx2])==frozenpool[frozenindex]['shared']:
                                            pass
                                        else:
                                            float('a')
                                frozenpool[frozenindex]={'amount':trans['outs'][frozenindex]['value'], 'address':newstuff['txin'][txid]['address']}
                                if inx1!='' and len(inx3)==2:
                                    frozenpool[frozenindex]['shared']=[inx1,inx2]
                                    frozenpool[frozenindex]['shared'].sort()
                                if meaning['message'][:5]=="**F**":
                                    frozenpool[frozenindex]['ftype']="F"
                                if meaning['message'][:5]=="**V**":
                                    frozenpool[frozenindex]['ftype']="V"
                                sharedfreeze=False
                                if ':' in meaning['message'][5:] and len(inx3)==2:
                                    if inx2 in frozenpool:
                                        if frozenpool[inx2]['ftype']!=meaning['message'][:5].replace("*",""):
                                            float('a')
                                        if 'shared' in frozenpool[inx2]:
                                            if ':' in meaning['message'][5:] and len(inx3)==2 and sorted([inx1,inx2])==frozenpool[inx2]['shared']:
                                                pass
                                            else:
                                                float('a')
                                    frozenpool[inx2]={'amount':trans['outs'][inx2]['value'], 'address':newstuff['txin'][txid]['address']}
                                    frozenpool[inx2]['shared']=[inx1,inx2]
                                    frozenpool[inx2]['shared'].sort()
                                    if meaning['message'][:5]=="**F**":
                                        frozenpool[inx2]['ftype']="F"
                                    if meaning['message'][:5]=="**V**":
                                        frozenpool[inx2]['ftype']="V"
                                    sharedfreeze=True
                                    frozenpool['freezeall']=True
                                if ':' in meaning['message'][5:] and len(inx3)>2:
                                    if len(inx3)>50:
                                        float('a')
                                    sharedfreeze=True
                                    frozenpool['freezeall']=True
                                    for inxes in inx3:
                                        inxes=int(inxes)
                                        if inxes<0 or inxes>len(trans['outs'])-1 or inxes==pos:
                                            float('a')
                                        if inxes in frozenpool and frozenpool[inxes]['ftype']!=meaning['message'][:5].replace("*",""):
                                            float('a')
                                        if inxes in frozenpool and 'shared' in frozenpool[inxes]:
                                            float('a')
                                        frozenpool[inxes]={'amount':trans['outs'][inxes]['value'], 'address':newstuff['txin'][txid]['address'], 'split':1}
                                        if meaning['message'][:5]=="**F**":
                                            frozenpool[inxes]['ftype']="F"
                                        if meaning['message'][:5]=="**V**":
                                            frozenpool[inxes]['ftype']="V"
                                if meaning['message'][:5]=="**F**" and reservetotal<trans['outs'][frozenindex]['value']:
                                    sharedfreeze=True
                                    frozenpool['freezeall']=True
                                if meaning['message'][:5]=="**V**" and liquidtotal<trans['outs'][frozenindex]['value']:
                                    sharedfreeze=True
                                    frozenpool['freezeall']=True
                                if meaning['message'][:5]=="**L**" and liquidtotal<trans['outs'][frozenindex]['value']:
                                    self.valid="Not enough liquidity"
                                    float('a')
                                if not sharedfreeze:
                                    if pool!={} and empty!=1:
                                        if meaning['message'][:5]=="**F**":
                                            pool, frozenpool[frozenindex]['liquidity']=self.CalculateOutput(pool,supply,trans['outs'][frozenindex]['value'],'Frozen', 1, reservetotal, liquidtotal)
                                            reservetotal-=trans['outs'][frozenindex]['value']
                                        if meaning['message'][:5]=="**V**":
                                            pool, frozenpool[frozenindex]['liquidity']=self.CalculateOutput(pool,supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                            liquidtotal-=trans['outs'][frozenindex]['value']
                                        if meaning['message'][:5]=="**L**":
                                            pool, frozenpool[frozenindex]['liquidity']=self.CalculateOutput(pool,supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                            liquidtotal-=trans['outs'][frozenindex]['value']
                                    else:
                                        if meaning['message'][:5]=="**F**":
                                            reservepool[newstuff['txin'][txid]['address']], frozenpool[frozenindex]['liquidity']=self.CalculateOutput(reservepool[newstuff['txin'][txid]['address']],supply,trans['outs'][frozenindex]['value'],'Frozen', 1, reservetotal, liquidtotal)
                                            reservetotal-=trans['outs'][frozenindex]['value']
                                            txreservetotal-=trans['outs'][frozenindex]['value']
                                        if meaning['message'][:5]=="**V**":
                                            liquiditypool[newstuff['txin'][txid]['address']], frozenpool[frozenindex]['liquidity']=self.CalculateOutput(liquiditypool[newstuff['txin'][txid]['address']],supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                            liquidtotal-=trans['outs'][frozenindex]['value']
                                            txliquidtotal-=trans['outs'][frozenindex]['value']
                                        if meaning['message'][:5]=="**L**":
                                            liquiditypool[newstuff['txin'][txid]['address']], frozenpool[frozenindex]['liquidity']=self.CalculateOutput(liquiditypool[newstuff['txin'][txid]['address']],supply,trans['outs'][frozenindex]['value'],'Liquid', 1, reservetotal, liquidtotal)
                                            liquidtotal-=trans['outs'][frozenindex]['value']
                                            txliquidtotal-=trans['outs'][frozenindex]['value']
                except:
                    traceback.print_exc()
                    if self.valid=='1':
                        self.valid='Frozen burn script was not valid'
                        float('a')
                for i in pool:
                    if i=='total' or i == 'frozen':
                        continue
                    if int(i)<supply:
                        amount=pool[i]
                        txreservetotal+=amount
                        if newstuff['txin'][txid]['address'] not in reservepool:
                            reservepool[newstuff['txin'][txid]['address']]={'total':0}
                        if i not in reservepool[newstuff['txin'][txid]['address']]:
                            reservepool[newstuff['txin'][txid]['address']][i]=amount
                            reservepool[newstuff['txin'][txid]['address']]['total']+=amount
                        else:
                            reservepool[newstuff['txin'][txid]['address']][i]+=amount
                            reservepool[newstuff['txin'][txid]['address']]['total']+=amount
                    else:                        
                        amount=pool[i]
                        txliquidtotal+=amount
                        if newstuff['txin'][txid]['address'] not in liquiditypool:
                            liquiditypool[newstuff['txin'][txid]['address']]={'total':0}
                        if i not in liquiditypool[newstuff['txin'][txid]['address']]:
                            liquiditypool[newstuff['txin'][txid]['address']][i]=amount
                            liquiditypool[newstuff['txin'][txid]['address']]['total']+=amount
                        else:
                            liquiditypool[newstuff['txin'][txid]['address']][i]+=amount
                            liquiditypool[newstuff['txin'][txid]['address']]['total']+=amount
                if 'inputs' not in newstuff['txin'][txid]:
                    newstuff['txin'][usedinputs[txid]]['pool']={} #The information was moved to liquidity pool
                totalin+=newstuff['txin'][txid]['amount']
                pos+=1
                if checkliquidity==1:
                    break
            print "TIME ELAPSED 2: ", str(txtime-time.time())
            reservepool['total']=txreservetotal
            bigliquiditypool['total']=txliquidtotal
            if whitelisted==0:
                if checkliquidity==1:
                    if checkaddress not in liquiditypool:
                        liquiditypool[checkaddress]={'total':0}
                    liquiditypool['total']=txliquidtotal
                    if 'frozen' in liquiditypool:
                        liquiditypool['ftype']=newstuff['txin'][txid]['ftype']
                    return liquiditypool, reservepool
                return True            
            if checkliquidity==1:
                if 'frozen' in liquiditypool:
                    liquiditypool['ftype']=newstuff['txin'][txid]['ftype']
                liquiditypool['total']=txliquidtotal
                if checkaddress not in liquiditypool:
                    liquiditypool[checkaddress]={'total':0}
                return liquiditypool, reservepool
            stake=0
            pos=0
            totalout=0
            if 'frozen' in liquiditypool:
                bigliquiditypool['frozen']=liquiditypool['frozen']
            for acct in liquiditypool:
                if acct=='total' or acct=='frozen':
                    continue
                for i in liquiditypool[acct]:
                    if i=='total' or i == 'frozen':
                        continue
                    if i not in bigliquiditypool:
                        bigliquiditypool[i]=liquiditypool[acct][i]
                    else:
                        bigliquiditypool[i]+=liquiditypool[acct][i]
            #print 'rtotal ', str(reservepool['total'])
            #print 'ltotal', str(bigliquiditypool['total'])
            txid2=txid
            for out in trans['outs']:
                if out['value']==0:
                    if out['script']!='':
                        pos+=1
                        continue
                    if len(trans['ins'])>1:
                        self.valid='Too many inputs to the stake'
                        float('a')
                    if len(trans['outs'])>8:
                        self.valid='Too many outputs to the stake'
                        float('a')
                    stake=json_deep_copy(newstuff['txin'][txid2])
                    stake['txidin']=txid2
                    stake['txid']=tx
                    stake['outs']=trans['outs']
                    stake['ltotal']=0
                    stake['rtotal']=0
                    if 'stake' in stake:
                        stake['prevstake']=1
                    if stake['address'] in reservepool:
                        stake['liquidity']=reservepool[stake['address']].copy()
                        stake['rtotal']+=stake['liquidity']['total']
                    else:
                        stake['liquidity']={'total':0}                            
                    for i in bigliquiditypool:
                        if i=='total' or i=='frozen':
                            continue
                        if i not in stake['liquidity']:
                            stake['liquidity'][i]=bigliquiditypool[i]
                            stake['liquidity']['total']+=bigliquiditypool[i]                                
                        else:
                            stake['liquidity'][i]+=bigliquiditypool[i]
                            stake['liquidity']['total']+=bigliquiditypool[i]
                        stake['ltotal']+=bigliquiditypool[i]
                    pos+=1
                    continue
                #For burn we should designate which funds to burn however not save in database
                if address_to_script(MakeCipherOutputs('peginflate')[0]) == out['script'] or address_to_script(MakeCipherOutputs('pegdeflate')[0]) == out['script'] or address_to_script(MakeCipherOutputs('pegnochange')[0]  ) == out['script']:
                    pass
                address=out['script']
                if address[:2]=="6a":
                    pass
                else:
                    try:
                        address=script_to_address2(address,85)
                    except:
                        pass
                txid=tx+":"+str(pos)
                newstuff['txout'][txid]={'address':address, 'amount':out['value'], 'index':pos}
                if stake!=0:
                    newstuff['txout'][txid]['stake']=1
                    if 'found' not in stake:
                        if stake['amount']>out['value']:
                            self.valid='Stakes must always return original funds to the staking address'
                            float('a')
                        if stake['address']!=address:
                            self.valid='Stakes must return to the staking address'
                            float('a')
                        if 'frozen' in stake:
                            newstuff['txout'][txid]['frozen']=stake['frozen']
                            newstuff['txout'][txid]['ftype']=stake['ftype']                                
                        stake['found']=1
                    else:
                        totalout+=out['value']
                        pos+=1
                        continue #Calculate the remaining inputs after we know fees, there is no voluntary freeze on stakes
                if pos in frozenpool and 'ftype' in frozenpool[pos]:
                    newstuff['txout'][txid]['frozen']=1
                    newstuff['txout'][txid]['ftype']=frozenpool[pos]['ftype']
                #print "TIME ELAPSED L: ", str(txtime-time.time())
                #print str(totalin)+"\n\n"+ str(newstuff['txout'][txid])+"\n\n"+str(frozenpool)+"\n\n"+str(reservepool)+"\n\n"+str(bigliquiditypool) +"\n\n"+str(stake)
                newstuff['txout'][txid]['pool'], frozenpool, reservepool, bigliquiditypool=self.CalculateLiquid(totalin, newstuff['txout'][txid], frozenpool, reservepool, bigliquiditypool, trans['locktime'], supply, stake)
                #print "TIME ELAPSED L1: ", str(txtime-time.time())
                #newstuff['txout'][txid]['block']=block['height']
                totalout+=out['value']
                pos+=1
            if stake!=0:#First we save the stake input, then we calculate after all tx fees collected. We must commit fees and outputs back as well.
                staketx=stake
                #print 'We staked this'
            else:
                pass
                #print 'Someone staked us!'
            fees=0
            #We should allow fee payment in both liquid and reserve to accomodate all kinds of transactions
            for act in reservepool:
                if act == 'total' or act=='frozen':
                    continue
                for i in reservepool[act]:
                    if i == 'total' or i=='frozen':
                        continue
                    fees+=reservepool[act][i]
                    if i not in txfees:
                        txfees[i]=reservepool[act][i]
                        txfees['total']+=reservepool[act][i]
                    else:
                        txfees[i]+=reservepool[act][i]
                        txfees['total']+=reservepool[act][i]
            for i in bigliquiditypool:
                if i == 'total' or i=='frozen':
                    continue
                fees+=bigliquiditypool[i]
                if i not in txfees:
                    txfees[i]=bigliquiditypool[i]
                    txfees['total']+=bigliquiditypool[i]
                else:
                    txfees[i]+=bigliquiditypool[i]
                    txfees['total']+=bigliquiditypool[i]                
            #Transactions are more expensive due to liquidity calculations
            if stake==0:
                if fees<(len(trans['outs'])*self.pegfeeperinput)+(len(trans['ins'])*self.pegfeeperinput):
                    self.valid="Fees are below the " + str(self.pegfeeperinput) + " satoshis per input/output minimum."
                    float('a')
            #print "Fees total: ", str(txfees['total'])
            #We could add some extra fee calculations here
            #print "TIME ELAPSED 4: ", str(txtime-time.time())
            res=True
            #print "TIME ELAPSED 5: ", str(txtime-time.time())
            if returnliquid==1:
                return res, newstuff, txfees
            return res
        except:
            myexc=str(traceback.format_exc())
            if self.valid=='1':
                self.valid='Block not valid: ' + myexc
            print self.valid
        return False    
    def formatfractions(self,fractions,address,value,supply=0):
        if supply==0:
            supply=self.CurrentSupply(self.Pegdatabase['blockcount'])
        liquid={}
        reserve={}
        if len(fractions)==0:
            liquid={'total':0,address:{'total':0}}
            reserve={'total':0,address:{'total':0}}
            stepindex=0
            for s in self.steps:
                if stepindex==len(self.steps)-1:
                    amount=value
                else:
                    amount=value/self.rate
                value-=amount
                if amount!=0:
                    if self.Pegdatabase['supply']>stepindex:
                        reserve[address][str(stepindex)]=amount
                        reserve['total']+=amount
                        reserve[address]['total']+=amount
                    else:
                        liquid[address][str(stepindex)]=amount
                        liquid['total']+=amount
                        liquid[address]['total']+=amount
                stepindex+=1
            return liquid, reserve
        #Address index has total and fractions
        ltot=0
        rtot=0
        stepindex=0
        for val in fractions['values']:
            if self.Pegdatabase['supply']>stepindex:
                rtot+=val
            else:
                ltot+=val
            stepindex+=1
        liquid['total']=ltot
        reserve['total']=rtot
        liquid[address]={'total':ltot}
        reserve[address]={'total':rtot}        
        #if fractions['flags']!='':
        #    liquid['ftype']=fractions['flags']
        #    reserve['ftype']=fractions['flags']
        if fractions['lock']!=0:
            liquid['frozen']=fractions['lock']            
            reserve['frozen']=fractions['lock']
        inx=0
        for val in fractions['values']:
            if inx < self.Pegdatabase['supply']:
                if val!=0:
                    reserve[address][str(inx)]=val
            else:
                if val!=0:
                    liquid[address][str(inx)]=val
            inx+=1
        return liquid, reserve
    def checkliquidity(self, liquid, reserve='', update=0, supply=0):
        #NOTE15
        try:
            if supply==0:
                supply=self.CurrentSupply(self.Pegdatabase['blockcount'])
            if reserve!='':#Combine
                for a in liquid:#Find address key
                    if len(a)<20:
                        continue
                    break
                liquid2=json_deep_copy(liquid)
                liquid2['rtotal']=reserve['total']
                liquid2['ltotal']=liquid2['total']
                if len(a)<20:
                    return liquid2
                if a in reserve:
                    for r in reserve[a]:
                        if r=='total':
                            continue
                        if r in liquid2[a]:
                            liquid2[a][r]+=reserve[a][r]
                        else:
                            liquid2[a][r]=reserve[a][r]
                        liquid2[a]['total']+=reserve[a][r]
                        if 'total' in liquid2:
                            liquid2['total']+=reserve[a][r]
                #Rate the quality of the liquidity
                period=self.rateliquidity(liquid2[a], supply)
                liquid2['future'], liquid2['nfreeze']=self.FutureFreeze(liquid2[a], self.contractbuffer, supply, 1)
                liquid['rating']=period
                liquid2['rating']=period                
                liquid['future']=liquid2['future']
                liquid['nfreeze']=liquid2['nfreeze']
                liquid['supply']=supply#It's best to know what it was when checked
                liquid2['supply']=supply
                return liquid2
            else:                
                for a in liquid:
                    if len(a)<20:
                        continue
                    break
                liquid2=json_deep_copy(liquid)
                if len(a)<20:
                    return liquid2
                reserve={a:{'total':0},'total':0}
                for l in liquid2[a]:
                    if l=='total':
                        continue
                    if int(l) < int(supply):
                        reserve[a][l]=liquid2[a][l]
                        reserve[a]['total']+=liquid2[a][l]
                        reserve['total']+=liquid2[a][l]
                        if 'total' in liquid2:
                            liquid2['total']-=liquid2[a][l]
                        liquid2[a]['total']-=liquid2[a][l]
                        liquid2[a][l]=0
                pos=0
                for x in self.steps:
                    ps=str(pos)
                    if ps in liquid2[a]:
                        if liquid2[a][ps]==0:
                            liquid2[a].pop(ps)
                    pos+=1
                #Rate the quality of the liquidity
                period=self.rateliquidity(liquid2[a], supply)
                liquid2['future'], liquid2['nfreeze']=self.FutureFreeze(liquid2[a], self.contractbuffer, supply, 1)
                liquid['rating']=period
                liquid2['rating']=period                
                liquid['future']=liquid2['future']
                liquid['nfreeze']=liquid2['nfreeze']
                liquid['supply']=supply#It's best to know what it was when checked
                liquid2['supply']=supply
                if update==1:
                    liquid['rtotal']=reserve['total']
                    liquid['ltotal']=liquid2['total']                    
                    return liquid
                return liquid2, reserve
        except:
            traceback.print_exc()
            return False
    def rateliquidity(self, liquid, supply=0):
        #NOTE16
        a='a'
        liquid2={'a':liquid}
        if supply==0:
            supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
        highkey=0
        total=0
        for i in liquid2[a]:
            if i=='total':
                continue
            if int(i)<supply:
                continue
            total+=liquid2[a][str(i)]
            if highkey<int(i):
                highkey=int(i)
        liquid2['ltotal']=total

        average=0
        l=supply
        periods=[]
        multiplier=1
        while l <= highkey:
            if int(l)<supply:
                l+=1
                continue
            if str(l) not in liquid2[a]:
                l+=1
                continue
            if l==self.amountofsteps+1:
                break
            d=(float(l-supply+1)/float(ThePeg.amountofsteps-supply+1))
            d=float(ThePeg.amountofsteps)-l
            e=(float(liquid2[a][str(l)])/float(liquid2['ltotal']))
            average+=e
            loopit=True
            while loopit:
                if multiplier>20:#This should not happen anyways but just in case
                    break
                loopit=False
                if average>.1*multiplier and len(periods)==(multiplier-1)*2:
                    loopit=True
                    periods.append(l-supply)
                    periods.append(average)
                    multiplier+=1
            l+=1
        x=1
        avg=0
        if periods==[]:
            periods=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        while x<=17:
            try:
                avg+=(periods[x]*periods[x-1])
                x+=2
            except:
                traceback.print_exc()
        goodscore=543
        avg=int(avg)
        periods.insert(0,avg)
        return periods
    def FutureFreeze(self,liquid, steps=3, supply=0, nfreeze=0):
        #NOTE17
        if supply==0:
            supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
        freezeamount=0
        nextfreeze=0
        for l in liquid:
            if l=='total':
                continue
            if int(l)==ThePeg.amountofsteps-1:
                continue
            if int(l)>=int(supply) and int(l)<int(supply+steps):
                freezeamount+=liquid[l]
            if int(l)>=int(supply) and int(l)<int(supply+3):#Changes vary from 1-3%
                nextfreeze+=liquid[l]
        if nfreeze==0:
            return freezeamount
        else:
            return freezeamount, nextfreeze
    def filterkeys(self, liq):
        spn={}
        if 'frozen' in liq:
            spn['frozen']=liq['frozen']
        if 'total' in liq:
            spn['total']=liq['total']
        if 'ltotal' in liq:
            spn['ltotal']=liq['ltotal']
        if 'rtotal' in liq:
            spn['rtotal']=liq['rtotal']
        if 'rating' in liq:
            spn['rating']=liq['rating']
        if 'future' in liq:
            spn['future']=liq['future']
        if 'nfreeze' in liq:
            spn['nfreeze']=liq['nfreeze']
        if 'supply' in liq:
            spn['supply']=liq['supply']
        return spn
    def votealgorithm(self, algo=''):
        #NOTE18        
        try:
            #No change: bNyZrPeFFNP6GFJZCkE82DDN7JC4K5Vrkk, Deflate: bNyZrP2SbrV6v5HqeBoXZXZDE2e4fe6STo Inflate: bNyZrPLQAMPvYedrVLDcBSd8fbLdNgnRPz
            if self.votealgo!='':
                exec(validateCode(self.votealgo))
            else:
                if algo=='':
                    text='pegnochange'
                    if githubrates!={}:
                        if githubrates['BAY']['pegvote']=='deflate':
                            text='pegdeflate'
                        if githubrates['BAY']['pegvote']=='inflate':
                            text='peginflate'
                        peak=Decimal(githubrates['BAY']['floor'])
                    if False:
                        usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap, 0)
                        if usd!='':
                            #Even though we can track it based on the floor, github node already does this. It's easier to change algo without fork this way
                            try:
                                peak=Decimal(AdvanceArray['btchistory']['peak'])/Decimal('100000')
                                if Decimal(usd)*Decimal(1.05)<peak:
                                    text='pegdeflate'
                                if Decimal(usd)*Decimal(0.95)>peak:
                                    if Decimal(usd)*Decimal(0.35)>peak:#Perhaps we can set a new floor
                                        #It's probably a good idea to have electrum style nodes track this data for new users
                                        #the price history otherwise would be totally relative to when a node is active
                                        newparadigm=1
                                        for rate in AdvanceArray['charts'][CoinSelect['name']]:
                                            if Decimal(rate['price'])*Decimal(0.35)>peak:
                                                pass
                                            else:
                                                newparadigm=0
                                        if newparadigm==1:
                                            AdvanceArray['btchistory']['peak']=str(Decimal(AdvanceArray['btchistory']['peak'])*Decimal(1.5))
                                    text='peginflate'
                            except:
                                pass
                        else:
                            print "Didn't find USD rate"
                            return False
                if algo=='random':
                    #myrand=str(int((Decimal("."+str(int(os.urandom(24).encode('hex'),16)))*Decimal(3)))+1)
                    myrand=str(random.randint(1,4))
                    text='pegnochange'
                    if myrand=='1':
                        text='pegnochange'
                    if myrand=='2':
                        text='pegdeflate'
                    if myrand=='3':
                        text='peginflate'
                out=MakeCipherOutputs(text)
                out=str(out[0])
                return out
        except:
            traceback.print_exc()
            return False
    def scanforchange(self, blockcount=0):
        try:
            if blockcount==0:
                blockcount=BLK.getblockcount()
            blockrange=self.getBlockRange(blockcount)
            votecycle=(blockcount - self.Pegdatabase['startingblock']) / self.interval
            while self.Pegdatabase['votecycle']+2<votecycle:
                blockrange=self.Pegdatabase['startingblock']+(self.interval*self.Pegdatabase['votecycle'])
                if max(self.Pegdatabase['votedata'][str(blockrange)])!=0:
                    i=self.Pegdatabase['votedata'][str(blockrange)].index(max(self.Pegdatabase['votedata'][str(blockrange)]))
                    t=1
                    x=0
                    y=0
                    if i==0:
                        x=1
                        y=2
                    if i==1:
                        x=0
                        y=2
                    if i==2:
                        x=0
                        y=1
                    if self.Pegdatabase['votedata'][str(blockrange)][i]>self.Pegdatabase['votedata'][str(blockrange)][x]*2 and self.Pegdatabase['votedata'][str(blockrange)][i]>self.Pegdatabase['votedata'][str(blockrange)][y]*2:
                        t=2
                    if self.Pegdatabase['votedata'][str(blockrange)][i]>self.Pegdatabase['votedata'][str(blockrange)][x]*3 and self.Pegdatabase['votedata'][str(blockrange)][i]>self.Pegdatabase['votedata'][str(blockrange)][y]*3:
                        t=3
                    if i==0:
                        try:
                            self.Pegdatabase['votedata'][str(blockrange)+'S']=self.NextStep(self.Pegdatabase['votedata'][str(blockrange-self.interval)+'S'], 'inflate')
                            if t>1:
                                self.Pegdatabase['votedata'][str(blockrange)+'S']=self.NextStep(self.Pegdatabase['votedata'][str(blockrange)+'S'], 'inflate')
                                t-=1
                            if t>1:
                                self.Pegdatabase['votedata'][str(blockrange)+'S']=self.NextStep(self.Pegdatabase['votedata'][str(blockrange)+'S'], 'inflate')
                                t-=1
                        except:
                            traceback.print_exc()
                            self.Pegdatabase['votedata'][str(blockrange)+'S']=0
                    if i==1:
                        try:
                            self.Pegdatabase['votedata'][str(blockrange)+'S']=self.NextStep(self.Pegdatabase['votedata'][str(blockrange-self.interval)+'S'], 'deflate')
                            if t>1:
                                self.Pegdatabase['votedata'][str(blockrange)+'S']=self.NextStep(self.Pegdatabase['votedata'][str(blockrange)+'S'], 'deflate')
                                t-=1
                            if t>1:
                                self.Pegdatabase['votedata'][str(blockrange)+'S']=self.NextStep(self.Pegdatabase['votedata'][str(blockrange)+'S'], 'deflate')
                                t-=1
                        except:
                            traceback.print_exc()
                            self.Pegdatabase['votedata'][str(blockrange)+'S']=1
                    if i==2:
                        try:
                            self.Pegdatabase['votedata'][str(blockrange)+'S']=self.Pegdatabase['votedata'][str(blockrange-self.interval)+'S']
                        except:
                            traceback.print_exc()
                            self.Pegdatabase['votedata'][str(blockrange)+'S']=0
                else:
                    try:
                        self.Pegdatabase['votedata'][str(blockrange)+'S']=self.Pegdatabase['votedata'][str(blockrange-self.interval)+'S']
                    except:
                        traceback.print_exc()
                        self.Pegdatabase['votedata'][str(blockrange)+'S']=0
                self.Pegdatabase['votecycle']+=1
            self.Pegdatabase['supply']=self.CurrentSupply(blockcount)
        except:
            traceback.print_exc()
            return False
    def CurrentSupply(self, blockcount, votecycle=0):
        global TestnetPeg
        if TestnetPeg==False:
            return self.Pegdatabase['supply']
        blockrange=self.getBlockRange(blockcount)
        x=0
        if votecycle>0:
            x=self.Pegdatabase['votecycle']-votecycle
        supply=0
        if str(blockrange-(self.interval*3)-(self.interval*x))+'S' in self.Pegdatabase['votedata']:
            supply=self.Pegdatabase['votedata'][str(blockrange-self.interval*(3+x))+'S']
        return supply
    def NextStep(self, current, direction, showindex=0):
        if showindex==1:
            i=self.steps.index(current)
        if direction=='inflate':
            if current==0:
                return current
            else:
                return current-1
        if direction=='deflate':
            if current==len(self.steps)-1:
                return current
            else:
                return current+1
    def getBlockRange(self, blockcount):
        return (((blockcount - self.Pegdatabase['startingblock']) / self.interval) * self.interval) + self.Pegdatabase['startingblock']
    def LoadExchange(self):
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase'
            fd="/"
        if not os.path.exists(pegdir+fd+'exchange'):
            os.mkdir(pegdir+fd+'exchange')
        if not os.path.exists(pegdir+fd+'exchange'+fd+'queue'):
            os.mkdir(pegdir+fd+'exchange'+fd+'queue')
        if not os.path.exists(pegdir+fd+'exchange'+fd+'queue2'):
            os.mkdir(pegdir+fd+'exchange'+fd+'queue2')
        res=self.CleanWrite(2)
        if res==False:
            return False
        #Exchange data
        with open(os.path.join(pegdir+fd+'exchange'+fd,"exchange.dat"),'a+') as f:
            f.close()
        l=['1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
        if os.stat(os.path.join(pegdir+fd+'exchange'+fd,"exchange.dat"))[6]==0:
            with open(os.path.join(pegdir+fd+'exchange'+fd,"exchange.dat"),'wb') as f:
                f.write(bsonjs.loads(ujson.dumps(self.exchange)))
                f.flush()
                os.fsync(f)
                f.close()
            for i in l:
                try:
                    os.mkdir(pegdir+fd+'exchange'+fd+i)
                except:
                    traceback.print_exc()
            for x in l:
                for y in l:
                    try:
                        os.mkdir(pegdir+fd+'exchange'+fd+x+fd+y)
                    except:
                        traceback.print_exc()
        with open(os.path.join(pegdir+fd+'exchange'+fd,"exchange.dat"),'rb') as f:
            self.exchange=ujson.loads(bsonjs.dumps(f.read()))
            f.close()
        #This exchange code is meant to support only a few hundred thousand accounts. To scale bigger another strategy must
        #be used. Most likely to store more on disk and work with a fast c++ implementation of this code.
        self.accounts={}
        if 'balances' not in self.accounts:
            self.accounts['balances']={}
        for x in l:
            for y in l:
                pth=pegdir+fd+'exchange'+fd+x+fd+y
                lst=os.listdir(pth)
                for l1 in lst:
                    with open(os.path.join(pth,l1),'rb') as f:
                        data=ujson.loads(bsonjs.dumps(f.read()))['data']
                        f.close()
                    for acct in data:
                        if acct=='total' or acct=='frozen':
                            continue
                        for i in data[acct]['liquidity']:
                            if i=='total' or i=='frozen':
                                continue
                            if i not in self.accounts['balances']:#The total is the input balances, not user balances
                                self.accounts['balances'][i]={'total':0}
                            if acct not in self.accounts['balances'][i]:#These are the user balances of trades
                                self.accounts['balances'][i][acct]=data[acct]['liquidity'][i]
        #Txids
        with open(os.path.join(pegdir+fd+'exchange'+fd,"txids.dat"),'a+') as f:
            f.close()
        if os.stat(os.path.join(pegdir+fd+'exchange'+fd,"txids.dat"))[6]==0:
            with open(os.path.join(pegdir+fd+'exchange'+fd,"txids.dat"),'wb') as f:
                f.write(bsonjs.loads(ujson.dumps({'data':{},'filehash':''})))
                f.flush()
                os.fsync(f)
                f.close()
        with open(os.path.join(pegdir+fd+'exchange'+fd,"txids.dat"),'rb') as f:
            self.accounts['txids']=ujson.loads(bsonjs.dumps(f.read()))['data']
            f.close()
        
        if 'users' not in self.accounts:
            self.accounts['users']={}
            self.accounts['users']['pool']={'liquid':0,'reserve':0}
        if 'withdraws' not in self.exchange:
            self.exchange['withdraws']={'liquid':[],'reserve':[],'raw':[],'spent':{}}
        if 'history' not in self.exchange['withdraws']:
            self.exchange['withdraws']['history']={}
        if 'addresses' not in self.exchange:
            self.exchange['addresses']={}
        #It's recommended that exchanges have one account for all users so reserve can be combined
        #Otherwise this system might need special accounts just for reserve and cold storage
        if 'exchangeaccounts' not in self.exchange:
            self.exchange['exchangeaccounts']=[]
        #This is an account for fees during the processing of withdraws. Trading fees should be
        #deducted manually as if it was an actual trade to a standard exchange account.
        if 'exchangefeeaccount' not in self.exchange:
            self.exchange['exchangefeeaccount']=''
        #Commission for withdraw. Should be at least over 10000 to cover staking fees
        if 'commission' not in self.exchange:
            self.exchange['commission']={'min':100000000,'max':1000000000,'percent':.001}
        if 'withdrawtime' not in self.exchange:
            self.exchange['withdrawtime']=0
        return res
    def SaveExchange(self,element='',hsh='',data='',pth=''):
        if hsh=='':
            hsh=os.urandom(16).encode('hex')
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase'
            fd="/"
        if not os.path.exists(pegdir+fd+'exchange'):
            os.mkdir(pegdir+fd+'exchange')
        if pth!='':
            with open(pth,'wb') as f:
                f.write(bsonjs.loads(ujson.dumps(data)))
                f.flush()
                os.fsync(f)
                f.close()
        if element=='' or element=='exchange':
            self.exchange['filehash']=hsh
            with open(os.path.join(pegdir+fd+'exchange'+fd,"exchange.dat"),'wb') as f:
                f.write(bsonjs.loads(ujson.dumps(self.exchange)))
                f.flush()
                os.fsync(f)
                f.close()
        if element=='' or element=='txids':
            with open(os.path.join(pegdir+fd+'exchange'+fd,"txids.dat"),'wb') as f:
                f.write(bsonjs.loads(ujson.dumps({'data':self.accounts['txids'],'filehash':hsh})))
                f.flush()
                os.fsync(f)
                f.close()
    def ExchangeQueue(self, qselect=0):
        global CoinSelect
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase\\exchange'
            qdir='\\queue'
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase/exchange'
            qdir='/queue'
            fd="/"
        lst=os.listdir(pegdir+qdir)
        nonces=[]
        for i in lst:
            nonces.append(int(i))
        nonces.sort()
        if self.queuenonce==0:
            if nonces==[]:
                self.queuenonce=1
            else:
                self.queuecount2=len(nonces)
                self.queuenonce=nonces[-1]
        lst=os.listdir(pegdir+qdir+'2')
        nonces2=[]
        for i in lst:
            nonces2.append(int(i))
        nonces2.sort()
        if self.queuenonce2==0:
            if nonces2==[]:
                self.queuenonce2=1
            else:
                self.queuecount4=len(nonces2)
                self.queuenonce2=nonces2[-1]
        if self.clearID!={}:
            for ID in self.clearID:
                self.exchange['withdraws']['history'].pop(ID)
        time.sleep(.1)
        try:
            self.CleanWrite()
            if qselect==0 or qselect==2:
                for x in nonces:
                    print "New item"
                    with open(os.path.join(pegdir+qdir+fd,str(x)),'rb') as f:
                        q=ujson.loads(bsonjs.dumps(f.read()))['1']
                        f.close()
                    self.globq=q
                    inx=0
                    hsh=''
                    for q1 in q:
                        if inx==0:
                            hsh=q1
                            inx+=1
                            continue
                        if q1['command']=='NewAddress':
                            busy=NetSplash(1, checkwait=1, nogui=1, ld2=1)
                            address=''
                            try:
                                if busy!=0:
                                    float('a')
                                res=BLK.importprivkey(q1['data']['key'],'',False)
                                address=privkey_to_address(q1['data']['key'],25)
                                print "New key generated"
                                busy=NetSplash(0, ld2=1)
                            except:
                                traceback.print_exc()
                                try:                                    
                                    res=BLK.dumpprivkey(res)
                                    address=privkey_to_address(q1['data']['key'],25)
                                    print "New key generated"
                                except:
                                    busy=NetSplash(0, ld2=1)
                                busy=NetSplash(0, ld2=1)
                            if address!='':
                                if self.CheckFileHash(os.path.join(pegdir+fd,"exchange.dat"),hsh):
                                    self.exchange['addresses'][address]=1
                                    self.SaveExchange('exchange',hsh)
                        if q1['command']=='Deposit':                            
                            if self.CheckFileHash(os.path.join(pegdir+fd,"txids.dat"),hsh):
                                print "Deposit to account."
                                self.DepositToAccount(q1['data']['name'],q1['data']['txids'])
                                self.SaveExchange('txids',hsh)
                        if q1['command']=='Trade':
                            pth=os.path.join(pegdir+fd+str(q1['data']['user1'][:1].lower())+fd+str(q1['data']['user1'][:2][1:].lower()+fd),str(q1['data']['user1'][-3:].lower()))
                            res, data=self.CheckFileHash(pth,hsh,1,'name')
                            if res:
                                print "Trade part 1"
                                deduction=self.Trade(q1['data']['user1'], q1['data']['amount'], q1['data']['user2'], q1['data']['style'],q1['data']['cycle'], showdeduction=1)
                                if not isinstance(deduction, dict):
                                    print str(deduction)
                                    float('a')
                                for i in deduction:
                                    if i=='frozen' or i=='total':
                                        continue                                    
                                    data['data'][q1['data']['user1']]['liquidity'][str(i)]-=deduction[str(i)]
                                data['filehash']=hsh
                                data['lastdeduction']=deduction
                                self.SaveExchange('name',hsh,data,pth)
                            else:
                                deduction=data['lastdeduction']
                            pth=os.path.join(pegdir+fd+str(q1['data']['user2'][:1].lower())+fd+str(q1['data']['user2'][:2][1:].lower()+fd),str(q1['data']['user2'][-3:].lower()))
                            res, data=self.CheckFileHash(pth,hsh,1,'name')
                            if res:
                                print "Trade part 2"
                                if q1['data']['user2'] not in data['data']:
                                    data['data'][q1['data']['user2']]={'liquidity':{}}
                                for i in deduction:
                                    if i=='frozen' or i=='total':
                                        continue
                                    if str(i) not in data['data'][q1['data']['user2']]['liquidity']:
                                        data['data'][q1['data']['user2']]['liquidity'][str(i)]=deduction[str(i)]
                                    else:
                                        data['data'][q1['data']['user2']]['liquidity'][str(i)]+=deduction[str(i)]
                                data['filehash']=hsh
                                self.SaveExchange('name',hsh,data,pth)
                            if q1['data']['withdraw']!='':                                
                                if self.CheckFileHash(os.path.join(pegdir+fd,"exchange.dat"),hsh):
                                    print "Trade part 3"
                                    self.exchange['withdraws'][q1['data']['style']].append({'ID':q1['data']['ID'],'amount':q1['data']['amount'],'cycle':q1['data']['cycle'],'address':q1['data']['withdraw'],'user':q1['data']['user1']})
                                    if q1['data']['style']=='liquid':
                                        if q1['data']['ID'] in self.liquidwithdrawcount:
                                            self.liquidwithdrawcount.pop(q1['data']['ID'])
                                    if q1['data']['style']=='reserve':
                                        if q1['data']['ID'] in self.reservewithdrawcount:
                                            self.reservewithdrawcount.pop(q1['data']['ID'])
                                    self.SaveExchange('exchange',hsh)
                        inx+=1
                    try:#Python runs Halo twice because the interpreter, so this is the best way to do a clean exit on Halo
                        os.remove(os.path.join(pegdir+qdir+fd,str(x)))
                    except:
                        traceback.print_exc()
                    self.queuecount+=1
            if qselect==0 or qselect==1:
                for x in nonces2:
                    print "New item"
                    with open(os.path.join(pegdir+qdir+'2'+fd,str(x)),'rb') as f:
                        q=ujson.loads(bsonjs.dumps(f.read()))['1']
                        f.close()
                    self.globq=q
                    inx=0
                    hsh=''
                    for q1 in q:
                        if inx==0:
                            hsh=q1
                            inx+=1
                            continue
                        if q1['command']=='Import':                            
                            res, data=self.CheckFileHash(os.path.join(pegdir+fd,"txids.dat"),hsh,1)
                            if res:
                                print "Importing funds"
                                self.accounts['txids'][q1['data']['txid']]['registered']=1
                                self.SaveExchange('txids',hsh)
                            pth=os.path.join(pegdir+fd+str(q1['data']['name'][:1].lower())+fd+str(q1['data']['name'][:2][1:].lower()+fd),str(q1['data']['name'][-3:].lower()))
                            res, data=self.CheckFileHash(pth,hsh,1,'name')
                            if res:
                                print "Exchange data"
                                if q1['data']['name'] not in data['data']:
                                    data['data'][q1['data']['name']]={'liquidity':{}}
                                for i in q1['data']['liquidity']:
                                    if i=='frozen' or i=='total':
                                        continue
                                    if str(i) not in data['data'][q1['data']['name']]['liquidity']:
                                        data['data'][q1['data']['name']]['liquidity'][str(i)]=q1['data']['liquidity'][str(i)]
                                    else:
                                        data['data'][q1['data']['name']]['liquidity'][str(i)]+=q1['data']['liquidity'][str(i)]
                                data['filehash']=hsh
                                self.SaveExchange('name',hsh,data,pth)
                        if q1['command']=='Declined' or q1['command']=='Expired' or q1['command']=='Clear':
                            if q1['command']=='Declined' or q1['command']=='Expired':
                                print "Expired/Declined withdraw"
                                u1='withdraws'
                                style='liquid'
                                for w in self.exchange['withdraws']['liquid']:
                                    if w['ID']==q1['data']['ID']:
                                        u2=w['user']
                                        amount=w['amount']
                                        cycle=w['cycle']
                                for w in self.exchange['withdraws']['reserve']:                                    
                                    if w['ID']==q1['data']['ID']:
                                        style='reserve'
                                        u2=w['user']
                                        amount=w['amount']
                                        cycle=w['cycle']
                            if q1['command']=='Clear':
                                u1='withdraws'
                                u2='x'
                            pth=os.path.join(pegdir+fd+str(u1[:1].lower())+fd+str(u1[:2][1:].lower()+fd),str(u1[-3:].lower()))
                            res, data=self.CheckFileHash(pth,hsh,1,'name')
                            if res:
                                if q1['command']=='Clear':
                                    print "Clearing withdraw"
                                    deduction={}
                                    for w in self.exchange['withdraws']['liquid']:
                                        d1=''
                                        cycle=w['cycle']
                                        style='liquid'
                                        amount=w['amount']
                                        if 'processing' in w and w['processing']==q1['data']['txid']:
                                            d1=self.Trade(u1, amount, u2, style, cycle, showdeduction=1)
                                            if not isinstance(d1, dict):
                                                print str(d1)
                                                float('a')
                                        if d1!='':
                                            for d in d1:
                                                if d not in deduction:
                                                    deduction[d]=d1[d]
                                                else:
                                                    deduction[d]+=d1[d]
                                    for w in self.exchange['withdraws']['reserve']:
                                        d1=''
                                        cycle=w['cycle']
                                        style='reserve'
                                        amount=w['amount']
                                        if 'processing' in w and w['processing']==q1['data']['txid']:
                                            d1=self.Trade(u1, amount, u2, style, cycle, showdeduction=1)
                                            if not isinstance(d1, dict):
                                                print str(d1)
                                                float('a')
                                        if d1!='':
                                            for d in d1:
                                                if d not in deduction:
                                                    deduction[d]=d1[d]
                                                else:
                                                    deduction[d]+=d1[d]
                                else:
                                    print "Clearing funds"
                                    deduction=self.Trade(u1, amount, u2, style, cycle, showdeduction=1)
                                    if not isinstance(deduction, dict):
                                        print str(deduction)
                                        float('a')
                                for i in deduction:
                                    if i=='frozen' or i=='total':
                                        continue
                                    data['data'][u1]['liquidity'][str(i)]-=deduction[str(i)]
                                data['filehash']=hsh
                                data['lastdeduction']=deduction
                                self.SaveExchange('name',hsh,data,pth)
                            else:
                                deduction=data['lastdeduction']
                            if u2!='x':
                                pth=os.path.join(pegdir+fd+str(u2[:1].lower())+fd+str(u2[:2][1:].lower()+fd),str(u2[-3:].lower()))
                                res, data=self.CheckFileHash(pth,hsh,1,'name')
                                if res:
                                    if u2 not in data['data']:
                                        data['data'][u2]={'liquidity':{}}
                                    for i in deduction:
                                        if i=='frozen' or i=='total':
                                            continue
                                        if str(i) not in data['data'][u2]['liquidity']:
                                            data['data'][u2]['liquidity'][str(i)]=deduction[str(i)]
                                        else:
                                            data['data'][u2]['liquidity'][str(i)]+=deduction[str(i)]
                                    data['filehash']=hsh
                                    self.SaveExchange('name',hsh,data,pth)
                            if self.CheckFileHash(os.path.join(pegdir+fd,"exchange.dat"),hsh):
                                print "Updating exchange database"
                                if q1['command']=='Declined' or q1['command']=='Expired':
                                    pos=0
                                    found=0
                                    txid=''
                                    ins=[]
                                    for w in self.exchange['withdraws']['liquid']:
                                        if q1['data']['ID']==w['ID']:
                                            if 'processing' in w:
                                                txid=w['processing']
                                            found=1
                                            break
                                        pos+=1
                                    if found==1:
                                        self.exchange['withdraws']['liquid'].pop(pos)
                                    pos=0
                                    found=0
                                    for w in self.exchange['withdraws']['reserve']:
                                        if q1['data']['ID']==w['ID']:
                                            if 'processing' in w:
                                                txid=w['processing']
                                            found=1
                                            break
                                        pos+=1
                                    if found==1:                                        
                                        self.exchange['withdraws']['reserve'].pop(pos)
                                    if txid!='':
                                        pos=0
                                        found=0
                                        for raw in self.exchange['withdraws']['raw']:
                                            if raw['txid']==txid:
                                                found=1
                                                if 'ins' in raw:
                                                    ins=raw['ins']
                                                break
                                            pos+=1
                                        for i in ins:
                                            if i in self.exchange['withdraws']['spent']:
                                                self.exchange['withdraws']['spent'].pop(i)
                                        if found==1:
                                            self.exchange['withdraws']['raw'].pop(pos)
                                if q1['command']=='Clear':
                                    ins=[]
                                    pos=0                                    
                                    l=len(self.exchange['withdraws']['liquid'])
                                    while pos<l:
                                        found=0
                                        if 'processing' in self.exchange['withdraws']['liquid'][pos] and self.exchange['withdraws']['liquid'][pos]['processing']==q1['data']['txid']:
                                            self.exchange['withdraws']['liquid'].pop(pos)
                                            found=1                                       
                                            l-=1
                                        if found==0:
                                            pos+=1
                                    pos=0                                    
                                    l=len(self.exchange['withdraws']['reserve'])
                                    while pos<l:
                                        found=0
                                        if 'processing' in self.exchange['withdraws']['reserve'][pos] and self.exchange['withdraws']['reserve'][pos]['processing']==q1['data']['txid']:
                                            self.exchange['withdraws']['reserve'].pop(pos)
                                            found=1                                       
                                            l-=1
                                        if found==0:
                                            pos+=1
                                    pos=0
                                    found=0
                                    for raw in self.exchange['withdraws']['raw']:
                                        if raw['txid']==q1['data']['txid']:
                                            found=1
                                            if 'ins' in raw:
                                                ins=raw['ins']
                                            break
                                        pos+=1
                                    for i in ins:
                                        if i in self.exchange['withdraws']['spent']:
                                            self.exchange['withdraws']['spent'].pop(i)
                                    if found==1:
                                        self.exchange['withdraws']['raw'].pop(pos)
                                self.SaveExchange('exchange',hsh)
                        inx+=1
                    try:#Python runs Halo twice because the interpreter, so this is the best way to do a clean exit on Halo
                        os.remove(os.path.join(pegdir+qdir+'2'+fd,str(x)))
                    except:
                        traceback.print_exc()
                    self.queuecount3+=1
            self.CleanWrite(1)
        except:
            traceback.print_exc()
            return False
        if qselect==1 and nonces2==[]:
            return False
        if qselect==2 and nonces==[]:
            return False
        return True
    def AddToQueue(self, command, q=0):
        if q==0:
            qdir=''
            if self.queuecount2-self.queuecount>3000:
                return "Server is busy"
        else:
            qdir='2'
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase\\exchange\\queue'+qdir
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase/exchange/queue'+qdir
            fd="/"
        if q==0:
            with open(os.path.join(pegdir+fd,str(self.queuenonce)),'wb') as f:
                f.write(bsonjs.loads(ujson.dumps({'1':command})))
                f.flush()
                os.fsync(f)
                f.close()
            self.queuenonce+=1
            self.queuecount2+=1
        else:
            with open(os.path.join(pegdir+fd,str(self.queuenonce2)),'wb') as f:
                f.write(bsonjs.loads(ujson.dumps({'1':command})))
                f.flush()
                os.fsync(f)
                f.close()
            self.queuenonce2+=1
            self.queuecount4+=1
        return True
    def CheckFileHash(self,path,hsh, rq=0,mk=''):
        if mk=='name':
            if not os.path.isfile(path):
                with open(os.path.join(path),'wb') as f:
                    f.write(bsonjs.loads(ujson.dumps({'filehash':'','data':{}})))
                    f.flush()
                    os.fsync(f)
                    f.close()
        with open(os.path.join(path),'rb') as f:
            q=ujson.loads(bsonjs.dumps(f.read()))
            f.close()
        if q['filehash']!=hsh:
            if rq==0:
                return True
            else:
                return True, q 
        else:
            if rq==0:
                return False
            else:
                return False, q
    def CleanWrite(self, c=0):
        #For now this technique is used for clean batch operations. However in the future it's better
        #to have a all changes in a file and then copy target files for previous version and then perform the change
        #and have each new operation with a file name in sequential order similar to a traditional database
        if os.name == 'nt':
            pegdir=application_path+"\\"+'pegdatabase'
            fd="\\"
        else:
            pegdir=application_path+"/"+'pegdatabase'
            fd="/"
        if not os.path.isfile(os.path.join(pegdir+fd+'exchange'+fd,"status.dat")):       
            with open(os.path.join(pegdir+fd+'exchange'+fd,"status.dat"),'w') as f:
                f.write('0')
                f.flush()
                os.fsync(f)
                f.close()
        if c==0:
            with open(os.path.join(pegdir+fd+'exchange'+fd,"status.dat"),'w') as f:
                f.write('1')
                f.flush()
                os.fsync(f)
                f.close()
        if c==1:
            with open(os.path.join(pegdir+fd+'exchange'+fd,"status.dat"),'w') as f:
                f.write('0')
                f.flush()
                os.fsync(f)
                f.close()
        if c==2:
            with open(os.path.join(pegdir+fd+'exchange',"status.dat"),'r') as f:
                l=f.readline().strip()
                f.close()
            if int(l)==1:
                return False
        return True
    def AccountMaintenance(self):
        global myblockcount
        exchangeinputs=[]
        exchangeinputs2=[]
        for inp in self.Spendable:
            if inp in ThePeg.accounts['txids']: 
                if 'registered' not in ThePeg.accounts['txids'][inp]:
                    continue
                if inp in ThePeg.exchange['withdraws']['spent']:
                    continue
                exchangeinputs2.append(ThePeg.Spendable[inp])
        rating=-1
        rchange=0
        #Combine as many small inputs as we can to larger pools
        style='liquid'
        s2='ltotal'
        exchangeinputs2 = sorted(exchangeinputs2, key=lambda k: k['liquidity'][s2])
        rlimit=0
        ltot=0
        for inp in exchangeinputs2:
            if inp['liquidity']['ltotal']==0 and self.exchange['exchangeaccounts'][0] not in self.Pegdatabase['specialaccounts']:
                continue
            else:
                if inp['liquidity']['ltotal']==0:
                    rlimit+=1
                    if rlimit>20:
                        continue
            ltot+=inp['liquidity']['ltotal']
            try:
                if rating==-1:
                    rating=inp['liquidity']['rating'][0]
                if rating!=inp['liquidity']['rating'][0]:
                    rchange=1
            except:
                traceback.print_exc()
                rchange=1
            if len(exchangeinputs)==45:
                break
            exchangeinputs.append(inp)
        if rchange==0:
            return "Success"
        if ltot<100000000 and self.exchange['exchangeaccounts'][0] not in self.Pegdatabase['specialaccounts']:
            return "Success"
        estimatedfees=(len(exchangeinputs)*10000)+(500000)
        total=0
        ltotal=0
        rtotal=0
        pos=0
        ins=[]
        outs=[]
        ins2=[]
        recipients={}
        for i in exchangeinputs:
            myin={}
            myin['output']=i['txid']+":"+str(i['vout'])
            myin['value']=int(Decimal(i['amount'])*Decimal(1e8))
            myin['address']=i['address']
            total+=myin['value']
            if self.exchange['exchangeaccounts'][0] not in self.Pegdatabase['specialaccounts']:                
                ltotal+=i['liquidity']['ltotal']
                if i['liquidity']['rtotal']!=0:
                    if i['address'] not in recipients:
                        recipients[i['address']]=i['liquidity']['rtotal']
                    else:
                        recipients[i['address']]+=i['liquidity']['rtotal']
            else:
                ltotal+=myin['value']
            ins2.append(myin['output'])
            ins.append(json_deep_copy(myin))
            pos+=1
        total=int((ltotal-estimatedfees)/4)
        if total<2500:
            return "Not enough funds for account maintenance."
        outs.append({'address':self.exchange['exchangeaccounts'][0],'value':total})
        outs.append({'address':self.exchange['exchangeaccounts'][0],'value':total})
        outs.append({'address':self.exchange['exchangeaccounts'][0],'value':total})
        outs.append({'address':self.exchange['exchangeaccounts'][0],'value':total})
        for user in recipients:
            outs.append({'address':user,'value':recipients[user]})
        #A notification to tell the system not to wait to register the outputs upon detection
        uniqueid=os.urandom(16).encode('hex')
        hexlen=""
        if len(uniqueid)>75:
            hexlen="4c"
        outs.append({'script':"6a"+hexlen+num_to_var_int((len(hexlify(uniqueid))/2)).encode('hex')+hexlify(uniqueid), 'value':5575})
        tx=self.SignTransaction(ins,outs)
        res=ThePeg.checktransaction(tx)
        if res==False:
            return "TX rejected: " + str(ThePeg.valid) 
        mytxhash=txhash(tx)
        for i in ins2:
            self.exchange['withdraws']['spent'][i]=1
        self.exchange['withdraws']['raw'].append({'tx':tx,'txid':mytxhash,'rejections':0,'success':0,'ins':ins2,'ID':uniqueid,'maintenance':1})
        self.exchange['withdraws']['history'][uniqueid]={'status':'unconfirmed','txid':mytxhash,'ID':uniqueid,'block':myblockcount,'in0':ins2[0]}
        self.SaveExchange('exchange')
        try:
            res=BLK.sendrawtransaction(tx)
        except:
            try:
                res=BLK.getrawtransaction(mytxhash,1)
            except:
                for w in self.exchange['withdraws']['raw']:
                    if w['txid']==mytxhash:
                        w['rejections']+=1
                return 'Transaction declined'
        for w in self.exchange['withdraws']['raw']:
            if w['txid']==mytxhash:
                w['success']=1
        return 'Success'
    def ClearWithdraw(self,txid):
        ins=[]
        pos=0
        found=0
        for raw in self.exchange['withdraws']['raw']:
            if raw['txid']==txid:
                found=1
                if 'ins' in raw:
                    ins=raw['ins']
                break
            pos+=1
        for i in ins:
            if i in self.exchange['withdraws']['spent']:
                self.exchange['withdraws']['spent'].pop(i)
        if found==1:
            self.exchange['withdraws']['raw'].pop(pos)
    def ProcessWithdraws(self, style='liquid', checkonly=0):
        global myblockcount        
        if self.exchange['withdraws']['raw']!=[]:
            for withdraw in self.exchange['withdraws']['raw']:
                if withdraw['success']==1:
                    try:
                        if withdraw['rejections']>10:#It didn't get into the mempool
                            self.CleanWrite()
                            withdraw['success']=2
                            self.exchange['withdraws']['history'][withdraw['ID']]['status']="Failed/Declined"      
                            for w in self.exchange['withdraws']['liquid']:
                                if 'processing' in w and w['processing']==withdraw['txid']:
                                    self.AddToQueue([os.urandom(16).encode('hex'),{'data':{'ID':w['ID']},'command':'Declined'}],1)
                            for w in self.exchange['withdraws']['reserve']:
                                if 'processing' in w and w['processing']==withdraw['txid']:
                                    self.AddToQueue([os.urandom(16).encode('hex'),{'data':{'ID':w['ID']},'command':'Declined'}],1)
                            if 'maintenance' in withdraw:
                                self.ClearWithdraw(withdraw['txid'])
                            self.SaveExchange('exchange')
                            self.CleanWrite(1)
                        else:
                            complete=0
                            if self.exchange['withdraws']['history'][withdraw['ID']]['status']=="Processing" or self.exchange['withdraws']['history'][withdraw['ID']]['status']=="Complete":
                                complete=1
                            else:
                                float('a')
                            if complete==1:
                                self.CleanWrite()
                                withdraw['success']=2
                                self.exchange['withdraws']['history'][withdraw['ID']]['status']="Complete"
                                if 'maintenance' in withdraw:
                                    self.ClearWithdraw(withdraw['txid'])
                                else:
                                    self.AddToQueue([os.urandom(16).encode('hex'),{'data':{'txid':withdraw['txid']},'command':'Clear'}],1)
                                self.SaveExchange('exchange')
                                self.CleanWrite(1)
                    except:
                        if myblockcount>self.exchange['withdraws']['history'][withdraw['ID']]['block']+10:
                            withdraw['rejections']+=1
                            self.exchange['withdraws']['history'][withdraw['ID']]['block']=myblockcount
                        self.SaveExchange('exchange')
                        traceback.print_exc()
                if withdraw['success']==0:
                    self.CleanWrite()
                    try:
                        res=BLK.sendrawtransaction(raw['tx'])
                        withdraw['success']=1
                    except:
                        if self.exchange['withdraws']['history'][withdraw['ID']]['status']=="Processing" or self.exchange['withdraws']['history'][withdraw['ID']]['status']=="Complete":
                            withdraw['success']=1
                        else:
                            if myblockcount>self.exchange['withdraws']['history'][withdraw['ID']]['block']+10:
                                withdraw['rejections']+=1
                                self.exchange['withdraws']['history'][withdraw['ID']]['block']=myblockcount
                    if withdraw['rejections']>3:
                        withdraw['success']=2
                        self.exchange['withdraws']['history'][withdraw['ID']]['status']="Failed/Declined"
                        for w in self.exchange['withdraws']['liquid']:
                            if 'processing' in w and w['processing']==withdraw['txid']:
                                self.AddToQueue([os.urandom(16).encode('hex'),{'data':{'ID':w['ID']},'command':'Declined'}],1)
                        for w in self.exchange['withdraws']['reserve']:
                            if 'processing' in w and w['processing']==withdraw['txid']:
                                self.AddToQueue([os.urandom(16).encode('hex'),{'data':{'ID':w['ID']},'command':'Declined'}],1)
                        if 'maintenance' in withdraw:
                            self.ClearWithdraw(withdraw['txid'])
                    self.SaveExchange('exchange')
                    self.CleanWrite(1)
        if checkonly==1:
            return "Success"
        if self.exchange['exchangeaccounts']==[]:
            return "No return address for exchange"
        if self.exchange['exchangefeeaccount']=='':
            return "No address for collecting withdraw fees"
        total=0
        outputs=0
        commission=0
        recipients={self.exchange['exchangefeeaccount']:0}
        pos=-1
        for withdraw in self.exchange['withdraws'][style]:
            pos+=1
            if 'processing' in withdraw or 'expired' in withdraw:
                continue
            if withdraw['cycle']<self.exchangecycle-1:
                print "Expired transaction"
                self.exchange['withdraws'][style][pos]['expired']=1
                self.SaveExchange('exchange')
                self.AddToQueue([os.urandom(16).encode('hex'),{'data':{'ID':withdraw['ID']},'command':'Expired'}],1)
                continue
            total+=withdraw['amount']
            c=int(float(withdraw['amount'])*float(self.exchange['commission']['percent']))
            if c<self.exchange['commission']['min']:
                c=self.exchange['commission']['min']
            if c>self.exchange['commission']['max']:
                c=self.exchange['commission']['max']
            if withdraw['address'] not in recipients:
                recipients[withdraw['address']]=withdraw['amount']-c
            else:
                recipients[withdraw['address']]+=withdraw['amount']-c
            commission+=c
            outputs+=1
            if style=='reserve' and len(recipients)>self.reservelimit:
                break
            if outputs==self.liquidlimit:
                break
        breakpos=pos
        if outputs==0:
            return "Success"
        recipients[self.exchange['exchangefeeaccount']]+=commission
        exchangeinputs=[]
        for s in self.Spendable:
            if s in self.accounts['txids']: 
                if 'registered' not in self.accounts['txids'][s]:
                    continue
                if s in self.exchange['withdraws']['spent']:
                    continue
                exchangeinputs.append(self.Spendable[s])
        if style=='liquid':
            s2='ltotal'
            #Take larger inputs first because those are usually exchange liquidity pools with better liquidity
            exchangeinputs = sorted(exchangeinputs, key=lambda k: k['liquidity'][s2], reverse=True)
        else:
            s2='rtotal'
            #We want to combine as many small inputs when we get the chance.
            exchangeinputs = sorted(exchangeinputs, key=lambda k: k['liquidity'][s2])
        estimatedfees=(outputs*10000)+(500000)
        if estimatedfees>commission:
            return "Not enough funds for fees. Withdraws need more funds to cover it. Try setting higher commissions for withdraws."
        recipients[self.exchange['exchangefeeaccount']]-=estimatedfees
        temptotal=total
        myinputs=[]
        testinputs=[]
        myouts={}
        inputlimit=0
        chg=0
        remainder=0
        try:
            s3=s2
            tot=0            
            while temptotal>0:
                found=0
                length=len(exchangeinputs)
                pos=0
                for inp in exchangeinputs:
                    if inp['liquidity'][s3]>temptotal:
                        found=1
                    else:
                        if style=='reserve' and inputlimit<30 and self.exchange['exchangeaccounts'][0] not in self.Pegdatabase['specialaccounts'] and inp['liquidity'][s3]!=0:
                            #We do this to consolidate as much reserves as possible due to change address concerns
                            #If special accounts are used the reserve can be merged and this is no longer a concern
                            #Currently in some cases, multiple 6a outputs are only allowed for each regular output
                            #because that rule makes no sense it won't be a rule after the peg fork
                            found=1
                            inputlimit+=1
                    if pos+1==length:
                        found=1
                    if found==1:
                        print inp['liquidity'][s3]
                        print temptotal
                        print inp['txid']+":"+str(inp['vout'])
                        temptotal-=inp['liquidity'][s3]
                        tot+=int(Decimal(inp['amount'])*Decimal(1e8))
                        remainder+=inp['liquidity']['ltotal']
                        myinputs.append(inp)
                        testinputs.append(inp)
                        break
                    pos+=1
                    print "Not found"
                if found==1:
                    exchangeinputs.pop(pos)
                if found==0:
                    if s3=='rtotal':
                        temptotal-=remainder
                        s3='ltotal'
                    else:
                        return "Not enough funds"
            chg=tot-total
            if s3=='rtotal' and self.exchange['exchangeaccounts'][0] not in self.Pegdatabase['specialaccounts'] and temptotal<0:
                #Change on reserve transfers must go to the correct addresses first
                #With a shared split, they are sorted in alphabetical order
                testinputs = sorted(testinputs, key=lambda k: k['address'], reverse=True)
                tt=abs(temptotal)
                chg-=tt
                for inp in testinputs:
                    addy=inp['address']
                    val=inp['liquidity'][s3]
                    if val>=tt:
                        if addy not in myouts:
                            myouts[addy]=tt
                        else:
                            myouts[addy]+=tt
                    else:
                        tt-=val
                        if addy not in myouts:
                            myouts[addy]=val
                        else:
                            myouts[addy]+=val
            if style=='reserve':
                if chg>0:
                    if self.exchange['exchangeaccounts'][0] not in myouts:
                        myouts[self.exchange['exchangeaccounts'][0]]=chg
                    else:
                        myouts[self.exchange['exchangeaccounts'][0]]+=chg
            if style=='liquid':
                if temptotal<0:
                    if self.exchange['exchangeaccounts'][0] not in myouts:
                        myouts[self.exchange['exchangeaccounts'][0]]=abs(temptotal)
                    else:
                        myouts[self.exchange['exchangeaccounts'][0]]+=abs(temptotal)
        except:
            traceback.print_exc()
            return "Not enough funds"
        ins=[]
        outs=[]
        start=len(myinputs)
        if len(recipients)<3:
            if len(recipients)==1:
                fstring='**F**'+str(start)+':'+str(start)+':'+str(start)
            if len(recipients)==2:
                fstring='**F**'+str(start)+':'+str(start+1)+':'+str(start+1)
            shortstring=fstring
        else:
            fstring='**F**'
            x=start
            pos=0
            while pos < len(recipients):
                fstring+=str(x)
                if pos<3:
                    shortstring=fstring
                if pos!=len(recipients)-1:
                    fstring+=":"
                x+=1
                pos+=1
            if len(recipients)<4:
                shortstring=fstring
        pos=0
        ins2=[]
        for i in myinputs:
            myin={}
            myin['output']=i['txid']+":"+str(i['vout'])
            myin['value']=int(Decimal(i['amount'])*Decimal(1e8))
            myin['address']=i['address']
            ins2.append(myin['output'])
            if style=='liquid':
                if i['liquidity']['rtotal']>0:
                    if self.exchange['exchangeaccounts'][0] not in self.Pegdatabase['specialaccounts']:
                        addy=i['address']
                    else:
                        addy=self.exchange['exchangeaccounts'][0]
                    if addy not in myouts:
                        myouts[addy]=i['liquidity']['rtotal']
                    else:
                        myouts[addy]+=i['liquidity']['rtotal']
            if style=='reserve':
                if pos!=0:
                    outs.append({'value':5590,'script':"6a"+num_to_var_int((len(hexlify(shortstring))/2)).encode('hex')+hexlify(shortstring)})
                else:
                    hexlen=""
                    if len(fstring)>75:
                        hexlen="4c"
                    outs.append({'value':5590,'script':"6a"+hexlen+num_to_var_int((len(hexlify(fstring))/2)).encode('hex')+hexlify(fstring)})
            ins.append(json_deep_copy(myin))
            pos+=1
        notary=1
        for user in recipients:
            if user==self.exchange['exchangeaccounts'][0]:
                notary=0
            outs.append({'address':user,'value':recipients[user]})
        for user in myouts:
            if user==self.exchange['exchangeaccounts'][0]:
                notary=0
            outs.append({'address':user,'value':myouts[user]})
        #A notification to tell the system not to wait to register the outputs upon detection and one output for malleability
        uniqueid=os.urandom(16).encode('hex')
        if notary==1:#Make sure we are notified
            outs.append({'address':self.exchange['exchangeaccounts'][0],'value':5575})
        hexlen=""
        if len(uniqueid)>75:
            hexlen="4c"
        outs.append({'script':"6a"+hexlen+num_to_var_int((len(hexlify(uniqueid))/2)).encode('hex')+hexlify(uniqueid), 'value':5575})
        tx=self.SignTransaction(ins,outs)
        res=ThePeg.checktransaction(tx)
        if res==False:
            return "TX rejected: " + str(ThePeg.valid) 
        mytxhash=txhash(tx)        
        for i in ins2:
            self.exchange['withdraws']['spent'][i]=1
        outputs=0
        pos=-1
        for withdraw in self.exchange['withdraws'][style]:
            pos+=1
            if 'processing' in withdraw or 'expired' in withdraw:                
                continue
            if withdraw['cycle']<self.exchangecycle-1:
                continue
            self.exchange['withdraws'][style][pos]['processing']=mytxhash
            outputs+=1
            self.exchange['withdraws']['history'][withdraw['ID']]=uniqueid
            if style=='reserve' and pos==breakpos:
                break
            if outputs==self.liquidlimit:
                break
        self.exchange['withdraws']['raw'].append({'tx':tx,'txid':mytxhash,'rejections':0,'success':0,'ins':ins2,'ID':uniqueid})
        self.exchange['withdraws']['history'][uniqueid]={'status':'unconfirmed','txid':mytxhash,'ID':uniqueid,'block':myblockcount,'in0':ins2[0]}
        self.SaveExchange('exchange')
        try:
            res=BLK.sendrawtransaction(tx)
        except:
            try:
                res=BLK.getrawtransaction(mytxhash,1)
            except:
                for w in self.exchange['withdraws']['raw']:
                    if w['txid']==mytxhash:
                        w['rejections']+=1
                return 'Transaction declined'
        for w in self.exchange['withdraws']['raw']:
            if w['txid']==mytxhash:
                w['success']=1
        return 'Success'
    def SignTransaction(self, ins, outs):
        if self.exchangepassword!='':
            BLK.walletpassphrase(self.exchangepassword, 120)
        tx = mktx_script(timestamp, ins,outs)
        x=0
        for i in ins:
            priv=BLK.dumpprivkey(i['address'])
            tx=pyblackcointools.sign(tx,x,priv)
            x+=1
        return tx
    def DepositToAccount(self, name, txids):
        global myblockcount
        #Exchanges should wait for enough confirmations before adding to the account. Get spendable also waits 7 confirmations
        #If pool pruning is active, then the addresses in the QT should archive deposit transactions to know their true liquidity
        #The notation for txids is the string txid:vout
        if name.lower()=='total' or name.lower()=='pool'or name.lower()=='frozen' or name.lower()=='x' or name.lower()=='exchange' or name.lower()=='withdraws':
            return False
        for tx in txids:
            if tx not in self.accounts['txids']:
                self.accounts['txids'][tx]={'name':name}
        return True
    def LoadSpendable(self, Unspent='',changeonly=0):
        if Unspent=='':
            Unspent=BLK.listunspent()
            try:
                u1=BLK.listfrozen()
                for u in u1:
                    Unspent.append(u)
            except:
                traceback.print_exc()
        self.Spendable=self.GetSpendable(Unspent, self.Spendable)
        for s in self.Spendable:
            check=0
            if 'change' in self.Spendable[s]:
                if s not in self.accounts['txids']:
                    self.accounts['txids'][s]={'name':'exchange','registered':1}
            if s in self.accounts['txids'] and 'registered' not in self.accounts['txids'][s] and changeonly==0:
                addy=self.Spendable[s]['address']
                if self.highkeyimport==1: #Deposit is not split, only high key is noted
                    highkey=self.Highkey(self.Spendable[s]['liquidity'][addy])
                    if str(highkey) not in self.accounts['balances']:
                        self.accounts['balances'][str(highkey)]={'total':0}
                    if self.accounts['txids'][s]['name'] not in self.accounts['balances'][str(highkey)]:
                        self.accounts['balances'][str(highkey)][self.accounts['txids'][s]['name']]=self.Spendable[s]['liquidity'][addy]['total']
                    else:
                        self.accounts['balances'][str(highkey)][self.accounts['txids'][s]['name']]+=self.Spendable[s]['liquidity'][addy]['total']
                    batchsave=[os.urandom(16).encode('hex'), {'command':'Import','data':{'txid':s,'liquidity':{str(highkey):self.Spendable[s]['liquidity'][addy]['total']},'name':self.accounts['txids'][s]['name']}}]
                else:
                    for i in self.Spendable[s]['liquidity'][addy]:
                        if i == 'frozen' or i == 'total':
                            continue
                        if str(i) not in self.accounts['balances']:
                            self.accounts['balances'][str(i)]={'total':0}
                        if self.accounts['txids'][s]['name'] not in self.accounts['balances'][str(i)]:
                            self.accounts['balances'][str(i)][self.accounts['txids'][s]['name']]=self.Spendable[s]['liquidity'][addy][str(i)]
                        else:
                            self.accounts['balances'][str(i)][self.accounts['txids'][s]['name']]+=self.Spendable[s]['liquidity'][addy][str(i)]
                    batchsave=[os.urandom(16).encode('hex'), {'command':'Import','data':{'txid':s,'liquidity':self.Spendable[s]['liquidity'][addy],'name':self.accounts['txids'][s]['name']}}]
                self.accounts['txids'][s]['registered']=1
                self.AddToQueue(batchsave,1)
        if changeonly==0:
            for i in self.accounts['balances']:
                self.accounts['balances'][str(i)]['total']=0
            for s in self.Spendable:
                if s in self.accounts['txids'] and 'registered' in self.accounts['txids'][s]:
                    addy=self.Spendable[s]['address']
                    for i in self.Spendable[s]['liquidity'][addy]:
                        if i == 'frozen' or i == 'total':
                            continue
                        if str(i) not in self.accounts['balances']:
                            self.accounts['balances'][str(i)]={'total':0}
                        self.accounts['balances'][str(i)]['total']+=self.Spendable[s]['liquidity'][addy][i]
        poplist=[]
        for tx in self.accounts['txids']:
            if 'registered' in self.accounts['txids'][tx] and tx not in self.Spendable:
                poplist.append(tx)
        for tx in poplist:
            self.accounts['txids'].pop(tx)
        self.CleanWrite()
        self.SaveExchange('txids')
        self.CleanWrite(1)
        return True
    def Highkey(self, liquid):
        i=0
        while i < self.amountofsteps:
            if str(i) in liquid:
                break
            i+=1
        return i
    def Trade(self, user1, amount, user2, style='liquid',votecycle=0, showdeduction=1, allowoverflow=1):
        try:
            if amount==0:
                return False
            supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'],votecycle)
            #These adjustments should be done at the API level instead of here.
            if user2=='':
                #They don't want to signal both trading partners. Instead they will add/subtract from a pool.
                #This technique is not recommended for exchanges and is only useful when there is limited information available
                #The technique should be to deduct first and add later when there is enough in the pool
                if amount < 0:#Deduction
                    amount=abs(amount)
                    user2='pool'
                else:#Take from pool
                    user2=user1
                    user1='pool'
            if user2 != 'x':#For withdraws
                if user2 not in self.accounts['users']:
                    self.accounts['users'][user2]={'liquid':0,'reserve':0}
            deductions={}
            if allowoverflow==0:
                if amount > self.accounts['users'][user1][style]:
                    return "Not enough "+style+" funds for deduction."
            else:
                if amount > self.accounts['users'][user1]['liquid']+self.accounts['users'][user1]['reserve']:
                    return "Not enough funds for deduction."
            #The exchanges perception of balance may be different from true balance based on liquidity share
            #and also because sometimes trades are registered in the database at a later time. So we calculate it.
            total=0
            for i in self.accounts['balances']:
                if i=='total' or i=='frozen':
                    continue
                if int(i)<supply and style=='liquid':
                    continue
                if int(i)>=supply and style=='reserve':
                    continue
                if user1 in self.accounts['balances'][i]:
                    total+=self.accounts['balances'][i][user1]
            if amount > total:
                amount2=total
            else:
                amount2=amount
            tmpamt=amount
            for i in self.accounts['balances']:
                if i=='total' or i=='frozen':
                    continue
                if int(i)<supply and style=='liquid':
                    continue
                if int(i)>=supply and style=='reserve':
                    continue
                if user1 in self.accounts['balances'][i]:
                    amt=int((float(self.accounts['balances'][i][user1])/float(total))*float(amount2))
                    tmpamt-=amt
                    if user2 != 'x':
                        if user2 not in self.accounts['balances'][i]:
                            self.accounts['balances'][i][user2]=amt
                        else:
                            self.accounts['balances'][i][user2]+=amt
                    deductions[i]=amt
                    self.accounts['balances'][i][user1]-=amt
                    if self.accounts['balances'][i][user1]==0:
                        self.accounts['balances'][i].pop(user1)
            while tmpamt>0:
                x=self.amountofsteps-1
                found=0
                while x>=0:
                    if x<supply and style=='liquid':
                        x-=1
                        continue
                    if x>=supply and style=='reserve':
                        x-=1
                        continue
                    if tmpamt<=0:
                        break
                    if str(x) in self.accounts['balances']:
                        i=str(x)
                        if user1 in self.accounts['balances'][i]:
                            found=1
                            tmpamt-=1
                            self.accounts['balances'][i][user1]-=1
                            if i not in deductions:
                                deductions[i]=1
                            else:
                                deductions[i]+=1
                            if user2 != 'x':
                                if user2 not in self.accounts['balances'][i]:
                                    self.accounts['balances'][i][user2]=1
                                else:
                                    self.accounts['balances'][i][user2]+=1
                            if self.accounts['balances'][i][user1]==0:
                                self.accounts['balances'][i].pop(user1)
                    x-=1
                if found==0:
                    if allowoverflow==0:
                        print "Not enough funds for trade! Check database."
                        ThePeg.stopexchange=1
                        break
                    else:
                        break
            if tmpamt>0:
                total=0
                if style=='liquid':
                    style2='reserve'
                if style=='reserve':
                    style2='liquid'
                for i in self.accounts['balances']:
                    if i=='total' or i=='frozen':
                        continue
                    if int(i)<supply and style2=='liquid':
                        continue
                    if int(i)>=supply and style2=='reserve':
                        continue
                    if user1 in self.accounts['balances'][i]:
                        total+=self.accounts['balances'][i][user1]
                amount2=tmpamt
                for i in self.accounts['balances']:
                    if i=='total' or i=='frozen':
                        continue
                    if int(i)<supply and style2=='liquid':
                        continue
                    if int(i)>=supply and style2=='reserve':
                        continue
                    if user1 in self.accounts['balances'][i]:
                        amt=int((float(self.accounts['balances'][i][user1])/float(total))*float(amount2))
                        tmpamt-=amt
                        if user2 != 'x':
                            if user2 not in self.accounts['balances'][i]:
                                self.accounts['balances'][i][user2]=amt
                            else:
                                self.accounts['balances'][i][user2]+=amt
                        if i not in deductions:
                            deductions[i]=amt
                        else:
                            deductions[i]+=amt
                        self.accounts['balances'][i][user1]-=amt
                        if self.accounts['balances'][i][user1]==0:
                            self.accounts['balances'][i].pop(user1)
                while tmpamt>0:
                    x=self.amountofsteps-1
                    found=0
                    while x>=0:
                        if x<supply and style2=='liquid':
                            x-=1
                            continue
                        if x>=supply and style2=='reserve':
                            x-=1
                            continue
                        if tmpamt<=0:
                            break
                        if str(x) in self.accounts['balances']:
                            i=str(x)
                            if user1 in self.accounts['balances'][i]:
                                found=1
                                tmpamt-=1
                                self.accounts['balances'][i][user1]-=1
                                if i not in deductions:
                                    deductions[i]=1
                                else:
                                    deductions[i]+=1
                                if user2 != 'x':
                                    if user2 not in self.accounts['balances'][i]:
                                        self.accounts['balances'][i][user2]=1
                                    else:
                                        self.accounts['balances'][i][user2]+=1
                                if self.accounts['balances'][i][user1]==0:
                                    self.accounts['balances'][i].pop(user1)
                        x-=1
                    if found==0:
                        #This probably should not happen.
                        print "Not enough funds for trade! Check database."
                        ThePeg.stopexchange=1
                        break
            if allowoverflow==0:
                self.accounts['users'][user1][style]-=amount
                if user2!='x':
                    self.accounts['users'][user2][style]+=amount
            else:
                if amount>self.accounts['users'][user1][style]:
                    amt1=self.accounts['users'][user1][style]
                    amt2=amount-amt1
                    self.accounts['users'][user1][style]-=amt1
                    if user2!='x':
                        self.accounts['users'][user2][style]+=amt1
                    if style=='liquid':
                        self.accounts['users'][user1]['reserve']-=amt2
                        if user2!='x':
                            self.accounts['users'][user2]['reserve']+=amt2
                    if style=='reserve':
                        self.accounts['users'][user1]['liquid']-=amt2
                        if user2!='x':
                            self.accounts['users'][user2]['liquid']+=amt2
                else:
                    self.accounts['users'][user1][style]-=amount
                    if user2!='x':
                        self.accounts['users'][user2][style]+=amount
            if showdeduction==1:
                return json_deep_copy(deductions)
            else:
                return True
        except:
            res=str(traceback.format_exc())
            return res
    def GetSpendable(self, txids, MySpendable='', checkonly=0):
        #This function gets the liquidity of a users coins based on the inputs they control.
        #Exhange should have at least 5+ confirmations before depositing a txid to an account
        #Because this can change the liquidity of everyones account, this should be called every time there is supply change
        if MySpendable=='':
            MySpendable={}
        txidlist={}
        SaveX=0
        for tx in txids:
            txidlist[str(tx['txid'])+":"+str(tx['vout'])]=1
            if str(tx['txid'])+":"+str(tx['vout']) in MySpendable:
                continue
            lookup=BLK.getrawtransaction(tx['txid'],1)
            blockcheck=BLK.getblock(lookup['blockhash'])['height']
            if ThePeg.prunetopools==1:
                if 'confirmations' in lookup and lookup['confirmations']<5+self.exchangeconfirmations:
                    continue
            else:
                if 'confirmations' in lookup and lookup['confirmations']<self.exchangeconfirmations:
                    continue
            if blockcheck % ThePeg.interval<7 or blockcheck % ThePeg.interval>ThePeg.interval-7:
                if 'confirmations' in lookup and lookup['confirmations']<5+self.exchangeconfirmations:
                    continue
            if ThePeg.Pegdatabase['blockcount']<blockcheck+1:#Not in database yet
                continue
            if tx['address'] not in self.exchange['addresses'] and tx['address'] not in self.exchange['exchangeaccounts'] and tx['address']!=self.exchange['exchangefeeaccount']:
                continue
            if lookup['vout'][-1]['scriptPubKey']['hex'][:2]=="6a" and len(lookup['vout'][-1]['scriptPubKey']['hex'])>2:
                try:
                    uid=unhexlify(deserialize_script(lookup['vout'][-1]['scriptPubKey']['hex'])[1])
                except:
                    uid=''
                if uid in self.exchange['withdraws']['history'] and self.exchange['withdraws']['history'][uid]['in0']==lookup['vin'][0]['txid']+':'+str(lookup['vin'][0]['vout']):
                    if self.exchange['withdraws']['history'][uid]['status']!="Processing" and self.exchange['withdraws']['history'][uid]['status']!="Complete":
                        if self.exchange['withdraws']['history'][uid]['txid']!=tx['txid']:#Malleability
                            self.exchange['withdraws']['history'][uid]['txid2']=tx['txid']
                        self.exchange['withdraws']['history'][uid]['status']="Processing"
                        SaveX=1
            addthis=1
            try:
                liquid, reserve=ThePeg.checktransaction(str(tx['txid'])+":"+str(tx['vout']))
                combined=ThePeg.checkliquidity(liquid,reserve)
                if combined==False:
                    addthis=0
                if 'frozen' in combined and combined['frozen']>timestamp-43200:
                    addthis=0
            except:
                addthis=0
                traceback.print_exc()
            if addthis==1:
                MySpendable[str(tx['txid'])+":"+str(tx['vout'])]=tx
                MySpendable[str(tx['txid'])+":"+str(tx['vout'])]['liquidity']=json_deep_copy(combined)
                if lookup['vout'][-1]['scriptPubKey']['hex'][:2]=="6a":
                    MySpendable[str(tx['txid'])+":"+str(tx['vout'])]['change']=1
        if SaveX==1:
            self.SaveExchange('exchange')
        if checkonly==0:
            popthis=[]
            for tx in MySpendable:
                if tx not in txidlist:
                    popthis.append(tx)
            for tx in popthis:
                MySpendable.pop(tx)
        return MySpendable
    def GetBalance(self, MySpendable, update=1, votecycle=0):
        #This function gets the reserve and liquid balance and other details. It will also update
        #the liquidity of inputs when necessary. This only needs to be done when the rate changes. However
        #a buffer is added so that some coins will freeze during rate change as protection from reorganization.
        #This is the balance of the exchanges pool. User balances are based on the orderbook and proportions and times of trades/deposits.
        global timestamp
        tx=''
        for tx in MySpendable:
            break
        if votecycle==0:
            supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
        else:
            supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'], votecycle)
        if tx!='' and update==1:#This might take a little bit of time
            try:
                if int(MySpendable[tx]['liquidity']['supply'])!=supply:
                    for tx in MySpendable:
                        MySpendable[tx]['liquidity']=ThePeg.checkliquidity(MySpendable[tx]['liquidity'], update=1)
            except:
                traceback.print_exc()
        reserve=0
        liquid=0
        frozen=0
        subpremium=0
        #Exchange balance is calculated once per interval and deposit change for all users. Then later it is updated on trades.
        for tx in MySpendable:
            if tx in self.exchange['withdraws']['spent']:
                continue
            if tx in self.accounts['txids'] and 'registered' in self.accounts['txids'][tx]:
                if 'frozen' in MySpendable[tx]['liquidity'] and MySpendable[tx]['liquidity']['frozen']>timestamp-43200:
                    frozen+=MySpendable[tx]['liquidity']['rtotal']+MySpendable[tx]['liquidity']['ltotal']
                else:
                    reserve+=MySpendable[tx]['liquidity']['rtotal']
                    liquid+=MySpendable[tx]['liquidity']['ltotal']
                    if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10 or self.exchangebuffer==1:
                        reserve+=MySpendable[tx]['liquidity']['nfreeze']
                        liquid-=MySpendable[tx]['liquidity']['nfreeze']
                    if MySpendable[tx]['liquidity']['rating'][0]<ThePeg.subpremiumrating:
                        subpremium+=MySpendable[tx]['liquidity']['ltotal']
        ExchangeBalance={'liquid':liquid,'reserve':reserve,'subpremium':subpremium,'frozen':frozen}
        #User balances we need to know the key where users start splitting
        x=self.amountofsteps-1
        myliquid=liquid
        for account in self.accounts['users']:
            self.accounts['users'][account]['liquid']=0
            self.accounts['users'][account]['reserve']=0
        while x>=0:
            if x<supply or myliquid==0:
                if str(x) in self.accounts['balances']:
                    for account in self.accounts['balances'][str(x)]:
                        if account=='total' or account=='frozen':
                            continue
                        if account not in self.accounts['users']:
                            self.accounts['users'][account]={'liquid':0,'reserve':0}
                        if self.accounts['balances'][str(x)][account] <= reserve:#The funds should be there
                            self.accounts['users'][account]['reserve']+=self.accounts['balances'][str(x)][account]
                            reserve-=self.accounts['balances'][str(x)][account]
            else:
                if str(x) in self.accounts['balances']:
                    tot=0
                    for account in self.accounts['balances'][str(x)]:#There might be a more efficient way of doing this.
                        if account=='total' or account=='frozen':
                            continue
                        tot+=self.accounts['balances'][str(x)][account]
                    if tot<=myliquid:
                        for account in self.accounts['balances'][str(x)]:
                            if account=='total' or account=='frozen':
                                continue
                            if account not in self.accounts['users']:
                                self.accounts['users'][account]={'liquid':0,'reserve':0}
                            self.accounts['users'][account]['liquid']+=self.accounts['balances'][str(x)][account]
                            myliquid-=self.accounts['balances'][str(x)][account]
                    else:#Last key
                        l=myliquid
                        myliquid=0
                        ratio=float(l)/float(tot)
                        for account in self.accounts['balances'][str(x)]:
                            if account=='total' or account=='frozen':
                                continue
                            if account not in self.accounts['users']:
                                self.accounts['users'][account]={'liquid':0,'reserve':0}
                            t=int(float(self.accounts['balances'][str(x)][account])*ratio)
                            d=self.accounts['balances'][str(x)][account]-t
                            self.accounts['users'][account]['liquid']+=t
                            self.accounts['users'][account]['reserve']+=d
            x-=1
        print str(self.accounts['users'])
        self.updatingbalance=1
        time.sleep(.5)
        if 'pool' not in self.accounts2['users']:
            self.accounts2['users']['pool']={'liquid':0,'reserve':0}
        for account in self.accounts['users']:
            if account=='total' or account=='frozen':
                continue
            if account not in self.accounts2['users']:
                self.accounts2['users'][account]={'liquid':0,'reserve':0}
            self.accounts2['users'][account]['liquid']=self.accounts['users'][account]['liquid']
            self.accounts2['users'][account]['reserve']=self.accounts['users'][account]['reserve']
            if 'temp' in self.accounts2['users'][account]:
                if self.accounts2['users'][account]['temp']['liquid']<0:
                    if abs(self.accounts2['users'][account]['temp']['liquid'])>self.accounts2['users'][account]['liquid']:
                        amt1=self.accounts2['users'][account]['liquid']
                        amt2=abs(self.accounts2['users'][account]['temp']['liquid'])-amt1
                    else:
                        amt1=abs(self.accounts2['users'][account]['temp']['liquid'])
                        amt2=0
                    self.accounts2['users'][account]['liquid']-=amt1
                    self.accounts2['users'][account]['reserve']-=amt2
                else:
                    self.accounts2['users'][account]['liquid']+=self.accounts2['users'][account]['temp']['liquid']
                if self.accounts2['users'][account]['temp']['reserve']<0:
                    if abs(self.accounts2['users'][account]['temp']['reserve'])>self.accounts2['users'][account]['reserve']:
                        amt1=self.accounts2['users'][account]['reserve']
                        amt2=abs(self.accounts2['users'][account]['temp']['reserve'])-amt1
                    else:
                        amt1=abs(self.accounts2['users'][account]['temp']['reserve'])
                        amt2=0
                    self.accounts2['users'][account]['reserve']-=amt1
                    self.accounts2['users'][account]['liquid']-=amt2
                else:
                    self.accounts2['users'][account]['reserve']+=self.accounts2['users'][account]['temp']['reserve']
                self.accounts2['users'][account].pop('temp')
        self.updatingbalance=0
        return ExchangeBalance, MySpendable

ThePeg = PegThread("ThePeg")
ThePeg.start()
if os.path.exists(os.path.join(application_path,"whitelist.dat")):    
    with open(os.path.join(application_path,"whitelist.dat"),'r') as f:
        lines=f.readlines()
        f.close()
    for line in lines:
        if "#" in line:
            line=line.replace("#","")
            ThePeg.Pegdatabase['startingblock']=int(line)
            ThePeg.Pegdatabase['blockcount']=ThePeg.Pegdatabase['startingblock']
            ThePeg.Pegdatabase['votesblockcount']=ThePeg.Pegdatabase['startingblock']
            ThePeg.Pegdatabase['votesblockcount2']=ThePeg.Pegdatabase['startingblock']
        else:
            ThePeg.whitelist[line.strip()]=''
class PythonThread(QtCore.QThread):#Thread for any special Python contracts or API calls
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        self.codetorun=''
        self.amrunning=True
    def stop(self):
        self.amrunning=False
    def run(self):
        while self.amrunning:
            time.sleep(.5)
            if self.codetorun!='':
                try:
                    exec(validateCode(self.codetorun))
                except:
                    traceback.print_exc()
RunPython = PythonThread("RunPython")
#We should probably allow this thread to only be started by API or special contracts
#RunPython.start()
class BridgeThread(QtCore.QThread):#Safe File saving thread
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        self.amrunning=True
        self.confirmedvotes={}
        self.votemerkles={}
        self.BridgeRefresh=0
        self.waitingconf=0
        self.lastHash={}
        self.mypairs=[['0xA563E960C3BD3EA13cF5eC3c55F925c9a1C1bDA6','0x566561B14eD45b3Ad4f0B864Bd10E43aA9bB4088','0xE349B271075B53062fde900657BDFB567cad6f92','0x10f5f17B0455bb8365Ed72471718e3E0a0984674']]
    def stop(self):
        self.amrunning=False
    def run(self):
        global BridgeAdmin, BridgeDriver, MySettingsInfo, globperc, merkleHashes
        loaded = 0
        thecount = 0
        time.sleep(10)
        restart = False
        result = []        
        while self.amrunning:
            time.sleep(1)
            thecount +=1
            if thecount == 100000:
                thecount = 0
            if restart == True and thecount % 120 != 0:
                continue
            else:
                restart = False
            try:
                if BridgeAdmin and globperc > 98:
                    if not ThePeg.Pegdatabase['bridgeactive']:
                        MySettingsInfo = "Bridge is currently not active"
                        continue
                    pubs=get_ordered_pubkeys(PrivKeyFilename1)
                    if loaded == 0:
                        try:
                            options = Options()
                            options.headless = True
                            if 'debugBrowser' in AdvanceArray:
                                options.headless = AdvanceArray['debugBrowser']
                            if os.name == 'nt':
                                myexe = "bridge/geckodriver.exe"
                            else:
                                myexe = "bridge/geckodriver"
                            myhtml = "bridge/bridge.htm"
                            BridgeDriver = webdriver.Firefox(executable_path = os.path.join(application_path, myexe), options=options)
                            BridgeDriver.get("file:///" + os.path.join(application_path, myhtml))
                            time.sleep(1)
                            if ThePeg.testthis == 1:
                                result = BridgeDriver.execute_script("return loadBridges("+str(ThePeg.Pegdatabase['bridgedb']['bridges'])+",'"+pubs[0]+"');")
                            else:
                                result = BridgeDriver.execute_script("return loadBridges("+str(AdvanceArray['bridgedb']['bridges'])+",'"+pubs[0]+"');")
                            MySettingsInfo = str(result[1])
                            if 'bridgeautomation' in AdvanceArray:
                                if AdvanceArray['bridgeautomation']['votes'] != {} and self.confirmedvotes == {}:
                                    self.waitingconf = 0
                            loaded = 1
                        except:
                            traceback.print_exc()
                            try:
                                print "Restarting bridge driver"
                                BridgeDriver.quit()
                            except:
                                pass
                            restart = True
                            loaded = 0
                            MySettingsInfo = "Error loading bridge"
                            continue
                    else:                    
                        if thecount % 120 == 0:
                            try:
                                somebridges = {}
                                if ThePeg.testthis == 1:
                                    result = BridgeDriver.execute_script("return loadBridges("+str(ThePeg.Pegdatabase['bridgedb']['bridges'])+",'"+pubs[0]+"');")
                                    somebridges = ThePeg.Pegdatabase['bridgedb']['bridges']
                                else:
                                    result = BridgeDriver.execute_script("return loadBridges("+str(AdvanceArray['bridgedb']['bridges'])+",'"+pubs[0]+"');")
                                    somebridges = AdvanceArray['bridgedb']['bridges']
                                try:
                                    x = 0
                                    for abridge in somebridges:
                                        name=abridge['n']
                                        if name not in self.lastHash:
                                            self.lastHash[name] = "0x0"
                                        if 'lastMerkle' in result[0][x]:
                                            self.lastHash[name] = result[0][x]['lastMerkle']
                                        ThePeg.Pegdatabase['netdata'][name] = {'pegsteps':result[0][x]['1'],'microsteps':result[0][x]['2']}
                                        x+=1
                                except:
                                    traceback.print_exc()
                                MySettingsInfo = str(result[1])
                            except:
                                traceback.print_exc()
                                try:
                                    print "Restarting bridge driver"
                                    BridgeDriver.quit()
                                except:
                                    pass
                                restart = True
                                loaded = 0
                                MySettingsInfo = "Error loading bridge"
                                continue
                        if "Bridge operations temporarily halted."  in MySettingsInfo or "This network is currently paused" in MySettingsInfo:
                            continue
                        thepriv = ""
                        if IsUnlocked():                        
                            text,check=DecryptPrivateKey(PrivKeyFilename1,PrivKeyFiledir1,"")
                            if privtopub(text) == pubs[0]:
                                thepriv = text
                            else:
                                text,check=DecryptPrivateKey(PrivKeyFilename2,PrivKeyFiledir2,"")
                                if privtopub(text) == pubs[0]:
                                    thepriv = text
                            if self.brainKey != "":
                                thepriv = txhash(thepriv + self.brainKey)
                        else:
                            if "Please unlock your wallet for staking to maintain the bridge" not in MySettingsInfo:
                                MySettingsInfo = "Please unlock your wallet for staking to maintain the bridge!<br>" + MySettingsInfo
                        if thecount % 150 == 0:
                            try:
                                if thepriv != "":
                                    result2 = BridgeDriver.execute_script("return updateSupply("+str(ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount']))+",'"+thepriv+"',"+str(self.mypairs)+");")
                            except:
                                traceback.print_exc()
                        if thecount % 180 == 0:
                            if ThePeg.noncesync == {}: #For python testing this will sync slowly. In production merkle trees are saved in peg database
                                if ThePeg.testthis == 1:
                                    for bridges in ThePeg.Pegdatabase['bridgedb']['bridges']:
                                        ThePeg.noncesync[bridges['n']] = 0;
                            try:
                                if ThePeg.testthis == 1:
                                    result2 = BridgeDriver.execute_script("return updateNonce("+str(ThePeg.noncesync)+");")
                                else:
                                    if merkleHashes != False and 'noncesync' in merkleHashes:
                                        result2 = BridgeDriver.execute_script("return updateNonce("+str(merkleHashes['noncesync'])+");")                                    
                            except:
                                traceback.print_exc()
                            try:
                                result2 = BridgeDriver.execute_script("return getRoots();")
                                for bridges in result2:
                                    if ThePeg.testthis == 1:
                                        mynonce = ThePeg.noncesync[bridges]
                                        if result2[bridges][0] == mynonce:
                                            if bridges not in ThePeg.Pegdatabase['merkles']:
                                                ThePeg.Pegdatabase['merkles'][bridges]={}
                                            if result2[bridges][1] in ThePeg.Pegdatabase['merkles'][bridges]:
                                                ThePeg.noncesync[bridges] += 1
                                            else:
                                                if result2[bridges][1] == 0:
                                                    self.votemerkles[bridges] = 0
                                                else:
                                                    self.votemerkles[bridges] = result2[bridges][1]
                                    else:
                                        if merkleHashes != False:
                                            if bridges in merkleHashes:
                                                if result2[bridges][0] == merkleHashes[bridges]['mylen']:
                                                    if result2[bridges][1] in merkleHashes[bridges]:
                                                        merkleHashes[bridges]['mylen'] += 1
                                                    else:
                                                        if result2[bridges][1] == 0:
                                                            self.votemerkles[bridges] = 0
                                                        else:
                                                            self.votemerkles[bridges] = result2[bridges][1]
                            except:
                                traceback.print_exc()     
                        if thecount % 180 == 0:
                            if ThePeg.testthis == 1:
                                if 'bridgeautomation' in AdvanceArray:
                                    if self.waitingconf == 0:
                                        if AdvanceArray['bridgeautomation']['votes'] != {} and self.confirmedvotes == {}:
                                            try:
                                                if thepriv != "":
                                                    result2 = BridgeDriver.execute_script("return sendVotes("+str(AdvanceArray['bridgeautomation']['votes'])+",'"+thepriv+"');")
                                                    if result2 == True:
                                                        self.waitingconf = 1
                                            except:
                                                traceback.print_exc()
                                    else:
                                        try:
                                            result2 = BridgeDriver.execute_script("return getVotes();")
                                            if result2 == True:
                                                self.confirmedvotes = copy.deepcopy(AdvanceArray['bridgeautomation']['votes'])
                                                self.waitingconf = 0
                                        except:
                                            traceback.print_exc()
                            else:
                                newvotes = {}                                
                                for key, val in merkleHashes['out'].iteritems():
                                    if merkleHashes['out'][key]['lastIndex'] < len(merkleHashes['out'][key]['list']):
                                        newvotes[key]['root'] = merkleHashes['out'][key]['list'][merkleHashes['out'][key]['lastIndex']][0]
                                        newvotes[key]['section'] = merkleHashes['out'][key]['list'][merkleHashes['out'][key]['lastIndex']][1]
                                if self.waitingconf == 0:
                                    if newvotes != {}:
                                        try:
                                            if thepriv != "":
                                                result2 = BridgeDriver.execute_script("return sendVotes("+str(newvotes)+",'"+thepriv+"');")
                                                if result2 == True:
                                                    self.waitingconf = 1
                                        except:
                                            traceback.print_exc()
                                else:
                                    try:
                                        result2 = BridgeDriver.execute_script("return getVotes();")
                                        if result2 == True:
                                            self.waitingconf = 0
                                    except:
                                        traceback.print_exc()
                    if ThePeg.testthis == 1 and thecount % 180 == 0:
                        nonce = str(ThePeg.Pegdatabase['merklenonce'])
                        poolprev = copy.deepcopy(ThePeg.Pegdatabase['bridgepool'])
                        fundsprev = ThePeg.Pegdatabase['fundsout']
                        try:
                            if nonce in ThePeg.Pegdatabase['merklelist']:
                                if ThePeg.Pegdatabase['merklelist'][nonce]['timestamp'] + ((ThePeg.Pegdatabase['merkleTimelimit']) * 2) < timestamp:
                                    ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'] = {}
                                    for mytx in ThePeg.Pegdatabase['merklelist'][nonce]['transactions']:
                                        x = 0                            
                                        name = ''
                                        #In production will want to ensure that variables can't be changed while processing.
                                        while x < len(ThePeg.Pegdatabase['bridgedb']['bridges']):
                                            if mytx['network'] == ThePeg.Pegdatabase['bridgedb']['bridges'][x]['n']:
                                                name=mytx['network']
                                                break
                                            x+=1
                                        try:
                                            if name == '':
                                                float('a')
                                            ThePeg.Pegdatabase['netdata'][name] = {'pegsteps':result[0][x]['1'],'microsteps':result[0][x]['2']}
                                            reserve = CompressFractions(mytx['pool'],ThePeg.Pegdatabase['merklelist'][nonce]['supply'],result[0][x]['1'],result[0][x]['2'])
                                            mydata = json.dumps([mytx['to'],reserve,mytx['txid']])
                                            myval = str(int(result[0][x]['1']) + int(result[0][x]['2']))
                                            myhash = BridgeDriver.execute_script("return getLeaf("+str(mydata)+","+myval+");")

                                            pegsteps = int(result[0][x]['1'])
                                            microsteps = int(result[0][x]['2'])
                                            currentsupply = int(ThePeg.Pegdatabase['merklelist'][nonce]['supply'])
                                            rate = 1200 / (pegsteps * microsteps)
                                            supply = int(currentsupply / rate)
                                            section = int(supply / microsteps)

                                            if name not in ThePeg.Pegdatabase['merklelist'][nonce]['finalTX']:
                                                ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][name] = {'leaves':[],'section':section}
                                            ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][name]['leaves'].append(myhash)
                                            if name not in ThePeg.Pegdatabase['bridgepool']:
                                                ThePeg.Pegdatabase['bridgepool'][name]=[0]*1200
                                            if name not in ThePeg.Pegdatabase['fundsout']:
                                                ThePeg.Pegdatabase['fundsout'][name]=0
                                            tot=0
                                            inx=0
                                            for val in mytx['pool']:
                                                tot+=val
                                                ThePeg.Pegdatabase['bridgepool'][name][inx]+=val
                                                inx+=1
                                            ThePeg.Pegdatabase['fundsout'][name] += tot                                
                                        except:
                                            print "Error converting fractions"
                                            #A single transaction may be discarded for an invalid address. However handle errors to make sure a valid TX is not discarded
                                            #Still, we don't want all of the other transactions to be held up because of one that fails.
                                            traceback.print_exc()
                                    for name2 in ThePeg.Pegdatabase['merklelist'][nonce]['finalTX']:
                                        ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][name2]['leaves'].sort() #They should have been deterministic but will sort just in case
                                        ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][name2]['root']=BridgeDriver.execute_script("return createMerkle("+str(ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][name2]['leaves']).replace(' u','').replace('[u','[')+");")
                                        print "Processed Merkle Tree:" + str(ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][name2]['root'])
                                    ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'] = ast.literal_eval(json.dumps(ThePeg.Pegdatabase['merklelist'][nonce]['finalTX']))
                                    if ThePeg.Pegdatabase['merklenonceTX'] <= nonce and ThePeg.Pegdatabase['merklelist'][nonce]['transactions'] == []:
                                        pass
                                    else:
                                        ThePeg.Pegdatabase['merklelist'][nonce]['transactions'] = [] #This could in theory be recovered so it can be pruned
                                        ThePeg.Pegdatabase['merklenonce'] += 1
                        except:
                            ThePeg.Pegdatabase['bridgepool'] = copy.deepcopy(poolprev)
                            ThePeg.Pegdatabase['fundsout'] = fundsprev
                            traceback.print_exc()
            except:
                MySettingsInfo = "Bridge thread crashed."
                traceback.print_exc()
TheBridgeThread = BridgeThread("TheBridgeThread")
TheBridgeThread.start()
def CompressFractions(pool, currentsupply, pegsteps, microsteps):
    currentsupply = int(currentsupply)
    pegsteps = int(pegsteps)
    microsteps = int(microsteps)
    rate = 1200 / (pegsteps * microsteps)
    supply = int(currentsupply / rate)
    section = int(supply / microsteps)
    newpool = [0] * (pegsteps + microsteps)
    myinx = 0
    while myinx < pegsteps:
        if myinx == section:
            x=0
            y=0
            while x<microsteps:
                z=0
                while z<rate:
                    newpool[pegsteps+x]+=pool[(myinx*(rate*microsteps))+y]
                    y+=1
                    z+=1
                x+=1
        else:
            x=0
            while x<(rate*microsteps):
                newpool[myinx]+=pool[(myinx*(rate*microsteps))+x]
                x+=1
        myinx+=1
    return copy.deepcopy(newpool)
def DecompressFractions(pool, name, section, pegsteps, microsteps):
    pegsteps = int(pegsteps)
    microsteps = int(microsteps)
    rate = 1200 / (pegsteps * microsteps)
    newpool = [0] * (1200)
    myinx = 0
    bridgepool = copy.deepcopy(ThePeg.Pegdatabase['bridgepool'][name])
    while myinx < pegsteps:
        if myinx == section:
            remainder=0
            z=0
            while z<microsteps:
                if pool[pegsteps + z]>0:
                    position=(myinx*(rate*microsteps))+(z*rate)
                    thetotal=0
                    x=0
                    while x<(rate):
                        thetotal+=bridgepool[position+x]
                        x+=1                
                    #Take what we can and later check the entire section for what remained
                    if thetotal < pool[pegsteps + z]:
                        remainder+=(pool[pegsteps + z]-thetotal)
                        pool[pegsteps + z]-=thetotal
                        x=0
                        while x<(rate):
                            newpool[position+x]+=bridgepool[position+x]
                            bridgepool[position+x]=0
                            x+=1
                    else:
                        tot=pool[pegsteps + z]
                        x=0
                        while x<(rate):
                            val=int((bridgepool[position+x] * pool[pegsteps + z])/thetotal)
                            bridgepool[position+x]-=val
                            tot-=val
                            newpool[position+x]+=val
                            x+=1
                        if tot>0:
                            x=0
                            while x<(rate):
                                if bridgepool[position+x] > 1:
                                    bridgepool[position+x]-=1
                                    tot-=1
                                    newpool[position+x]+=1
                                x+=1
                                if tot==0:
                                    break
                        if tot != 0:
                            return False
                        pool[pegsteps + z]=0
                z+=1
            if remainder > 0:
                position=(myinx*(rate*microsteps))
                thetotal=0
                x=0
                while x<(rate*microsteps):
                    thetotal+=bridgepool[position+x]
                    x+=1                
                if thetotal < remainder:
                    return False
                tot=remainder
                x=0
                while x<(rate*microsteps):
                    val=int((bridgepool[position+x] * remainder)/thetotal)
                    bridgepool[position+x]-=val
                    tot-=val
                    newpool[position+x]+=val
                    x+=1
                if tot>0:
                    x=0
                    while x<(rate*microsteps):
                        if bridgepool[position+x] > 1:
                            bridgepool[position+x]-=1
                            tot-=1
                            newpool[position+x]+=1
                        x+=1
                        if tot==0:
                            break
                if tot != 0:
                    return False                
        else:
            if pool[myinx]>0:
                position=(myinx*(rate*microsteps))
                thetotal=0
                x=0
                while x<(rate*microsteps):
                    thetotal+=bridgepool[position+x]
                    x+=1                
                if thetotal < pool[myinx]:
                    return False
                tot=pool[myinx]
                x=0
                while x<(rate*microsteps):
                    val=int((bridgepool[position+x] * pool[myinx])/thetotal)
                    bridgepool[position+x]-=val
                    tot-=val
                    newpool[position+x]+=val
                    x+=1
                if tot>0:
                    x=0
                    while x<(rate*microsteps):
                        if bridgepool[position+x] > 1:
                            bridgepool[position+x]-=1
                            tot-=1
                            newpool[position+x]+=1                        
                        x+=1
                        if tot==0:
                            break
                if tot != 0:
                    return False
        myinx+=1
    return copy.deepcopy(newpool)
class FileThread(QtCore.QThread):#Safe File saving thread
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        self.url = url
        self.messageonce=0
        self.amrunning=True
    def stop(self):
        self.amrunning=False
    def SaveQueue(self, BitQueue1):
        with open(os.path.join(application_path,"BitQueue.dat"),'a+') as f:
            f.close()
        with open(os.path.join(application_path,"BitQueue.dat"),'w') as f:
            f.write(str(BitQueue1))
            f.flush()
            os.fsync(f)
            f.close()
    def SaveTranslations(self, translations1):
        with open(os.path.join(application_path,"Translations.dat"),'w') as f:
            f.write(str(translations1))
            f.flush()
            os.fsync(f)
            f.close()
    def SaveCFG(self, cfg_path,cfg):
        with open(os.path.join(cfg_path), 'w') as f:
            f.write(cfg)
            f.flush()
            os.fsync(f)
            f.close()
    def SaveContracts(self, MyContracts1, OnOrders1, multisig):
        #This part opens the contracts and saves them
        data=[]#Need to do this more frequently
        backup=GetfromCfg("#BackupPath#")
        with open(os.path.join(application_path,"Contracts.dat"),'a+') as f:
            f.close()
            pass
        try:
            with open(os.path.join(application_path,"Contracts.dat"),'r') as f:
                data=f.readlines()
                f.close()
        except:
            return

        i=0
        pos=0
        pop=0
        st=""
        for d in data:
            if d[0]=="#":
                #Here we look for our data and see if there was any orders in it under our name.
                try:
                    if data[i+1].strip()==multisig:
                        pos=i
                        pop=1
                except:
                    pass #print "Exception"
                    return
            i+=1
        if pop==1:#remove the old data we will just move it to the end of the file
            data.pop(pos)
            data.pop(pos)
            data.pop(pos)
            data.pop(pos)
        if multisig:
            st+="#"
            if MyContracts1:
                st+="$"
            else:
                st+=" "
            if OnOrders1:
                st+="%"
            else:
                st+=" "
            data.append(st+"\n")
            data.append(multisig+"\n")
            data.append(str(MyContracts1)+"\n")
            data.append(str(OnOrders1)+"\n")
        try:
            with open(os.path.join(application_path,"Contracts.dat"),'w') as f:
                for d in data:
                    f.write(str(d))
                f.flush()
                os.fsync(f)
                f.close()
        except:
            f.flush()
            os.fsync(f)
            f.close()
        if backup != " ":#Our backup is live... we make a new one after a certain size is reached
            try:
                with open(strOUT(backup),'a+') as f:
                    f.close()
            except:
                if self.messageonce==0:
                    self.messageonce=1
                    UpdateCfg('#BackupPath#'," ")
            try:
                with open(strOUT(backup), 'r') as f:
                    data2=f.readlines()
                    f.close()
                if os.path.getsize(strOUT(backup))>10000000:#10000000
                    try:
                        bk=strOUT(backup)+".bak"
                        with open(os.path.join(bk), 'a+') as f:
                            f.close()
                        with open(os.path.join(bk), 'w') as f:
                            for d in data2:
                                f.write(str(d))
                            f.flush()
                            os.fsync(f)
                            f.close()
                        with open(strOUT(backup),'w') as f:#Don't let it get so big just overwrite the old information
                            f.flush()
                            os.fsync(f)
                            f.close()
                    except Exception, e:
                        traceback.print_exc()
                        f.flush()
                        os.fsync(f)
                        f.close()
                d=" "
                for d in data2:
                    pass
                try:
                    d=ast.literal_eval(d.strip())
                except:
                    pass
                BackupNoDetails=[]
                #We are going to filter out images for now so backup files are smaller
                for c in MyContracts1:
                    e=json_deep_copy(c,1)
                    if 'Details' in c:
                        if 'image' in c['Details']:
                            e['Details']['image']=""
                    BackupNoDetails.append(e)
                if d!=BackupNoDetails:#Append at the end something new has happened. We have to take contracts pretty seriously so everything is saved
                    with open(strOUT(backup),'a') as f:
                        f.write("\n"+str(HaloTime)+"\n")
                        for d in data:
                            try:
                                t=ast.literal_eval(d.strip())
                                for e in t:
                                    pos=0
                                    if 'Details' in e:
                                        if 'image' in e['Details']:
                                            t[pos]['Details']['image']=""
                                    pos+=1
                                d=str(t)+"\n"
                            except Exception,e:
                                pass
                            f.write(str(d))#old stuff
                        f.write(str(BackupNoDetails))#Last change... contracts are the best indicator of change
                        f.flush()
                        os.fsync(f)
                        f.close()
            except:
                return
    def SaveOtherData(self, a,b,c,d,e,z):
        with open(os.path.join(application_path,"Other.dat"),'a+') as f:
            f.close()
            pass
        with open(os.path.join(application_path,"Other.dat"),'w') as f:
            f.write(str(a)+"\n")
            f.write(str(b)+"\n")
            f.write(str(c)+"\n")
            f.write(str(d)+"\n")
            f.write(str(e)+"\n")
            f.write(str(z)+"\n")
            f.flush()
            os.fsync(f)
            f.close()
    def run(self):
        global DontExit
        Contracts=[]
        Orders=[]
        cfg=""
        a=""
        b=""
        c=""
        d=""
        e=""
        f=""
        Queue=""
        trans=""
        self.Queue = []
        while self.amrunning:
            if self.Queue == []:
                DontExit[3]=0
            else:
                DontExit[3]=1
            time.sleep(.1)
            try:#We have to be careful that it doesnt get changed/added to while iterating
                for Q in self.Queue:
                    if "SaveContracts" in Q:
                        if Q['Contracts']!=Contracts or Q['Orders']!=Orders:
                            Contracts=Q['Contracts']
                            Orders=Q['Orders']
                            self.SaveContracts(Contracts,Orders,Q['multisig'])
                    if "SaveCFG" in Q:
                        if Q['CFG']!=cfg:
                            cfg=Q['CFG']
                            self.SaveCFG(Q['PATH'],Q['CFG'])
                    if "SaveOther" in Q:
                        if Q['DontRepopulate']!=a or Q['EscrowResults']!=b or Q['WatchlistQueue']!=c or Q['HistoryDetail']!=d or Q['AdvanceArray']!=e or Q['Markets']!=f:
                            a=Q['DontRepopulate']
                            b=Q['EscrowResults']
                            c=Q['WatchlistQueue']
                            d=Q['HistoryDetail']
                            e=Q['AdvanceArray']
                            f=Q['Markets']
                            self.SaveOtherData(a,b,c,d,e,f)
                    if "SaveQueue" in Q:
                        if Q['BitQueue']!=Queue:
                            Queue=Q['BitQueue']
                            self.SaveQueue(Q['BitQueue'])
                    if "SaveTrans" in Q:
                        if Q['translations']!=trans:
                            trans=Q['translations']
                            self.SaveTranslations(Q['translations'])
                    self.Queue.pop(0)
            except:
                traceback.print_exc()
        return
FileSave = FileThread("RPCThread")
FileSave.start()
class RPCThread(QtCore.QThread):#Api thread
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        self.mstatus=0
        self.mtime=time.time()
        self.url=url
        self.public=""
        self.APIhist={}
    def stop(self):
        self.exit()
    # Register an instance; all the methods of the instance are
    # published as XML-RPC methods (in this case, just 'div').
    class MyFuncs:
        def SetPassword(self,newpassw='',passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            ThePeg.apipassword=newpassw
            return True
        def StartExchange(self, passw='', start=1, isrunning=0):#Test exchange for the peg enforced client side
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if isrunning==1:
                if ThePeg.exchangeready==0:
                    return False
                else:
                    return True
            if start==1:
                ThePeg.startexchange=1
                ThePeg.exchangerunning=True
            else:
                ThePeg.startexchange=0
            return True
        def ShutDown(self, passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            ThePeg.stopexchange=1
            window.ExitHalo()
            return True
        def ExchangePassword(self,xpassw='',passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            ThePeg.exchangepassword=xpassw
            return True
        def GenerateDepositAddress(self,passw=''):
            global SALT
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password", ''
            if ThePeg.stopexchange==1 or ThePeg.startexchange==0:
                return "Exchange is stopped.", ''
            key=txhash(os.urandom(16).encode('hex')+SALT)
            key=encode_privkey(key, 'wif_compressed', 25)
            res=ThePeg.AddToQueue([os.urandom(16).encode('hex'),{'data':{'key':key},'command':'NewAddress'}])
            return key, res
        def GetSpendable(self, address='', passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            #It is recommended to search one address at a time
            Spn={}
            for s in ThePeg.Spendable:
                addthis=0
                if ThePeg.Spendable[s]['address']==address or address=='':
                    addthis=1
                if addthis==1:
                    Spn[s]={}
                    if 'liquidity' not in ThePeg.Spendable[s]:
                        Spn[s]['amount']=str(int(Decimal(ThePeg.Spendable[s]['amount'])*Decimal(1e8)))
                        Spn[s]['rtotal']=0
                        Spn[s]['ltotal']=0
                        Spn[s]['nfreeze']=0
                        Spn[s]['supply']=0
                    else:
                        Spn[s]['rtotal']=str(ThePeg.Spendable[s]['liquidity']['rtotal'])
                        Spn[s]['ltotal']=str(ThePeg.Spendable[s]['liquidity']['ltotal'])
                        Spn[s]['amount']=str(Spn[s]['rtotal']+Spn[s]['ltotal'])
                        Spn[s]['nfreeze']=str(ThePeg.Spendable[s]['liquidity']['nfreeze'])
                        Spn[s]['supply']=ThePeg.Spendable[s]['liquidity']['supply']
                    if 'change' in ThePeg.Spendable[s]:
                        Spn[s]['change']=1
                    Spn[s]['address']=ThePeg.Spendable[s]['address']
                    Spn[s]['confirmations']=str(ThePeg.Spendable[s]['confirmations'])
            return Spn
        def Deposit(self, name, txids, passw='', allowchangerecovery=0):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if name.lower()=='total' or name.lower()=='pool'or name.lower()=='frozen' or name.lower()=='x' or name.lower()=='exchange' or name.lower()=='withdraws':
                return "Name reserved for exchange operations. Please use different name."
            if len(name)<4:
                return "Name is too short in length."
            if ThePeg.stopexchange==1 or ThePeg.startexchange==0:
                return "Exchange is stopped."
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            for i in txids:
                if i not in ThePeg.Spendable:
                    return str(i) + " not in Spendable list yet."
                if 'change' in ThePeg.Spendable[i] and allowchangerecovery==0:
                    return "You can not deposit change transactions."
            res=ThePeg.AddToQueue([os.urandom(16).encode('hex'),{'data':{'name':name,'txids':txids},'command':'Deposit'}])
            return res
        def GetDeposits(self, txid='', passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            try:
                if txid=='':
                    return ThePeg.accounts['txids']
                else:
                    return ThePeg.accounts['txids'][txid]
            except:
                traceback.print_exc()
                return False
        def GetBalance(self, user, passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            try:
                if ThePeg.updatingbalance==1:
                    return "Balance is updating"
                if ThePeg.stopexchange==1 or ThePeg.startexchange==0:
                    return "Exchange is stopped."
                if user.lower()=='exchange':
                    return ThePeg.ExchangeBalance
                else:
                    return ThePeg.accounts2['users'][user]
            except:
                traceback.print_exc()
                return False
        def Trade(self, user1, amount, user2, style='liquid', passw='', withdraw='', uniqueid=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if ThePeg.updatingbalance==1:
                return "Exchange is busy. Please try again in a few minutes."
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            if ThePeg.stopexchange==1 or ThePeg.startexchange==0:
                return "Exchange is stopped."
            name=user1
            if name.lower()=='total' or name.lower()=='pool'or name.lower()=='frozen' or name.lower()=='x' or name.lower()=='exchange' or name.lower()=='withdraws':
                return "Name reserved for exchange operations. Please use different name."
            if len(name)<4:
                return "Name is too short in length."
            name=user2
            if name.lower()=='withdraws' and withdraw=='':
                return "Name reserved for exchange operations. Please use different name."
            if name.lower()=='total' or name.lower()=='pool'or name.lower()=='frozen' or name.lower()=='x' or name.lower()=='exchange':
                return "Name reserved for exchange operations. Please use different name."
            if len(name)<4 and name!='':
                return "Name is too short in length."
            if user2=='':
                #They don't want to signal both trading partners. Instead they will add/subtract from a pool.
                #This technique is not recommended for exchanges and is only useful when there is limited information available
                #The technique should be to deduct first and add later when there is enough in the pool
                if amount < 0:#Deduction
                    amount=abs(amount)
                    user2='pool'
                else:#Take from pool
                    user2=user1
                    user1='pool'
            if user2 not in ThePeg.accounts2['users']:
                ThePeg.accounts2['users'][user2]={'liquid':0,'reserve':0}
            if ThePeg.exchangebusy==1:
                if 'temp' not in ThePeg.accounts2['users'][user1]:
                    ThePeg.accounts2['users'][user1]['temp']={'liquid':0,'reserve':0}
                if 'temp' not in ThePeg.accounts2['users'][user2]:
                    ThePeg.accounts2['users'][user2]['temp']={'liquid':0,'reserve':0}
            if amount<0:
                return "Amount can not be negative if both users are known"
            if amount>ThePeg.accounts2['users'][user1][style]:
                if user1=='pool':
                    return "Insufficient funds in " + style + " pool. Please make the debit before the credit."
                else:
                    return "Insufficient "+style+" balance"
            ThePeg.accounts2['users'][user1][style]-=amount
            ThePeg.accounts2['users'][user2][style]+=amount
            if ThePeg.exchangebusy==1:
                ThePeg.accounts2['users'][user1]['temp'][style]-=amount
                ThePeg.accounts2['users'][user2]['temp'][style]+=amount
            res=ThePeg.AddToQueue([os.urandom(16).encode('hex'),{'data':{'user1':user1,'user2':user2,'amount':amount,'style':style,'cycle':ThePeg.exchangecycle,'withdraw':withdraw,'ID':uniqueid},'command':'Trade'}])
            return res
        def Withdraw(self, user, amount, address, style='liquid', passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password", ''
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            if address=='':
                return False, ''
            try:
                b58check_to_hex(address)
            except:
                return "Withdraw address not valid", ''
            if amount <= ThePeg.exchange['commission']['min']+10000:
                return "Withdraw amount is too low", ''
            if ThePeg.stopexchange==1 or ThePeg.startexchange==0:
                return "Exchange is stopped.", ''
            uniqueid=os.urandom(16).encode('hex')
            #Check the withdraw limit here
            if style=='liquid':
                if ThePeg.liquidlimit<len(ThePeg.liquidwithdrawcount)+len(ThePeg.exchange['withdraws']['liquid']):
                    return "Withdraw limit reached, please wait until transactions clear.", ''
            else:
                if ThePeg.reservelimit-1<len(ThePeg.reservewithdrawcount)+len(ThePeg.exchange['withdraws']['reserve']):
                    return "Reserve withdraw limit reached, please wait until transactions clear.", ''
            res=self.Trade(user, amount, 'withdraws', style, passw, address, uniqueid)
            if res:
                if style=='liquid':
                    ThePeg.liquidwithdrawcount[uniqueid]=1
                else:
                    ThePeg.reservewithdrawcount[uniqueid]=1
            return res, uniqueid
        def CheckWithdraw(self, ID, clear=0, passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            try:
                ID2=ThePeg.exchange['withdraws']['history'][ID]
            except:
                ID2=ID
            if not isinstance(ID2, dict):
                try:
                    ID2=ThePeg.exchange['withdraws']['history'][ID2]
                except:
                    ID2="ID not found"
            if clear==1:
                ThePeg.clearID[ID]=1
            return ID2
        def ExchangeSettings(self, exchangeaccounts='', exchangefeeaccount='', commission='', exchangeconfirmations='', passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if ThePeg.stopexchange==1 or ThePeg.startexchange==0:
                return "Exchange is stopped."
            if exchangeaccounts !='':
                if not type(exchangeaccounts) is list:
                    return "Exchange accounts must be a list and must contain all accounts used by the exchange for receiving change."
                ThePeg.exchange['exchangeaccounts']=exchangeaccounts
            #This is an account for fees during the processing of withdraws. Trading fees should be
            #deducted manually as if it was an actual trade to a standard exchange account.
            if exchangefeeaccount !='':
                ThePeg.exchange['exchangefeeaccount']=exchangefeeaccount
            #Commission for withdraw. Should be at least over 10000 to cover staking fees
            if commission !='':
                if commission['percent']<0:
                    return False
                if commission['percent']>.05:
                    return "Commission is too high."
                if commission['max']<commission['min']:
                    return False
                if commission['min']<10000:
                    return "Minimum commission should be high enough to cover basic fees and maintenance."
                ThePeg.exchange['commission']={'min':100000000,'max':1000000000,'percent':.001}
                ThePeg.exchange['commission']['min']=commission['min']
                ThePeg.exchange['commission']['max']=commission['max']
                ThePeg.exchange['commission']['percent']=commission['percent']
            if exchangeconfirmations!='':
                if exchangeconfirmations<7:
                    return "Not enough confirmations"
                if exchangeconfirmations>15:
                    return "Too many confirmations"
                ThePeg.exchangeconfirmations=exchangeconfirmations
            ThePeg.saveexchange=1
            return True
        def GetCycle(self, passw=''):
            if ThePeg.apipassword!='':
                if passw!=ThePeg.apipassword:
                    return "Incorrect Password"
            if ThePeg.exchangeready==0:
                return "Exchange is not loaded yet."
            return ThePeg.exchangecycle
        def ShowHalo(self, pw='', coldstake=''):
            if coldstake!='':
                if AdvanceArray['MySettings']['ColdStake']!='':
                    return "AlreadyStaking"
            if pw=='':
                return True
            if coldstake=='':
                window.setWindowState(window.windowState() & ~QtCore.Qt.WindowMinimized | QtCore.Qt.WindowActive)
                window.activateWindow()
            window.show()
            return True
        def API(self, command):
            global RPC
            #Example of how to use the API:
            #sig=highlevelcrypto.sign(txhash('print "Hello world"'), privatekey)
            #sig=base64.b64encode(sig)
            #HaloRPC = xmlrpclib.ServerProxy('http://localhost:55779')
            #HaloRPC.API({'sig':sig,'exec':'print "Hello world"'})
            if RPC.public!="" and os.path.exists(os.path.join(application_path, 'API.share')):
                myhash=txhash(command['exec'])
                if myhash not in RPC.APIhist:
                    RPC.APIhist[myhash]=''
                else:#Just in case we will want users to always slightly change the commands hash
                    return "Command sent previously"
                res=highlevelcrypto.verify(myhash,base64.b64decode(command['sig']),RPC.public)
                if res:
                    result=True
                    try:
                        exec(command['exec'])#Here you can set the result as well
                    except:
                        return str(traceback.format_exc())
                    return result
                else:
                    return "Signature failed"
            return False
        def ColdStake(self, msg, multiscript, sigs2, stakeinput, mystakeouts, kerneltime, tx, blocktemplate, amt, val, chg):
            try:
                global BLK, AdvanceArray, AddNewOrders, OnOrders, MasterOrders
                amt=int(amt)
                val=int(val)
                chg=int(chg)
                kerneltime=int(kerneltime)
                indx=0
                for item in stakeinput:
                    stakeinput[indx]['value']=int(stakeinput[indx]['value'])
                    indx+=1
                indx=0
                for item in mystakeouts:
                    mystakeouts[indx]['value']=int(mystakeouts[indx]['value'])
                    indx+=1 
                if AdvanceArray['MySettings']['Staking'] and IsUnlocked() and keysconnected != "0":
                    pass
                else:
                    return "", False
                for ords in OnOrders:
                    if 'type' in ords:
                        if ords['type']=="CONTRACT" or ords['type']=="2STEP" or ords['type']=="SPENT" or ords['type']=="PAY TO EMAIL":
                            if stakeinput[0]['output'] in str(ords):#A contract or spend reserved this input
                                return "", False
                if stakeinput[0]['output'] in MasterOrders:
                    return "", False
                if 'StakedOrders' in AdvanceArray:
                    if stakeinput[0]['output'] in str(AdvanceArray['StakedOrders']):
                        return "", False                                
                msig,multiscript=create_multisig_address(PrivKeyFilename1)
                mainaccount=0
                if msig==msg:
                    mainaccount=1
                res1=False
                if mainaccount==0:
                    try:                        
                        msig,multiscript=create_multisig_address(AdvanceArray['StakingAccounts'][msg]['key1'], AdvanceArray['StakingAccounts'][msg]['dir1'])
                        if msig!=msg:
                            return "", False
                        try:
                            pw1=password.DecryptWithAES(str("Halo Master"), AdvanceArray['StakingAccounts'][msg]['pw1'])
                        except:
                            pw1=AdvanceArray['StakingAccounts'][msg]['pw1']
                        sigs, res1=create_sig_for_redemption(stakeinput, mystakeouts, AdvanceArray['StakingAccounts'][msg]['key1'], AdvanceArray['StakingAccounts'][msg]['dir1'], kerneltime, 0, tx, pwtext=pw1)
                    except:
                        pass
                else:
                    sigs, res1=create_sig_for_redemption(stakeinput, mystakeouts, PrivKeyFilename1, PrivKeyFiledir1, kerneltime, 0, tx)
                itsvalid=0
                for stakeout in mystakeouts:
                    if stakeout['value'] >= stakeinput[0]['value']: #For now we leave room to donate the stake profits, the maximum voting payments are 111080
                        if stakeout['script'] == address_to_script(stakeinput[0]['address']):
                            itsvalid=1
                if itsvalid==0 or len(stakeinput)>1:
                    return "", False
                if res1==False:
                    return "", False
                pos=0
                pos2=0
                whoisfirst=1#Our swapping function is backwards
                if mainaccount==0:                                        
                    pubs=get_ordered_pubkeys(AdvanceArray['StakingAccounts'][msg]['key1'], AdvanceArray['StakingAccounts'][msg]['dir1'])
                else:
                    pubs=get_ordered_pubkeys(PrivKeyFilename1)
                testmg,sc=create_multisig_from_publics(pubs[0],pubs[1])
                testmg1,sc=create_multisig_from_publics(pubs[1],pubs[0])
                if mainaccount==0:
                    if need_swap(get_ordered_pubkeys(AdvanceArray['StakingAccounts'][msg]['key1'], AdvanceArray['StakingAccounts'][msg]['dir1']), AdvanceArray['StakingAccounts'][msg]['key1'], AdvanceArray['StakingAccounts'][msg]['dir1']):
                        whoisfirst=0
                else:
                    if need_swap(get_ordered_pubkeys(PrivKeyFilename1)):
                        whoisfirst=0
                for inp in stakeinput:
                    if inp['address']==msg:
                        if whoisfirst==1:
                            mysigs=[sigs[pos2],sigs2[pos2]]
                        else:
                            mysigs=[sigs2[pos2],sigs[pos2]]
                        pos2+=1
                        tx = apply_multisignatures(tx,pos,multiscript,mysigs)
                    pos+=1
                print "Found Cold Stake: ", txhash(tx)
                self.tx=tx
                self.mainaccount=mainaccount
                self.msg=msg
                self.amt=amt
                self.val=val
                self.chg=chg
                self.mystakeouts=mystakeouts
                self.stakeinput=stakeinput
                self.kerneltime=kerneltime
                #We cannot submit the cold stake block from the 
                #res=BLK.submitblock(blocktemplate,{'coinstake':tx})
                return tx, True
            except:
                print "Cold Stake Failed!"
                return "", False
        def ConfirmColdStake(self, tx):
            global BLK, AdvanceArray, AddNewOrders
            if tx==self.tx:
                NewOrder={}
                #Both regular expenses and pay to email still wait on the same change.
                NewOrder['type']="SPENT"
                NewOrder['stake']=True
                NewOrder['ordernumber']=os.urandom(16).encode('hex')
                NewOrder['total']=self.val
                NewOrder['change']=str(Decimal(self.chg)/Decimal(1e8))#-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8))
                NewOrder['currentblock']=CurrentBlock
                NewOrder['Confirmation TXID']=txhash(tx)
                NewOrder['inputs']=self.stakeinput
                NewOrder['output']=self.mystakeouts
                NewOrder['amount']=self.amt
                NewOrder['fee']=0
                NewOrder['address']=self.msg
                NewOrder['timestamp']=self.kerneltime
                NewOrder['version']=CoinSelect['HaloName'] + " " + clientversion
                #For the sake of speed, we don't make this RPC command wait so any editing of major data needs to be done in the main thread
                AddNewOrders.append({'mainaccount': self.mainaccount, 'msg': self.msg, 'NewOrder': NewOrder})
                print "Cold Stake Success!"
                return True
            else:
                print "Error adding order data from Cold Stake"
                return False
        def MessageStatus(self, status):#For dropped bitmessage imap connections, tracking the process is failsafe
            global RPC, BMStartTime
            BMStartTime=time.time()
            RPC.mstatus=int(status)
            RPC.mtime=time.time()
            return True
    def run(self):
        # Create server
        server = SimpleXMLRPCServer(("", 55779),requestHandler=RequestHandler, logRequests = False)#Used to be 8877
        server.register_introspection_functions()
        #Register functions
        server.register_instance(self.MyFuncs())
        # Run the server's main loop
        server.serve_forever()
class BitMessageThread(QtCore.QThread):#For sending messages and pre/post processing
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        self.url = url
        self.amrunning=True
    def stop(self):
        self.amrunning=False
    def run(self):
        data=['0']*7
        BitAddr=GetfromCfg("#BitMessage#")
        global BitAddrGlob, EmailPassword, AuthError, BitmessageStatus, Markets, DontExit, AdvanceArray, NewBitAddr, LockTHIS, Exiting, ManualPassword, MyEmail, BMHasPW, BMStartTime, BitMRPC
        BitAddrGlob=BitAddr
        BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')
        action=1
        with open(os.path.join(application_path,"BitTMP.dat"),'a+') as f:
            f.close()
        if os.stat(os.path.join(application_path,"BitTMP.dat"))[6]==0:
            try:
                with open(os.path.join(application_path,"BitTMP.dat"),'w') as f:
                    f.write("1"+"\n")#It starts out as our turn
                    f.write(""+'\n')#The second line is for commands and lines
                    f.flush()
                    os.fsync(f)
                    f.close()
            except:
                f.close()
        global BitQueue, MyMessages, RPC
        emptytemp=0
        BMStartTime=time.time()
        while self.amrunning:#Will need a queue list for functions that are called multiple times
            try:
                if os.stat(os.path.join(application_path,"BitTMP.dat"))[6]==0:                    
                    emptytemp+=1
                    if emptytemp>500:
                        BMStartTime=time.time()
                        try:
                            with open(os.path.join(application_path,"BitTMP.dat"),'w') as f:
                                f.write("1"+"\n")#It starts out as our turn
                                f.write(""+'\n')#The second line is for commands and lines
                                f.flush()
                                os.fsync(f)
                                f.close()
                        except:
                            f.close()
                if RPC.mstatus==1:#Downloading a message
                    if int(time.time())-int(RPC.mtime)>720:#12 minutes to download a message
                        BMStartTime=time.time()
                        result=ResetBitMHalo()                        
                        Notification(1,"Email Timed Out!")
                        if result:
                            RPC.mstatus=0
                if int(time.time())-int(BMStartTime)>720:#12 minutes have passed and no response from BitMHalo, lets reset it
                    print "Resetting BitMHalo"
                    BMStartTime=time.time()
                    result=ResetBitMHalo()
            except:
                traceback.print_exc()
            skpread=0                
            try:
                result=BitMRPC.FileLock("0")
                if result==False:
                    skpread=1
            except:
                BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')                
            if skpread==0:
                try:                
                    with open(os.path.join(application_path,"BitTMP.dat"),'r') as f:
                        data[0]=f.readline().strip()
                        data[1]=f.readline().strip()
                        if data[1]=="new1":
                            data[2]=f.readline().strip()
                            #We should check and see if he had a bitmessage maybe they switched wallets and we never want to overwrite anything. If a new user gets loaded then will not know to make the request until loaded.
                            multisig,multiscript=create_multisig_address(PrivKeyFilename1)
                            data[3]=f.readline().strip()
                            dat=GetfromCfg("#BitMessage#")
                            try:
                                NewBitAddr.remove(data[3])
                            except:
                                pass
                            if data[3]==multisig:#If this doesn't match they must have switched accounts really fast
                                if dat!=data[2]:#They needed one or they have to switch.
                                    UpdateCfg('#BitMessage#',data[2], data[3])
                                    if CoinSelect['moderngui']==0:
                                        window.MyAddress_3.setText(Gtranslate("BITMESSAGE: ")+ data[2])
                                    else:
                                        window.ReceiveBitcoins.receiveBitMessageAddressLineEdit.setText(data[2])
                        if "GetMessages1" in data[1] or "Clean Inbox1" in data[1]:
                            #If we decide to not read messages compulsively we can choose to use the archive for all
                            #situations not only inbox cleansing. The code is in place in BitMHalo to support this
                            clean=0
                            if "Clean Inbox1" in data[1]:
                                clean=1
                            data[1]=data[1].replace("GetMessages1:","")
                            data[1]=data[1].replace("Clean Inbox1:","")
                            if "False:" in data[1]:
                                data[1].replace("False:","")
                                AuthError=1
                            try:
                                data[1]=ast.literal_eval(data[1])
                                BitmessageStatus=data[1]
                            except:
                                pass
                            data[2]=f.readline().strip()
                            MyMessages=data[2]
                            while True:
                                if 'AP' not in LockTHIS and 'UD' not in LockTHIS:
                                    break
                                if Exiting == 1:
                                    break 
                                time.sleep(.001)                       
                            LockTHIS['BM']=1
                            if "Clean Inbox1" in data[1]:
                                if 'Archive' not in AdvanceArray:
                                    AdvanceArray['Archive']={}
                                if multisig not in AdvanceArray['Archive']:
                                    AdvanceArray['Archive'][multisig]=[]
                                try:
                                    MyMessagesX=ast.literal_eval(MyMessages)
                                except:
                                    MyMessagesX=[]
                                    print "Clean Inbox Response: EVAL ERROR"                             
                                pos1=0
                                for mes in MyMessagesX:
                                    MyMessagesX[pos1]['archive']=1
                                    AdvanceArray['Archive'][multisig].append(MyMessagesX[pos1])
                                    pos1+=1
                            data[3]=f.readline().strip()
                            if str(data[3])[:5]!="False":
                                mydata=ast.literal_eval(data[3])
                                for mdat in mydata:
                                    for mkey in AdvanceArray['OUTBOX']:
                                        for msgid in AdvanceArray['OUTBOX'][mkey]:
                                            if AdvanceArray['OUTBOX'][mkey][msgid]['ackdata']==mdat['ackData']:
                                                if 'msgsent' in mdat['status'] or 'ackreceived' in mdat['status']:
                                                    AdvanceArray['OUTBOX'][mkey].pop(msgid)
                                                    OutboxWindow.populate()
                                                    break
                                                else:
                                                    if 'pow' in mdat['status']:
                                                        AdvanceArray['OUTBOX'][mkey][msgid]['status']="Computing POW"
                                                    else:
                                                        AdvanceArray['OUTBOX'][mkey][msgid]['status']=mdat['status']
                                                OutboxWindow.populate()
                            LockTHIS.pop('BM',None)
                            try:
                                LockTHIS.pop('BM',None)
                                SaveOtherdata()
                            except:
                                pass
                        if "chan1" in data[1]:
                            data[2]=f.readline().strip()
                            data[3]=f.readline().strip()
                            if data[2]!="Exception":
                                if "*"+data[2][:10] not in Markets['Banlist']:
                                    Markets["MyMarkets"][data[3]]=data[2]
                                UpdateMarketList()
                            try:
                                SaveOtherdata()
                            except:
                                pass
                        if "Send1" in data[1]:
                            while True:
                                if 'AP' not in LockTHIS and 'UD' not in LockTHIS:
                                    break
                                if Exiting == 1:
                                    break
                                time.sleep(.001)                        
                            LockTHIS['BM']=1
                            data[2]=f.readline().strip()
                            data[3]=f.readline().strip()
                            for mkey in AdvanceArray['OUTBOX']:
                                for msgid in AdvanceArray['OUTBOX'][mkey]:
                                    if msgid == data[3]:
                                        if str(data[2])[:5]=="False":
                                            data[2]=data[2].replace("False","",1)
                                            AdvanceArray['OUTBOX'][mkey][msgid]['status']="Email Failed"
                                            Notification(1, "Message Failure!")
                                            AdvanceArray['OUTBOX'][mkey][msgid]['data']=data[2]
                                        if str(data[2])[:4]=="True":
                                            AdvanceArray['OUTBOX'][mkey].pop(msgid)
                                        if str(data[2])[:4]!="True" and str(data[2])[:5]!="False":
                                            AdvanceArray['OUTBOX'][mkey][msgid]['ackdata']=str(data[2])
                                        OutboxWindow.populate()
                                        break
                            LockTHIS.pop('BM',None)
                            try:
                                LockTHIS.pop('BM',None)
                                SaveOtherdata()
                            except:
                                pass
                        f.close()
                except:
                    try:
                        LockTHIS.pop('BM',None)
                    except:
                        pass
                    traceback.print_exc()
                    print "Read exception from BitTMP"
                    try:
                        f.close()
                    except:
                        pass
                    pass #print "error" #Maybe the file was open we can just try again later
                try:
                    if data[0] == "1":
                        emptytemp=0
                        RPC.mstatus=0
                        RPC.mtime=time.time()
                        BMStartTime=time.time()
                        #A custom locking system is made for communicating between bitmessage api and this program. I had to do it this way since Bitmessage wanted to
                        #be in the main thread and was slowing down loading and causing errors otherwise. Will want to make it part of the main program in the future.
                        for command in BitQueue:
                            try:
                                if 'MyBMAddress' in BitQueue[0]:
                                    if "@" in BitQueue[0]['MyBMAddress']:
                                        try:#We should catch this early
                                            passw="*"
                                            if BitQueue[0]['MyBMAddress']==MyEmail:
                                                passw=GetEmailGlobals(BitQueue[0]['MyBMAddress'])
                                                if AdvanceArray['MySettings']['ManualLogin']:
                                                    passw=ManualPassword
                                            if passw=="*":#They want manual login, there is no saved password
                                                float("A")
                                            BitQueue[0]['password']=passw
                                            Encryptthis1="PASSWORD:"+passw
                                        except:
                                            ChangePosition=dict(BitQueue[0])
                                            BitQueue.pop(0)
                                            BitQueue.append(ChangePosition)
                                            SaveQueue()
                                            break
                                else:
                                    if 'Password' in BitQueue[0] and BitQueue[0]['Command']=='GetMessages':  
                                        if BitQueue[0]['Password']=="*":
                                            try:
                                                if BitQueue[0]['Email Address']==MyEmail:
                                                    AuthError=1
                                            except:
                                                pass
                                            BitQueue.pop(0)
                                            SaveQueue()
                                            break
                                        if BMHasPW:
                                            BitQueue[0]['Password']="#!#"
                                try:
                                    result=BitMRPC.FileLock("1")
                                except:
                                    BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')                                  
                                with open(os.path.join(application_path,"BitTMP.dat"),'w') as f:
                                    if 'MyBMAddress' in BitQueue[0]:
                                        btm=GetfromCfg("#BitMessage#")
                                        Encryptthis=""
                                        Encryptthis1=""
                                        content=""
                                        GetEmailGlobals()
                                        if "@" in BitQueue[0]['MyBMAddress']:#Ok we should send a password we checked for a password earlier
                                            passw="*"
                                            if BitQueue[0]['MyBMAddress']==MyEmail:
                                                passw=GetEmailGlobals(BitQueue[0]['MyBMAddress'])
                                                if AdvanceArray['MySettings']['ManualLogin']:
                                                    passw=ManualPassword
                                            if passw=="*":#They want manual login, there is no saved password
                                                float("A")
                                            BitQueue[0]['password']=passw
                                            Encryptthis1="PASSWORD:"+passw#Will throw an exception if its for a different account which is fine we move this one to the end of the queue
                                        if 'ordernumber' in BitQueue[0] and 'dontencrypt' not in BitQueue[0]:
                                            for co in MyContracts:
                                                if co['ordernumber'] == BitQueue[0]['ordernumber']:#If a person does a contract with himself with the same email this could accidentally encrypt with the wrong key
                                                    if 'theirpublic' in co and co['Process']!="Offer" and "Counter" not in co['Process']:
                                                        if 'password' in BitQueue[0]:
                                                            BitQueue[0].pop('password')
                                                        if BitQueue[0]['MyBMAddress'] == btm or BitQueue[0]['MyBMAddress'] == MyEmail:#Ok we will encrypt with the correct key
                                                            Encryptthis=Encryptthis1+"MY:"+BitQueue[0]['MyBMAddress']+"THEIR:"+BitQueue[0]['TheirBMAddress']+"ENCRYPTED:"
                                                            #Here is the encryption magic.
                                                            cipher = encrypt(str(BitQueue[0]), co['theirpublic'])
                                                            cipher = base64.b64encode(cipher)
                                                            content=str(Encryptthis)+str(cipher)+"###"
                                                        else:
                                                            float("A")
                                        mrand=os.urandom(16).encode('hex')
                                        if BitQueue[0]['MyBMAddress'] not in AdvanceArray['OUTBOX']:
                                            AdvanceArray['OUTBOX'][BitQueue[0]['MyBMAddress']]={mrand:{'ackdata':"", 'status':"Queued"}}
                                        else:
                                            AdvanceArray['OUTBOX'][BitQueue[0]['MyBMAddress']][mrand]={'ackdata':"", 'status':"Queued"}
                                        if Encryptthis=="":
                                            f.write("0"+"\n")
                                            f.write(BitQueue[0]['Command']+"\n")
                                            f.write(str(BitQueue[0])+"\n")
                                            f.write(str(mrand)+"\n")
                                        else:
                                            f.write("0"+"\n")
                                            f.write(BitQueue[0]['Command']+"\n")
                                            f.write(str(content)+"\n")
                                            f.write(str(mrand)+"\n")
                                    else:
                                        f.write("0"+"\n")
                                        f.write(BitQueue[0]['Command']+"\n")
                                        f.write(str(BitQueue[0])+"\n")
                                    f.flush()
                                    os.fsync(f)
                                    f.close()
                                try:
                                    result=BitMRPC.FileLock("2")
                                except:
                                    BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')                                  
                                BitQueue.pop(0)
                                SaveQueue()
                            except Exception,e:
                                traceback.print_exc()
                                ChangePosition=dict(BitQueue[0])
                                BitQueue.pop(0)
                                BitQueue.append(ChangePosition)
                                SaveQueue()
                                try:
                                    f.flush()
                                    os.fsync(f)
                                    f.close()
                                except:
                                    pass
                                try:
                                    result=BitMRPC.FileLock("1")
                                except:
                                    BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')                                    
                                try:                                  
                                    with open(os.path.join(application_path,"BitTMP.dat"),'w') as f:
                                        f.write("1"+"\n")
                                        f.write("PASS"+"\n")
                                        f.write(str(BitQueue[0])+"\n")
                                        f.flush()
                                        os.fsync(f)
                                        f.close()
                                except Exception, g:
                                    print str(g)
                                    pass
                                try:
                                    result=BitMRPC.FileLock("2")
                                except:
                                    BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')                                      
                            break
                except:
                    traceback.print_exc()
            DontExit[0]=0
            time.sleep(0.34567)
            DontExit[0]=1
        DontExit[0]=0
        return
class BlackCoinThread(QtCore.QThread):#For any Halo that uses daemon.
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        self.url = url
        self.amrunning=True
    def stop(self):
        self.amrunning=False
    def run(self):
        global updatesomething, isdownloading, interneton, globaltxh, globaltx,globalargs, NewUser
        global MyContracts, OnOrders
        global CurrentBlock,HaloTime
        global lockdownload
        global lockdownload2
        global BlackUnspent
        global BLK
        global globperc,globcount
        global UniversalTimeStamp
        global timestamp
        global rescanning
        global DontExit
        global WatchlistQueue
        global AdvanceArray
        global Markets
        global LockTHIS
        global EscrowResults
        global disconnected
        global addrlist
        global MacWine
        global Spendable
        global MasterOrders
        global HaloRPC
        global AddNewOrders
        global NEWTxidLookup
        global NEWTxidLookup2
        global spentinputs
        global NotaryScripts
        global CanStakeTime
        global connectioncount
        global iswaiting
        global myblockcount
        global globliq
        global RunHalo
        global totalstaked
        global loadtime
        global notDownloading
        global coininfo
        global merkleHashes
        disconnect=0
        conn=False
        BLK = None
        count = 0
        maxConnectAttempts = 200        
        time.sleep(3)
        fail=0
        tx3cont=0        
        BlackUnspent2=[]
        spentinputs={}
        stayconnected=0
        prevsupply=0
        skipuntil={}
        Reindexing=0
        checkliq = 1
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if TestnetPeg==True:            
                ThePeg.LoadDatabase()
                prevsupply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
            else:
                prevsupply=(-1)
        if BitMHalo.poll() != None:
            fail=1
        while not conn:
            try:
                BLKurl = 'http://'+CoinSelect['rpcuser']+':'+CoinSelect['rpcpassword']+'@localhost:'+CoinSelect['rpcport']
                if BlackHalo!=None:
                    if BlackHalo.poll() != None:
                        fail=2
                if fail != 0:
                    count+=maxConnectAttempts
                    float("A")
                if BlackHalo!=None:                    
                    BLK = AuthServiceProxy(BLKurl)
                    BLK.getblockcount()
                conn=True
                print 'connection to network successful'
            except:
                print ('Connection attempt: '+str(count))
                time.sleep(3)
                count += 1

            if count >= maxConnectAttempts:
                res=0
                if stayconnected==0:
                    print 'exceeded max connection attempts to Halo, exiting.'
                else:
                    count-=50
                    res=1
                if fail==0 and stayconnected==0:
                    if BitHaloClient and 'bitcoind' not in CoinSelect['daemon']:
                        res=QuestionBox(Gtranslate("BitHalo is connecting however the subprocess")+" "+CoinSelect['daemon']+" "+Gtranslate("for")+" "+CoinSelect['HaloName']+" "+Gtranslate("tried multiple times to connect to the network but failed. Perhaps the daemon was busy or is improperly configured. Please check your configuration and try again or proceed to only use BitHalo."), Gtranslate("Exit Halo"), Gtranslate("Continue connecting"), 1)
                    else:
                        res=QuestionBox(Gtranslate("The subprocess")+" "+CoinSelect['daemon']+" "+Gtranslate("tried multiple times to connect to the network but failed. Perhaps the daemon was busy or is improperly configured. Please check your configuration and try again. Halo will now exit."), Gtranslate("Exit Halo"), Gtranslate("Continue trying to connect"), 1)
                    if res!=0:
                        stayconnected=1
                        count=0
                        if BitHaloClient and 'bitcoind' not in CoinSelect['daemon'] and Reindexing==0:
                            conn=True
                            break
                if fail==1:
                    QuestionBox("Bitmessage subprocess did not load. Please make sure you have OpenSSL properly installed. Also make sure the program is not being blocked by antivirus and that the directory you installed to has administrator privileges. Halo will now exit and will also redirect you to the OpenSSL download page.", "OK")
                    if os.name == 'nt':
                        webbrowser.open("https://slproweb.com/products/Win32OpenSSL.html")
                    else:
                        webbrowser.open("https://www.google.com/search?safe=off&espv=2&q=openssl+linux+mac&oq=openssl+linux+mac&gs_l=serp.3...3209.4000.0.4177.4.4.0.0.0.0.174.335.0j2.2.0.msedr...0...1c.1.61.serp..3.1.174.SCz3T0oieUM&gws_rd=cr&ei=dgTOVMPAA-P6mQWJnYDgAg")
                if fail==2:
                    if BitHaloClient and 'bitcoind' not in CoinSelect['daemon']:
                        res=QuestionBox(Gtranslate("BitHalo is connecting however the subprocess")+" "+CoinSelect['daemon']+" "+Gtranslate("for")+" "+CoinSelect['HaloName']+" "+Gtranslate("failed to load. Please make sure you are not running another QT wallet that shares the same port. Also make sure it was not interfered with by antivirus or administrator privileges in your computer. If the program was installed to program files that could be one reason as well. Please try troubleshooting the issue. You can choose to use BitHalo only and reindex or exit the program."), Gtranslate("Exit Halo"), Gtranslate("Try to reindex blockchain"), 1)
                    else:
                        res=QuestionBox(Gtranslate("The subprocess")+" "+CoinSelect['daemon']+" "+Gtranslate("failed to load. Please make sure you are not running another QT wallet that shares the same port. Also make sure it was not interfered with by antivirus or administrator privileges in your computer. If the program was installed to program files that could be one reason as well. Please try troubleshooting the issue. Halo will now exit."), Gtranslate("Exit Halo"), Gtranslate("Try to reindex blockchain"), 1)
                    if res==1:
                        res=QuestionBox("Reindex can fix the block database if corrupted. There are times where this will correct the problem but it is not guaranteed. On some computers this can take hours to complete. Proceed anyways?", " No ", " Yes ")
                if res==0:
                    window.ExitHalo()
                else:
                    if stayconnected==0:
                        Reindexing=1
                        count = 0
                        fail=0
                        Reconnect(9)
                        time.sleep(10)                    
        if os.name == 'nt' and MacWine == 0:
            with open(os.path.join(application_path,"HaloTemp.tmp"),'a+') as f:
                f.close()
        prvblock=0
        checkinfo = time.time()
        prvtime=time.time()
        count = 0
        timethis=time.time()
        if 'repcheck' not in AdvanceArray:
            AdvanceArray['repcheck']=[]
        gtxidlist={}
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            inx=0
            for spnme in globliq:
                if 'liquidity' in spnme:
                    gtxidlist[spnme['txid']+':'+str(spnme['vout'])]=inx
                inx+=1
        while count < 7 and self.amrunning:
            DontExit[1]=0
            iswaiting=1
            time.sleep(1)
            while lockdownload==1 or lockdownload2==1:
                time.sleep(.001)
            iswaiting=0
            count+=1
            #Manual blockchain checking
            try:
                pass
                #t=BLK.getblock(rawx['blockhash'])
                #print deserialize(BLK.getrawtransaction("1e1539452663624a9fc45697c75853e449aa55406b928ae3eae908a5f0c8c751"))
                #m.getch()
            except:
                traceback.print_exc()
                print "Raw not available"
            try:
                cnct=1
                try:
                    #When synchronizing the percentage is estimated based on time stamps
                    if BlackHalo!=None:
                        connectioncount=str(BLK.getconnectioncount())
                        count1 = BLK.getblockcount()
                    else:
                        connectioncount="0"
                        count1 = 0
                    myblockcount=count1
                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                        if TestnetPeg==False:
                            peginfo=BLK.getpeginfo()
                            #ThePeg.amountofsteps=peginfo['steps']
                            ThePeg.interval=peginfo['interval']
                            ThePeg.pegfeeperinput=peginfo['pegfeeperinput']
                            ThePeg.subpremiumrating=peginfo['subpremiumrating']
                            ThePeg.Pegdatabase['startingblock']=peginfo['startingblock']#1000000000 means it has not started yet
                            ThePeg.Pegdatabase['supply']=peginfo['peg']
                            ThePeg.Pegdatabase['blockcount']=myblockcount
                    if BlackHalo!=None:
                        hsh= BLK.getbestblockhash()
                        hsh= BLK.getblock(hsh)
                    else:
                        try:
                            thenewtime=time.mktime(datetime.datetime.utcnow().timetuple())
                        except:
                            thenewtime=time.time()
                        hsh={'time':thenewtime}
                    UniversalTimeStamp=hsh['time']
                    try:
                        timestamp=time.mktime(datetime.datetime.utcnow().timetuple())
                    except:
                        timestamp=time.time()
                    if timestamp > UniversalTimeStamp:
                        timestamp=UniversalTimeStamp#At some point we may want to distinguish because of synchronizing
                        #In contracts it doesnt matter because the longer you wait the more the timestamp reflects the drift
                        #However, if the block changes every minute or so, and the timestamp is greater then the transaction gets rejected
                        #Therefore since timestamps can vary, we should use the one we get from the blockchain when available
                    #Ok so the timestamp on the block is used to guess the height based on the current time in minutes
                    max1=0
                    if HaloTime:#Convertdate
                        if "1970-01-01 00:00:00" in str(HaloTime) and interneton==1:
                            hours_difference = datetime.datetime.utcfromtimestamp(time.time())-datetime.datetime.utcfromtimestamp(hsh['time'])
                        else:
                            hours_difference = HaloTime-datetime.datetime.utcfromtimestamp(hsh['time'])
                        hours_difference = hours_difference.total_seconds()/60.0
                        hours_difference = round(hours_difference, 2)
                        max1 = count1+int(abs(hours_difference))
                    else:
                        max1=count1+10000000000000000000#If we cant get time off the internet we will wait until we do
                        cnct=0
                    try:
                        t= int((count1/float(max1))*100)
                        if (count1/float(max1))>.9999:
                            t=100
                    except:
                        t=0

                    if count1<max1 and cnct==1:
                        if count1==prvblock:
                            if int(time.time()-prvtime)>(int(CoinSelect['blocktime'])*20):#20 blocks have passed and no progress on our block, lets reconnect. If it's Bitcoin then 200 minutes passed.
                                disconnect=30
                                prvblock=count1
                                prvtime=time.time()
                        else:
                            prvblock=count1
                            prvtime=time.time()
                    globperc=t
                    globcount=count1
                except Exception, e:
                    if BlackHalo!=None:
                        BLK = ""
                        BLK = AuthServiceProxy(BLKurl)
                    traceback.print_exc()
                    pass
                iswaiting=1
                while lockdownload==1 or lockdownload2==1:
                    time.sleep(.001)
                iswaiting=0
                if BitHaloClient==False and BlackHalo!=None:
                    connection=0
                    rscn=0
                    while connection==0:
                        try:
                            #test = BLK.help()   #Shows all the daemon commands
                            try:
                                BLK = ""
                                BLK = AuthServiceProxy(BLKurl)
                                test=BLK.getblockcount()
                                #test= BLK.getmininginfo()
                            except:
                                BLK = ""
                                BLK = AuthServiceProxy(BLKurl)
                                test=BLK.getblockcount()
                            connection=1
                            disconnected=0
                        except:
                            print "Possibly disconnected from network"
                            disconnected=1
                            disconnect+=1
                            time.sleep(1)
                        passme=0
                        if disconnect<=29:
                            if rescanning==1 and WatchlistQueue != []:
                                passme=1
                        if passme==0:
                            if disconnect>29 or rescanning==1:
                                if rescanning==1:
                                    rscn=1
                                disconnect=0
                                res=False
                                while res==False:
                                    print "Reconnecting..."
                                    res=Reconnect(rescanning)
                                    time.sleep(10)
                                BLK = ""
                                BLKurl = 'http://'+CoinSelect['rpcuser']+':'+CoinSelect['rpcpassword']+'@localhost:'+CoinSelect['rpcport']
                                BLK = AuthServiceProxy(BLKurl)
                                if rscn==1:
                                    rescanning=2
                                    connection2=0
                                    while connection2==0:
                                        try:
                                            BLKurl = 'http://'+CoinSelect['rpcuser']+':'+CoinSelect['rpcpassword']+'@localhost:'+CoinSelect['rpcport']
                                            BLK = AuthServiceProxy(BLKurl)
                                            test=BLK.getblockcount()
                                            connection2=1
                                            rescanning=0
                                        except:
                                            if BlackHalo.poll() != None:#This can happen if bitbayd runs out of memory or fails during rescan
                                                rescanning=1
                                                connection=0
                                                print "Disconnected!"
                                                break
                                            print "Rescanning..."
                                            time.sleep(10)
                if updatesomething==1:
                    if RunHalo==False:
                        isdownloading=1
                        try:
                            if 'pegging' in CoinSelect and CoinSelect['pegging'] and globperc==100:
                                if TestnetPeg==True:
                                    blocksremaining=ThePeg.scanblocks(500, myblockcount)
                                else:
                                    blocksremaining=myblockcount
                        except:
                            traceback.print_exc()
                        isdownloading=0
                    if BitHaloClient==False and RunHalo and BlackHalo!=None:
                        isdownloading=1
                        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
                        try:
                            if time.time() > checkinfo:
                                checkinfo = time.time() + 540
                                coininfo = BLK.getinfo()
                                try:
                                    if 'pegging' in CoinSelect and CoinSelect['pegging'] and globperc==100:
                                        if ThePeg.testthis==0:
                                            #bdb=BLK.getbridgeinfo()
                                            bdb2=BLK.bridges()
                                            isPaused = 'a'
                                            try:
                                                isPaused = BLK.is_paused()
                                            except:
                                                traceback.print_exc()
                                            if bdb2==False:
                                                float('a')
                                            myBridges = []
                                            for key, val in bdb2.items():
                                                myBridges.append({'n':val['name'],'s':val['symb'],'l':val['links'],'i':val['chain_id'],'c':val['contract'],'p':val['pegsteps'],'m':val['microsteps']})
                                            try:
                                                pass
                                                #BLK.tstakers1()
                                                #BLK.tstakers2()
                                                #BLK.consensus()
                                                #BLK.timelockpasses()
                                            except:
                                                pass
                                            ThePeg.Pegdatabase['bridgeactive']=True#bdb[0]
                                            if isPaused != 'a':
                                                if isPaused:
                                                    ThePeg.Pegdatabase['bridgeactive']=False
                                                else:
                                                    ThePeg.Pegdatabase['bridgeactive']=True
                                            ThePeg.Pegdatabase['bridgedb']['bridges']=copy.deepcopy(myBridges)
                                            lenchange = False
                                            lenchange2 = False
                                            if merkleHashes == False:
                                                merkleHashes = {'out':{}}
                                                if 'merkleHashes' in AdvanceArray:
                                                    merkleHashes = copy.deepcopy(AdvanceArray['merkleHashes'])
                                                merkleHashes2 = BLK.merklesin(0)
                                                for key, val in merkleHashes2.iteritems():
                                                    thename = ''
                                                    for bridgeName in myBridges:
                                                        if txhash(bridgeName['n'])[:64] == val['brhash']:
                                                            thename = bridgeName['n']
                                                    if thename != '':
                                                        if thename not in merkleHashes:
                                                            merkleHashes[thename] = {}
                                                        lenchange = True
                                                        merkleHashes[thename][key] = 1
                                                        if 'mylen' not in merkleHashes[thename]:
                                                            merkleHashes[thename]['mylen'] = 0
                                                merkleHashes3 = BLK.merklesout(0)
                                                templist = {}
                                                for key, val in merkleHashes3.iteritems():
                                                    thename = ''
                                                    for bridgeName in myBridges:
                                                        if txhash(bridgeName['n'])[:64] == val['brhash']:
                                                            thename = bridgeName['n']
                                                    if thename != '':
                                                        if thename not in merkleHashes['out']:
                                                            merkleHashes['out'][thename] = {}
                                                            merkleHashes['out'][thename]['list'] = []
                                                            merkleHashes['out'][thename]['inx'] = {}
                                                            merkleHashes['out'][thename]['lastHash'] = "0x0"
                                                            merkleHashes['out'][thename]['lastIndex'] = 0
                                                        if thename not in templist:
                                                            templist[thename] = []
                                                        if key not in merkleHashes['out'][thename]["inx"]:
                                                            templist[thename].insert(0,[key,val['section']])
                                                            lenchange2 = True
                                                        else:
                                                            break
                                                if lenchange2:
                                                    for nm in templist:
                                                        for el in templist[nm]:
                                                            merkleHashes['out'][nm]['list'].append(el)
                                            else:
                                                merkleHashes2 = BLK.merklesin(25)
                                                for key, val in merkleHashes2.iteritems():
                                                    thename = ''
                                                    for bridgeName in myBridges:
                                                        if txhash(bridgeName['n'])[:64] == val['brhash']:
                                                            thename = bridgeName['n']
                                                    if thename != '':
                                                        if thename not in merkleHashes:
                                                            merkleHashes[thename] = {}
                                                        if key not in merkleHashes[thename]:
                                                            lenchange = True
                                                            merkleHashes[thename][key] = 1
                                                        if 'mylen' not in merkleHashes[thename]:
                                                            merkleHashes[thename]['mylen'] = 0
                                                merkleHashes3 = BLK.merklesout(0)
                                                templist2 = {}
                                                for key, val in merkleHashes3.iteritems():
                                                    thename = ''
                                                    for bridgeName in myBridges:
                                                        if txhash(bridgeName['n'])[:64] == val['brhash']:
                                                            thename = bridgeName['n']
                                                    if thename != '':                                                        
                                                        if thename not in merkleHashes['out']:
                                                            merkleHashes['out'][thename] = {}
                                                            merkleHashes['out'][thename]['list'] = []
                                                            merkleHashes['out'][thename]['inx'] = {}
                                                            merkleHashes['out'][thename]['lastHash'] = "0x0"
                                                            merkleHashes['out'][thename]['lastIndex'] = 0
                                                        if thename not in templist2:
                                                            templist2[thename] = []
                                                        if key not in merkleHashes['out'][thename]["inx"]:
                                                            templist2[thename].insert(0,[key,val['section']])
                                                            lenchange2 = True
                                                        else:
                                                            break
                                                if lenchange2:
                                                    for nm in templist2:
                                                        for el in templist2[nm]:
                                                            merkleHashes['out'][nm]['list'].append(el)
                                            if merkleHashes != False:
                                                if 'noncesync' not in merkleHashes:
                                                    merkleHashes['noncesync'] = {}
                                                if lenchange:
                                                    for key, val in merkleHashes:
                                                        merkleHashes[key]['mylen'] = len(merkleHashes[key]) - 1
                                                        merkleHashes['noncesync'][key] = merkleHashes[key]['mylen']
                                                if lenchange2:
                                                    for key, val in merkleHashes['out'].iteritems():
                                                        myxpos = len(merkleHashes['out'][key]['list']) - 1  # Start from the last index
                                                        for myHash in reversed(merkleHashes['out'][key]['list']):  # Reverse iteration
                                                            if myHash[0] not in merkleHashes['out'][key]["inx"]:  # Only add if not present
                                                                merkleHashes['out'][key]["inx"][myHash[0]] = myxpos
                                                            else:
                                                                break
                                                            myxpos -= 1  # Decrement position
                                                for key, val in merkleHashes['out'].iteritems():
                                                    if key in TheBridgeThread.lastHash:
                                                        merkleHashes['out'][key]['lastHash'] = TheBridgeThread.lastHash[key]
                                                        if TheBridgeThread.lastHash[key] in merkleHashes['out'][key]["inx"]:
                                                            merkleHashes['out'][key]['lastIndex'] = merkleHashes['out'][key]["inx"][TheBridgeThread.lastHash[key]] + 1
                                            if waitlock() == True:
                                                AdvanceArray['bridgedb'] = ThePeg.Pegdatabase['bridgedb']
                                                AdvanceArray['merkleHashes'] = copy.deepcopy(merkleHashes)

                                except:
                                    traceback.print_exc()
                                    print "Bridge not loaded"
                        except:
                            print "Check coin info failed"                            
                        try:
                            try:
                                if 'pegging' in CoinSelect and CoinSelect['pegging'] and globperc==100:
                                    if TestnetPeg==True:
                                        blocksremaining=ThePeg.scanblocks(500, myblockcount)
                                    else:
                                        blocksremaining=myblockcount
                            except:
                                traceback.print_exc()
                            #Check for any reputation data
                            for repcheck in AdvanceArray['repcheck']:
                                if waitlock() == False:
                                    break
                                try:
                                    txresult=repcheck['txresult']
                                    tx3=repcheck['tx3']
                                    mypub=repcheck['mypub']
                                    theirpub=repcheck['theirpub']
                                    review=repcheck['review']
                                    qreview=QtCore.QString(review)
                                    result=BLK.getrawtransaction(txresult,1)
                                    if result['vin'][0]['txid']!=tx3:
                                        float("A")
                                    if 'addresses' in result['vout'][0]['scriptPubKey']:
                                        result=result['vout'][0]['scriptPubKey']['addresses'][0]
                                    if result=="bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3" or result=="1BitcoinEaterAddressDontSendf59kuE":
                                        result=0
                                    else:
                                        result=1
                                    rawx=BLK.getrawtransaction(tx3, 1)
                                    raw1=BLK.getrawtransaction(rawx['vin'][0]['txid'], 1)#Temporary
                                    raw2=BLK.getrawtransaction(rawx['vin'][1]['txid'], 1)#2nd Temporary
                                    #If its a guarantor contract there is no way to see their address. So for now we only confirm full Halo contracts
                                    hex1=raw1['vin'][0]['scriptSig']['hex']
                                    hex2=raw2['vin'][0]['scriptSig']['hex']
                                    if mypub in hex1 or mypub in hex2:
                                        if theirpub in hex1 or theirpub in hex2:
                                            if mypub not in Markets['Reputation']:
                                                Markets['Reputation'][mypub]={'Bitmessage':[],'Address':[],'D':[], 'Reputation': {'Reviews':[],'Review Points':0,'Flags':[0,time.time()],'Rating':0}}
                                            if theirpub not in Markets['Reputation']:
                                                Markets['Reputation'][theirpub]={'Bitmessage':[],'Address':[],'D':[], 'Reputation': {'Reviews':[],'Review Points':0,'Flags':[0,time.time()],'Rating':0}}
                                        else:
                                            float("A")
                                    for rep in Markets['Reputation']:
                                        found=0
                                        foundself=0
                                        if rep in hex1:
                                            found=1
                                            if mypub in hex1:
                                                found=2#its ourselves
                                        if rep in hex2:
                                            found=1
                                            if mypub in hex2:
                                                found=2#its ourselves
                                        if mypub in hex1 or mypub in hex2:#We are involved in the deal
                                            foundself=1
                                            if mypub in hex1 and mypub in hex2:#The inputs are not different parties
                                                found=0
                                        if found>0 and foundself==1:
                                            if 'txids' not in Markets['Reputation'][rep]['Reputation']:
                                                Markets['Reputation'][rep]['Reputation']['txids']=[]
                                            if 'Ratio' not in Markets['Reputation'][rep]['Reputation']:
                                                Markets['Reputation'][rep]['Reputation']['Ratio']=[0,0]
                                            if tx3 not in Markets['Reputation'][rep]['Reputation']['txids']:
                                                Markets['Reputation'][rep]['Reputation']['txids'].append(tx3)#We could even make them sign their reviews
                                                if len(qreview)<41 and review!="" and found==1 and Markets['Reputation'][rep]['Reputation']['Review Points']>2:
                                                    Markets['Reputation'][rep]['Reputation']['Reviews'].append("Reviewed by: " + mypub[:10] + "\n" + review)
                                                    Markets['Reputation'][rep]['Reputation']['Review Points']-=3#It costs us points to review
                                                if result==1:
                                                    Markets['Reputation'][rep]['Reputation']['Rating']+=10
                                                else:
                                                    Markets['Reputation'][rep]['Reputation']['Rating']-=50
                                                Markets['Reputation'][rep]['Reputation']['Review Points']+=1
                                                Markets['Reputation'][rep]['Reputation']['Ratio'][0]+=result
                                                Markets['Reputation'][rep]['Reputation']['Ratio'][1]+=1
                                except:
                                    traceback.print_exc()                                
                                AdvanceArray['repcheck'].pop(0)
                                break

                            try:
                              if checkliq == 1:
                                  checkliq = 0
                                  BlackUnspent = bsonjs.loads(json.dumps({'1': globliq}, cls=DecimalEncoder))
                                  BlackUnspent = json.loads(bsonjs.dumps(BlackUnspent), object_hook=DecodeDecimal)['1']
                                  mypos = 0
                                  mylen = len(BlackUnspent)
                                  while mypos < mylen:
                                      next1 = 1
                                      foundit = 0
                                      if BlackUnspent[mypos]['amount'] == Decimal('0.00005577'):
                                          foundit = 1
                                      if foundit == 1:
                                          next1 = 0
                                          mylen -= 1
                                          BlackUnspent.pop(mypos)
                                      if next1 == 1:
                                          mypos += 1
                            except:
                                traceback.print_exc()
                                BlackUnspent = []
                            #If account pruning is activated then the inputs must update when pruning happens and also when
                            #special transactions deduct liquidity or reserve from the pool changing the proportion. It's
                            #possible that this information can be obtained from the mempool which will also need to store it.

                            #Get unspent inputs and get transaction data
                            BlackUnspent2= BLK.listunspent()
                            if 'pegging' in CoinSelect and CoinSelect['pegging'] and not TestnetPeg:
                                u1=BLK.listfrozen()
                                for u in u1:
                                    BlackUnspent2.append(u)
                            if 'pegging' in CoinSelect and CoinSelect['pegging'] and ThePeg.testthis==1:
                                if 'bridgecheck' in AdvanceArray:
                                    for elem in AdvanceArray['bridgecheck']:                                        
                                        if elem not in AdvanceArray['bridgetx']:
                                            if waitlock() == True:
                                                AdvanceArray['bridgetx'][elem]={'pool':[0]*1200}
                                        try:
                                            fractions=BLK.getfractions(elem)['values']
                                            if waitlock() == True:
                                                AdvanceArray['bridgetx'][elem]['pool']=copy.deepcopy(fractions)
                                                AdvanceArray['bridgecheck'].remove(elem)
                                                break
                                        except:
                                            traceback.print_exc()
                                            try:
                                                if 'timeout' not in AdvanceArray['bridgetx'][elem]:
                                                    if waitlock() == True:
                                                        AdvanceArray['bridgetx'][elem]['timeout']=timestamp
                                                if AdvanceArray['bridgetx'][elem]['timeout']+2419200<timestamp:
                                                    if waitlock() == True:
                                                        AdvanceArray['bridgecheck'].remove(elem)
                                                        break
                                            except:
                                                traceback.print_exc()
                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                if 'bridgeautomation' not in AdvanceArray:
                                    if waitlock() == True:
                                        AdvanceArray['bridgeautomation'] = {'processnonce':0,'votes':{}}
                                if BridgeAdmin and ThePeg.testthis==1:
                                    nonce = str(AdvanceArray['bridgeautomation']['processnonce'])
                                    #if ThePeg.testthis==1:
                                    if True:
                                        if nonce in ThePeg.Pegdatabase['merklelist']:
                                            if 'finalTX' in ThePeg.Pegdatabase['merklelist'][nonce] and AdvanceArray['bridgeautomation']['votes'] == {}:
                                                for myname in ThePeg.Pegdatabase['merklelist'][nonce]['finalTX']:
                                                    if myname not in AdvanceArray['bridgeautomation']['votes']:
                                                        if waitlock() == True:
                                                            AdvanceArray['bridgeautomation']['votes'][myname] = {'root':ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][myname]['root'],'section':ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][myname]['section']}
                                    #else:
                                    #    try:
                                    #        if AdvanceArray['bridgeautomation']['votes'] == {}:
                                    #            while(BLK.getroot(int(nonce)+3) != False):
                                    #                if waitlock() == True:
                                    #                    AdvanceArray['bridgeautomation']['processnonce'] += 1
                                    #                else:
                                    #                    break
                                    #                nonce = str(AdvanceArray['bridgeautomation']['processnonce'])
                                    #            myroots=BLK.getroot(int(nonce))
                                    #            if myroots != False:
                                    #                if waitlock() == True:
                                    #                    AdvanceArray['bridgeautomation']['votes'] = copy.deepcopy(myroots)
                                    #    except:
                                    #        traceback.print_exc()
                                    completethis = 0
                                    if AdvanceArray['bridgeautomation']['votes'] != {}:
                                        if TheBridgeThread.confirmedvotes == AdvanceArray['bridgeautomation']['votes']:
                                            completethis = 1
                                    if completethis == 1:
                                        if waitlock() == True:
                                            TheBridgeThread.confirmedvotes = {}
                                            AdvanceArray['bridgeautomation']['processnonce'] += 1
                                            AdvanceArray['bridgeautomation']['votes'] = {}
                            try:
                                BlackUnspent3=json.loads(json.dumps(BlackUnspent2,cls=DecimalEncoder))
                            except:
                                BlackUnspent3=[]
                            ntxidlist={}
                            for spnme in BlackUnspent:
                                ntxidlist[spnme['txid']+str(spnme['vout'])]=1
                            checkme=0
                            for txid in BlackUnspent2:
                                if txid['txid']+str(txid['vout']) not in ntxidlist:
                                    checkme=1
                                    break
                            if len(BlackUnspent2)!=len(ntxidlist):
                                checkme=1
                            if checkme==1:
                                txidlist2={}
                                for txid in BlackUnspent2:
                                    txidlist2[txid['txid']+str(txid['vout'])]=1
                                #Maybe there is a faster way to get the sender like using the function below, it may depend on the inputs
                                #get_address_from_input_script(input['script'].decode('hex'))
                                i=0
                                j=0
                                leng=len(BlackUnspent)
                                #Checking for changes in unspent transactions.
                                while j<leng:
                                    next1=1
                                    found=0
                                    if BlackUnspent[j]['txid']+str(BlackUnspent[j]['vout']) in txidlist2:
                                        found=1
                                    if found==0:#This got spent, this would be obvious just using the new list but since we want more advanced info later, we avoid making so many requests to the daemon
                                        next1=0
                                        leng-=1
                                        BlackUnspent.pop(j)
                                    if next1==1:
                                        j+=1
                                #Finding out where the coins came from
                                
                                for Black in BlackUnspent2:
                                    if str(Black['txid']+str(Black['vout'])) not in ntxidlist:                           
                                        if str(Black['txid']+str(Black['vout'])) in skipuntil:#We may wait for more confirmations under some conditions
                                            if ThePeg.Pegdatabase['blockcount']<skipuntil[str(Black['txid']+str(Black['vout']))]+1:
                                                i+=1
                                                continue
                                            else:
                                                skipuntil.pop(str(Black['txid']+str(Black['vout'])))
                                        #Looking for sender and block data
                                        lookup=BLK.getrawtransaction(Black['txid'],1)
                                        blockcheck=0
                                        addthis=1
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            blockcheck=BLK.getblock(lookup['blockhash'])['height']
                                            if ThePeg.prunetopools==1:
                                                if 'confirmations' in lookup and lookup['confirmations']<10:
                                                    i+=1
                                                    continue
                                            if blockcheck % ThePeg.interval<7 or blockcheck % ThePeg.interval>ThePeg.interval-7:
                                                if 'confirmations' in lookup and lookup['confirmations']<5:
                                                    i+=1
                                                    continue
                                            if ThePeg.Pegdatabase['blockcount']<blockcheck+1:
                                                skipuntil[str(Black['txid']+str(Black['vout']))]=blockcheck
                                                i+=1
                                                continue
                                        #Notification of spent exotic scripts
                                        if Black['amount'] == Decimal('0.00005579'):
                                            lookup2=deserialize(BLK.getrawtransaction(Black['txid']))
                                            for inpt in lookup2['ins']:
                                                spentinputs[str(inpt['outpoint']['hash'])+":"+str(inpt['outpoint']['index'])]=True                                      
                                        #Looking for Exotic Scripts
                                        if Black['amount'] == Decimal('0.00005577'):
                                            if str(Black['txid'])+":"+str(Black['vout']) not in NEWTxidLookup2:
                                                lookup3=deserialize(BLK.getrawtransaction(Black['txid']))
                                                myouts=[]
                                                ps=0
                                                for myout in lookup3['outs']:
                                                    if myout['value']==5576:
                                                        if ps>Black['vout']:
                                                            myouts.append(myout)
                                                    ps+=1
                                                NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]=DecodeScriptFromOuts(myouts)
                                                if NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]!={}:
                                                    ps=0
                                                    foundme=0
                                                    try:
                                                        for myout in lookup3['outs']:
                                                            if script_to_address2(myout['script'], 85)==scriptaddr(NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['script'].decode('hex')):#Check for Halo
                                                                foundme=1
                                                                NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['txid']=str(Black['txid'])+":"+str(ps)
                                                                NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['address']=script_to_address2(myout['script'], 85)
                                                                NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['amount']=myout['value']
                                                                try:
                                                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                        if TestnetPeg:
                                                                            liquid, reserve=ThePeg.checktransaction(lookup3, ps, txid2=str(Black['txid']))
                                                                        else:                                                                            
                                                                            fractions=BLK.getfractions(str(Black['txid'])+':'+str(ps))
                                                                            liquid, reserve=ThePeg.formatfractions(fractions, NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['address'],NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['amount'])
                                                                        combined=ThePeg.checkliquidity(liquid,reserve)
                                                                        if combined==False:
                                                                            addthis=0
                                                                            float('a')
                                                                        NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['liquidity']=json_deep_copy(combined)
                                                                except:
                                                                    traceback.print_exc()
                                                                    addthis=0
                                                                    float('a')
                                                                if myout['value']==5577:#This might confuse things, just ignore the low value lock
                                                                    foundme=0
                                                            ps+=1
                                                    except:
                                                        foundme=0
                                                        traceback.print_exc()
                                                    if foundme==0:
                                                        NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]={}
                                        #We could shortcut here and see if all the outputs are to the same address to know if its a pure change transaction
                                        l= lookup['vin'][0]['txid']#We knew the outputs, but who put the input? If there were multiple people who paid just like the first
                                        try:
                                            res=ea.get_address_from_input_script(lookup['vin'][0]['scriptSig']['hex'].decode('hex'))
                                            if len(res[0]) != 2:
                                                msigaddr = pubkey_to_address(res[0], 25)
                                            else:
                                                mscript = mk_multisig_script(res[0],2,2)
                                                msigaddr = scriptaddr(mscript.decode('hex'))
                                            BlackUnspent2[i]['FROM']=msigaddr
                                        except:
                                            res=BLK.getrawtransaction(l,1)
                                            if 'addresses' in res['vout'][(lookup['vin'][0]['vout'])]['scriptPubKey']:
                                                BlackUnspent2[i]['FROM']=res['vout'][(lookup['vin'][0]['vout'])]['scriptPubKey']['addresses'][0]
                                            else:
                                                BlackUnspent2[i]['FROM']=res['vout'][(lookup['vin'][0]['vout'])]['scriptPubKey']['hex']
                                        pure=[]
                                        for v in lookup['vout']:
                                            try:
                                                if v['scriptPubKey']['addresses'][0] not in pure:
                                                    pure.append(v['scriptPubKey']['addresses'][0])
                                            except:
                                                if "type" and "hex" and "asm" in v['scriptPubKey']:
                                                    if v['scriptPubKey']['hex']=="" and v['scriptPubKey']['asm']=="":
                                                        if 'value' in v and Decimal(v['value'])==Decimal(0):
                                                            BlackUnspent2[i]['FROM']="Mined Coins"
                                        if pure != [] and len(pure)==1:
                                            BlackUnspent2[i]['BrokeForChange']=1
                                        else:
                                            BlackUnspent2[i]['BrokeForChange']=0
                                        if Black['amount'] == Decimal('0.00005560'):
                                            lookup2=deserialize(BLK.getrawtransaction(Black['txid']))
                                            try:
                                                meaning=translate_script(lookup2['outs'][Black['vout']-1]['script'])
                                                if meaning!={}:
                                                    if 'message' in meaning:
                                                        NotaryScripts[Black['txid']+":"+str(Black['vout'])]=lookup2['outs'][Black['vout']-1]['script']
                                                else:
                                                    pass
                                            except:
                                                pass
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            if str(Black['txid'])+":"+str(Black['vout']) in gtxidlist:
                                                BlackUnspent2[i]['liquidity']=ThePeg.checkliquidity(globliq[gtxidlist[str(Black['txid'])+":"+str(Black['vout'])]]['liquidity'], update=1)
                                            else:
                                                if TestnetPeg:
                                                    liquid, reserve=ThePeg.checktransaction(str(Black['txid'])+":"+str(Black['vout']))
                                                else:
                                                    fractions=BLK.getfractions(str(Black['txid'])+":"+str(Black['vout']))
                                                    liquid, reserve=ThePeg.formatfractions(fractions, multisig, int(Black['amount']*Decimal(1e8)))
                                                combined=ThePeg.checkliquidity(liquid,reserve)
                                                if combined==False:
                                                    addthis=0
                                                BlackUnspent2[i]['liquidity']=json_deep_copy(combined)
                                        if addthis==1:
                                            BlackUnspent.append(BlackUnspent2[i])
                                    i+=1
                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
                                if prevsupply!=supply:
                                    for Black in BlackUnspent:
                                        Black['liquidity']=ThePeg.checkliquidity(Black['liquidity'], update=1)
                                    for txid in NEWTxidLookup2:
                                        if 'liquidity' in NEWTxidLookup2[txid]:
                                            NEWTxidLookup2[txid]['liquidity']=ThePeg.checkliquidity(NEWTxidLookup2[txid]['liquidity'], update=1)
                                    prevsupply=supply
                        except:
                            traceback.print_exc()                            
                            try:
                                time.sleep(1)
                                #json.loads(json.dumps({'1':BlackUnspent},cls=DecimalEncoder), cls=DecimalEncoder)
                                prevunspent=copy.deepcopy(BlackUnspent)
                                BlackUnspent4= BLK.listunspent()
                                if 'pegging' in CoinSelect and CoinSelect['pegging'] and not TestnetPeg:
                                    u1=BLK.listfrozen()
                                    for u in u1:
                                        BlackUnspent4.append(u)
                                BlackUnspent=[]
                                for Black in BlackUnspent4:
                                    addthis=1
                                    #Looking for sender and block data
                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                        lookup=BLK.getrawtransaction(Black['txid'],1)
                                        blockcheck=BLK.getblock(lookup['blockhash'])['height']
                                        if blockcheck % ThePeg.interval<7 or blockcheck % ThePeg.interval>ThePeg.interval-7:
                                            if 'confirmations' in lookup and lookup['confirmations']<5:
                                                continue
                                        if ThePeg.Pegdatabase['blockcount']<blockcheck+1:
                                            continue
                                    if Black['amount'] == Decimal('0.00005579'):
                                        lookup2=deserialize(BLK.getrawtransaction(Black['txid']))
                                        for inpt in lookup2['ins']:
                                            spentinputs[str(inpt['outpoint']['hash'])+":"+str(inpt['outpoint']['index'])]=True
                                    if Black['amount'] == Decimal('0.00005560'):
                                        lookup2=deserialize(BLK.getrawtransaction(Black['txid']))
                                        try:
                                            meaning=translate_script(lookup2['outs'][Black['vout']-1]['script'])
                                            if meaning!={}:
                                                if 'message' in meaning:
                                                    NotaryScripts[Black['txid']+":"+str(Black['vout'])]=lookup2['outs'][Black['vout']-1]['script']
                                                    #AddToHistory(Black['txid'],Black['vout'],"*", Black['amount'] , "Notary/Burn", {'script':lookup2['outs'][Black['vout']-1]['script']})
                                        except:
                                            pass
                                    if Black['amount'] == Decimal('0.00005577'):
                                        if str(Black['txid'])+":"+str(Black['vout']) not in NEWTxidLookup2:
                                            lookup=deserialize(BLK.getrawtransaction(Black['txid']))
                                            myouts=[]
                                            ps=0
                                            for myout in lookup['outs']:
                                                if myout['value']==5576:
                                                    if ps>Black['vout']:
                                                        myouts.append(myout)
                                                ps+=1
                                            NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]=DecodeScriptFromOuts(myouts)
                                            if NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]!={}:
                                                ps=0
                                                foundme=0
                                                try:
                                                    for myout in lookup['outs']:
                                                        if script_to_address2(myout['script'], 85)==scriptaddr(NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['script'].decode('hex')):#Check for Halo
                                                            foundme=1
                                                            NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['txid']=str(Black['txid'])+":"+str(ps)
                                                            NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['address']=script_to_address2(myout['script'], 85)
                                                            NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['amount']=myout['value']
                                                            try:
                                                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                    if TestnetPeg:
                                                                        liquid, reserve=ThePeg.checktransaction(lookup, ps, txid2=str(Black['txid']))
                                                                    else:
                                                                        fractions=BLK.getfractions(str(Black['txid'])+":"+str(ps))
                                                                        liquid, reserve=ThePeg.formatfractions(fractions, NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['address'], NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['amount'])
                                                                    combined=ThePeg.checkliquidity(liquid,reserve)
                                                                    if combined==False:
                                                                        addthis=0
                                                                        float('a')
                                                                    NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]['liquidity']=json_deep_copy(combined)
                                                            except:
                                                                traceback.print_exc()
                                                                addthis=0
                                                                float('a')
                                                            if myout['value']==5577:#This might confuse things, just ignore the low value lock
                                                                foundme=0                                                            
                                                        ps+=1
                                                except:
                                                    foundme=0
                                                    traceback.print_exc()
                                                    #if addthis==0:
                                                    #    float('a')
                                                if foundme==0:
                                                    NEWTxidLookup2[str(Black['txid'])+":"+str(Black['vout'])]={}
                                    Black['BrokeForChange']=0
                                    Black['FROM']="*"
                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                        if str(Black['txid'])+":"+str(Black['vout']) in gtxidlist:
                                            Black['liquidity']=ThePeg.checkliquidity(globliq[gtxidlist[str(Black['txid'])+":"+str(Black['vout'])]]['liquidity'], update=1)
                                        else:
                                            if TestnetPeg:
                                                liquid, reserve=ThePeg.checktransaction(str(Black['txid'])+":"+str(Black['vout']))
                                            else:
                                                fractions=BLK.getfractions(str(Black['txid'])+":"+str(Black['vout']))
                                                liquid, reserve=ThePeg.formatfractions(fractions, multisig, int(Black['amount']*Decimal(1e8)))
                                            combined=ThePeg.checkliquidity(liquid,reserve)
                                            if combined==False:
                                                addthis=0
                                            Black['liquidity']=json_deep_copy(combined)
                                    if addthis==1:
                                        BlackUnspent.append(Black)
                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                    supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
                                    if prevsupply!=supply:
                                        prevsupply=supply
                            except:
                                BlackUnspent=copy.deepcopy(prevunspent)#Instead of clearing BlackUnspent on RPC issue, we can revert to original dictionary
                                print "Second error parsing unspent list"
                            print "Error parsing Unspent list"
                        IsPeg=True
                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                                IsPeg=False
                        #For staking, we check for coins that are eligable.
                        if AdvanceArray['MySettings']['Staking'] and IsUnlocked() and keysconnected != "0" and CanStakeTime and IsPeg and multisig!='':
                            try:###To do: check the spendable array instead of BlackUnspent, finish code below correctly
                                #WANT TO PRE-FILTER BY ADDRESS!?
                                #MasterOrders is a dict of outputs
                                benchmark=time.time()
                                try:
                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                        result=BLK.checkkernel(BlackUnspent3,True)
                                    else:
                                        result=BLK.checkkernel(BlackUnspent,True)
                                except:
                                    result={'found': False}
                                found=False
                                if result['found']==True:                                    
                                    SpendThis=list(FilterSpendable(OnOrders,Spendable,1,0))
                                    #Give OPTION for staking across all accounts
                                    mainaccount=0
                                    print str(result['kernel']['txid']+":"+str(result['kernel']['vout']))
                                    for inputs in BlackUnspent:#value address input
                                        if inputs['txid']+":"+str(inputs['vout'])==result['kernel']['txid']+":"+str(result['kernel']['vout']):
                                            if inputs['address'] ==  multisig:
                                                continue
                                            if result['kernel']['txid']+":"+str(result['kernel']['vout']) in MasterOrders:
                                                continue
                                            if 'StakedOrders' in AdvanceArray:
                                                if result['kernel']['txid']+":"+str(result['kernel']['vout']) in str(AdvanceArray['StakedOrders']):
                                                    continue
                                            if inputs['address'] in AdvanceArray['StakingAccounts']:                                                
                                                stakeinput={}
                                                stakeinput['output']=result['kernel']['txid']+":"+str(result['kernel']['vout'])
                                                stakeinput['value']=int(Decimal(str(inputs['amount']))*Decimal(1e8))
                                                if stakeinput['value']<6000:#Avoid staking exotic spends
                                                    continue
                                                stakeinput['address']=inputs['address']
                                                found=True
                                                break
                                    for inputs in SpendThis:#value address input                                        
                                        if inputs['output']==result['kernel']['txid']+":"+str(result['kernel']['vout']):
                                            found=True
                                            stakeinput={}
                                            stakeinput['output']=result['kernel']['txid']+":"+str(result['kernel']['vout'])
                                            stakeinput['value']=inputs['value']
                                            if stakeinput['value']<6000:#Avoid staking exotic spends
                                                continue
                                            stakeinput['address']=inputs['address']
                                            mainaccount=1
                                            break
                                    if found:#For now let's not stake exotic spend
                                        if stakeinput['output'] in NEWTxidLookup2 or stakeinput['output'] in NEWTxidLookup or stakeinput['value']==5577:
                                            found=False
                                    if found:                                        
                                        tx,mystake=mktx_kernel(result['kernel']['time'],0,"6a"+num_to_var_int((len(result['blocktemplatesignkey'])/2)).encode('hex')+result['blocktemplatesignkey'],[stakeinput])
                                        amt=BLK.getstakesubsidy(tx)
                                        val=stakeinput['value']+result['blocktemplatefees']+amt
                                        chg=val
                                        thedif=0
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            thevotes={}
                                            if ThePeg.testthis==0:
                                                thevotes=BLK.getmerklevotes()
                                            else:                                                
                                                thevotes=copy.deepcopy(TheBridgeThread.votemerkles)
                                            if thevotes != {}:
                                                for thebridge in thevotes:
                                                    if thevotes[thebridge] != 0:
                                                        voteaddy=MakeCipherOutputs('**M**' + txhash(thebridge)[:64] + thevotes[thebridge], 1)
                                                        voteaddy=str(voteaddy[0])
                                                        mystake['outs'].append({'value':5554,'script':voteaddy})
                                                        chg-=5554
                                                        thedif+=5554
                                        if len(AdvanceArray['MySettings']['Voting'])>0 and len(AdvanceArray['MySettings']['Voting'])<21:
                                            donation=0
                                            lenvotes=len(AdvanceArray['MySettings']['Voting'])                                            
                                            if AdvanceArray['MySettings']['Voting'][0]['vote']=="**DONATETOTHISADDRESS**":
                                                lenvotes-=1
                                                donation=result['blocktemplatefees']+amt-(lenvotes*5554)
                                            chg=chg-(lenvotes*5554)-donation
                                            mystake['outs'].append({'value':chg,'script':address_to_script(stakeinput['address'])})
                                            if donation>0:
                                                mystake['outs'].append({'value':donation,'script':address_to_script(AdvanceArray['MySettings']['Voting'][0]['address'])})
                                            for myvote in range(len(AdvanceArray['MySettings']['Voting'])):
                                                if donation!=0 and myvote > 0:
                                                    voteaddy=address_to_script(AdvanceArray['MySettings']['Voting'][myvote]['address'])
                                                    if AdvanceArray['MySettings']['Voting'][myvote]['vote']=='pegautomatic':
                                                        voteaddy=ThePeg.votealgorithm()
                                                        if voteaddy==False:
                                                            voteaddy=MakeCipherOutputs('pegburn', 1)
                                                            voteaddy=str(voteaddy[0])
                                                        else:
                                                            voteaddy=address_to_script(voteaddy)
                                                    mystake['outs'].append({'value':5554,'script':voteaddy})
                                                if donation==0:
                                                    if(AdvanceArray['MySettings']['Voting'][myvote]['address'][:2]) != "6a":
                                                        voteaddy=address_to_script(AdvanceArray['MySettings']['Voting'][myvote]['address'])
                                                    else:
                                                        voteaddy=AdvanceArray['MySettings']['Voting'][myvote]['address']
                                                    if AdvanceArray['MySettings']['Voting'][myvote]['vote']=='pegautomatic':
                                                        voteaddy=ThePeg.votealgorithm()
                                                        if voteaddy==False:
                                                            voteaddy=MakeCipherOutputs('pegburn', 1)
                                                            voteaddy=str(voteaddy[0])
                                                        else:
                                                            voteaddy=address_to_script(voteaddy)
                                                    mystake['outs'].append({'value':5554,'script':voteaddy})
                                        else:
                                            val=stakeinput['value']+result['blocktemplatefees']+amt-thedif
                                            mystake['outs'].append({'value':val,'script':address_to_script(stakeinput['address'])})
                                        tx=serialize(mystake)
                                        res=False
                                        res1=False
                                        coldstake=0
                                        #THE AMOUNT ON CHANGE DEPENDS ON VOTES ETC
                                        if mainaccount==0:
                                            try:
                                                msg,multiscript=create_multisig_address(AdvanceArray['StakingAccounts'][stakeinput['address']]['key1'], AdvanceArray['StakingAccounts'][stakeinput['address']]['dir1'])
                                                try:
                                                    pw1=password.DecryptWithAES(str("Halo Master"), AdvanceArray['StakingAccounts'][stakeinput['address']]['pw1'])
                                                except:
                                                    pw1=AdvanceArray['StakingAccounts'][stakeinput['address']]['pw1']
                                                sigs, res=create_sig_for_redemption([stakeinput], mystake['outs'], AdvanceArray['StakingAccounts'][stakeinput['address']]['key1'], AdvanceArray['StakingAccounts'][stakeinput['address']]['dir1'], result['kernel']['time'], 0, tx, pwtext=pw1)                                                
                                                if AdvanceArray['StakingAccounts'][stakeinput['address']]['key2']!='':
                                                    try:
                                                        pw2=password.DecryptWithAES(str("Halo Master"), AdvanceArray['StakingAccounts'][stakeinput['address']]['pw2'])
                                                    except:
                                                        pw2=AdvanceArray['StakingAccounts'][stakeinput['address']]['pw2']
                                                    sigs2, res1=create_sig_for_redemption([stakeinput], mystake['outs'], AdvanceArray['StakingAccounts'][stakeinput['address']]['key2'], AdvanceArray['StakingAccounts'][stakeinput['address']]['dir2'], result['kernel']['time'], 0, tx, pwtext=pw2)
                                                else:#Cold Stake
                                                    if AdvanceArray['MySettings']['ColdStake']!='' and res != False:
                                                        coldstake=2
                                            except:
                                                traceback.print_exc()
                                                print "Exception with multistake."
                                        else:
                                            sigs, res=create_sig_for_redemption([stakeinput], mystake['outs'], PrivKeyFilename1, PrivKeyFiledir1, result['kernel']['time'], 0, tx)
                                            if keysconnected=='2':
                                                sigs2, res1=create_sig_for_redemption([stakeinput], mystake['outs'], PrivKeyFilename2, PrivKeyFiledir2, result['kernel']['time'], 0, tx)
                                            else:
                                                msg=multisig                                                
                                                if AdvanceArray['MySettings']['ColdStake']!='' and res != False:
                                                    coldstake=2
                                        if coldstake==2:
                                            try:#XML Lib has problems with long integers
                                                ins=list([stakeinput])
                                                outs=list(mystake['outs'])
                                                indx=0
                                                for item in ins:
                                                    ins[indx]['value']=str(ins[indx]['value'])
                                                    indx+=1
                                                indx=0
                                                for item in outs:
                                                    outs[indx]['value']=str(outs[indx]['value'])
                                                    indx+=1                                                    
                                                HaloRPC = xmlrpclib.ServerProxy('http://' + AdvanceArray['MySettings']['ColdStake'] + ':55779')
                                                tx, res = HaloRPC.ColdStake(msg, multiscript, sigs, ins, outs, str(result['kernel']['time']), tx, result['blocktemplate'], str(amt), str(val), str(chg))
                                                if res==False:
                                                    print "Cold Stake Failed"
                                                else:                                                    
                                                    res=BLK.submitblock(result['blocktemplate'],{'coinstake':tx})                                                    
                                                    if "rejected" in str(res):
                                                        print "BLOCK REJECTED"
                                                        res=False
                                                    if res!=False:
                                                        res3=HaloRPC.ConfirmColdStake(tx)
                                                        if res3==True:
                                                            print "Block confirmed"
                                            except:
                                                trbk=str(traceback.format_exc())
                                                if "connected host has failed to respond" in trbk:
                                                    if waitlock() == True:
                                                        AdvanceArray['MySettings']['ColdStake']=""
                                                res=False
                                            if res!=False:
                                                coldstake=1
                                                print "Cold Stake Success!"
                                            else:
                                                print "Cold Stake Rejected"                                                
                                        if coldstake==1:                                            
                                            print "Found Stake: ", txhash(tx)
                                            totalstaked+=1
                                            NewOrder={}
                                            #Both regular expenses and pay to email still wait on the same change.
                                            NewOrder['type']="SPENT"
                                            NewOrder['stake']=True
                                            NewOrder['ordernumber']=os.urandom(16).encode('hex')
                                            NewOrder['total']=val
                                            NewOrder['change']=str(Decimal(chg)/Decimal(1e8))#-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8))
                                            NewOrder['currentblock']=CurrentBlock
                                            NewOrder['Confirmation TXID']=txhash(tx)
                                            NewOrder['inputs']=[stakeinput]
                                            NewOrder['output']=mystake['outs']
                                            NewOrder['amount']=amt
                                            NewOrder['fee']=0
                                            NewOrder['address']=stakeinput['address']
                                            NewOrder['timestamp']=timestamp
                                            NewOrder['version']=CoinSelect['HaloName'] + " " + clientversion
                                            if waitlock() == True:
                                                breakme=0
                                                while breakme==0:
                                                    breakme=1
                                                    for myvote in range(len(AdvanceArray['MySettings']['Voting'])):
                                                        if AdvanceArray['MySettings']['Voting'][myvote]['quantity']==1:
                                                            AdvanceArray['MySettings']['Voting'].pop(myvote)
                                                            breakme=0
                                                            break
                                                for myvote in range(len(AdvanceArray['MySettings']['Voting'])):
                                                    AdvanceArray['MySettings']['Voting'][myvote]['quantity']-=1
                                                if mainaccount==1:
                                                    OnOrders.append(NewOrder)
                                                else:
                                                    if stakeinput['address'] not in AdvanceArray['StakedOrders']:
                                                        AdvanceArray['StakedOrders'][stakeinput['address']]=[]
                                                    xpos=0
                                                    for myord in AdvanceArray['StakedOrders'][stakeinput['address']]:
                                                        if myord['Confirmation TXID'] in str(NewOrder['inputs']):
                                                            AdvanceArray['StakedOrders'][stakeinput['address']].pop(xpos)
                                                            break
                                                        xpos+=1
                                                    AdvanceArray['StakedOrders'][stakeinput['address']].append(NewOrder)
                                            else:
                                                AddNewOrders.append({'mainaccount': mainaccount, 'msg': stakeinput['address'], 'NewOrder': NewOrder})
                                        if res != False and res1 != False:
                                            pos=0
                                            pos2=0
                                            whoisfirst=1#Our swapping function is backwards
                                            found=0
                                            if mainaccount==0:                                        
                                                pubs=get_ordered_pubkeys(AdvanceArray['StakingAccounts'][stakeinput['address']]['key1'], AdvanceArray['StakingAccounts'][stakeinput['address']]['dir1'])
                                            else:
                                                pubs=get_ordered_pubkeys(PrivKeyFilename1)
                                            testmg,sc=create_multisig_from_publics(pubs[0],pubs[1])
                                            testmg1,sc=create_multisig_from_publics(pubs[1],pubs[0])
                                            if mainaccount==0:
                                                if need_swap(get_ordered_pubkeys(AdvanceArray['StakingAccounts'][stakeinput['address']]['key1'], AdvanceArray['StakingAccounts'][stakeinput['address']]['dir1']), AdvanceArray['StakingAccounts'][stakeinput['address']]['key1'], AdvanceArray['StakingAccounts'][stakeinput['address']]['dir1']):
                                                    whoisfirst=0
                                            else:
                                                if need_swap(get_ordered_pubkeys(PrivKeyFilename1)):
                                                    whoisfirst=0
                                            for inp in [stakeinput]:
                                                if inp['address']==stakeinput['address']:
                                                    found=1
                                                    if whoisfirst==1:
                                                        mysigs=[sigs[pos2],sigs2[pos2]]
                                                    else:
                                                        mysigs=[sigs2[pos2],sigs[pos2]]
                                                    pos2+=1
                                                    tx = apply_multisignatures(tx,pos,multiscript,mysigs)
                                                pos+=1
                                            if found==1:
                                                print "Found Stake: ", txhash(tx)
                                                res=BLK.submitblock(result['blocktemplate'],{'coinstake':tx})
                                                print "RESULT:", str(res)
                                                if "rejected" in str(res):
                                                    print "BLOCK REJECTED"
                                                    #print str(result['kernel']['time'])
                                                    #print str(timestamp)
                                                    #If the kernel time is the same as timestamp then the block
                                                    #is too early. Will have to try again.
                                                    float("a")
                                                avg=int(abs(timestamp-loadtime)/3600)#/86400
                                                if avg==0:
                                                    avg=1
                                                totalstaked+=1
                                                tt=(totalstaked/avg)
                                                if tt>1:
                                                    ts="hour"
                                                else:
                                                    avg=avg/24
                                                    if avg==0:
                                                        avg=1
                                                    tt=(totalstaked/avg)
                                                    if tt>1:
                                                        ts="day"
                                                    else:
                                                        avg=avg/30
                                                        if avg==0:
                                                            avg=1
                                                        tt=(totalstaked/avg)
                                                        ts="month"
                                                print "Blocks found per "+ts+": ", str(int(tt))
                                                NewOrder={}
                                                #Both regular expenses and pay to email still wait on the same change.
                                                NewOrder['type']="SPENT"
                                                NewOrder['stake']=True
                                                NewOrder['ordernumber']=os.urandom(16).encode('hex')
                                                NewOrder['total']=val
                                                NewOrder['change']=str(Decimal(chg)/Decimal(1e8))#-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8))
                                                NewOrder['currentblock']=CurrentBlock
                                                NewOrder['Confirmation TXID']=txhash(tx)
                                                NewOrder['inputs']=[stakeinput]
                                                NewOrder['output']=mystake['outs']
                                                NewOrder['amount']=amt
                                                NewOrder['fee']=0
                                                NewOrder['address']=stakeinput['address']
                                                NewOrder['timestamp']=timestamp
                                                NewOrder['version']=CoinSelect['HaloName'] + " " + clientversion
                                                if waitlock() == True:
                                                    breakme=0
                                                    while breakme==0:
                                                        breakme=1
                                                        for myvote in range(len(AdvanceArray['MySettings']['Voting'])):
                                                            if AdvanceArray['MySettings']['Voting'][myvote]['quantity']==1:
                                                                AdvanceArray['MySettings']['Voting'].pop(myvote)
                                                                breakme=0
                                                                break
                                                    for myvote in range(len(AdvanceArray['MySettings']['Voting'])):
                                                        AdvanceArray['MySettings']['Voting'][myvote]['quantity']-=1
                                                    if mainaccount==1:
                                                        OnOrders.append(NewOrder)
                                                    else:
                                                        if stakeinput['address'] not in AdvanceArray['StakedOrders']:
                                                            AdvanceArray['StakedOrders'][stakeinput['address']]=[]
                                                        AdvanceArray['StakedOrders'][stakeinput['address']].append(NewOrder)
                                                        xpos=0
                                                        for myord in AdvanceArray['StakedOrders'][stakeinput['address']]:
                                                            if myord['Confirmation TXID'] in str(NewOrder['inputs']):
                                                                AdvanceArray['StakedOrders'][stakeinput['address']].pop(xpos)
                                                                break
                                                            xpos+=1                                                        
                                                else:
                                                    AddNewOrders.append({'mainaccount': mainaccount, 'msg': stakeinput['address'], 'NewOrder': NewOrder})
                                        else:
                                            if coldstake!=1:
                                                pass
                            except Exception, e:
                                print traceback.print_exc()
                        iswaiting=1
                        while 'EW' in LockTHIS:
                            time.sleep(.001)
                        iswaiting=0
                        LockTHIS['ES']=1
                        ps=-1
                        theconfirmations = 2
                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                            theconfirmations = 2
                        if EscrowResults != []:
                            for command in EscrowResults:
                                print command
                                ps+=1
                                if command['BitHalo']==False:
                                    if 'raw' in command and command['raw']!="":
                                        if command['rspns']==0:
                                            su=0
                                            if 'billing' in command:
                                                if command['time']+60>timestamp:
                                                    print "Waiting..."
                                                    su=1
                                            if su==0:
                                                try:                                                    
                                                    if 'pegging' in CoinSelect and CoinSelect['pegging'] and TestnetPeg:                                                        
                                                        res=ThePeg.checktransaction(command['raw'])
                                                        if res==False:
                                                            print str(ThePeg.valid)
                                                            float('a')
                                                        if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                                                            su=1
                                                    #For main net peg you can use validaterawtransaction instead of checktransaction however we can just submit it anyways
                                                    if su==0:
                                                        EscrowResults[ps]['rspns'] = BLK.sendrawtransaction(command['raw'])
                                                except:
                                                    traceback.print_exc()
                                                    EscrowResults[ps]['rspns'] = "TX rejected"
                                    if 'history' in command and command['history']!="":
                                        if command['rspns']==0:
                                            EscrowResults[ps]['rspns']=[]
                                            try:
                                                for Black in BlackUnspent:
                                                    if Black['address']==command['history']:
                                                        spn={}
                                                        spn['value']=Black['amount']
                                                        spn['address']=Black['address']
                                                        spn['output']=Black['txid']+":"+str(Black['vout'])
                                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                            spn['liquidity']=Black['liquidity']
                                                        spn['value']=int(spn['value']*Decimal(1e8))
                                                        EscrowResults[ps]['rspns'].append(spn)
                                            except Exception, e:
                                                print "EXCEPTION TX: ", str(e)
                                            if EscrowResults[ps]['rspns']==[] or 'txid3' in command: #Well I've had problems with this "importaddress" function before so the temporary fix is to check TXID
                                                try:
                                                    if 'txid1' in command:
                                                        rawx=BLK.getrawtransaction(command['txid1'], 1)
                                                        if 'confirmations' not in rawx:
                                                            rawx['confirmations']=10
                                                        if 'addresses' in rawx['vout'][0]['scriptPubKey']:
                                                            myaddy=rawx['vout'][0]['scriptPubKey']['addresses'][0]
                                                        else:
                                                            myaddy=rawx['vout'][0]['scriptPubKey']['hex']
                                                        if rawx['confirmations']>0:
                                                            spn={}
                                                            if myaddy==command['history']:#Ok it was for the one we wanted
                                                                spn['address']=command['history']
                                                                spn['value']=int(rawx['vout'][0]['value']*Decimal(1e8))
                                                                spn['output']=command['txid1']+":0"
                                                                if 'pegging' in CoinSelect and CoinSelect['pegging'] and 'checkthis' in command:
                                                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                        if ThePeg.Pegdatabase['blockcount']<BLK.getblock(rawx['blockhash'])['height']+1:
                                                                            float('a')
                                                                    if TestnetPeg:
                                                                        liquid, reserve=ThePeg.checktransaction(spn['output'])
                                                                    else:
                                                                        fractions=BLK.getfractions(spn['output'])
                                                                        liquid, reserve=ThePeg.formatfractions(fractions, spn['address'], spn['value'])
                                                                    combined=ThePeg.checkliquidity(liquid,reserve)
                                                                    if combined==False:
                                                                        float('a')
                                                                    spn['liquidity']=combined
                                                                    spn['liquidity']=ThePeg.filterkeys(spn['liquidity'])
                                                            else:
                                                                if "Check:" in command['history']:#Ok they were looking for a specific txid unrelated to our history
                                                                    spn['address']=myaddy
                                                                    spn['value']=int(rawx['vout'][0]['value']*Decimal(1e8))
                                                                    spn['output']=command['txid1']+":0"
                                                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                            if ThePeg.Pegdatabase['blockcount']<BLK.getblock(rawx['blockhash'])['height']+1:
                                                                                float('a')
                                                                        if TestnetPeg:
                                                                            liquid, reserve=ThePeg.checktransaction(spn['output'])
                                                                        else:
                                                                            fractions=BLK.getfractions(spn['output'])
                                                                            liquid, reserve=ThePeg.formatfractions(fractions, spn['address'], spn['value'])
                                                                        combined=ThePeg.checkliquidity(liquid,reserve)
                                                                        if combined==False:
                                                                            float('a')
                                                                        spn['liquidity']=combined
                                                                        spn['liquidity']=ThePeg.filterkeys(spn['liquidity'])
                                                            EscrowResults[ps]['rspns'].append(spn)
                                                except Exception, e:
                                                    print "EXCEPTION TX1:", str(e)
                                                try:
                                                    if 'txid2' in command:
                                                        rawx=BLK.getrawtransaction(command['txid2'], 1)
                                                        if 'confirmations' not in rawx:
                                                            rawx['confirmations']=10
                                                        if 'addresses' in rawx['vout'][0]['scriptPubKey']:
                                                            myaddy=rawx['vout'][0]['scriptPubKey']['addresses'][0]
                                                        else:
                                                            myaddy=rawx['vout'][0]['scriptPubKey']['hex']
                                                        if rawx['confirmations']>0:
                                                            spn={}
                                                            if myaddy==command['history']:#Ok it was for the one we wanted
                                                                spn['address']=command['history']
                                                                spn['value']=int(rawx['vout'][0]['value']*Decimal(1e8))
                                                                spn['output']=command['txid2']+":0"
                                                                if 'pegging' in CoinSelect and CoinSelect['pegging'] and 'checkthis' in command:
                                                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                        if ThePeg.Pegdatabase['blockcount']<BLK.getblock(rawx['blockhash'])['height']+1:
                                                                            float('a')
                                                                    if TestnetPeg:
                                                                        liquid, reserve=ThePeg.checktransaction(spn['output'])
                                                                    else:
                                                                        fractions=BLK.getfractions(spn['output'])
                                                                        liquid, reserve=ThePeg.formatfractions(fractions, spn['address'], spn['value'])
                                                                    combined=ThePeg.checkliquidity(liquid,reserve)
                                                                    if combined==False:
                                                                        float('a')
                                                                    spn['liquidity']=combined
                                                                    spn['liquidity']=ThePeg.filterkeys(spn['liquidity'])
                                                                EscrowResults[ps]['rspns'].append(spn)
                                                except Exception, e:
                                                    print "EXCEPTION TX2:", str(e)
                                                try:
                                                    if 'txid3' in command:
                                                        t=0
                                                        try:
                                                            rawx=BLK.getrawtransaction(command['txid3'], 1)
                                                            t=BLK.getblock(rawx['blockhash'])
                                                        except:
                                                            #We check for the block several times, it doesn't always immediately show up
                                                            #This is not a strict rule since we are only looking for the most accurate time stamp(which should always be several days)
                                                            if tx3cont>7:
                                                                tx3cont=0
                                                            else:
                                                                float("A")
                                                            tx3cont+=1#Code never gets here, but what is the logic?
                                                            t=0
                                                        if 'confirmations' not in rawx:
                                                            rawx['confirmations']=10
                                                        if rawx['confirmations']>theconfirmations and EscrowResults[ps]['rspns']==[]:
                                                            spn={}
                                                            z=0
                                                            for out in rawx['vout']:
                                                                if 'addresses' in out['scriptPubKey']:
                                                                    myaddy=out['scriptPubKey']['addresses'][0]
                                                                else:
                                                                    myaddy=out['scriptPubKey']['hex']
                                                                if myaddy==command['history']:#Ok it was for the one we wanted
                                                                    spn['address']=command['history']
                                                                    spn['value']=int(out['value']*Decimal(1e8))
                                                                    spn['output']=command['txid3']+":"+str(z)
                                                                    EscrowResults[ps]['rspns'].append(spn)
                                                                z+=1
                                                        if t!=0:
                                                            EscrowResults[ps]['time']=t['time']#Commence their timers based on confirmed block
                                                        print "FOUND TIMESTAMP"
                                                except Exception, e:
                                                    EscrowResults[ps]['rspns']=[]
                                                    #If they change the txid, we will not be getting a timestamp and will use the internet timestamp
                                                    #That does pose a slight risk of both parties having different accept times. This is why all contracts have a buffer of time.
                                                    print "EXCEPTION TX3:", str(e), command['txid3']
                                    print "RESPONSE"
                                    print command['rspns']
                            DontExit[1]=1
                            SaveOtherdata()
                            DontExit[1]=0
                        if waitlock() == True:
                            if 'clearnotxid' in AdvanceArray:#For cleaning up the array when checking histories
                                fnd=1
                                while fnd==1:
                                    i=0
                                    fnd=0
                                    skpme=0
                                    for ords in OnOrders:
                                        if 'type' in ords:
                                            if ords['type']=="CONTRACT" or ords['type']=="2STEP" or ords['type']=="SPENT" or ords['type']=="PAY TO EMAIL":
                                                skpme=1
                                    for command in EscrowResults:
                                        try:
                                            if 'sender' in command: #Sometimes these get left behind
                                                if MyContracts==[] and skpme==0:#No contracts or orders are live
                                                    if command['sender']==multisig:
                                                        EscrowResults.pop(i)
                                                        fnd=1
                                                        break
                                        except:
                                            print "Error clearing old raw"
                                        if 'notxid' in command:
                                            EscrowResults.pop(i)
                                            fnd=1
                                            break
                                        i+=1
                                AdvanceArray.pop('clearnotxid')
                        LockTHIS.pop('ES',None)
                        if WatchlistQueue != []:#I have noticed timeouts on importaddress... so we have a queue for this
                            pos=0
                            l = len(WatchlistQueue)
                            while pos<l:
                                watch=WatchlistQueue[pos]
                                try:
                                    if watch[:1]=="0":
                                        BLK.importaddress(watch[1:], "", False)
                                    else:
                                        if multisig=='':
                                            pos+=1
                                            continue
                                        BLK.importaddress(watch[1:], "", False) #BLK.importaddress(watch[1:], "") #This command causes crashing sometimes when rescan is asked for... import and rescan manually
                                        if multisig not in addrlist:
                                            rescanning=1
                                            addrlist.append(multisig)
                                    WatchlistQueue.pop(pos)
                                    l-=1
                                    print "Success importing wallet"
                                except Exception, e:
                                    pos+=1
                                    print "IMPORT WALLET EXCEPTION:", str(e)
                        DontExit[1]=1
                        SaveOtherdata()
                        DontExit[1]=0
                        #Here we check for the txids with 5500 satoshis. If they are encrypted messages with a bitmessage account we add it as a contact request.
                        global TxidLookup
                        for txid in TxidLookup:
                            if NewUser!=[]:#A new user is coming in we will do this some other time
                                break
                            skip=0
                            global DontRepopulate
                            for populate in DontRepopulate:
                                if populate==txid:
                                    skip=1
                            for contract in MyContracts:
                                if contract['ordernumber']==txid:
                                    if 'sent' in contract:
                                        skip=1
                            if skip==0:
                                try:
                                    xxx=BLK.getrawtransaction(txid, 1)
                                    ps=0
                                    addrs=[]
                                    for out in xxx['vout']:
                                        if ps==0:
                                            ps+=1
                                            continue
                                        if str(out['value'])=="0.00005500":
                                            addrs.append(out['scriptPubKey']['addresses'][0])
                                    if addrs:
                                        try:
                                            if waitlock()==False:
                                                float("a")
                                            message=DecodeCipherOutputs(addrs)
                                            message=message.rstrip('*')
                                            if window.EnableEmail.isChecked():
                                                if "@" in message:#Ok it looks like they sent us a contract lets message them
                                                    GetEmailGlobals()
                                                    if MyEmail != "":
                                                        Order={}
                                                        Order['Command']='Send'
                                                        Order['MyBMAddress']=MyEmail
                                                        Order['TheirBMAddress']=message
                                                        Order['Process']='Handshake'
                                                        Order['type']="CONTRACT"
                                                        Order['ordernumber']=txid.encode("ascii")
                                                        Order['status']="offer"
                                                        Order['version']=CoinSelect['HaloName'] + " " + clientversion
                                                        Order['currentblock']=CurrentBlock
                                                        Order['sent']=1
                                                        DontRepopulate.append(Order['ordernumber'])
                                                        MyContracts.append(Order)
                                                        BitQueue.append(Order)
                                                        DontExit[1]=1
                                                        SaveQueue()
                                                        DontExit[1]=0
                                            if window.EnableBitmessage.isChecked():
                                                if "BM-" in message:#Ok it looks like they sent us a contract lets message them
                                                    BitAddr=GetfromCfg("#BitMessage#")
                                                    Order={}
                                                    Order['Command']='Send'
                                                    Order['MyBMAddress']=BitAddr
                                                    Order['TheirBMAddress']=message
                                                    Order['Process']='Handshake'
                                                    Order['type']="CONTRACT"
                                                    Order['ordernumber']=txid.encode("ascii")
                                                    Order['status']="offer"
                                                    Order['version']=CoinSelect['HaloName'] + " " + clientversion
                                                    Order['currentblock']=CurrentBlock
                                                    Order['sent']=1
                                                    DontRepopulate.append(Order['ordernumber'])
                                                    MyContracts.append(Order)
                                                    BitQueue.append(Order)
                                                    DontExit[1]=1
                                                    SaveQueue()
                                                    DontExit[1]=0
                                        except Exception, ex:
                                            print str(ex)
                                except Exception, e:
                                    print "Did not get raw... will try again later"
                                    traceback.print_exc()
                        DontExit[1]=1
                        SaveOtherdata()
                        DontExit[1]=0
                        isdownloading=0
                        notDownloading = 1
                        iswaiting=1
                        time.sleep(1)
                        while lockdownload==1 or lockdownload2==1:
                            time.sleep(.001)
                        iswaiting=0
            except:
                try:
                    LockTHIS.pop('ES',None)
                except:
                    pass
                isdownloading=0
                traceback.print_exc()
            if count==7:
                count=0
                timethis=time.time()
                if BitHaloClient==False:
                    isdownloading=1
                    updatesomething=1
        return
class DownloadThread(QtCore.QThread):#For BitHalo electrum server and general downloading
    def __init__(self, url):
        QtCore.QThread.__init__(self)
        self.url = url
    def stop(self):
        self.exit()
    def run(self):
        global updatesomething, isdownloading, interneton, globaltxh, globaltx,globalargs, NewUser, UpdateMessage, BitARGS
        global MyContracts, OnOrders
        global CurrentBlock,HaloTime
        global lockdownload
        global Biteasy
        global BitEasyPrev
        global publicaddress
        global CoinMarketCap
        global checkpastebin
        global uploadnew
        global AdvanceArray
        global LockTHIS
        global EscrowResults
        global DontExit
        global NEWTxidLookup
        global NEWTxidLookup2
        global BitcoinCASH
        global CanStakeTime
        global btcfeekb
        global iswaiting
        global githubrates
        global thecoins
        global CoinGecko
        BitEasyPrev={}
        blockapi = testblock.bitcoinapi()
        count = 0
        checktime=1
        ipserver=1
        time.sleep(3)
        while count < 60:
            DontExit[2]=0
            #For all halos we go off bitcoins blocks(for consistency) and googles time(for agreement and safety)
            xz=0
            while xz == 0:#Give me something to break out of
                xz+=1
                if internet_on()==True:
                    interneton=1
                    if checktime==1:
                        try:
                            for paste in checkpastebin:
                                try:
                                    if checkpastebin[paste]=="":
                                        try:
                                            checkpastebin[paste]=showpaste(paste)
                                            if checkpastebin[paste]==False:
                                                checkpastebin[paste]="FALSE"
                                        except:
                                            checkpastebin[paste]="FALSE"
                                except:
                                    pass
                        except:
                            pass
                        try:
                            for newpaste in uploadnew:
                                if uploadnew[newpaste]['result']=="waiting":
                                    try:
                                        ID=fpaste(uploadnew[newpaste]['image'])
                                        if ID == False:
                                            float("A")
                                        uploadnew[newpaste]['result']=ID
                                    except:
                                        uploadnew[newpaste]['result']="false"
                        except:
                            print "Exception with uploading pastebin"
                        try:
                            CurrentBlock=int(str(requestURL("https://blockchain.info/q/getblockcount")))
                            float(CurrentBlock)
                        except:
                            CurrentBlock=0
                        try:
                            HaloTime=requestURL("https://just-the-time.appspot.com/")
                            if "UTC" not in str(HaloTime):
                                HaloTime+="UTC"
                        except:
                            HaloTime=""
                        #Use regex to convert string to date/time this way we can use it in math operations
                        try:
                            matchObj = re.match( r'(.*)-(.*?)-(.*?) (.*?):(.*?):(.*?) UTC', HaloTime, re.M|re.I)
                            try:
                                HaloTime = datetime.datetime(int(matchObj.group(1)),int(matchObj.group(2)),int(matchObj.group(3)),int(matchObj.group(4)),int(matchObj.group(5)),int(matchObj.group(6)))
                                hd=HaloTime-datetime.datetime.utcnow()
                                hd=abs(hd.total_seconds())
                                if hd > 600: #Ten minute difference in our time vs internet time, this can effect staking and synchronizing
                                    CanStakeTime=False
                                else:
                                    CanStakeTime=True
                                if hd > 86400: #Make sure UTC site didn't get hacked, better safe than sorry.
                                    float('a')
                            except:
                                HaloTime = datetime.datetime(1970, 1, 1, 0, 0, 0, 0)#Ok it failed we now have a time that can't pass a current time
                        except:
                            pass
                        try:
                            UpdateMessage=requestURL("https://bithalo.github.io/bithalo/updates.htm")
                        except:
                            UpdateMessage=clientversion
                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                            try:
                                TheBridgeThread.mypairs=json.loads(requestURL("https://github.com/bitbaymarket/Bitbay-Solidity/Html/bridgepairs.txt"))
                            except:
                                pass
                        try:
                            githubrates=json.loads(requestURL("https://raw.githubusercontent.com/bitbaymarket/ratedb/master/rates.json"))
                            tbtc=Decimal(int((Decimal(githubrates['BAY']['price'])/Decimal(githubrates['BTC']['price']))*Decimal(1e8)))/Decimal(1e8)
                            tbtc=dropzeros(remove_exponent(tbtc),1)
                            thecoins=' id="id-'+'bitcoin'+'price" data-usd="'+str(githubrates['BTC']['price'])+'"'+' data-btc="'+'1'+'"'+'id="id-'
                            thecoins+=' id="id-'+'bitbay'+'price" data-usd="'+str(githubrates['BAY']['price'])+'"'+' data-btc="'+str(tbtc)+'"'+'id="id-'
                        except:
                            thecoins=''
                            print "Exception getting rates"
                        try:
                            try:
                                CoinMarketCap2=''
                                if CoinSelect['name'] not in CoinMarketCap2:#Eventually we could iterate all coins in CoinSelect
                                    if CoinSelect['name'] == "BitBay":
                                        CoinMarketCap2+=' id="id-'+CoinSelect['name'].lower()+'price" data-usd="'+str(githubrates['BAY']['price'])+'"'+' data-btc="'+str(tbtc)+'"'+'id="id-'
                                    else:
                                        try:
                                            if CoinGecko == 1:
                                                float('a')
                                            try:
                                                mycoin = requestURL('https://coinmarketcap.com/currencies/' + CoinSelect['name'])
                                                tusd = mycoin.split('<span class="cmc-details-panel-price__price">$')[1].split('</span>')[0].replace(',', '')
                                                tbtc = mycoin.split('<span class="cmc-details-panel-price__crypto-price">')[1].split(' BTC</span>')[0].replace(',', '')
                                            except:
                                                CoinGecko = 1
                                                float('a')
                                        except:
                                            try:
                                                mycoin = requestURL('https://www.coingecko.com/en/coins/' + CoinSelect['name'].lower())
                                                tusd = mycoin.split('data-target="price.price">$')[1].split('</span>')[0].replace(',', '')
                                                try:
                                                    tbtc = mycoin.split('class="text-muted text-normal">\n')[1].split(' BTC')[0].replace(',', '')
                                                except:
                                                    tbtc = mycoin.split('data-price-btc="')[1].split('"')[0].replace(',', '')
                                            except:
                                                CoinGecko = 0
                                                float('a')
                                        CoinMarketCap2+=' id="id-'+CoinSelect['name'].lower()+'price" data-usd="'+tusd+'"'+' data-btc="'+tbtc+'"'+'id="id-'
                                usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap2, 0)
                                if usd=="":
                                    float('a')
                                CoinMarketCap=CoinMarketCap2
                            except:
                                if thecoins=='':
                                    float('a')
                                #print "Coinmarketcap exception: Using rate from github"
                                CoinMarketCap=thecoins
                            #Need to grab a price history for price tracking
                            if waitlock(1000) == True:
                                if 'charts' not in AdvanceArray:
                                    AdvanceArray['charts']={}
                                x=UniversalTimeStamp
                                for coin in Coins:#Need to record ranges of time for the prices
                                    usd,btc=GetMarketValue(coin['name'],CoinMarketCap)
                                    if usd != "":
                                        if coin['name'] not in AdvanceArray['charts']:
                                            AdvanceArray['charts'][coin['name']]=[{'starttime':abs(round(int(x)-500,-3)),'endtime':abs(round(int(x)+500,-3)),'price':usd}]
                                        if AdvanceArray['charts'][coin['name']][0]['price']==usd:
                                            AdvanceArray['charts'][coin['name']][0]['endtime']=abs(round(int(x)+500,-3))
                                        else:
                                            AdvanceArray['charts'][coin['name']].insert(0,{'starttime':abs(round(int(x)-500,-3)),'endtime':abs(round(int(x)+500,-3)),'price':usd})
                                        if len(AdvanceArray['charts'][coin['name']])>480:
                                            AdvanceArray['charts'][coin['name']].pop()
                        except:
                            print "Marketcap Exception"
                            try:
                                usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap, 0)#if the data is junk this probably will not work
                            except:
                                pass
                        try:
                            if ipserver==1:
                                publicaddress = json.loads(requestURL('https://api64.ipify.org/?format=json'))['ip']                                
                            else:
                                publicaddress = requestURL('https://ip.42.pl/raw')
                        except:
                            if ipserver==1:
                                ipserver=0
                            else:
                                ipserver=1
                            try:
                                publicaddress = requestURL('https://ip.42.pl/raw')
                            except:
                                pass
                        try:
                            startdate=datetime.datetime(2018, 6, 1, 0, 0, 0, 0)
                            if 'btchistory' not in AdvanceArray:
                                AdvanceArray['btchistory']={'peak':'20000', 'date': (2018, 6, 1, 0, 0, 0, 0)}
                            
                            curtime = str(HaloTime)[:7]+'-01'
                            if curtime not in AdvanceArray['btchistory']:
                                btchist=json.loads(requestURL('https://api.coindesk.com/v1/bpi/historical/close.json?start=2018-06-01' + '&end=' + curtime))['bpi']
                                while startdate<HaloTime:
                                    mydate=ConvertDate(startdate,0)
                                    if str(startdate)[:10] in btchist: #Keep checking until it appears
                                        peak=int(Decimal(str(btchist[str(startdate)[:10]])))
                                        if str(startdate)[:10] not in AdvanceArray['btchistory']:
                                            AdvanceArray['btchistory'][str(startdate)[:10]]=peak
                                            if int(AdvanceArray['btchistory']['peak'])<int(peak):
                                                AdvanceArray['btchistory']['peak']=AdvanceArray['btchistory'][str(startdate)[:10]]
                                                AdvanceArray['btchistory']['date']=mydate
                                                print "New peak price: ", AdvanceArray['btchistory']['peak'], str(mydate)
                                    startdate=addmonths(1,startdate)
                            
                            if HaloTime-ConvertDate(AdvanceArray['btchistory']['date'],1)>datetime.timedelta(days=31):
                                AdvanceArray['btchistory']['peak']=str(int(Decimal(AdvanceArray['btchistory']['peak'])*Decimal(1.01)))
                                AdvanceArray['btchistory']['date']=ConvertDate(addmonths(1,ConvertDate(AdvanceArray['btchistory']['date'],1)),0)
                                print "New peak price: ", AdvanceArray['btchistory']['peak'], str(AdvanceArray['btchistory']['date'])
                            peak=Decimal(AdvanceArray['btchistory']['peak'])/Decimal('100000')
                            usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap, 0)
                            if usd!='':
                                if Decimal(usd)*Decimal(0.35)>peak:#Perhaps we can set a new floor
                                    #It's probably a good idea to have electrum style nodes track this data for new users
                                    #the price history otherwise would be totally relative to when a node is active
                                    newparadigm=0
                                    for rate in AdvanceArray['charts'][CoinSelect['name']]:
                                        if Decimal(rate['price'])*Decimal(0.35)>peak:
                                            newparadigm+=1
                                    if newparadigm>300:
                                        AdvanceArray['btchistory']['peak']=str(Decimal(AdvanceArray['btchistory']['peak'])*Decimal(1.5))
                        except:
                            traceback.print_exc()
                        try:
                            btcfeekb=0
                            if BitHaloClient:
                                btcfee=str(requestURL('https://bitcoinfees.earn.com/api/v1/fees/recommended'))
                                btcfeekb=int(json.loads(btcfee)['fastestFee'])
                        except:
                            btcfeekb=0
                        checktime=0
                else:
                    interneton=0
                try:
                    if BitHaloClient==True:#At some point we should store what we download in memory.
                        if updatesomething==1:
                            if interneton == 1:
                                interneton=1
                                updatesomething=1
                                isdownloading=1
                                BitAddr=GetfromCfg("#BitMessage#")
                                if NewUser != []:
                                    isdownloading=0
                                    break
                                multisig,multiscript=create_multisig_address(PrivKeyFilename1)
                                if NewUser != []:
                                    isdownloading=0
                                    break
                                while lockdownload==1:
                                    time.sleep(.001)
                                if BitHaloClient==True:
                                    while 'EW' in LockTHIS:#Message Scanning also uses EscrowResults
                                        time.sleep(.001)
                                    LockTHIS['ES']=1
                                    ps=-1
                                    for command in EscrowResults:
                                        ps+=1
                                        if command['BitHalo']==True:
                                            if 'raw' in command and command['raw']!="":
                                                if command['rspns']==0:
                                                    su=0
                                                    if 'billing' in command:
                                                        if command['time']+60>timestamp:
                                                            print "Waiting..."
                                                            su=1
                                                    if su==0:                                                    
                                                        try:
                                                            EscrowResults[ps]['rspns'] = sendBTCtx(command['raw'])
                                                        except:
                                                            pass
                                            if 'history' in command and command['history']!="":
                                                if command['rspns']==0:
                                                    if 'txid1' in command:
                                                        if 'Check:' in command['history']:
                                                            try:
                                                                command['rspns']=[json.loads(requestURL('https://blockchain.info/rawtx/'+command['history'].replace("Check:","")))]
                                                            except Exception, e:
                                                                pass
                                                    try:
                                                        if 'Check:' not in command['history']:
                                                            EscrowResults[ps]['rspns'] = history(command['history']) #History is located in pybitcointools and pyblackcointools
                                                            mpos=0
                                                            for h in EscrowResults[ps]['rspns']:
                                                                try:
                                                                    a=str(requestURL("https://blockchain.info/rawblock/"+str(h['block_height'])+"?format=json"))
                                                                    EscrowResults[ps]['rspns'][mpos]['time']=int(a.split('"time":')[1].split(',')[0].strip())
                                                                except:
                                                                    pass
                                                                mpos+=1
                                                    except:
                                                        pass
                                                        #Try again later. However if blockchain.info doesn't respond for a block time, it is possible the two parties will not have an exact agreed upon time.
                                                        #So the question remains, should they find another way to agree on a start time or should they wait?
                                                        #EscrowResults[ps]['rspns']=[]#If we want to wait and keep checking for a valid time
                                            print "RESPONSE"
                                            print command['rspns']
                                    if waitlock() == True:
                                        if 'clearnotxid' in AdvanceArray:
                                            fnd=1
                                            while fnd==1:
                                                i=0
                                                fnd=0
                                                skpme=0
                                                for ord1 in OnOrders:
                                                    if 'type' in ord1:
                                                        if ord1['type']=="CONTRACT" or ord1['type']=="2STEP" or ord1['type']=="SPENT" or ord1['type']=="PAY TO EMAIL":
                                                            skpme=1
                                                for command in EscrowResults:
                                                    try:
                                                        if 'sender' in command: #Sometimes these get left behind
                                                            if MyContracts==[] and skpme==0:#No contracts or orders are live
                                                                if command['sender']==multisig:
                                                                    EscrowResults.pop(i)
                                                                    fnd=1
                                                                    break
                                                    except:
                                                        print "Error clearing old raw"
                                                    if 'notxid' in command:
                                                        EscrowResults.pop(i)
                                                        fnd=1
                                                        break
                                                    i+=1
                                            AdvanceArray.pop('clearnotxid')
                                    LockTHIS.pop('ES',None)
                                    DontExit[2]=1
                                    SaveOtherdata()
                                    DontExit[2]=0
                                    #query online servers for a list of txs at this address with block height
                                    try:#Its one large try because bogus results or timeouts will throw an error
                                        #need to build a list of requests to send to parse, asking for the raw transaction data
                                        justskipme=0
                                        BitEasyPrev2=dict(Biteasy)
                                        Biteasy={}
                                        #Blockchain.info they do everything backwards with big endian https://blockchain.info/unspent?active=1jF5y195UEEYzQQssAjumJquXiCwfkxCq
                                        #To make sure it waits for at least one confirmation add &confirmations=1 at the end of the request
                                        if Biteasy=={}:
                                            try:                                                
                                                spen=[]
                                                biths=[]
                                                rec=0
                                                print multisig
                                                if not BitcoinCASH:
                                                    print "Getting Bitcoin data from blockchain.info..."
                                                    x= str(requestURL("https://blockchain.info/unspent?active="+multisig+"&format=json&confirmations=1"))
                                                    if "No free outputs to spend" in x:
                                                        x={}
                                                        x['unspent_outputs']=[]
                                                    else:
                                                        x= ast.literal_eval(x)
                                                    for op in x['unspent_outputs']:
                                                        spn={}
                                                        bith={}
                                                        if op['confirmations'] > 0:
                                                            spn['value']=op['value']
                                                            spn['address']=multisig
                                                            spn['output']=str(ReverseHash(op['tx_hash']))+":"+str(op['tx_output_n'])
                                                            bith['Values']=[op['value']]
                                                            bith['Txid']=str(ReverseHash(op['tx_hash']))
                                                            bith['vout']=[op['tx_output_n']]
                                                            rec+=op['value']
                                                            spen.append(spn)
                                                            biths.append(bith)
                                                    Biteasy['unspent']=spen
                                                    Biteasy['received']=rec
                                                    Biteasy['history']=biths
                                                    Biteasy['api']="Blockchain"
                                                else:
                                                    print "Getting Bitcoin CASH data from bitcoin.com..."#Since this is only a debug feature will want users to use their own API keys or choose from a set.
                                                    #Bitcoin SV is as below
                                                    #str(requestURL("https://api.whatsonchain.com/v1/bsv/main/address/"+multisig+"/unspent"))
                                                    x= str(requestURL("https://rest.bitcoin.com/v2/address/utxo/"+multisig))
                                                    x= json.loads(x)
                                                    for op in x['utxos']:
                                                        spn={}
                                                        bith={}
                                                        spn['value']=op['satoshis']
                                                        spn['address']=multisig
                                                        spn['output']=str(op['txid'])+":"+str(op['vout'])
                                                        bith['Values']=[op['satoshis']]
                                                        bith['Txid']=str(op['txid'])
                                                        bith['vout']=[op['vout']]
                                                        rec+=op['satoshis']
                                                        spen.append(spn)
                                                        biths.append(bith)
                                                    Biteasy['unspent']=spen
                                                    Biteasy['received']=rec
                                                    Biteasy['history']=biths
                                                    Biteasy['api']="bitcoin.com"                                                   
                                            except Exception, e:#Both sites may be down
                                                Biteasy={}
                                                #traceback.print_exc()
                                                pass                                        
                                        #Biteasy
                                        if Biteasy=={} and not BitcoinCASH:
                                            try:
                                                print "Getting Bitcoin data from api.biteasy.com..."
                                                spen=[]
                                                biths=[]
                                                rec=0
                                                x= "https://api.biteasy.com/blockchain/v1/addresses/"+multisig+"/unspent-outputs?page=1"                                                
                                                x = json.loads(requestURL(x))
                                                pg=2
                                                y=dict(x)
                                                while y['data']['pagination']['next_page']!=False:
                                                    y = "https://api.biteasy.com/blockchain/v1/addresses/"+multisig+"/unspent-outputs?page="+str(pg)
                                                    y = json.loads(requestURL(y))
                                                    for op in y['data']['outputs']:
                                                        x['data']['outputs'].append(op)
                                                    pg+=1
                                                for op in x['data']['outputs']:
                                                    spn={}
                                                    bith={}
                                                    spn['value']=op['value']
                                                    spn['address']=op['to_address']
                                                    spn['output']=op['transaction_hash']+":"+str(op['transaction_index'])
                                                    bith['Values']=[op['value']]
                                                    bith['Txid']=op['transaction_hash']
                                                    bith['vout']=[op['transaction_index']]
                                                    rec+=op['value']
                                                    spen.append(spn)
                                                    biths.append(bith)
                                                Biteasy['unspent']=spen
                                                Biteasy['received']=rec
                                                Biteasy['history']=biths
                                                Biteasy['api']="Biteasy"
                                            except Exception,e:
                                                Biteasy={}
                                                #traceback.print_exc()
                                                pass
                                        if Biteasy==BitEasyPrev and "*" not in str(BitEasyPrev2):
                                            Biteasy=json_deep_copy(BitEasyPrev2)
                                            justskipme=1
                                        else:
                                            BitEasyPrev=str(dict(Biteasy))
                                            BitEasyPrev=ast.literal_eval(BitEasyPrev)
                                        #We should make it eventually so Biteasy txids are listed for electrum so only new transactions are needed
                                        #Anyways, if the first two fail we try electrum
                                        if Biteasy=={}:
                                            print "Electrum disabled"
                                            #The electrum nodes and process has changed so for now this section is disabled
                                            float('a')
                                            txdetails = ea.get_from_electrum([multisig],t='a')
                                            x = txdetails[0]
                                            args=[]
                                            for txdict in x['result']:
                                                args.append([txdict["tx_hash"],txdict["height"]])
                                            #place transactions in order of height for correct calculation of balance
                                            args.sort(key=lambda x: int(x[1]))
                                            #unconfirmed will now be at the beginning but need to be at the end
                                            unconf_args = [item for item in args if item[1]==0]
                                            conf_args = [item for item in args if item[1]!=0]
                                            args = conf_args +unconf_args
                                            globalargs=args
                                            #This is to make downloading thread efficient
                                            txs=globaltx
                                            for arg in args:
                                                if arg not in BitARGS:
                                                    BitARGS.append(arg)
                                                    tempar=[]
                                                    txs1=[]
                                                    tempar.append(arg)
                                                    txs1= ea.get_from_electrum(tempar,t='t')#These are prone to timeout on slow internet.
                                                    txs.append(txs1[0])
                                                if NewUser != []:#We don't want to be stuck downloading while waiting to switch
                                                    isdownloading=0
                                                    break
                                            if NewUser != []:
                                                isdownloading=0
                                                break
                                        #This was how I could get the sender however usually I just use a function to get it from the script in the input unless im using an online api
                                        if Biteasy != {} and justskipme==0:
                                            try:
                                                i=0
                                                foundtxid={}#This variable can be global so it doesnt keep repeating. It would have to store all the IDs in memory. For now, we just download it each time.
                                                for d in Biteasy['history']:
                                                    if NewUser != []:
                                                        float("A")
                                                        break
                                                    #tx=pybit.deserialize(d['result']) #the full tx from our electrum results
                                                    try:
                                                        if 'Inputs' not in d:
                                                            Biteasy['history'][i]['Inputs']=[]
                                                        if d['Txid'] in foundtxid and 'FROM' not in d:
                                                            Biteasy['history'][i]['FROM']=Biteasy['history'][i-1]['FROM']
                                                        if d['Txid'] not in foundtxid and 'FROM' not in d:
                                                            #Here we dont need to ask to parse str(tx['ins'][0]['outpoint']['hash']) because blockchain.info has previous output listed when the transaction is queried
                                                            try:
                                                                print "Getting info about sender: ", d['Txid']
                                                                #getaddress=requestURL("https://blockchain.info/tx-index/"+d['Txid']+"?format=json")
                                                                getaddress=requestURL("https://blockchain.info/rawtx/"+d['Txid']+"?format=json")
                                                                try:
                                                                    getaddress=json.loads(getaddress)
                                                                    if 'addr' not in getaddress['inputs'][0]['prev_out']:
                                                                        if 'script' not in getaddress['inputs'][0]['prev_out']:
                                                                            Biteasy['history'][i]['FROM']="*"
                                                                        else:
                                                                            Biteasy['history'][i]['FROM']=getaddress['inputs'][0]['prev_out']['script']
                                                                    else:
                                                                        Biteasy['history'][i]['FROM']=getaddress['inputs'][0]['prev_out']['addr']
                                                                    #matchObj=re.match(r'(.*?)("addr":")(.*?)"', getaddress, re.M|re.I)
                                                                    #Biteasy['history'][i]['FROM']=str(matchObj.group(3))
                                                                    #foundtxid[d['Txid']]=str(matchObj.group(3))
                                                                except:
                                                                    traceback.print_exc()
                                                                    float('a')
                                                                    #getaddy=json.loads(getaddress)
                                                                    #Biteasy['history'][i]['FROM']=str(getaddy['inputs'][0]['prev_out']['addr'])
                                                                    #foundtxid[d['Txid']]=str(getaddy['inputs'][0]['prev_out']['addr'])
                                                            except:
                                                                traceback.print_exc()
                                                                float('a')
                                                                raw =ea.get_from_electrum([d['Txid']],t='t')
                                                                x=pybit.deserialize(raw[0]['result'])
                                                                gt=ea.get_address_from_input_script(x['ins'][0]['script'].decode('hex'))
                                                                for gtt in gt:
                                                                    pass
                                                                Biteasy['history'][i]['FROM']=gtt
                                                                foundtxid[d['Txid']]=gtt
                                                        i+=1
                                                    except Exception, e:
                                                        #traceback.print_exc()
                                                        Biteasy['history'][i]['FROM']="*"
                                                        i+=1
                                                if NewUser != []:
                                                    isdownloading=0
                                                    break
                                                try:
                                                    j=0
                                                    prev=""
                                                    leng=len(Biteasy['history'])
                                                    #This function just keeps our format consistent with how we are getting the data in electrum
                                                    while j<leng:
                                                        next1=1
                                                        found=0
                                                        if Biteasy['history'][j]['Txid']==prev:
                                                            Biteasy['history'][j-1]['Values'].append(Biteasy['history'][j]['Values'][0])
                                                            Biteasy['history'][j-1]['Inputs'].append(Biteasy['history'][j]['FROM'])
                                                            Biteasy['history'][j-1]['vout'].append(Biteasy['history'][j]['vout'][0])
                                                            found=1
                                                        else:
                                                            Biteasy['history'][j]['Inputs'].append(Biteasy['history'][j]['FROM'])

                                                        prev=Biteasy['history'][j]['Txid']
                                                        if found==1:#This got spent, this would be obvious just using the new list but since we want more advanced info later, we avoid making so many requests to the daemon
                                                            next1=0
                                                            leng-=1
                                                            Biteasy['history'].pop(j)
                                                        if next1==1:
                                                            j+=1
                                                except Exception, e:
                                                    traceback.print_exc()
                                                    txs=0
                                                    txdetails=0
                                                    Biteasy={}
                                            except Exception, e:
                                                pass
                                        if Biteasy != {}:#Here we check for unconfirmed.
                                            try:                                                
                                                Biteasy['unconfirmed']=[]
                                                v=0
                                                txs=0
                                                txdetails=0
                                                float('a')
                                                txdetails = ea.get_from_electrum([multisig],t='a')
                                                x = txdetails[0]
                                                args=[]
                                                for txdict in x['result']:
                                                    args.append([txdict["tx_hash"],txdict["height"]])
                                                #place transactions in order of height for correct calculation of balance
                                                args.sort(key=lambda x: int(x[1]))
                                                #unconfirmed will now be at the beginning but need to be at the end
                                                conf_args= [item for item in args if item[1]!=0]
                                                unconf_args = [item for item in args if item[1]==0]
                                                args=unconf_args
                                                for arg in unconf_args:#Blockchain.info constantly trips up ast.literal and it gives json errors to so we just have a little fun with regex
                                                    raw=[]
                                                    try:
                                                        getvalue=requestURL("https://blockchain.info/tx-index/"+str(arg[0])+"?format=json")
                                                    except:
                                                        traceback.print_exc()
                                                        raw =ea.get_from_electrum([arg[0]],t='t')
                                                    if raw != []:
                                                        try: #Eventually we are going to have to see if the transaction is from someone else or us because it effects out sent outputs for change.
                                                            x=pybit.deserialize(raw[0]['result'])
                                                            #ea.get_address_from_input_script(x['ins'][0]['script'].decode('hex'))
                                                            for o in x['outs']:
                                                                gt= ea.get_address_from_output_script(o['script'].decode('hex'))
                                                                if multisig==gt[1]:
                                                                    v=v+o['value']
                                                        except Exception, e:
                                                            traceback.print_exc()
                                                    else:
                                                        getvalue=getvalue.replace(" ","")
                                                        getvalue=getvalue.replace("\r","")
                                                        getvalue=getvalue.replace("\n","")
                                                        getvalue = getvalue.split('"out":')[1]
                                                        matchObj=" "
                                                        while matchObj!="":
                                                            my_regex = r'(.*?"addr":"' + re.escape(multisig) + '",)("value":)(.*?),'
                                                            matchObj=None
                                                            matchObj=re.match(my_regex, str(getvalue), re.M|re.I)
                                                            try:
                                                                rep=matchObj.group(1)+matchObj.group(2)+matchObj.group(3)
                                                                getvalue=getvalue.replace(rep,'', 1)
                                                            except:
                                                                pass
                                                            if matchObj is not None:
                                                                v=v+int(matchObj.group(3))
                                                            else:
                                                                break
                                                    Biteasy['unconfirmed'].append(v)
                                            except Exception, e:
                                                if BitcoinCASH:
                                                    Biteasy['unconfirmed']=[]
                                                else:
                                                    try:
                                                        val=0
                                                        val=ast.literal_eval(requestURL("https://sochain.com/api/v2/get_address_received/btc/"+multisig))
                                                        val=val['data']['unconfirmed_received_value']
                                                        val=int(Decimal(str(val))*Decimal(1e8))
                                                        Biteasy['unconfirmed'].append(val)
                                                    except:
                                                        try:
                                                            float('a')#not using this service since unconfirmed wasn't showing anyways.
                                                            val=0
                                                            val=int(ast.literal_eval(requestURL("https://blockexplorer.com/api/addr/"+multisig+"/unconfirmedBalance")))
                                                            Biteasy['unconfirmed'].append(val)
                                                        except:
                                                            #If unconfirmed APIs are down just proceed and wait
                                                            Biteasy['unconfirmed']=[]
                                        globaltxh=txdetails
                                        globaltx=txs
                                        global skipthis
                                        skipthis=""
                                        #Here we check blockchain.info for the txids with 5500 satoshis. If they are encrypted messages with a bitmessage account we add it as a contact request.
                                        global TxidLookup
                                        for txid in TxidLookup:
                                            if NewUser!=[]:#A new user is coming in we will do this some other time
                                                break
                                            skip=0
                                            global DontRepopulate
                                            for populate in DontRepopulate:
                                                if populate==txid.encode("ascii"):
                                                    skip=1
                                            for contract in MyContracts:
                                                if contract['ordernumber']==txid.encode("ascii"):
                                                    if 'sent' in contract:
                                                        skip=1
                                            if BitcoinCASH:
                                                skip=1
                                            if skip==0:
                                                x=requestURL('https://blockchain.info/rawtx/'+(txid.encode("ascii")))
                                                matchObj=re.match(r'(.*?)("value":5500,"addr":")(.*?)(")(.*?)("value":5500,"addr":")(.*?)(")(.*?)("value":5500,"addr":")(.*?)(")', x, re.M|re.I)
                                                matchObj=re.match(r'(.*?)("value":5500,"addr":")(.*?)(")(.*?)("value":5500,"addr":")(.*?)(")(.*?)("value":5500,"addr":")(.*?)(")', x, re.M|re.I)
                                                addrs=[]
                                                if matchObj:
                                                    addrs.append(matchObj.group(7))
                                                    addrs.append(matchObj.group(11))
                                                if not matchObj:
                                                    matchObj=re.match(r'(.*?)("value":5500,"addr":")(.*?)(")(.*?)("value":5500,"addr":")(.*?)(")', x, re.M|re.I)
                                                    addrs.append(matchObj.group(7))
                                                if addrs:
                                                    try:
                                                        if waitlock() == False:
                                                            float("a")
                                                        message=DecodeCipherOutputs(addrs)
                                                        message=message.rstrip('*')
                                                        if window.EnableEmail.isChecked():
                                                            if "@" in message:#Ok it looks like they sent us a contract lets message them
                                                                GetEmailGlobals()
                                                                if MyEmail != "":
                                                                    Order={}
                                                                    Order['Command']='Send'
                                                                    Order['MyBMAddress']=MyEmail
                                                                    Order['TheirBMAddress']=message
                                                                    Order['Process']='Handshake'
                                                                    Order['type']="CONTRACT"
                                                                    Order['ordernumber']=txid.encode("ascii")
                                                                    Order['status']="offer"
                                                                    Order['version']=CoinSelect['HaloName'] + " " + clientversion
                                                                    Order['currentblock']=CurrentBlock
                                                                    Order['sent']=1
                                                                    DontRepopulate.append(Order['ordernumber'])
                                                                    MyContracts.append(Order)#This could harm other threads
                                                                    BitQueue.append(Order)
                                                                    DontExit[2]=1
                                                                    SaveQueue()
                                                                    DontExit[2]=0
                                                        if window.EnableBitmessage.isChecked():
                                                            if "BM-" in message:#Ok it looks like they sent us a contract lets message them
                                                                BitAddr=GetfromCfg("#BitMessage#")
                                                                Order={}
                                                                Order['Command']='Send'
                                                                Order['MyBMAddress']=BitAddr
                                                                Order['TheirBMAddress']=message
                                                                Order['Process']='Handshake'
                                                                Order['type']="CONTRACT"
                                                                Order['ordernumber']=txid.encode("ascii")
                                                                Order['status']="offer"
                                                                Order['version']=CoinSelect['HaloName'] + " " + clientversion
                                                                Order['currentblock']=CurrentBlock
                                                                Order['sent']=1
                                                                DontRepopulate.append(Order['ordernumber'])
                                                                MyContracts.append(Order)
                                                                BitQueue.append(Order)
                                                                DontExit[2]=1
                                                                SaveQueue()
                                                                DontExit[2]=0
                                                    except Exception, ex:
                                                        pass #print Exception, ex
                                        DontExit[2]=1
                                        SaveOtherdata()
                                        DontExit[2]=0
                                        isdownloading=0
                                        time.sleep(3)
                                    except Exception, ex:#There are a few ways we can get a download error. If it happens we have to skip it and refresh (We cant work with bad info)
                                        print "Timeout/error trying again. "
                                        traceback.print_exc()
                                        #Another possible error is a list changed while iterating
                                        isdownloading=0
                                        updatesomething =0
                                        #Electrum did not connect. We can just try again later since the internet is technically working
                            else:
                                interneton=0
                                isdownloading=0
                except:
                    try:
                        LockTHIS.pop('ES',None)
                    except:
                        pass
                    isdownloading=0
                    traceback.print_exc()
            count += 10
            time.sleep(10)
            if count == 60:
                count=0
                checktime=1
                if BitHaloClient==True:
                    updatesomething=1
                    isdownloading=1

#Updates for main program loop
def Update():
    global PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, NewUser, BitQueue,skipthis, AuthError, BitmessageStatus
    global Spendable,isdownloading, interneton, globaltxh,globaltx, globalargs, OnOrders, CurrentBlock, MyContracts, BitARGS, Console
    global multisig,multiscript
    global updatesomething
    global DontRepopulate
    global lockdownload
    global BlackUnspent
    global timestamp
    global BitAddrGlob
    global EmailPassword
    global MyEmail
    global NewBitAddr
    global versioncheck
    global changearray
    global minedarray
    global Biteasy
    global HistoryDetail
    global EscrowResults
    global Markets
    global AdvanceArray
    global checkbitmessage
    global uploadnew
    global DontExit
    global AuthTimeStamp
    global LockTHIS
    global EmailCheckTime
    global disconnected
    global stakelist
    global AddNewOrders      
    global NEWTxidLookup
    global NEWTxidLookup2
    global NotifyEXOTIC
    global spentinputs
    global NotaryScripts
    global CanStakeTime
    global StakeTimeNotify
    global connectioncount
    global myblockcount
    global notDownloading
    global coininfo
    global OffSetNotify
    notDownloading = 0
    starttime=time.time()
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    BitAddr=GetfromCfg("#BitMessage#")
    GetEmailGlobals()
    BitAddrGlob=BitAddr
    LockTHIS['UD']=1
    if multisig not in AdvanceArray:
        AdvanceArray[multisig]={}
    if 'ignorelist' not in AdvanceArray[multisig]:
        AdvanceArray[multisig]['ignorelist']=[]
    if 'investigate' not in AdvanceArray[multisig]: 
        AdvanceArray[multisig]['investigate']={}        
    if 'hashpasswords' not in AdvanceArray:
        AdvanceArray['hashpasswords']={}        
    if 'BM' not in LockTHIS:
        if AddNewOrders!=[]:
            while AddNewOrders!=[]:
                try:
                    for addord in AddNewOrders:
                        if addord['mainaccount']==1 and multisig==addord['msg']:
                            OnOrders.append(addord['NewOrder'])
                        else:
                            if addord['msg'] not in AdvanceArray['StakedOrders']:
                                AdvanceArray['StakedOrders'][addord['msg']]=[]
                            xpos=0
                            for myord in AdvanceArray['StakedOrders'][addord['msg']]:
                                if myord['Confirmation TXID'] in str(addord['NewOrder']['inputs']):
                                    AdvanceArray['StakedOrders'][addord['msg']].pop(xpos)
                                    break
                                xpos+=1                                
                            AdvanceArray['StakedOrders'][addord['msg']].append(addord['NewOrder'])
                        AddNewOrders.pop(0)
                        break
                except:
                    print "Error adding orders"
                    AddNewOrders=[]
        if 'checktime' not in AdvanceArray['StakedOrders']:
            AdvanceArray['StakedOrders']['checktime']=timestamp-1700
        if timestamp-AdvanceArray['StakedOrders']['checktime']>1800:
            AdvanceArray['StakedOrders']['checktime']=timestamp
            for addy in AdvanceArray['StakedOrders']:
                if addy=='checktime':
                    continue
                l=len(AdvanceArray['StakedOrders'][addy])
                pos=0
                while pos<l:
                    next1=1
                    if AdvanceArray['StakedOrders'][addy][pos]['currentblock']==0:
                        if AdvanceArray['StakedOrders'][addy][pos]['timestamp']+7200<timestamp:
                            next1=0
                    else:
                        if AdvanceArray['StakedOrders'][addy][pos]['currentblock']+12<CurrentBlock:#Ok, its been 12 Bitcoin blocks, it should be made spendable again
                            next1=0
                    if next1==1:
                        pos+=1
                    else:
                        l-=1
                        AdvanceArray['StakedOrders'][addy].pop(pos)
        if AdvanceArray['InboxCleanTime']+172800<timestamp and BitAddr != " ":
            AdvanceArray['InboxCleanTime']=timestamp
            CleanInbox(BitAddr)
    LockTHIS.pop('UD', None)
    if isdownloading==0:
        try:
            SaveOtherdata()
        except:
            pass
    ourmatch=""
    available=0
    actual=0
    if FileSave.messageonce==1:
        FileSave.messageonce=2
        res=QuestionBox("Backup path not found. Please check the path and try again. If using a flash drive make sure it is connected. Please update your backup path.", "Update now", "Update later", timed=1, defres=1)
        if res==0:
            window.BrowseBackup()
    if not CanStakeTime and StakeTimeNotify:
        QuestionBox("Your computers clock is not accurate. When synchronizing the chain or when staking, an accurate timestamp is needed. Please synchonize your computers clock with the internet. Staking will be disabled until the time is fixed.", " OK ", timed=1)
        StakeTimeNotify=False
    try:
        if OffSetNotify and 'NotifyOffset' not in AdvanceArray and 'timeoffset' in coininfo and coininfo['timeoffset'] > 180:
            res = QuestionBox('Your computers clock is offset several minutes from the network average. This may be due to your ISP interfering with timestamps or your computers clock not set properly. It may also be because your clock does not synchronize with a time server causing it to drift. This issue can cause you to fall behind blocks, be ignored by other nodes and sometimes it may interfere with sending transactions. If the problem persists, please reach out to the community and forums for support.', ' OK ', ' How can I fix this? ', " Don't show this again. ", timed=1)
            OffSetNotify = False
            if res == 1:
                QuestionBox('You can test to see if this is caused by your ISP by tethering your computers internet connection to your phone and restarting the software. You may also attempt to set maxtimeadjustment in the config file in your data directory. You may also reach out to the community or forums for support and further questions.', ' OK ', timed=1)
            if res == 2:
                AdvanceArray['NotifyOffset'] = 1
    except:
        traceback.print_exc()
    if UpdateMessage != clientversion:
        matchObj=re.match(r'(##)(.*?)(##)(.*?)(##)(.*?)(##)(.*?)(##)', str(UpdateMessage), re.M|re.I)
        if matchObj and matchObj.group(2)!=clientversion and versioncheck!=1:
            versioncheck=1
            try:
                if Decimal(matchObj.group(2))>Decimal(clientversion):
                    mbox = QuestionBox("There is a new version of Halo available. Please update to ensure your client is compatible.", "Update now", "Update later", timed=1, defres=1)
                    if mbox == 0:
                        if os.name == 'nt':
                            if MacWine != 0:
                                QuestionBox("Because this is a Mac Wine build, you should update using the Windows updater.\n\nInstructions on how to update:\nFirst download the Windows updater.\nThen go to your app and look inside it by selecting 'show package contents'.\nRun WineSkin and have it install the updater executable.\nAfter you complete the install, it might tell you it cannot find new executables.\nIgnore the message and exit WineSkin.\nYour software will be updated.", "OK", timed=1, defres=0)
                            webbrowser.open(CoinSelect['updatewindows'])
                        else:
                            window.Website()
            except Exception, e:
                print "Version checking error",e
        if matchObj and matchObj.group(4)!=" ":
            ourmatch=matchObj.group(4)
        if matchObj and matchObj.group(6)!=" ":
            Markets['Enable']=0
            window.OfferTable.hide()
        if matchObj and matchObj.group(6)==" ":
            window.OfferTable.show()
            Markets['Enable']=1
        if matchObj and matchObj.group(8)!=" ":
            try:
                serverban=ast.literal_eval(str(matchObj.group(8)))
                for bn in serverban:
                    if bn not in Markets['Banlist']:
                        Markets['Banlist'].append(bn)
            except:
                pass
    globperc2=globperc
    if MySettingsInfo != "" and MySettingsInfo != "Loading bridge information...":
        if int(time.time())-TheBridgeThread.BridgeRefresh>60:
            TheBridgeThread.BridgeRefresh=int(time.time())
            MySettings.BridgeInfo.setText(MySettingsInfo)
    if rescanning == 2:
        window.labelProgress.setText(Gtranslate("Rescanning... "))
        if CoinSelect['moderngui']==0:
            window.labelProgress2.setText(Gtranslate("Rescanning... "))
    elif disconnected == 1:
        window.labelProgress.setText(Gtranslate("Disconnected... "))
        if CoinSelect['moderngui']==0:
            window.labelProgress2.setText(Gtranslate("Disconnected... "))
    else:
        locktxt=""
        if CoinSelect['moderngui']==0:
            if IsUnlocked():
                locktxt='/images/lock1.png'
            else:
                locktxt='/images/lock.png'
            locktxt="<html><img src="+application_path+locktxt+" width='12' height='16'></html> "
        else:
            canstake=False
            if AdvanceArray['MySettings']['Staking'] and IsUnlocked() and keysconnected != "0" and CanStakeTime:
                canstake=True
            statusbar(IsUnlocked(),globperc,connectioncount,canstake)
        if globperc<100:
            window.labelProgress.setText(locktxt+Gtranslate("Synchronizing: ") + str(globcount))
            if CoinSelect['moderngui']==0:
                window.labelProgress2.setText(locktxt+Gtranslate("Synchronizing: ") + str(globcount))
        else:
            insync=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                    insync=0
                    x=abs(globcount-ThePeg.Pegdatabase['startingblock'])
                    y=abs(ThePeg.Pegdatabase['blockcount']-ThePeg.Pegdatabase['startingblock'])
                    if x==0:
                        x=1
                    globperc2=Decimal(y)/Decimal(x)
                    if globperc2>Decimal(.99999):
                        globperc2=100
                    else:
                        globperc2=int(globperc2*Decimal(100))
                    globc=int(ThePeg.Pegdatabase['blockcount'])
                    window.labelProgress.setText(locktxt+Gtranslate("Peg Database: ") + str(globc))
                    if CoinSelect['moderngui']==0:
                        window.labelProgress2.setText(locktxt+Gtranslate("Peg Database: ") + str(globc))
            if insync==1:
                window.labelProgress.setText(locktxt+Gtranslate("Synchronized: ") + str(globcount))
                if CoinSelect['moderngui']==0:
                    window.labelProgress2.setText(locktxt+Gtranslate("Synchronized: ") + str(globcount))
    window.progressBar.setProperty("value", globperc2)
    if CoinSelect['moderngui']==0:
        window.progressBar2.setProperty("value", globperc2)
    if BitAddr!=" " and checkbitmessage !=0:
        Command={}
        Command['Command']='GetMessages'
        Command['Address']=BitAddr
        if window.EnableEmail.isChecked():
            #We should not be checking more than every 3 minutes to prevent authentication errors
            if int(time.time()-EmailCheckTime)>180:
                EmailCheckTime=time.time()
                for o in OnOrders:
                    if 'Contacts' in o:
                        for contact in o['Contacts']:
                            if contact['Name'].replace("Self:","")==multisig:
                                if contact['Password']!="":
                                    if contact['Password']=="*":
                                        Command['Password']=ManualPassword
                                    else:
                                        Command['Password']=contact['Password']
                                    Command['Name']=contact['Name'].replace("Self:","")
                                    Command['Email Address']=contact['Email Address']
                                    if str(contact['Email Address']) not in AdvanceArray:
                                        AdvanceArray[str(contact['Email Address'])]={}
                                        AdvanceArray[str(contact['Email Address'])]['uids']=[]
                                    if 'uids' in AdvanceArray[str(contact['Email Address'])]:
                                        Command['uids']=AdvanceArray[str(contact['Email Address'])]['uids']
        #Just ask for messages once and don't fill up the queue
        try:
            if Command not in BitQueue:
                BitQueue.append(Command)
                SaveQueue()
        except:
            traceback.print_exc()
    else:#Need an address
        skip=0
        for addy in NewBitAddr:
            if addy==multisig:
                skip=1
        Command={}
        Command['Command']='new'
        pubs=[]
        #We want a way to identify each key in case of joint accounts. They may want to pass info from one key to another using two computers. Its best if they have unique Bitmessage addresses
        #Also, we want to make sure if a person changes computers they have a deterministic address so they don't lose their contracts because they would not have access to their keys
        #This is now based on the first line of the key file
        firstline=""
        pubs, firstline=get_ordered_pubkeys(PrivKeyFilename1, PrivKeyFiledir1, 1, 1)
        if pubs == None:#It will generate an address anyways...
            pubs=['123456789',CoinSelect['rpcpassword']]
        if str(keysconnected)=="0":#Just generate a generic shared BM address. May eventually forgo the default address
            pubs=['123456789',CoinSelect['rpcpassword']]
        if pubs[0] != '123456789':
            pubs[0]=txhash(firstline)
            if 'Bitmessage key:' in str(firstline):#If they change directories or computers this makes the address consistent.
                pubs[1]=txhash(firstline)
        Command['Pubs']=pubs
        Command['multisig']=multisig
        if keysconnected=="0":
            Command['multisig']="Default"
        #Just ask for messages once and don't fill up the queue
        if Command in BitQueue:
            skip=1
        if skip==0:
            checkbitmessage=1
            if multisig not in NewBitAddr:
                NewBitAddr.append(multisig)
            BitQueue.append(Command)
            SaveQueue()
    if Console.amrunning:
        Console.updatethis()
    #Ok lets scan our messages and do anything required to communicate
    if 'ES' not in LockTHIS:
        LockTHIS['EW']=1
        ScanMessages()
        LockTHIS.pop('EW',None)
    if NewUser==[]:
        if isdownloading==1:
            window.KeysConnected.setText(Gtranslate("Updating from internet..."))
            if 'networkConnections' in BitmessageStatus:
                window.BitmessageStatus.setText(Gtranslate("Status: Network Connections- ") + str(BitmessageStatus['networkConnections']))
            if AuthError==1:
                window.EmailStatus.setText(Gtranslate("Email Authentication Failure..."))
                if int(time.time()-AuthTimeStamp)>900:
                    AuthTimeStamp=time.time()
                    res=QuestionBox("Email Authentication Failure! You were not logged in to your Email. There are many reasons this can happen. This can happen if you change locations, your Email provider may want you to log in through the browser first and confirm the login is secure. This may be caused by Two-Factor Authentication if you have that enabled in your Email. You are able to set up special passwords for applications in some Email providers. This can also happen if your password has changed. Please check with your Email provider to resolve this issue.", "OK", timed=1)
                AuthError=0
    else:
        if isdownloading!=1:
            if updatesomething!=1:
                GetNewUser()
                multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    if updatesomething == 1:
        if NewUser==[]:
            if CoinSelect['moderngui']==0:
                window.MyAddress_3.setText(Gtranslate("BITMESSAGE: ")+ BitAddr)
                window.MyAddress_7.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multisig)
                window.MyAddress_2.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multisig)
                window.MyAddress.setText(Gtranslate(CoinSelect['name'].upper()+": ")+ multisig)
                if MyEmail == "":
                    window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS(RECOMMENDED): "))
                else:
                    window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS: ")+ MyEmail)
            else:
                window.ReceiveBitcoins.receiveBitMessageAddressLineEdit.setText(BitAddr)
                window.tab.myAddressLineEdit.setText(multisig)
                window.History.le_myAddress.setText(multisig)
                window.ReceiveBitcoins.receiveCoinAddressLineEdit.setText(multisig)
                if MyEmail == "":
                    window.ReceiveBitcoins.receiveEmailLineEdit.setText("")
                else:
                    window.ReceiveBitcoins.receiveEmailLineEdit.setText(MyEmail)
        if interneton == 1:
            if True:#We can detect for keys connected for a default display here
                #Any UI delays we could check iteration delay below.
                if isdownloading!=1:
                    if Markets['MyMarkets'][CoinSelect['default market']]=="":
                        if 'Add Channel' not in str(BitQueue):
                            AddMarket(CoinSelect['default market'])
                    lockdownload=1
                    window.EmailStatus.setText("")
                    #Here we check to see if any contract offers have been sitting for a month and remove them and free the inputs
                    if False: #For now this is deactivated because we want long term offers in the markets
                        o=-1                    
                        for contract in MyContracts:
                            o+=1
                            if contract['status'] == "offer":#Once the last raw is sent we will not pop only recommend pop(status will change to broadcast or escrow)
                                try:#Just in case the site went down
                                    if 'Process' in contract:
                                        if "Cancel" in contract['Process'] or "Accept" in contract['Process'] or "Making" in contract['Process'] or "Failed" in contract['Process'] or "cancel" in contract:
                                            continue
                                    if contract['currentblock']+5000<CurrentBlock:
                                        print "Removing old contracts!"
                                        if contract['currentblock']!=0:
                                            #Want to check if an offer needs to be "silenced" before getting popped. For example a handshake we would keep sending via BitMessage but maybe thats OK
                                            DontRepopulate.append(contract['ordernumber'])
                                            if contract['Process']=="Market Order":
                                                leng=len(MyContracts)
                                                i=0
                                                while i<leng:
                                                    next1=1
                                                    if MyContracts[i]['Process']=="Market Order":
                                                        if MyContracts[i]['ordernumber']==contract['ordernumber']:
                                                            DeleteOrder(MyContracts[i]['ordernumber'])
                                                            RemoveFromMarket(MyContracts[i])
                                                            next1=0
                                                    if MyContracts[i]['Process']=="Market Offer" or "MCount" in MyContracts[i]['Process']:
                                                        if MyContracts[i]['oldordernumber']==contract['ordernumber']:
                                                            DeleteOrder(MyContracts[i]['ordernumber'])
                                                            next1=0
                                                    if next1==0:
                                                        leng-=1
                                                        DeleteOrder(MyContracts[i]['ordernumber'])
                                                        DeleteContract(i)
                                                    else:
                                                        i+=1
                                                break
                                            else:
                                                DeleteOrder(MyContracts[o]['ordernumber'])
                                                DeleteContract(o)
                                                break
                                except:
                                    pass
                    #Looking for expired peg offers
                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                        o=-1
                        supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
                        for contract in MyContracts:
                            o+=1
                            expired=0
                            if contract['status'] == "offer":
                                if 'MCount' in contract['Process'] or 'Accept' in contract['Process']:
                                    if 'pegsupply' in contract['Market Data']:
                                        if contract['Market Data']['pegsupply']+9<supply:
                                            expired=1
                                    if 'reply' in contract['Market Data'] and 'pegsupply' in contract['Market Data']['reply']:
                                        if contract['Market Data']['reply']['pegsupply']+9<supply:
                                            expired=1
                                if expired==1:
                                    MyContracts[o]['Process']="Expired"
                    o=-1
                    for contract in Markets['Orders']:
                        o+=1
                        if contract['status'] == "offer":#Once the last raw is sent we will not pop only recommend pop(status will change to broadcast or escrow)
                            try:#Just in case the site went down
                                if contract['currentblock']==9999999999999999 or contract['currentblock']==0:#We want orders that didn't get a block to clear eventually
                                    if CurrentBlock!=0:
                                        Markets['Orders'][o]['currentblock']=CurrentBlock+288                            
                                if contract['theiraddress']==multisig:
                                    if contract['currentblock']+258<CurrentBlock and contract['currentblock']!=0:#Its our contract, lets resubmit. So if we stay connected we will perpetually keep our contracts live.
                                        print "Resubmitting offer to market..."
                                        fnd=0
                                        mps=0
                                        for c in MyContracts:
                                            if c['ordernumber']==contract['ordernumber']:
                                                fnd=1
                                                break
                                            mps+=1
                                        if fnd==1:
                                            imghsh=c['ordernumber']
                                            if c['Details']['image']=="":
                                                Resubmit(MyContracts[mps])
                                                Markets['Orders'][o]['currentblock']=CurrentBlock
                                            else:
                                                if imghsh not in uploadnew:
                                                    uploadnew[imghsh]={"image":c['Details']['image'],"result":"waiting"}
                                                else:
                                                    if uploadnew[imghsh]['result']!="waiting":
                                                        MyContracts[mps]['Details']['pastebin']=uploadnew[imghsh]['result']
                                                        Resubmit(MyContracts[mps])
                                                        Markets['Orders'][o]['currentblock']=CurrentBlock
                                                        uploadnew.pop(imghsh)
                                        else:
                                            pass
                                if contract['currentblock']+288<CurrentBlock:
                                    pv=0
                                    if 'Private' in contract['Market Data'] and contract['Market Data']['Private']==2:
                                        pv=1
                                    if contract['currentblock']!=0 and pv==0:
                                        #Want to check if an offer needs to be "silenced" before getting popped. For example a handshake we would keep sending via BitMessage but maybe thats OK
                                        DontRepopulate.append(contract['ordernumber'])
                                        Markets['Orders'].pop(o)
                                        break
                            except:
                                traceback.print_exc()
                    try:
                        CheckEscrow()#If we start seeing UI delays this would be a function to check
                    except:
                        traceback.print_exc()
                    ntimeout=0
                    totalonorders=0
                    temptotal=0
                    chng=0
                    NEWTxidLookup=json_deep_copy(NEWTxidLookup2)
                    if BitHaloClient==True:
                        try:#If there was a timeout, this will fail so we can "try again"... to break the infinite loop we may just wait out the 60 seconds instead of requesting that here
                            if Biteasy=={}:
                                xxx=str(globaltx[0]['result'])#If it loaded this would exist if not we dont spam the console
                                received=0
                                Spendable=[]
                                myhistory=[]
                                received,unconf, unconf2, myhistory,Spendable=get_balance_lspnr(multisig,globaltxh,globaltx,globalargs)#Consider moving this to download thread because it can take time
                                #Biteasy['api']="Electrum"
                            else:
                                Spendable=Biteasy['unspent']
                                received=Biteasy['received']
                                if Biteasy['api']=="Biteasy":
                                    for u in Biteasy['unconfirmed']:
                                        received-=u
                                received=float(Decimal(received)/Decimal(1e8))
                                unconf=0
                                for u in Biteasy['unconfirmed']:
                                    unconf=Decimal(unconf)+Decimal(u)
                                unconf=float(Decimal(unconf)/Decimal(1e8))
                                unconf2=unconf
                                myhistory=Biteasy['history']
                            myhistory2=[]
                            changearray=[]
                            for d in myhistory:
                                vout=0
                                for v in d['Values']:
                                    found=0
                                    Bit={}
                                    Bit['vout']=d['vout'][vout]
                                    for s in Spendable:
                                        if d['Txid']+":"+str(Bit['vout']) == s['output']:
                                            found=1
                                    if found==1:
                                        v=int(Decimal(str(v))*Decimal(1e8))
                                        v=Decimal(v)/Decimal(1e8)
                                        v=Decimal(v)/Decimal(1e8)
                                        v=Decimal(dropzeros(v,1))
                                        Bit['amount']=v
                                        Bit['txid']=d['Txid']
                                        Bit['FROM']=d['FROM']
                                        if len(list(set(d['Inputs'])))==1 and d['Inputs'][0]==multisig:
                                            Bit['BrokeForChange']=1
                                        else:
                                            Bit['BrokeForChange']=0
                                        mystr="Amount: " + str(Bit['amount'])
                                        mystr=mystr.ljust(33)
                                        dstr=mystr + "\tFrom: " + str(Bit['FROM']) + "\tTransaction ID: " + str(Bit['txid']+":"+str(Bit['vout']))
                                        if Bit['FROM']==multisig:
                                            if Bit['BrokeForChange']==1:
                                                dstr2 = ("Created Change: ").ljust(33) + "\tTransaction ID: " + str(Bit['txid'])
                                                if dstr2 not in myhistory2:
                                                    myhistory2.append(dstr2)
                                                changearray.append(mystr + "\tTransaction ID: " + str(Bit['txid']+":"+str(Bit['vout'])))
                                        else:
                                            #We need to check and see if its new in our history
                                            AddToHistory(d['Txid'],Bit['vout'],d['FROM'], v, "Received")
                                            myhistory2.append(str(dstr))
                                    vout+=1
                            if changearray != []:
                                myhistory2.append("Show change")

                            myhistory=myhistory2
                            ord1={}
                            ord1['type']="Spendable"
                            spn=list(Spendable)
                            ord1['Spendable']=spn#For loading on startup
                            ps=-1
                            gotit=0
                            for o in OnOrders:
                                ps+=1
                                if o['type']=="Spendable":
                                    OnOrders[ps]=ord1
                                    gotit=1
                            if gotit==0:
                                OnOrders.append(ord1)
                        except Exception,ex:
                            print "Exception!", ex
                            traceback.print_exc()
                            BitARGS=[]#We should just ask it to refresh everything
                            ntimeout=1
                    else:
                        received=0
                        Spendable=[]
                        myhistory=[]
                        changearray=[]
                        minedarray=[]
                        global TxidLookup
                        NotifyEX=[]
                        for Black in BlackUnspent:
                            if Black['address']==multisig:
                                spn={}
                                spn['value']=Black['amount']
                                spn['address']=Black['address']
                                spn['output']=Black['txid']+":"+str(Black['vout'])
                                r1=""
                                if 'liquidity' in Black:
                                    spn['liquidity']={}
                                    if 'frozen' in Black['liquidity']:
                                        spn['liquidity']['frozen']=Black['liquidity']['frozen']
                                    if 'total' in Black['liquidity']:
                                        spn['liquidity']['total']=Black['liquidity']['total']
                                    if 'ltotal' in Black['liquidity']:
                                        spn['liquidity']['ltotal']=Black['liquidity']['ltotal']
                                    if 'rtotal' in Black['liquidity']:
                                        spn['liquidity']['rtotal']=Black['liquidity']['rtotal']
                                    if 'rating' in Black['liquidity']:
                                        r1=str(Black['liquidity']['rating'][0])
                                        spn['liquidity']['rating']=json_deep_copy(Black['liquidity']['rating'])
                                    if 'future' in Black['liquidity']:
                                        spn['liquidity']['future']=Black['liquidity']['future']
                                    if 'nfreeze' in Black['liquidity']:
                                        spn['liquidity']['nfreeze']=Black['liquidity']['nfreeze']
                                    if 'supply' in Black['liquidity']:
                                        spn['liquidity']['supply']=Black['liquidity']['supply']
                                freezethis=0
                                received=Decimal(received)+Decimal(Black['amount'])
                                v=int((Black['amount'])*100000000)
                                if 'liquidity' in spn:
                                    if (spn['liquidity']['ltotal'] + spn['liquidity']['rtotal']) != v:
                                        print 'Error: Calculation on input incorrect'
                                        print str(spn['liquidity']['ltotal']) + '\n' + str(spn['liquidity']['rtotal']) + '\n' + str(v)
                                        float('a')
                                v=Decimal(dropzeros(Decimal(v),1))/Decimal(1e8)
                                #v=dropzeros(Decimal(v))
                                mystr="Amount: " + str(v)
                                mystr=mystr.ljust(33)
                                dstr=mystr + "From: " + str(Black['FROM']) + "\tTransaction ID: " + str(Black['txid']+":"+str(Black['vout']))
                                dontaddlater=0
                                if Black['FROM']==multisig or Black['FROM']=='Mined Coins':
                                    dontaddlater=1
                                    if Black['FROM']=='Mined Coins':
                                        minedarray.append("Amount: " + str(Black['amount']) + "\tTransaction ID: " + str(Black['txid']+":"+str(Black['vout'])))
                                    else:
                                        if Black['BrokeForChange']==1:
                                            dstr2 = ("Created Change: ").ljust(33) + "Transaction ID: " + str(Black['txid'])
                                            if dstr2 not in myhistory:
                                                myhistory.append(dstr2)
                                        changearray.append("Amount: " + str(Black['amount']) + "\tTransaction ID: " + str(Black['txid']+":"+str(Black['vout'])))
                                if 'liquidity' in Black:
                                    if 'frozen' in Black['liquidity'] and Black['liquidity']['frozen']>timestamp-43200:
                                        freezethis=1
                                        dstr2 = ("Frozen Coins: ").ljust(33) + "Transaction ID: " + str(Black['txid']+":"+str(Black['vout']))
                                        myhistory.append(dstr2)
                                spn['value']=int(spn['value']*Decimal(1e8))
                                #5500 satoshi check
                                if spn['value'] == 5500 or spn['value'] == 5501 or spn['value'] == 5499:
                                    skip=0
                                    for contract in MyContracts:
                                        if contract['ordernumber']==Black['txid']:
                                            if 'sent' in contract:
                                                skip=1
                                    if skip==0:
                                        TxidLookup.append(Black['txid'])
                                #5577 satoshi check (Exotic Script)
                                pause=0
                                r2=""
                                if spn['value'] == 5577:
                                    if spn['output'] in NEWTxidLookup:                                        
                                        if NEWTxidLookup[spn['output']]!={} and freezethis==0:
                                            meaning=translate_script(NEWTxidLookup[spn['output']]['script'])
                                            if meaning!={}:
                                                meaning['script']=NEWTxidLookup[spn['output']]['script']
                                                if meaning['type'] == "Freeze":
                                                    if meaning['destination'] == multisig:#Okay it's going to be ours soon
                                                        spn2={}
                                                        spn2['value'] = NEWTxidLookup[spn['output']]['amount']
                                                        #Technically this is not necessarily the address paid but usually the address to notify or redeem
                                                        spn2['address']=Black['address']
                                                        spn2['output'] = NEWTxidLookup[spn['output']]['txid']
                                                        if 'liquidity' in NEWTxidLookup[spn['output']]:
                                                            spn2['liquidity']={}
                                                            if 'frozen' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['frozen']=NEWTxidLookup[spn['output']]['liquidity']['frozen']
                                                            if 'total' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['total']=NEWTxidLookup[spn['output']]['liquidity']['total']
                                                            if 'ltotal' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['ltotal']=NEWTxidLookup[spn['output']]['liquidity']['ltotal']
                                                            if 'rtotal' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['rtotal']=NEWTxidLookup[spn['output']]['liquidity']['rtotal']
                                                            if 'rating' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                r2=str(NEWTxidLookup[spn['output']]['liquidity']['rating'][0])
                                                                spn2['liquidity']['rating']=json_deep_copy(NEWTxidLookup[spn['output']]['liquidity']['rating'])
                                                            if 'future' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['future']=NEWTxidLookup[spn['output']]['liquidity']['future']
                                                            if 'nfreeze' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['nfreeze']=NEWTxidLookup[spn['output']]['liquidity']['nfreeze']
                                                            if 'supply' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['supply']=NEWTxidLookup[spn['output']]['liquidity']['supply']
                                                        if 'liquidity' in spn2:
                                                            if 'frozen' in spn2['liquidity'] and spn2['liquidity']['frozen']>timestamp-43200:
                                                                freezethis=1
                                                        if spn2['output'] not in NEWTxidLookup and freezethis==0:#A bit redundant but we need to look these up later
                                                            NEWTxidLookup[spn2['output']]=NEWTxidLookup[spn['output']]                                                        
                                                            v2=Decimal(spn2['value'])/Decimal(1e8)
                                                            if meaning['spendable']!="Yes":                                                            
                                                                #Totalonorders is just to show how much is waiting
                                                                totalonorders+=spn2['value']+5577
                                                                chng=Decimal(chng)+(Decimal(spn2['value']+5577)/Decimal(1e8))
                                                                received=Decimal(received)-Decimal(Black['amount'])#Not available yet
                                                            else:
                                                                received=Decimal(received)+v2
                                                            v2=dropzeros(Decimal(v2))
                                                            dstr2 = ("Frozen Coins: ").ljust(33) + "Transaction ID: " + spn2['output'] + "\tSpendable: " + meaning['spendable']
                                                            myhistory.append(dstr2)
                                                            dontaddlater=1
                                                            txid,vout=spn2['output'].split(":")
                                                            Spendable.append(spn2)
                                                            AddToHistory(txid,vout,Black['FROM'], Decimal(v)+Decimal(v2), "Exotic", meaning, r2)
                                                        else:
                                                            NEWTxidLookup[spn['output']]={}#They notified us multiple times we need to unpair these
                                                if meaning['type'] == "Switch" or meaning['type'] == "Assured Destruction":
                                                    if meaning['destination'] == multisig or meaning['before'] == multisig:#Okay it's going to be ours soon
                                                        spn2={}
                                                        spn2['value'] = NEWTxidLookup[spn['output']]['amount']
                                                        #Technically this is not necessarily the address paid but usually the address to notify or redeem
                                                        spn2['address']=Black['address']
                                                        spn2['output'] = NEWTxidLookup[spn['output']]['txid']
                                                        r2=''
                                                        if 'liquidity' in NEWTxidLookup[spn['output']]:
                                                            spn2['liquidity']={}
                                                            if 'frozen' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['frozen']=NEWTxidLookup[spn['output']]['liquidity']['frozen']
                                                            if 'total' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['total']=NEWTxidLookup[spn['output']]['liquidity']['total']
                                                            if 'ltotal' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['ltotal']=NEWTxidLookup[spn['output']]['liquidity']['ltotal']
                                                            if 'rtotal' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['rtotal']=NEWTxidLookup[spn['output']]['liquidity']['rtotal']
                                                            if 'rating' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                r2=str(NEWTxidLookup[spn['output']]['liquidity']['rating'][0])
                                                                spn2['liquidity']['rating']=json_deep_copy(NEWTxidLookup[spn['output']]['liquidity']['rating'])
                                                            if 'future' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['future']=NEWTxidLookup[spn['output']]['liquidity']['future']
                                                            if 'nfreeze' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['nfreeze']=NEWTxidLookup[spn['output']]['liquidity']['nfreeze']
                                                            if 'supply' in NEWTxidLookup[spn['output']]['liquidity']:
                                                                spn2['liquidity']['supply']=NEWTxidLookup[spn['output']]['liquidity']['supply']
                                                        if 'liquidity' in spn2:
                                                            if 'frozen' in spn2['liquidity'] and spn2['liquidity']['frozen']>timestamp-43200:
                                                                freezethis=1
                                                        if spn2['output'] not in NEWTxidLookup and NEWTxidLookup[spn['output']]['txid'] not in AdvanceArray[multisig]['ignorelist'] and NEWTxidLookup[spn['output']]['txid'] not in spentinputs and freezethis==0:                                                            
                                                            NEWTxidLookup[spn2['output']]=NEWTxidLookup[spn['output']]
                                                            NotifyEX.append(meaning['description'])
                                                            v2=Decimal(spn2['value'])/Decimal(1e8)
                                                            timeout=0
                                                            if meaning['timestamp']<timestamp and meaning['before'] == multisig:#Time is up
                                                                timeout=1
                                                                if meaning['destination']==multisig:#odd, did they send two puzzles?
                                                                    timeout=0                                                            
                                                            if spn2['output'] in AdvanceArray[multisig]['investigate']:
                                                                pause=1
                                                            if meaning['spendable']!="Yes" or pause==1:                                                            
                                                                #Totalonorders is just to show how much is waiting
                                                                if CoinSelect['checksequenceverify']==True:#Exclusive
                                                                    if timeout==0:
                                                                        totalonorders+=spn2['value']+5577
                                                                        chng=Decimal(chng)+(Decimal(spn2['value']+5577)/Decimal(1e8))
                                                                        received=Decimal(received)-Decimal(Black['amount'])#Not available yet
                                                                else:
                                                                    totalonorders+=spn2['value']+5577
                                                                    chng=Decimal(chng)+(Decimal(spn2['value']+5577)/Decimal(1e8))
                                                                    received=Decimal(received)-Decimal(Black['amount'])#Not available yet                                                                
                                                            else:
                                                                if CoinSelect['checksequenceverify']==True:#Exclusive
                                                                    if timeout==0:#We should also notify if it is not already being done
                                                                        received=Decimal(received)+v2                                                                        
                                                                else:
                                                                    received=Decimal(received)+v2
                                                            v2=dropzeros(Decimal(v2))
                                                            pwprotect=""
                                                            pw=0
                                                            pwbefore=0                                                        
                                                            if meaning['before']==multisig and meaning['hashbefore']!="":
                                                                pw=1
                                                                if meaning['hashbefore'] in AdvanceArray['hashpasswords']:
                                                                    if hash160(AdvanceArray['hashpasswords'][meaning['hashbefore']])==meaning['hashbefore']:
                                                                        pw=0#We have this password
                                                                        pwbefore=1
                                                            if meaning['destination']==multisig and meaning['hashafter']!="":
                                                                pw=1
                                                                if meaning['hashafter'] in AdvanceArray['hashpasswords']:
                                                                    if hash160(AdvanceArray['hashpasswords'][meaning['hashafter']])==meaning['hashafter']:
                                                                        pw=0#We have this password
                                                            if pw==1:
                                                                if meaning['spendable']!="Yes":#In case we are listed before and after lets see if it's spendable
                                                                    pwprotect="(password protected)"
                                                            if CoinSelect['checksequenceverify']==True:
                                                                if timeout==1:
                                                                    pwprotect="(expired)"
                                                                    if 'autoclearexpired' in AdvanceArray:
                                                                        if NEWTxidLookup[spn['output']]['txid'] not in AdvanceArray[multisig]['ignorelist']:
                                                                            AdvanceArray[multisig]['ignorelist'].append(NEWTxidLookup[spn['output']]['txid'])                                                            
                                                                            #We still add it to Spendable even though it will eventually get ignored
                                                            else:
                                                                if meaning['timestamp']<timestamp:
                                                                    pwprotect+="(non-exclusive)"
                                                            if pwprotect!="(expired)":
                                                                if pause==1:
                                                                    pwprotect="(click here to investigate)"
                                                            else:
                                                                pause=0
                                                            if NEWTxidLookup[spn['output']]['txid'] not in AdvanceArray[multisig]['ignorelist']:
                                                                dstr2 = (meaning['type']+pwprotect+": ").ljust(33) + "Transaction ID: " + spn2['output'] + "\tSpendable: " + meaning['spendable']
                                                                myhistory.append(dstr2)
                                                                dontaddlater=1
                                                            txid,vout=spn2['output'].split(":")
                                                            Spendable.append(spn2)
                                                            AddToHistory(txid,vout,Black['FROM'], Decimal(v)+Decimal(v2), "Exotic", meaning, r2)
                                                        else:
                                                            NEWTxidLookup[spn['output']]={}#Unpair this
                                                    else:#It's not for us, ignore it
                                                        if NEWTxidLookup[spn['output']]['txid'] not in AdvanceArray[multisig]['ignorelist']:
                                                            AdvanceArray[multisig]['ignorelist'].append(NEWTxidLookup[spn['output']]['txid'])
                                        else:
                                            NEWTxidLookup[spn['output']]={}
                                if spn['value'] == 5560:
                                    if Black['txid']+":"+str(Black['vout']) in NotaryScripts:
                                        res=CheckNotary(Black['txid']+":"+str(Black['vout']))
                                        if res:
                                            try:
                                                v3=int((res['amount'])*100000000)
                                                v3=Decimal(dropzeros(Decimal(v3),1))/Decimal(1e8)
                                                AddToHistory(Black['txid'],res['vout'],Black['FROM'], v3, "Payment/Notary", {'script':NotaryScripts[Black['txid']+":"+str(Black['vout'])]})
                                            except:
                                                AddToHistory(Black['txid'],Black['vout'],Black['FROM'], v, "Notary/Burn", {'script':NotaryScripts[Black['txid']+":"+str(Black['vout'])]})
                                        else:
                                            AddToHistory(Black['txid'],Black['vout'],Black['FROM'], v, "Notary/Burn", {'script':NotaryScripts[Black['txid']+":"+str(Black['vout'])]})
                                if dontaddlater==0:
                                    AddToHistory(Black['txid'],Black['vout'],Black['FROM'], v, "Received", rating=r1)
                                    myhistory.append(str(dstr))                                
                                if pause==0:
                                    Spendable.append(spn)    
                        if NotifyEX!=[]:
                            if not NotifyEXOTIC:
                                res2=QuestionBox("You received a time locked payment! Halo recommends that you spend this specific payment as soon as possible. It also recommended that you check your history tab to understand how these payments work. Would you like to see the description of the payment/payments?", " OK ", " I can check the history tab later ", timed=1, defres=1)
                                if res2==0:
                                    for notifyme in NotifyEX:
                                        if len(NotifyEX)>1:
                                            res3=QuestionBox("Exotic Script:\n\n"+notifyme, " Continue ", " I can check the history tab later ", notrans=1, timed=1, defres=1)
                                        else:
                                            res3=QuestionBox("Exotic Script:\n\n"+notifyme, " OK ", notrans=1, timed=1, defres=0)
                                        if res3==1:
                                            break
                                NotifyEXOTIC=True
                        if minedarray != []:
                            myhistory.insert(0,"Show mined coins")
                        if changearray != []:
                            myhistory.insert(0,"Show change")                            
                        unconf=0 #Blackcoin is so fast there is not reason to care about unconfirmed unless it reflects in spendable which seems that it does not
                        unconf2=0
                    if skipthis=="skip":#Just to protect contracts 100%
                        skipthis=""
                        ntimeout=1
                    if ntimeout==0:
                        #Ok everything is good
                        #Here we check and make sure everything is still spendable
                        i=0
                        popthis=0
                        leng=len(MyContracts)
                        if False:
                            pass
                            #Eventually find a way to see if inputs are truly spent and have multiple confirmations before clearing.
                            #Otherwise this method can delete valid contracts in the case of balance crashes or other anomalies.
                            #The original goal of this was to protect against users doing the same thing on multiple computers.
                            while i<leng:
                                next1=1
                                #Technically we are only looking for contracts at a certain stage. Because we may want to alert them about it being spent depending on the circumstances.
                                #If we are in broadcast mode then there is a few things we want to check for while popping
                                if MyContracts[i]['type']=="CONTRACT" and MyContracts[i]['status'] == "offer":
                                    if 'inputs' in MyContracts[i]:
                                        for input1 in MyContracts[i]['inputs']:
                                            pass #print input1
                                            match=0
                                            for s in Spendable:
                                                if s['output']==input1['output']:
                                                    match=1
                                            if match==0:
                                                leng-=1
                                                popthis=1
                                                next1=0
                                    if popthis==1:
                                        DeleteOrder(MyContracts[i]['ordernumber'])
                                        DeleteContract(i)
                                    popthis=0
                                if next1==1:
                                    i+=1
                        i=0
                        popthis=0                        
                        stillinaccount=0
                        match=0
                        leng=len(OnOrders)
                        while i<leng:
                            next1=1
                            # and OnOrders[i]['status'] == "offer"
                            #Technically we are only looking for contracts at a certain stage. Because we may want to alert them about it being spent depending on the circumstances
                            if OnOrders[i]['type']=="CONTRACT" or OnOrders[i]['type']=="2STEP" or OnOrders[i]['type']=="SPENT" or OnOrders[i]['type']=="PAY TO EMAIL":
                                if 'inputs' in OnOrders[i]:
                                    for input1 in OnOrders[i]['inputs']:
                                        match=0
                                        stillinaccount=0
                                        if 'Confirmation TXID' in OnOrders[i]:
                                            match=1 #In this case, assume it can't be cleared unless the matching ID is found
                                            if Decimal(OnOrders[i]['change'])==Decimal(0):#However, if there is no change coming we do it this way
                                                if 'currentblock' in OnOrders[i]:#Lets wait to prevent two different apis in BitHalo competing for the same input
                                                    if OnOrders[i]['currentblock']+1<CurrentBlock or CurrentBlock==0 or OnOrders[i]['currentblock']==0:
                                                        match=0
                                                else:
                                                    match=0
                                        for s in Spendable:
                                            if s['output']==input1['output']:
                                                match=1
                                                stillinaccount=1
                                            if 'Confirmation TXID' in OnOrders[i]:
                                                if OnOrders[i]['change']>0: #We are expecting some change so we can go by the ID
                                                    if OnOrders[i]['Confirmation TXID'] in s['output']:
                                                        match=0
                                        #For now, if it never confirms we make them cancel it manually. Malleability can cause a larger actual balance calculation
                                        #Because of the expectation of change coming but finding under a different transaction. Its too risky to clear it for similar looking transactions
                                        if 'Confirmation TXID' in OnOrders[i] and stillinaccount==0 and match==1:                                            
                                            if OnOrders[i]['currentblock']==0 and 'timestamp' in OnOrders[i]:
                                                if OnOrders[i]['timestamp']+18000<timestamp:
                                                    match=0
                                            else:
                                                if OnOrders[i]['currentblock']+300<CurrentBlock:#Ok, its been 300 blocks and its still has not shown change in our account? There was either malleability or the miners did not like it.
                                                    match=0
                                        if 'Confirmation TXID' in OnOrders[i] and stillinaccount==1 and match==1 and 'stake' in OnOrders[i]:#Maybe the stake was conflicted
                                            if OnOrders[i]['currentblock']==0:
                                                if OnOrders[i]['timestamp']+7200<timestamp:
                                                    match=0
                                            else:
                                                if OnOrders[i]['currentblock']+12<CurrentBlock:#Ok, its been 12 Bitcoin blocks, it should be made spendable again
                                                    match=0
                                    if match==0:
                                        leng-=1
                                        popthis=1
                                        next1=0
                                if 'Confirmation TXID' in OnOrders[i] and stillinaccount==0 and match==1 and popthis==0:
                                    if BitHaloClient==False:#Note: Once we allow bitcoind we may want to remove this line or change for electrum
                                        temptotal+=(Decimal(OnOrders[i]['total'])/Decimal(1e8))
                                if popthis==1:
                                    #We check to see if its a 2 Step confirming.
                                    if multisig not in HistoryDetail:
                                        HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
                                    mpos=0
                                    npos=0
                                    for dct in HistoryDetail[multisig]:
                                        if 'ordernumber' in dct['Details'] and 'ordernumber' in OnOrders[i]:
                                            if OnOrders[i]['ordernumber']==dct['Details']['ordernumber']:
                                                if 'Pending' in HistoryDetail[multisig][mpos]['Details']:
                                                    HistoryDetail[multisig][mpos]['Details']['Pending']=False
                                                    npos=mpos
                                                    PopulateHistory()
                                        mpos+=1
                                    if OnOrders[i]['type']=="PAY TO EMAIL":
                                        temptotal+=(Decimal(OnOrders[i]['amount'])/Decimal(1e8))
                                        next1=1
                                        leng+=1
                                        if OnOrders[i]['currentblock']==0 and CurrentBlock > 11:#If they didn't get the block before we just need to make sure they get it. Eventually we can time everything in Blackcoin blocks.
                                            OnOrders[i]['currentblock']=CurrentBlock
                                        if OnOrders[i]['currentblock']+2<CurrentBlock and globperc>97 and OnOrders[i]['currentblock']!=0:#Time passed we can check the balance. If its Zero, they spent it. Also, we want to make sure we are synchronized
                                            rspns=0
                                            found=0
                                            ps1=-1
                                            for results in EscrowResults:
                                                ps1+=1
                                                if results['history']== OnOrders[i]['Temporary Address']:
                                                    found=1
                                                    ps2=ps1
                                                    rspns=results['rspns']
                                            if found==0:
                                                rawd={}
                                                rawd['BitHalo']=BitHaloClient
                                                rawd['history']=OnOrders[i]['Temporary Address']
                                                rawd['notxid']=OnOrders[i]['Confirmation TXID']
                                                rawd['raw']=""
                                                rawd['rspns']=0
                                                EscrowResults.append(rawd)
                                            if rspns != 0 and not isinstance(rspns, list):
                                                EscrowResults.pop(ps2)
                                                rspns=0
                                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                                                    rspns=0
                                            if rspns !=0:
                                                leng1=0
                                                hist=rspns
                                                leng1=len(hist)
                                                EscrowResults.pop(ps2)
                                                if leng1==0:
                                                    HistoryDetail[multisig][npos]['Details']['Redeemed']=1
                                                    PopulateHistory()
                                                    next1=0
                                                    leng-=1
                                                    OnOrders.pop(i)
                                                else:
                                                    try:
                                                        try:
                                                            tt=hist[0]['output']
                                                            tt=tt.replace(":0","")
                                                            if tt != str(OnOrders[i]['Confirmation TXID']):#Malleability
                                                                OnOrders[i]['Confirmation TXID']=tt
                                                        except:
                                                            pass
                                                        if OnOrders[i]['currentblock']+1000<CurrentBlock:#One week passed and was it still not redeemed?
                                                            priv = password.DecryptWithAES("Halo Master", OnOrders[i]['priv'])
                                                            if "PASSWORDPROTECTED:" not in priv:#It was probably a tip, automatically spend it back
                                                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                    liq=json_deep_copy(rspns[0]['liquidity'])
                                                                if BitHaloClient == True:
                                                                    tmptx = pybit.transaction.mktx([{'output':str(OnOrders[i]['Confirmation TXID'])+":0",'value':int(OnOrders[i]['amount']),'address':str(OnOrders[i]['Temporary Address'])}],[{'value':(int(OnOrders[i]['amount'])-int(OnOrders[i]['fee'])),'address':str(multisig)}])
                                                                else:
                                                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                                        ltot=liq['ltotal']
                                                                        rtot=liq['rtotal']
                                                                        ftot=0
                                                                        #For now, we just freeze a buffer if we are close to a rate change
                                                                        if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                                                                            ftot=liq['nfreeze']
                                                                        ltot-=ftot                                                                         
                                                                        rtot+=ftot
                                                                        if ltot<=int(OnOrders[i]['fee'])+1000:
                                                                            rtot+=ltot
                                                                            ltot=0
                                                                        if ltot==0:
                                                                            p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':(int(OnOrders[i]['amount'])-int(OnOrders[i]['fee'])),'script':address_to_script(multisig)}]
                                                                        else:
                                                                            p2mouts=[]
                                                                            if rtot!=0:
                                                                                p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':int(rtot),'script':address_to_script(multisig)}]
                                                                            p2mouts.append({'value':(int(OnOrders[i]['amount'])-int(OnOrders[i]['fee'])-int(rtot)),'script':address_to_script(multisig)})
                                                                        tmptx = mktx_script(timestamp,[{'output':str(OnOrders[i]['Confirmation TXID'])+":0",'value':int(OnOrders[i]['amount']),'address':str(OnOrders[i]['Temporary Address'])}],p2mouts)
                                                                    else:
                                                                        tmptx = mktx(timestamp,[{'output':str(OnOrders[i]['Confirmation TXID'])+":0",'value':int(OnOrders[i]['amount']),'address':str(OnOrders[i]['Temporary Address'])}],[{'value':(int(OnOrders[i]['amount'])-int(OnOrders[i]['fee'])),'address':str(multisig)}])
                                                                tx = signall(tmptx,priv)
                                                                rspns=0
                                                                found=0
                                                                ps1=-1
                                                                for results in EscrowResults:
                                                                    ps1+=1
                                                                    if 'MyTXID' in results:
                                                                        if results['MyTXID']==OnOrders[i]['Confirmation TXID']:
                                                                            found=1
                                                                            ps2=ps1
                                                                            rspns=results['rspns']
                                                                if found==0:
                                                                    rawd={}
                                                                    rawd['BitHalo']=BitHaloClient
                                                                    rawd['MyTXID']=OnOrders[i]['Confirmation TXID']
                                                                    rawd['raw']=tx
                                                                    rawd['sender']=multisig
                                                                    rawd['history']=""
                                                                    rawd['rspns']=0
                                                                    EscrowResults.append(rawd)
                                                                if rspns !=0:
                                                                    if "TX rejected" in str(rspns):
                                                                        EscrowResults.pop(ps2)
                                                                        if "Rejectedsigned" not in  OnOrders[i]:
                                                                            OnOrders[i]['Rejectsigned']=0
                                                                        OnOrders[i]['Rejectsigned']+=1
                                                                        if OnOrders[i]['Rejectsigned']>3:#They may have sent it last minute. For now, we can have the protocol remove the order
                                                                            next1=0
                                                                            leng-=1
                                                                            OnOrders.pop(i)
                                                                    else:
                                                                        EscrowResults.pop(ps2)
                                                                        next1=0
                                                                        leng-=1
                                                                        OnOrders.pop(i)
                                                    except:
                                                        traceback.print_exc()
                                    else:
                                        OnOrders.pop(i)
                                popthis=0
                            if next1==1:
                                i+=1
                        window.KeysConnected.setText("You have " + keysconnected + " private key connected")
                        #Add a few more things to the history...
                        window.HistorylistWidget.clear()#Clears the old history
                        myhistory=list(reversed(myhistory))
                        myorder=""
                        chnglist=[]
                        shwstk=0
                        stakelist=[]
                        for Order in OnOrders:
                            skpthis=0
                            if Order['type']=="Spendable" or Order['type']=="History":#We save it so we are incessantly downloading it
                                continue
                            if Order['type']!="CONTRACT":
                                if Order['type']=="SPENT":                                                                        
                                    if 'stake' in Order:
                                        stakelist.append(str("Order number:  " + Order['ordernumber'] + "   Confirmation TXID: " + Order['Confirmation TXID']))
                                        if shwstk==0:
                                            myorder="Staked coins! (click for options)"                                            
                                            shwstk=1
                                        else:
                                            skpthis=1
                                    else:
                                        myorder="Spent coins! Waiting for confirmations(click here if the order never confirms):      Order number:  " + Order['ordernumber'] + "   Confirmation TXID: " + Order['Confirmation TXID']
                                    chnglist.append(Decimal(Order['change']))
                                else:
                                    if Order['type']=="2STEP":
                                        myorder="Unconfirmed order(click for options): " + str(Order['ordernumber'])
                                    if Order['type']=="PAY TO EMAIL":
                                        myorder="Pay To Email(click for options): " + str(Order['ordernumber'])
                                    chnglist.append(Decimal(Order['change']))
                            else:
                                myorder="Unconfirmed contract: " + str(Order['ordernumber'])
                                chnglist.append(Decimal(Order['mychangetotal']))
                            if skpthis==0:
                                myhistory.append(myorder)
                            totalonorders+= Order['total']
                        #We do this because uncomfirmed transactions in Bitcoin distrupt the balance so we see if an order of similar value comes back
                        #Realize due to malleability, we cannot be sure that somebody did not send us an identical order(at least not with electrum). We could also consider checking TXID of the incoming TX or outgoing TX
                        for c in chnglist:
                            found=0
                            if BitHaloClient==False:
                                chng=Decimal(chng)+Decimal(c)
                            else:
                                pos=0
                                if 'unconfirmed' in Biteasy:
                                    for e in Biteasy['unconfirmed']:
                                        if str(Decimal(e)) == str(Decimal(c)) or e==int(Decimal(c)*Decimal(1e8)):
                                            found=1
                                            Biteasy['unconfirmed'].pop(pos)
                                            break
                                    pos+=1
                                if found==0:
                                    chng=Decimal(chng)+Decimal(c)
                        totalonorders=Decimal(Decimal(totalonorders)/Decimal(1e8))
                        received=Decimal(str(received))
                        received-=Decimal(str(totalonorders))
                        actual=received

                        tot=0
                        myspen=[]
                        ltot=0
                        rtot=0
                        ftot=0
                        subpremium=0
                        try:
                            myspen=FilterSpendable(OnOrders,Spendable, filterfrozen=0)
                            if myspen==[]:
                                for o in OnOrders:
                                    if o['type']=="CONTRACT" and o['status'] == "offer" or o['type']=="2STEP" or o['type']=="SPENT" or o['type']=="PAY TO EMAIL":
                                        tot+=1
                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                for s in myspen:
                                    if 'frozen' in s['liquidity'] and s['liquidity']['frozen']>timestamp-43200:
                                        ftot+=s['liquidity']['total']
                                    else:                                        
                                        ltot+=s['liquidity']['ltotal']
                                        if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                                            ltot-=s['liquidity']['nfreeze']
                                            rtot+=s['liquidity']['nfreeze']
                                        rtot+=s['liquidity']['rtotal']
                                        if s['liquidity']['rating'][0]<ThePeg.subpremiumrating:
                                            if TestnetPeg:
                                                if multisig in ThePeg.whitelist:
                                                    subpremium+=s['liquidity']['ltotal']
                                            else:
                                                subpremium+=s['liquidity']['ltotal']
                            if tot>0:
                                checkit=1
                        except:
                            pass
                        if Decimal(str(totalonorders))>Decimal(0) or rtot>0 or ftot>0:
                            if Decimal(str(totalonorders)) != Decimal(0):
                                totalonorders2="On Orders: " + str(totalonorders)
                                myhistory.append(totalonorders2)
                            actual=Decimal(received)+Decimal(chng)+Decimal(temptotal)
                            available=Decimal(str(received))+Decimal(temptotal)
                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                available=Decimal(ltot)/Decimal(1e8)
                            window.WelcomeAvailableBalance.show()
                            window.SendAvailableBalance.show()
                            window.MyBalance_4.show()
                            window.MyBalance_8.show()
                            window.Symbol_2.show()
                            window.Symbol_4.show()
                        else:
                            window.WelcomeAvailableBalance.hide()
                            window.SendAvailableBalance.hide()
                            window.MyBalance_4.hide()
                            window.MyBalance_8.hide()
                            window.Symbol_2.hide()
                            window.Symbol_4.hide()
                            available=0
                        if chng>0:
                            totalonorders2="Change: " + str(chng)
                            myhistory.append(totalonorders2)
                        if unconf!=0 and unconf2 !=0:
                            unconfirmed="Unconfirmed: " + str(unconf)
                            myhistory.append(unconfirmed)
                        if ourmatch!="":
                            myhistory.append(ourmatch)
                        myhistory=list(reversed(myhistory))
                        checkit=0
                        if Decimal(actual) <= Decimal(0):
                            actual=0
                        if Decimal(available) < Decimal(0):
                            available=0
                        if Decimal(received) < Decimal(0):
                            received=0
                        actual=dropzeros(actual, 1)
                        available=dropzeros(available, 1)
                        #Populate the history
                        j=0
                        if NewUser==[]:
                            hist={}#Loading can be so slow so we just save it
                            hist['type']="History"
                            hist['myhistory']=myhistory
                            hist['balance']=str(received)
                            ps=-1
                            gotit=0
                            for o in OnOrders:
                                ps+=1
                                if o['type']=="History":
                                    if 'Contacts' in o:
                                        hist['Contacts']=o['Contacts']
                                    OnOrders[ps]=hist
                                    gotit=1
                            if gotit==0:
                                OnOrders.append(hist)
                            for i in myhistory:
                                item=str(myhistory[j])
                                window.HistorylistWidget.addItem(item)
                                j=j+1
                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
                                if supply==0:
                                    window.HistorylistWidget.insertItem(0,"Supply: " + "100%")
                                else:
                                    ss=Decimal(int(ThePeg.steps[supply-1]*1e8))/Decimal(1e6)
                                    window.HistorylistWidget.insertItem(0,"Supply: " + str(ss) + "%")
                                if ftot!=0:
                                    window.HistorylistWidget.insertItem(0,"Frozen: " + str(Decimal(ftot)/Decimal(1e8)))
                                if rtot!=0:
                                    window.HistorylistWidget.insertItem(0,"Reserve: " + str(Decimal(rtot)/Decimal(1e8)))
                                if subpremium!=0:
                                    window.HistorylistWidget.insertItem(0,"Subpremium: " + str(Decimal(subpremium)/Decimal(1e8)))
                                window.HistorylistWidget.insertItem(0,"Liquid: " + str(Decimal(ltot)/Decimal(1e8)))
                            if Decimal(available)>Decimal(0) or checkit==1 or rtot!=0 or ftot!=0:
                                checkit=0
                                window.WelcomeAvailableBalance.show()
                                window.SendAvailableBalance.show()
                                window.MyBalance_4.show()
                                window.MyBalance_8.show()
                                window.Symbol_2.show()
                                window.Symbol_4.show()
                                window.WelcomeActualBalance.setText(Gtranslate("Actual Balance:"))
                                window.SendActualBalance.setText(Gtranslate("Actual Balance:"))
                                window.WelcomeAvailableBalance.setText(Gtranslate("Available Balance:"))
                                window.SendAvailableBalance.setText(Gtranslate("Available Balance:"))
                                window.MyBalance_8.setText(str(available))
                                window.MyBalance_4.setText(str(available))
                                window.MyBalance_3.setText(str(actual))
                                window.MyBalance_7.setText(str(actual))
                                window.MyBalance.setText(str(available))
                                UpdateCfg('#prevbalance#',str(available))
                            else:
                                window.WelcomeActualBalance.setText(Gtranslate("Actual Balance:"))
                                window.SendActualBalance.setText(Gtranslate("Actual Balance:"))
                                window.WelcomeAvailableBalance.hide()
                                window.SendAvailableBalance.hide()
                                window.MyBalance_4.hide()
                                window.MyBalance_8.hide()
                                window.Symbol_2.hide()
                                window.Symbol_4.hide()
                                if Decimal(received)==Decimal(0):
                                    received=0
                                window.MyBalance_3.setText(str(received))
                                window.MyBalance_7.setText(str(received))
                                window.MyBalance.setText(str(received))
                                UpdateCfg('#prevbalance#',str(received))
                        window.KeysConnected.setText(Gtranslate("You have " + keysconnected + " private key connected"))
                        updatesomething=0
                        if NewUser!=[]:
                            if isdownloading!= 1:
                                GetNewUser()
                        #Populate list of offers
                        window.MyPendingOffers.clear()
                        window.MyOpenContracts.clear()
                        #Sent
                        PopulateContracts()
                        PopulateMarkets()
                        lockdownload=0
                    else:
                        lockdownload=0
                        window.KeysConnected.setText(Gtranslate("Please refresh..."))
                        if NewUser!=[]:
                            if isdownloading!= 1:
                                GetNewUser()
        else:
            if isdownloading !=1:
                updatesomething=0
            prevbal=GetfromCfg("#prevbalance#")
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                prevbal=""
            if CoinSelect['moderngui']==0:
                window.MyBalance.setText(prevbal + Gtranslate(" (not up to date)"))
            else:
                window.MyBalance.setText(Gtranslate(" (not up to date)"))
            avail2=0
            for o in OnOrders:
                if o['type']=="CONTRACT" or o['type']=="2STEP" or o['type']=="SPENT" or o['type']=="PAY TO EMAIL":
                    avail2=1
                    break
            #See if the balance is available or actual THIS may have to change once contracts allow for ZERO deposits (HINT, maybe different contract type for that)
            if avail2==0:
                window.WelcomeAvailableBalance.show()
                window.SendAvailableBalance.show()
                window.MyBalance_4.show()
                window.MyBalance_8.show()
                window.Symbol_2.show()
                window.Symbol_4.show()
                if CoinSelect['moderngui']==0:
                    window.MyBalance_3.setText(prevbal + Gtranslate(" (not up to date)"))
                    window.MyBalance_7.setText(prevbal + Gtranslate(" (not up to date)"))
                else:
                    window.tab.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
                    window.tab.le_actualBalance.setText(prevbal)
                    window.SendBitcoins.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
                    window.SendBitcoins.le_actualBalance.setText(prevbal)
            else:
                window.WelcomeAvailableBalance.show()
                window.SendAvailableBalance.show()
                window.MyBalance_4.show()
                window.MyBalance_8.show()
                window.Symbol_2.show()
                window.Symbol_4.show()
                if CoinSelect['moderngui']==0:
                    window.MyBalance_8.setText(prevbal + Gtranslate(" (not up to date)"))
                    window.MyBalance_4.setText(prevbal + Gtranslate(" (not up to date)"))
                else:
                    window.SendBitcoins.l_availableBalance.setText(Gtranslate("Available Balance (not up to date):"))
                    window.SendBitcoins.le_availableBalance.setText(prevbal)
                    window.tab.l_availableBalance.setText(Gtranslate("Available Balance (not up to date):"))
                    window.tab.le_availableBalance.setText(prevbal)
            if NewUser!=[]:#Ok  if it failed downloading it will hang, we should wait
                GetNewUser()
            window.KeysConnected.setText("Not connected to internet!")

###########################################################
def statusbar(isunlocked,perc,connections,canstake):
    if isunlocked:
        window.setWalletLocked(False)
    else:
        window.setWalletLocked(True)
    try:
        window.setCoinPeersCount(int(connections))
    except:
        window.setCoinPeersCount(0)
    window.setStakingActive(canstake)
    if perc<100:
        window.setBlockchainInSync(False)
    if perc<100:
        window.setBlockchainInSync(True)        
def waitlock(limit=1000):
    global LockTHIS
    lktik=0
    while 'AP' in LockTHIS or 'EW' in LockTHIS or 'BM' in LockTHIS or 'UD' in LockTHIS:
        lktik+=1
        time.sleep(.01)
        if lktik==limit:
            break
    if 'AP' not in LockTHIS and 'EW' not in LockTHIS and 'BM' not in LockTHIS and 'UD' not in LockTHIS:
        return True
    else:
        return False
def requestURL(URL):
    global noproxy, mechurl
    try:
        if AdvanceArray['MySettings']['Proxy']!='':
            if URL[:15] in noproxy:
                float('a')
            url, port = AdvanceArray['MySettings']['Proxy'].split(":",1)
            socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, url, int(port))
            socket.socket = socks.socksocket
            socket.create_connection = create_connection
            try:
                if URL[:15] not in mechurl:
                    try:
                        text=rget(URL)
                    except:
                        print "Mechnize URL: ", str(URL)
                        float('a')
                else:
                    float('a')
            except:
                if URL[:15] not in mechurl:
                    mechurl[URL[:15]]=1
                try:
                    mechbrowser=mechanize.Browser()
                    #mechbrowser.set_all_readonly(False)    # allow everything to be written to
                    mechbrowser.set_handle_robots(False)   # ignore robots
                    mechbrowser.set_handle_refresh(False)  # can sometimes hang without this
                    #mechbrowser.addheaders = [('User-agent', 'Firefox')]
                    mechbrowser.addheaders = [('User-agent', 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.1) Gecko/2008071615 Fedora/3.0.1-1.fc9 Firefox/3.0.1')]
                except:
                    traceback.print_exc()
                    print 'Loading of Mechanize failed'
                    float('a')
                text = mechbrowser.open(URL)
                text = text.read() 
            if 'Completing the CAPTCHA proves' in text:
                float('a')
            if 'One more step' in text and 'Please complete the security check' in text:
                float('a')
            return text
        else:            
            float('a')
    except:
        if AdvanceArray['MySettings']['Proxy']!='':            
            if URL[:15] not in noproxy:
                print "Unable to use proxy on URL:"+str(URL[:15])
                noproxy[URL[:15]]=1
            socket.socket = socket_original
            socket.create_connection = connection_original
        #if 'api.biteasy.com' in URL or "https://chain.so/api/" in URL or "https://blockchain.info/" in URL or "http://coinmarketcap.com/" in URL or 'estimatefee.com' in URL or 'api.coindesk.com' in URL or 'bitcoin.com' in URL or 'blockexplorer.com' in URL or 'githubusercontent' in URL or 'api64.ipify.org' in URL or 'pastebin.com':#These sites prefer requests
        try:
            return rget(URL)
        except:
            return str(urllib2.urlopen(URL, None, 60).read())
        #except:
        #    return rget(URL)
#def fpaste(content, expire_options=604800):
#    global noproxy
#    try:
#        if AdvanceArray['MySettings']['Proxy']!='':
#            if 'fpaste' in noproxy:
#                socket.socket = socket_original
#                socket.create_connection = connection_original
#            else:
#                url, port = AdvanceArray['MySettings']['Proxy'].split(":",1)
#                socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, url, int(port))
#                socket.socket = socks.socksocket
#                socket.create_connection = create_connection
#        try:
#            mCookieJar = mechanize.CookieJar()
#            mechbrowser=mechanize.Browser()
#            #mechbrowser.set_all_readonly(False)    # allow everything to be written to
#            mechbrowser.set_handle_robots(False)   # ignore robots
#            mechbrowser.set_handle_refresh(False)  # can sometimes hang without this
#            #mechbrowser.addheaders = [('User-agent', 'Firefox')]
#            mechbrowser.addheaders = [('User-agent', 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.1) Gecko/2008071615 Fedora/3.0.1-1.fc9 Firefox/3.0.1')]
#            mechbrowser.set_cookiejar(mCookieJar)
#        except:
#            traceback.print_exc()
#            print 'Loading of Mechanize failed'
#            float('a')
#        url='https://pastebin.com/'
#        response = mechbrowser.open(url)
#        x=response.read()      # the text of the page
#        for form in mechbrowser.forms():
#            if "TextareaControl(PostForm" in str(form):
#                mechbrowser.form = form
#                break
#        mechbrowser.form['PostForm[text]']=content
#        response=mechbrowser.submit()
#        x=response.read()
#        if content not in x:
#            print "Content not found in result"      
#            clipboard = app.clipboard()
#            clipboard.setText(x) 
#            print response.geturl()
#            float('a')
#        return str({'paste_id_repr':response.geturl()})
#    except:
#        traceback.print_exc()
#        if AdvanceArray['MySettings']['Proxy']!='' and 'fpaste' not in noproxy:
#            noproxy['fpaste']=1
#            socket.socket = socket_original
#            socket.create_connection = connection_original
#            return fpaste(content, expire_options)
#    return False
def fpaste(content, expire_options=604800):
    global timestamp #The new fpaste wants a specific timestamp
    URL = "https://dpaste.com/api/"
    try:
        query = {"content": content, "syntax": "python", "expiry_days": 365}
        resp = rpost(URL, query, 1)
        resptext = resp.text.replace("\n","")
        print resptext
        if "err_" in str(resptext) or "_failure" in str(resptext) or "Error" in str(resptext) or "http" not in str(resptext):
           return False
        return str({'paste_id_repr':resptext})
    except:
        traceback.print_exc()
        return False
def showpaste(ID):#Receive as a string    
    try:
        ID=ast.literal_eval(ID)
        resp=repr(requestURL(ID['paste_id_repr']+".txt"))
        if resp[0]=="u" and resp[1]=="'":
            resp=ast.literal_eval(resp)
        return str(resp)#response['result']['data']
    except Exception, e:
        traceback.print_exc()
        print "PASTEBIN FAILED: ", str(ID)
        return False
#def showpaste(ID):#Receive as a string
#    try:
#        ID=ast.literal_eval(ID)
#        resp=repr(requestURL(ID['paste_id_repr']))
#        resp=resp.split('div id="raw-content" hidden>\\n')[1].split("\\n</div>")[0]
#        return str(resp)#response['result']['data']
#    except Exception, e:
#        traceback.print_exc()
#        print "PASTEBIN FAILED: ", str(ID)
#        return False
#Unfortunately fpaste wants an API key now. And too many services change their API so we resort to scraping now.
#If the page we are using changes then we will add more redundant services
#def fpaste(content, expire_options=604800):
#    global timestamp #The new fpaste wants a specific timestamp
#    valid_expire_options = {
#        '3600': 'In one hour',
#        '10800': 'In three hours',
#        '43200': 'In twelve hours',
#        '86400': 'In one day',
#        '604800': 'In one week'}
#    URL = "https://paste.fedoraproject.org/api/paste/submit"
#    try:
#        query = {'contents': content, 'language': "python", 'expiry_time': expire_options + timestamp,'password':"Halo123"}
#        resp = rpost('https://paste.fedoraproject.org/api/paste/submit', query)
#        response = json.loads(resp.text)
#        resptext = resp.text
#       if "err_" in str(resptext) or "_failure" in str(resptext):
#           return False
#        return str({'paste_id_repr':response['paste_id_repr']})
#    except:
#        traceback.print_exc()
#        return False
#def showpaste(ID):#Receive as a string
#    try:
#        ID=ast.literal_eval(ID)
#        resp = rpost('https://paste.fedoraproject.org/api/paste/details', {'paste_id': ID['paste_id_repr'],'password': 'Halo123'})
#    
#        response = json.loads(resp.text)
#        resptext = resp.text
#        if "err_" in str(resptext) or "_failure" in str(resptext):
#            print resptext
#            return False
#        return str(response['details']['contents'])#response['result']['data']
#    except Exception, e:
#        traceback.print_exc()
#        print "PASTEBIN FAILED: ", str(ID)
#        return False
def CheckNotary(txid):
    global MyContracts
    mytx2=False
    try:
        res=translate_script(NotaryScripts[txid])
        if res['message'][0]=="*" and res['message'][1]=="E" and res['message'][2]=="*":#Possible escrow message
            for contract in MyContracts:
                if 'billing' in contract:
                    if txhash(str(contract['billing'])+contract['ordernumber'])[:17]==res['message'].replace('*E*',''):
                        if "I pay" not in contract['whopays']:#Eventually it might be worthwhile for both parties to confirm this way
                            tx,n=txid.split(":")
                            try:#Rate check
                                match=0
                                if contract['Market Data']['tracking']!=0:
                                    if 'prevrate' not in contract:
                                        contract['prevrate']=contract['Market Data']['rate']
                                    for mytx in BlackUnspent:
                                        if mytx['txid']==tx and int(mytx['vout'])==int(n)+3:
                                            mytx2=json_deep_copy(mytx)
                                            prevrate=str((Decimal(contract['Market Data']['rate'])*((Decimal(contract['amount'])/Decimal(1e8))/Decimal(mytx['amount']))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))
                                            print "Payment exchange rate: ", prevrate
                                            found=0
                                            for rate in AdvanceArray['charts'][CoinSelect['name']]:                                            
                                                thetime=ConvertDate(contract['billing'], 1)
                                                thetime2=thetime + datetime.timedelta(hours=24)
                                                starttime=datetime.datetime.utcfromtimestamp(rate['starttime'])
                                                endtime=datetime.datetime.utcfromtimestamp(rate['endtime'])
                                                amount=Decimal(int((Decimal(contract['amount']))*(Decimal(contract['Market Data']['rate'])/Decimal(rate['price'])))/Decimal(1e8))
                                                if starttime > thetime and starttime < thetime2:
                                                    found=1
                                                if endtime > thetime and endtime < thetime2:
                                                    found=1
                                                if found==1:
                                                    if Decimal(mytx['amount']) < amount*Decimal(1.03) and Decimal(mytx['amount']) > amount*Decimal(.97):
                                                        usd=rate['price']
                                                        contract['ratematch']=1
                                                        match=1
                                                        break
                                            contract['prevrate']=prevrate
                                    if match==0:
                                        contract['ratematch']=0

                            except:
                                traceback.print_exc()
                                float('a')
                            mytime=ConvertDate(contract['billing'], 1)
                            if "Week" in contract['Market Data']['Pay Frequency']:
                                NewTime=mytime+ datetime.timedelta(hours=168)
                                contract['billing']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                            if "Month" in contract['Market Data']['Pay Frequency']:
                                NewTime=addmonths(1,mytime)
                                contract['billing']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                            mytime=ConvertDate(contract['time'],1)
                            WinContracts.hide()
                            if "Week" in contract['Market Data']['Pay Frequency']:
                                NewTime=mytime+ datetime.timedelta(hours=168)
                                contract['time']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                contract['blocks']=contract['blocks']+(int(7)*144)
                                WinContracts.Requests.addItem("Time extended: " + str(7) + " Days")
                                contract['MyMessages'].append({'message': "Time extended: " + str(7) + " Days"})
                                contract['MyRequests'].append("Time extended: " + str(7) + " Days")                                                        
                            if "Month" in contract['Market Data']['Pay Frequency']:
                                NewTime=addmonths(1,mytime)
                                contract['time']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                contract['blocks']=contract['blocks']+(int(31)*144)
                                WinContracts.Requests.addItem("Time extended: " + str(1) + " Month")
                                contract['MyMessages'].append({'message': "Time extended: " + str(1) + " Month"})
                                contract['MyRequests'].append("Time extended: " + str(1) + " Month")
                            if "Milestone" in contract['Market Data']['Pay Frequency']:
                                contract['billingpaid']=contract['billing']
                                contract.pop('billing')
                            WinContracts.Requests.addItem("Escrow Payment: " + tx+str(int(n)+3))
                            contract['MyMessages'].append({'message': "Escrow Payment: " + tx+str(int(n)+3)})
                            contract['MyRequests'].append("Escrow Payment: " + tx+str(int(n)+3))
                            Notification(1, "Payment Received!")
                            break
        return mytx2
    except:
        traceback.print_exc()
        return False

def rpost(url,query,data=0):
    global reqsession
    global noproxy
    try:
        try:
            if AdvanceArray['MySettings']['Proxy']!='':
                if url[:15] in noproxy:
                    float('a')
                url2, port = AdvanceArray['MySettings']['Proxy'].split(":",1)
                socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, url2, int(port))
                socket.socket = socks.socksocket
                socket.create_connection = create_connection
                if data==0:
                    resp = requests.post(url,json=query)
                else:
                    resp = requests.post(url,data=query)
                if 'captcha' in resp or "CAPTCHA" in resp or 'security' in resp:
                    float('a')
                return resp
            else:            
                float('a')
        except:
            if AdvanceArray['MySettings']['Proxy']!='':            
                if url[:15] not in noproxy:
                    print "Unable to use proxy on URL:"+str(url[:15])
                    noproxy[url[:15]]=1
                socket.socket = socket_original
                socket.create_connection = connection_original
        if reqsession=="":
            if data==0:
                resp = requests.post(url,json=query)
            else:
                resp = requests.post(url,data=query)
        else:
            if data==0:
                resp = reqsession.post(url,json=query)
            else:
                resp = reqsession.post(url,data=query)
    except:
        exc=str(traceback.format_exc())
        print exc
        if "SSLError:" in exc:# [Errno bad ca_cert ... for example
            if reqsession=="":
                reqsession = requests.Session()
                reqsession.mount('https://', MyAdapter())
            if data==0:
                resp = reqsession.post(url,json=query)
            else:
                resp = reqsession.post(url,data=query)
        else:
            float('a')    
    return resp

def rget(url):
    global reqsession
    try:
        if reqsession=="":
            resp = requests.get(url, timeout=60).text
        else:
            resp = reqsession.get(url, timeout=60).text
    except:
        stack=str(traceback.extract_stack())
        exc=str(traceback.format_exc())        
        if "SSLError:" in exc:# [Errno bad ca_cert ... for example
            if reqsession=="":
                reqsession = requests.Session()
                reqsession.mount('https://', MyAdapter())
            else:
                try:
                    resp = reqsession.get(url.replace("http:","https:"), timeout=60).text
                except:
                    reqsession=""
        else:
            print stack, "\n"
            print exc
            float('a')    
    return resp
def GetMarketValue(thecoin, coins="", check=1):
    global CoinMarketCap, thecoins, CoinGecko, githubrates
    coinsG=""
    usd=""
    btc=""
    if coins==" ":
        return usd,btc
    try:
        if coins=="" and check==1:
            if thecoin not in coins:#Eventually we could iterate all coins in CoinSelect
                if thecoin=="BitBay":
                    githubrates=json.loads(requestURL("https://raw.githubusercontent.com/bitbaymarket/ratedb/master/rates.json"))
                    tbtc=Decimal(int((Decimal(githubrates['BAY']['price'])/Decimal(githubrates['BTC']['price']))*Decimal(1e8)))/Decimal(1e8)
                    tbtc=dropzeros(remove_exponent(tbtc),1)
                    coins=' id="id-'+'bitcoin'+'price" data-usd="'+str(githubrates['BTC']['price'])+'"'+' data-btc="'+'1'+'"'+'id="id-'
                    coins+=' id="id-'+'bitbay'+'price" data-usd="'+str(githubrates['BAY']['price'])+'"'+' data-btc="'+str(tbtc)+'"'+'id="id-'
                else:
                    try:
                        if CoinGecko == 1:
                            float('a')
                        try:
                            mycoin = requestURL('https://coinmarketcap.com/currencies/' + thecoin)
                            tusd = mycoin.split('<span class="cmc-details-panel-price__price">$')[1].split('</span>')[0].replace(',', '')
                            tbtc = mycoin.split('<span class="cmc-details-panel-price__crypto-price">')[1].split(' BTC</span>')[0].replace(',', '')
                        except:
                            CoinGecko = 1
                            float('a')
                    except:
                        try:
                            mycoin = requestURL('https://www.coingecko.com/en/coins/' + thecoin)
                            tusd = mycoin.split('data-target="price.price">$')[1].split('</span>')[0].replace(',', '')
                            try:
                                tbtc = mycoin.split('class="text-muted text-normal">\n')[1].split(' BTC')[0].replace(',', '')
                            except:
                                tbtc = mycoin.split('data-price-btc="')[1].split('"')[0].replace(',', '')
                        except:
                            CoinGecko = 0
                            float('a')
                    coins+=' id="id-'+thecoin.lower()+'price" data-usd="'+tusd+'"'+' data-btc="'+tbtc+'"'+'id="id-'
            coinsG=coins
        try:
            try:
                try:
                    coins=coins.split(' id="id-'+thecoin.lower())[1].split('id="id-')[0]
                except:
                    coins=strIN(coins)
                    coins=coins.split(' id="id-'+thecoin.lower())[1].split('id="id-')[0]
            except:                
                coinsa='price" data-usd="'+coins.split('class="cmc-link">'+thecoin+'</a>')[1].split('class="cmc-link">$')[1].split('</a>')[0].replace(",","")+'"'
                if thecoin.lower()=='bitcoin':
                    coinsb=' data-btc="1"'
                else:
                    aa=coinsa.split('price" data-usd="')[1].split('"')[0].replace(",","")
                    btc2=coins.split('class="cmc-link">Bitcoin</a>')[1].split('class="cmc-link">$')[1].split('</a>')[0].replace(",","")
                    btcv=dropzeros(remove_exponent(Decimal(int((Decimal(aa)/Decimal(btc2))*Decimal(1e8)))/Decimal(1e8)),1)
                    coinsb=' data-btc="'+btcv+'"'
                coins=coinsa+coinsb
            usd=coins.split('price" data-usd="')[1].split('"')[0]
            btc=coins.split(usd+'" data-btc="')[1].split('"')[0]
            f=float(btc)
            f=str(int(Decimal(f)*Decimal(1e8)))
            f=Decimal(f)/Decimal(1e8)
            btc=str(format(Decimal(btc),"f"))[:10]
        except:
            if thecoin==CoinSelect['name'] or thecoin=='Bitcoin':
                pass
            try:
                if thecoins!='':
                    coins=thecoins
                coins=coins.split(' id="id-'+thecoin.lower())[1].split('id="id-')[0]
                usd=coins.split('price" data-usd="')[1].split('"')[0]
                btc=coins.split(usd+'" data-btc="')[1].split('"')[0]
                f=float(btc)
                f=str(int(Decimal(f)*Decimal(1e8)))
                f=Decimal(f)/Decimal(1e8)
                btc=str(format(Decimal(btc),"f"))[:10]
            except:
                if thecoin==CoinSelect['name'] or thecoin=='Bitcoin':
                    CoinMarketCap=" "
                    traceback.print_exc()
                    print "RESET RATE"
                    print thecoin
                usd=""
                btc=""
        if usd!="" and check==1 and coinsG!="":
            CoinMarketCap=coinsG
    except:
        pass
    return usd,btc
def UpdateMarketList():
    global Markets
    window.MarketBox.blockSignals(True)
    try:
        list1=[]
        for name, mark in Markets['MyMarkets'].iteritems():
            list1.append(name)
        list1.sort()
        list1.append("ALL")
        window.MarketBox.clear()
        window.MarketBox.addItems(list1)
        index = window.MarketBox.findText(Markets['Current'], QtCore.Qt.MatchFixedString)
        if index >= 0:
             window.MarketBox.setCurrentIndex(index)
    except:
        traceback.print_exc()
        pass
    window.MarketBox.blockSignals(False)
def RemoveMarket(address):
    Command={}
    addr=address
    if addr=="":
        return ""
    Command['Command']='Remove Channel'
    Command['Address']=addr
    BitQueue.append(Command)
    SaveQueue()
def AddMarket(address):
    Command={}
    addr=address
    if addr=="":
        return ""
    Command['Command']='Add Channel'
    Command['Address']=addr
    BitQueue.append(Command)
    SaveQueue()
def CleanInbox(BitAddr):
    global Markets, MyContracts
    #For speeding up inbox if there are many orders, can can have scanmessages build a list of read market orders to clear more frequently.
    #WE can use the don't repopulate array to clean the inbox and eventually thin out that array when messages are empty
    #Also, since we wait for empty contracts to clean the inbox a user who is always contracting can experience lag. So again we could
    #clear their inbox based on don't repopulate.
    Command={}
    Command['Command']='Clean Inbox'
    Command['MyMarkets']=[]
    for Market in Markets['MyMarkets']:#Every couple days we clear out old market orders.
        Command['MyMarkets'].append(Markets['MyMarkets'][Market])
    Command['Bitmessage Address']=BitAddr
    if MyContracts==[]:
        Command['Clear Sent']=1
    BitQueue.append(Command)
    SaveQueue()
def CleanInboxOrder(ordernumber, privkey):
    #Whenever an order is cleared we search the inbox for any email with its ordernumber. This keeps the inbox managable.
    global MyEmail, EmailPassword
    Command={}
    if ordernumber=="":
        return
    GetEmailGlobals()
    if MyEmail=="":
        return
    Command['Command']='Remove Order'
    Command['ordernumber']=ordernumber
    Command['Email Address']=MyEmail
    Command['Password']=EmailPassword
    #Its a bit tedious but we need to try and decrypt the related emails
    Command['Private Key']=privkey
    BitQueue.append(Command)
    SaveQueue()
def ModerationCheck(multisig, priv, contract, Mpub="", Orgpub=""):
    global publicaddress, masterpublic, MyContracts
    BitAddr=GetfromCfg("#BitMessage#")
    pubs=get_ordered_pubkeys(PrivKeyFilename1)
    pub = privtopub(priv)
    try:
        if pubs[0]==pub:
            mypub=pubs[0]
        if pubs[1]==pub:
            mypub=pubs[1]
        if masterpublic==pub or ModeratorPublicKey==pub:
            mypub=pub
        if Mpub!="":
            mypub=Mpub
        ident=encrypt(publicaddress, masterpublic)#For protecting ip addresses from eavesdropping
        ident=base64.b64encode(ident)+Markets['U']
        if 'Market Data' not in contract:
            contract['Market Data']={}
        if Orgpub!="":#In some cases during resubmit we use the public key inside the contract instead of the original key
            contract['Market Data']['orgpublic']=Orgpub
        else:
            contract['Market Data']['orgpublic']=mypub
        contract['Market Data']['public']=mypub
        contract['Market Data']['ident']=ident
        contract['Market Data']['Bitmessage']=BitAddr
        contract['Market Data']['Address']=multisig
        if 'verify' in contract['Market Data']:
            contract['Market Data'].pop('verify')
        ordernumber=make_hash(contract)#Since we use ast a lot, this is a safe method for getting the hash
        print "HASH:", ordernumber
        sig=highlevelcrypto.sign(ordernumber[:19],priv)
        sig=base64.b64encode(sig)
        contract['Market Data']['verify']=sig
        print "SIZE:", sys.getsizeof(str(contract))
        if "*"+ident[:10] in Markets['Banlist'] or "*"+ident[-10:] in Markets['Banlist'] or "*" + BitAddr in Markets['Banlist'][:10] or "*"+multisig[:10] in Markets['Banlist'] or "*" + mypub[:10] in Markets['Banlist'] or mypub[:10] in Markets['Banlist']:
            QuestionBox("Sorry, this option is no longer available.", "OK")
            return False
        #We can fill in the rest of the market data later
        return contract
    except Exception, e:
        traceback.print_exc()
        return False
###########################################################
#Ok here we scan the messages and perform the actions needed for each one and each step. Its pretty critical to get everything right here
#Versions should be backwards compatible so that a contract is never ignored at any stage however the client will let you know and this may not always be the case
def ScanMessages():
    global updatesomething, MyContracts, OnOrders, HaloTime, WatchlistQueue, MyMessages3, MyMessages, MyEmail, AdvanceArray, NewUser
    global DontRepopulate
    global HistoryDetail
    global checkpastebin
    global SilenceUI
    global EscrowResults
    global timestamp
    global isdownloading
    global lockdownload
    global NotForMe
    global LockTHIS
    global myblockcount
    at=time.time()

    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    BitAddr=GetfromCfg("#BitMessage#")
    GetEmailGlobals()
    if str(MyEmail) not in AdvanceArray:
        AdvanceArray[MyEmail]={}
    if 'uids' not in AdvanceArray[str(MyEmail)]:
        AdvanceArray[str(MyEmail)]['uids']=[]
    myorigEmail=str(MyEmail)
    if MyMessages3=="" or MyMessages3== None:
        MyMessages3=[]
    try:
        MyMessages4=ast.literal_eval(MyMessages3)
    except:
        MyMessages4=[]
    try:
        MyMessages2=ast.literal_eval(MyMessages)
    except:
        MyMessages2=[]
    for mes in MyMessages4:
        MyMessages2.append(mes)
    if 'Archive' in AdvanceArray:
        if multisig in AdvanceArray['Archive']:
            try:
                MyArchive=json_deep_copy(AdvanceArray['Archive'][multisig],1)
                for mes in MyArchive:
                    if mes not in MyMessages2:
                        MyMessages2.append(mes)
                #messages can only be removed on something like dontrepopulate
            except:
                print "Archive Exception"
    #If we have read the messages and nothing is new why keep reading every few seconds?
    for message in MyMessages2:
        #Because UI and back end are mixed the quick fix is to update the UI here when contracts
        #are not being interfered with. We check to see if 1/20th of a second has passed
        #We might spend time re-reading messages that we have already read on contracts that are open
        #Consider that some wait for txids or wait for images. Others we will notice they are already read
        #The only orders we can maybe prevent from being compulsively read are Market Offers by comparing
        #What is in our orderbook to what messages we have in Bitmessage. However this logic goes to the Bitmessage
        #Thread and we do not need to process that here since it would not speed up the UI
        if time.time()-at>.05:
            at=time.time()
            try:
                if 'BM' not in LockTHIS and 'DL' not in LockTHIS and 'BL' not in LockTHIS:
                    LockTHIS['AP']=1
                    app.processEvents()
                    LockTHIS.pop('AP', None)
            except:
                LockTHIS.pop('AP', None)
                print "Error in Application EVENT"
                traceback.print_exc()
            if myorigEmail != MyEmail:
                break
        try:
            message['toAddress']=message['toAddress'][:16].lower()
        except:
            traceback.print_exc()
            pass
        if txhash(str(message)) in NotForMe: #If we share emails we end up reading messages over and over
            continue
        #It takes time to process messages!

        #While in escrow there will be little discrimination for canceling... as long as the signature is correct we go ahead with it
        #In early stages I see no reason as to why the clients should not be naive as long as the important information matches before signing
        #We may want to encrypt messages with their public key and hexify it but for now everything is done by using the order number since a public key can be intercepted too. Although the raw will be encrypted of course(an imposted cant decrypt it)
        #Check to see if the body is actually a valid dictionary
        try:
            body=message['message']
        except:
            try:
                body=message['body']
            except:
                body=""

        body=body.replace("\'", "'")#I saw some messages sent this way not sure what it means but I think its a bitmessage thing
        validorder=-1#this will be assigned if we clear a checkpoint as well as the message position
        #Lets see if its valid
        try:
            if NewUser!=[]:
                return
            try:
                body=ast.literal_eval(body)
            except:
                try:
                    test=quopri.decodestring(body)
                    body=ast.literal_eval(test)
                except:
                    try:
                        test=body.replace("=\r\n","")
                        test=test.replace("****","")
                        test=quopri.decodestring(test)
                        body=ast.literal_eval(test)
                    except:
                        pass
            #The next few blocks are other types of requests besides contracts. A sensible method of avoiding spam could be considered(perhaps starting with a signature).
            try:
                if 'fromAddress' in message:
                    if message['fromAddress'] != body['MyBMAddress']:#If its Bitmessage and someone is pretending to be another account
                        if body['ordernumber'] in DontRepopulate:
                            continue
                        else:
                            DontRepopulateThis(message, multisig, body['ordernumber'])
                            continue
                if 'status' in body:
                    if body['status']=='Joint 2 Step':
                        if body['ordernumber'] in DontRepopulate:
                                continue
                        if body['type']!='CONTRACT':
                            print float("A")
                        test=body['ordernumber']+"A"
                        test=json_deep_copy(body['sigs'],1)
                        test=json_deep_copy(body['Order'],1)
                        test=body['MyBMAddress']+"A"
                        test=body['TheirBMAddress']+"A"
                        if 'auto' in body:
                            continue
                        if body['TheirBMAddress']!=MyEmail:
                            if body['TheirBMAddress']!=BitAddr:
                                continue
                        if body['BitHaloClient'] is not True and body['BitHaloClient'] is not False:
                            test=body['BitHaloClient']+"A"
                        if body['BitHaloClient'] != BitHaloClient:
                            continue
                        if multisig in AdvanceArray:
                            if 'AutoSign' not in AdvanceArray[multisig]:
                                AdvanceArray[multisig]['AutoSign']=0
                            if AdvanceArray[multisig]['AutoSign']==1:
                                body['auto']=1
                                MyContracts.append(body)
                                Notification(1, "Two Step Send Request!")
                                DontRepopulateThis(message, multisig, body['ordernumber'])
                                window.TwoStepSendpt2(body)
                                continue
                        t=body['TheirBMAddress']
                        t2=body['MyBMAddress']
                        body['TheirBMAddress']=t2
                        body['MyBMAddress']=t
                        MyContracts.append(body)
                        Notification(1, "Two Step Send Request!")
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    if body['status']=='Joint Account Offer':
                        if body['ordernumber'] in DontRepopulate:
                                continue
                        if body['type']!='CONTRACT':
                            print float("A")
                        test=body['ordernumber']+"A"
                        test=body['public']+"A"
                        test=body['MyBMAddress']+"A"
                        test=body['TheirBMAddress']+"A"
                        if body['TheirBMAddress']!=MyEmail:
                            if body['TheirBMAddress']!=BitAddr:
                                continue
                        if body['BitHaloClient'] is not True and body['BitHaloClient'] is not False:
                            test=body['BitHaloClient']+"A"
                        body['public']=body['public'].strip()
                        body['status']='Joint Account Offer1'
                        t=body['TheirBMAddress']
                        t2=body['MyBMAddress']
                        body['TheirBMAddress']=t2
                        body['MyBMAddress']=t
                        MyContracts.append(body)
                        Notification(1, "Joint Account Request!")
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    if body['status']=='Joint Account Offer2':
                        if body['ordernumber'] in DontRepopulate:
                                continue
                        if body['type']!='CONTRACT':
                            print float("A")
                        test=body['ordernumber']+"A"
                        test=body['oldordernumber']+"A"
                        test=body['public']+"A"
                        test=body['MyBMAddress']+"A"
                        test=body['TheirBMAddress']+"A"
                        if body['TheirBMAddress']!=MyEmail:
                            if body['TheirBMAddress']!=BitAddr:
                                continue
                        if body['BitHaloClient'] is not True and body['BitHaloClient'] is not False:
                            test=body['BitHaloClient']+"A"
                        o=-1
                        for c in MyContracts:
                            o+=1
                            if c['ordernumber']==body['oldordernumber']:
                                try:
                                    with open(strOUT(MyContracts[o]['path']),'r') as fi:
                                        data1=fi.readlines()
                                        fi.close()
                                    #Put the public keys in each private key file
                                    data1[1]=data1[1].replace('COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.',body['public'])
                                    with open(strOUT(MyContracts[o]['path']),'wb') as fi:
                                        for d in data1:
                                            fi.write(d.strip()+"\n" )
                                        fi.flush()
                                        os.fsync(fi)
                                        fi.close()
                                    MyContracts[o]['status']='Joint Account Offer2'
                                    MyContracts[o]['public']=body['public']
                                    Notification(1, "Joint Account Confirmed!")
                                except:
                                    traceback.print_exc()
                                    Notification(1, "Joint Account Failed!")
                                break
                        DontRepopulateThis(message, multisig, body['ordernumber'])
            except:
                try:
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    else:
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                        continue
                except:
                    pass
            if "PAY TO EMAIL BASE64 IMAGE:" in str(body):
                try:
                    try:
                        rawimg=StringIO.StringIO(base64.b64decode(body.replace("PAY TO EMAIL BASE64 IMAGE:","")))
                        im=Image.open(rawimg)
                        body=stepic.decode(im)
                        ordernumber = body.split('***')[1].split('###')[0]
                        rawimg.close()
                        rawimg=""
                    except Exception, e:
                        rawimg.close()
                        rawimg=""
                        print "EXCEPTION"
                        print e
                        continue
                    if ordernumber in DontRepopulate:
                        continue
                    #Some basic validity tests
                    content = body.split('DATA:')[1].split('***')[0]
                    content = password.DecryptWithAES("Halo Master", content)
                    content=ast.literal_eval(content)
                    test=content['type']+"A"
                    test=content['Redeemed']+1
                    test=content['Temporary Address']+"A"
                    test=content['priv']+"A"
                    test=content['ordernumber']+"A"
                    test=content['theiraddress']+"A"
                    if content['total']>0:
                        test=content['total']+1
                    test=content['change']+"A"
                    if content['currentblock']>=0:
                        test=content['currentblock']+1
                    test=content['Confirmation TXID']+"A"
                    if content['amount']>0:
                        test=content['amount']+1
                    if content['fee']>0:
                        test=content['fee']+1
                    test=content['address']+"A"
                    fnd=0
                    if CoinSelect['HaloName'] in content['version']:
                        fnd=1
                    if fnd==0:
                        continue
                    try:
                        if content['MyBMAddress']==MyEmail:
                            continue
                    except:
                        pass
                    rspns=0
                    found=0
                    ps1=-1
                    tt=content['Confirmation TXID']
                    skipthis=0
                    for results in EscrowResults:
                        ps1+=1
                        if 'MyTXID' in results:
                            if tt==results['MyTXID']:
                                if 'raw' in results:
                                    if 'sendEmail' in results:
                                        if results['sendEmail']!=multisig:#Someone else shares the email, they submitted it
                                            skipthis=1
                        if results['history']== "Check:"+tt:
                            found=1
                            ps2=ps1
                            rspns=results['rspns']
                    if found==0 and skipthis==0:
                        rawd={}
                        rawd['BitHalo']=BitHaloClient
                        rawd['history']="Check:"+tt
                        rawd['txid1']=tt
                        rawd['notxid']=tt
                        rawd['raw']=""
                        rawd['rspns']=0
                        EscrowResults.append(rawd)
                    if rspns != 0 and not isinstance(rspns, list):
                        EscrowResults.pop(ps2)
                        rspns=0
                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                        if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                            rspns=0
                    if rspns !=0 and skipthis==0:
                        leng=0
                        hist=rspns
                        leng=len(hist)
                        EscrowResults.pop(ps2)
                        if leng>0: #We have to wait until it confirms since we aren't adding the wallet to watchonly
                            priv = password.DecryptWithAES("Halo Master", content['priv'])
                            if "PASSWORDPROTECTED:" not in priv:#It was probably a tip, aitomatically spend it back
                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                    liq=json_deep_copy(rspns[0]['liquidity'])
                                if BitHaloClient == True:
                                    tmptx = pybit.transaction.mktx([{'output':str(content['Confirmation TXID'])+":0",'value':int(content['amount']),'address':str(content['Temporary Address'])}],[{'value':(int(content['amount'])-int(content['fee'])),'address':str(multisig)}])
                                else:
                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                        ltot=liq['ltotal']
                                        rtot=liq['rtotal']
                                        ftot=0
                                        #For now, we just freeze a buffer if we are close to a rate change
                                        if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                                            ftot=liq['nfreeze']
                                        ltot-=ftot                                                                         
                                        rtot+=ftot
                                        if ltot<=int(content['fee'])+1000:
                                            rtot+=ltot
                                            ltot=0
                                        if ltot==0:
                                            p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':(int(content['amount'])-int(content['fee'])),'script':address_to_script(multisig)}]
                                        else:
                                            p2mouts=[]
                                            if rtot!=0:
                                                p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':int(rtot),'script':address_to_script(multisig)}]
                                            p2mouts.append({'value':(int(content['amount'])-int(content['fee'])-int(rtot)),'script':address_to_script(multisig)})
                                        tmptx = mktx_script(timestamp,[{'output':str(content['Confirmation TXID'])+":0",'value':int(content['amount']),'address':str(content['Temporary Address'])}],p2mouts)
                                    else:
                                        tmptx = mktx(timestamp,[{'output':str(content['Confirmation TXID'])+":0",'value':int(content['amount']),'address':str(content['Temporary Address'])}],[{'value':(int(content['amount'])-int(content['fee'])),'address':str(multisig)}])
                                if CurrentBlock>0 or content['currentblock']==0:
                                    if content['currentblock']+1<CurrentBlock or content['currentblock']==0:
                                        tx = signall(tmptx,priv)
                                        rspns=0
                                        found=0
                                        ps1=-1
                                        for results in EscrowResults:
                                            ps1+=1
                                            if 'MyTXID' in results:
                                                if results['MyTXID']==content['Confirmation TXID']:
                                                    found=1
                                                    ps2=ps1
                                                    rspns=results['rspns']
                                        if found==0:
                                            rawd={}
                                            rawd['BitHalo']=BitHaloClient
                                            rawd['raw']=tx
                                            rawd['sendEmail']=multisig
                                            rawd['MyTXID']=content['Confirmation TXID']
                                            rawd['history']=""
                                            rawd['rspns']=0
                                            EscrowResults.append(rawd)
                                        if rspns !=0:
                                            EscrowResults.pop(ps2)
                                            hist={}
                                            hist['Amount']=str(dropzeros((Decimal(content['amount'])/Decimal(1e8)),1))
                                            hist['Details']=content
                                            hist['Details']['date']=ConvertDate(HaloTime,0)
                                            hist['Details']['Pending']=False
                                            hist['Type']="Pay To Email"
                                            hist['Label']=''
                                            if multisig not in HistoryDetail:
                                                HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
                                            if "TX rejected" in str(rspns):
                                                DontRepopulateThis(message, multisig, ordernumber)
                                                Notification(1, "Pay To Email Not Redeemed!")
                                                hist['Details']['Redeemed']=0
                                                hist['Details']['explain']="Payment not redeemed! May have expired or counterparty canceled the transaction."
                                                if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
                                                    HistoryDetail[multisig]=[hist]
                                                else:
                                                    HistoryDetail[multisig].insert(0,hist)
                                                PopulateHistory()
                                            else:
                                                try:
                                                    DontRepopulateThis(message, multisig, ordernumber)
                                                    Notification(1, "Received Pay To Email!")
                                                    hist['Details']['Redeemed']=1
                                                    if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
                                                        HistoryDetail[multisig]=[hist]
                                                    else:
                                                        HistoryDetail[multisig].insert(0,hist)
                                                    PopulateHistory()
                                                except:
                                                    traceback.print_exc()
                            else:
                                if content['ordernumber'] not in str(MyContracts):
                                    Notification(1, "Pay To Email Request!")
                                    content['type']='CONTRACT'
                                    content['status']="Pay To Email"
                                    content['Process']="P2M"
                                    try:
                                        content['TheirBMAddress']=content['MyBMAddress']
                                        content['MyBMAddress']=MyEmail
                                    except:
                                        content['MyBMAddress']=""
                                        content['TheirBMAddress']=""
                                    MyContracts.append(content)
                except Exception, e:
                    traceback.print_exc()
                    if ordernumber in DontRepopulate:
                        continue
                    else:
                        DontRepopulateThis(message, multisig, ordernumber)
                        continue
                    pass
                continue
            new=1
            pos=-1
            #Eventually we can log uids of known messages
            for contract in MyContracts:
                if NewUser!=[]:
                    return
                pos+=1
                if "ENCRYPTED:" in str(body):#Each contract has its own key, so always try and decrypt
                    try:
                        #Remove some of the potential email encoding
                        MyCipher=body.replace("=\r\n","")
                        MyCipher=MyCipher.replace("\r\n","")
                        MyCipher=MyCipher.replace(" ","")
                        MyCipher=MyCipher.replace("****","")
                        try:
                            MyCipher=MyCipher.encode('utf8')
                        except:
                            pass
                        try:
                            MyCipher=quopri.decodestring(MyCipher)
                        except:
                            pass
                        MyCipher=MyCipher.replace("ENCRYPTED:","")
                        missing_padding = len(MyCipher) % 4
                        if missing_padding != 0:
                            MyCipher += b'='* (4 - missing_padding)
                        MyCipher=base64.b64decode(MyCipher)
                        MyCipher=decrypt(MyCipher, contract['myprivate'])
                        body=ast.literal_eval(MyCipher)
                    except Exception, e:
                        continue
                if body['ordernumber']==contract['ordernumber']:#Great! A match... they want to tell us something
                    if 'fromAddress' in message:
                        if message['fromAddress'][:16].lower()!=contract['MyBMAddress'][:16].lower():#I test contracts with myself so I want to make sure I'm not reading my own messages
                            message['toAddress']=contract['MyBMAddress'][:16].lower()#Ok so if our address changes the order numbers match so its probably for us it also matches one of our keys anyway
                    validorder=pos#ok we cleared the first checkpoint if it fails we will check this number to see where it failed... more details can be done using similar logic later
                    if contract['status']=="Escrow" and message['toAddress']==contract['MyBMAddress'][:16].lower():
                        if 'MessageID' in body:
                            if 'Read' in contract:
                                if 'MyRequests' not in contract:
                                    MyContracts[pos]['MyRequests']=[]
                                if 'MyMessages' not in contract:
                                    MyContracts[pos]['MyMessages']=[]                                
                                if body['MessageID'] not in contract['Read']:
                                    if "Signing again..." in body['Process'] and "Fixed" not in MyContracts[pos]:#unless we have performed a re-sign here we drop what we are doing and sign again
                                        if 'tx4theirsig' in body:
                                            if MyContracts[pos]['tx4raw']=="1" or MyContracts[pos]['tx4raw']=="0":
                                                MyContracts[pos]['tx4theirsig']=body['tx4theirsig']
                                                MyContracts[pos]['tx4raw']=str(int(MyContracts[pos]['tx4raw'])+2)
                                        if 'tx5theirsig' in body:
                                            if 'tx5raw' in body:
                                                if MyContracts[pos]['tx5raw']=="1" or MyContracts[pos]['tx5raw']=="0":
                                                    MyContracts[pos]['tx5theirsig']=body['tx5theirsig']
                                                    MyContracts[pos]['tx5raw']=str(int(MyContracts[pos]['tx5raw'])+2)
                                        MyContracts[pos]['Read'].append(body['MessageID'])
                                        if 'uid' in message:
                                            if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                                AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])                                            
                                    else:
                                        if "Broadcasting c" not in MyContracts[pos]['Process'] and "Complete:" not in MyContracts[pos]['Process']:
                                            if 'Received message' in body['Process']:
                                                if 'Market Data' not in MyContracts[pos]:
                                                    pass
                                                else:
                                                    if MyContracts[pos]['Market Data']['allowchat']==0:
                                                        continue#We may want to see it later
                                                try:
                                                    x=body['Message']+"A"
                                                    WinContracts.Requests.addItem("Message: "+body['Message'].replace("\n"," ").replace("<br />"," ").replace("\r"," "))
                                                    MyContracts[pos]['MyRequests'].append("Message: "+body['Message'].replace("\n"," ").replace("<br />"," ").replace("\r"," "))
                                                    MyContracts[pos]['MyMessages'].append({'message':body['Message']})
                                                except:
                                                    traceback.print_exc()
                                                MyContracts[pos]['Process']="New message!"
                                                Notification(1, "New Message!")
                                            if 'Chat requested!' in body['Process']:
                                                if 'Market Data' in MyContracts[pos]:
                                                    if MyContracts[pos]['Market Data']['allowchat']!=1:
                                                        if 'Chat requested!' not in MyContracts[pos]['MyRequests']:
                                                            WinContracts.Requests.addItem("Chat requested!(click to respond)")
                                                            MyContracts[pos]['MyRequests'].append("Chat requested!(click to respond)")
                                                            MyContracts[pos]['Process']="Chat requested!"
                                                            Notification(1, "New Chat Request!")
                                            if 'theircancelsig' in body:
                                                sigvalid=1
                                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                    if 'mycancelsig' in MyContracts[pos]:
                                                        if MyContracts[pos]['mycancelsig']['ltot']!=body['theircancelsig']['ltot'] or MyContracts[pos]['mycancelsig']['rtot']!=body['theircancelsig']['rtot']:
                                                            MyContracts[pos]['MyRequests'].append("Cancellation request did not match")
                                                            MyContracts[pos]['Process']="Please resubmit cancellation"
                                                            MyContracts[pos].pop('mycancelsig')
                                                            Notification(1, "Cancellation Request Failed!")
                                                            if 'keep' not in body:
                                                                sigvalid=0
                                                if sigvalid==1:
                                                    WinContracts.Requests.addItem("Received cancellation request")
                                                    MyContracts[pos]['MyRequests'].append("Received cancellation request")
                                                    MyContracts[pos]['Process']="Received cancellation request"
                                                    MyContracts[pos]['Rejectsigned']=0
                                                    MyContracts[pos]['theircancelsig']=body['theircancelsig']
                                                    Notification(1, "New Cancellation Request!")
                                            if 'theircompletesig' in body:
                                                sigvalid=1
                                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                    if 'mycompletesig' in MyContracts[pos]:
                                                        if MyContracts[pos]['mycompletesig']['ltot']!=body['theircompletesig']['ltot'] or MyContracts[pos]['mycompletesig']['rtot']!=body['theircompletesig']['rtot']:
                                                            MyContracts[pos]['MyRequests'].append("Completion request did not match")
                                                            MyContracts[pos]['Process']="Please resubmit completion"
                                                            MyContracts[pos].pop('mycompletesig')
                                                            Notification(1, "Completion Request Failed!")
                                                            if 'keep' not in body:
                                                                sigvalid=0
                                                if sigvalid==1:
                                                    WinContracts.Requests.addItem("Received completion request")
                                                    MyContracts[pos]['MyRequests'].append("Received completion request")
                                                    MyContracts[pos]['Process']="Received completion request"
                                                    MyContracts[pos]['Rejectsigned']=0
                                                    MyContracts[pos]['theircompletesig']=body['theircompletesig']
                                                    Notification(1, "New Completion Request!")
                                            if 'Received confirmation number ' in body['Process']:
                                                MyContracts[pos]['Process']='Received confirmation number'
                                                try:
                                                    x=int(body['Message'])#Eventually we will do filtering for all the data that we end up seeing
                                                    MyContracts[pos]['MyRequests'].append("Received confirmation number: " + str(body['Message']))
                                                    MyContracts[pos]['MyMessages'].append({'message':"Received confirmation number: " + str(body['Message'])})
                                                    WinContracts.Requests.addItem("Received confirmation number: " + str(body['Message']))
                                                    Notification(1, "New Confirmation Number!")
                                                except:
                                                    pass
                                            if 'Received request for funds' in body['Process']:
                                                try:
                                                    x=int(body['Message'])
                                                    MyContracts[pos]['Process']='Received request for funds'                                                    
                                                    MyContracts[pos]['MyRequests'].append("Received request for funds(click to respond): " + str(body['Message']))
                                                    MyContracts[pos]['MyMessages'].append({'message':"Received request for funds(click to respond): " + str(body['Message'])})
                                                    WinContracts.Requests.addItem("Received request for funds(click to respond): " + str(body['Message']))
                                                    Notification(1, "New request for funds!")
                                                except:
                                                    pass
                                            if 'Received progress report' in body['Process']:
                                                try:
                                                    x=body['Message']+"A"
                                                    MyContracts[pos]['Process']='Received progress report'                                                    
                                                    MyContracts[pos]['MyRequests'].append("Received progress report: " + body['Message'])
                                                    if 'MyReports' not in MyContracts[pos]:
                                                        MyContracts[pos]['MyReports']={}
                                                    MyContracts[pos]['MyReports'][str(body['date'])]=""
                                                    WinContracts.Requests.addItem("Received progress report: " + body['Message'])
                                                    Notification(1, "Received progress report!")
                                                except:
                                                    pass
                                            if 'Received milestone invoice' in body['Process']:
                                                try:
                                                    if 'Milestone' not in MyContracts[pos]['Market Data']['Pay Frequency']:
                                                        float('a')
                                                    x=body['Message']+"A"
                                                    if x!='':
                                                        MyContracts[pos]['MyMessages'].append({'message':"Received progress report: " + body['Message']})
                                                        MyContracts[pos]['MyRequests'].append("Received progress report: " + body['Message'])
                                                        WinContracts.Requests.addItem("Received progress report: " + body['Message'])
                                                    MyContracts[pos]['Process']='Received milestone invoice'
                                                    MyContracts[pos]['MyRequests'].append("Received milestone invoice: " + str(body['date']))
                                                    if 'MyReports' not in MyContracts[pos]:
                                                        MyContracts[pos]['MyReports']={}
                                                    MyContracts[pos]['MyReports'][str(body['date'])]=""
                                                    if 'billing' not in MyContracts[pos]:
                                                        MyContracts[pos]['billing']=body['date']
                                                    WinContracts.Requests.addItem("Received milestone invoice: " + str(body['date']))
                                                    Notification(1, "Received progress report!")
                                                except:
                                                    pass
                                            if 'Received extension request' in body['Process']:
                                                try:
                                                    x=int(body['Message'])#Eventually we will do filtering for all the data that we end up seeing
                                                    MyContracts[pos]['Process']='Received time extension request'
                                                    MyContracts[pos]['MyRequests'].append("Received time extension request(click to respond): " + str(body['Message']) + " Days")
                                                    MyContracts[pos]['MyMessages'].append({'message': "Time extension request: " + str(body['Message']) + " Days"})
                                                    WinContracts.Requests.addItem("Received time extension request(click to respond): " + str(body['Message']) + " Days")
                                                    Notification(1, "New Extension Request!")
                                                except:
                                                    pass
                                            if 'Accept extension request' in body['Process']:
                                                mpos=-1
                                                try:
                                                    mposx2=body['Message'].replace("Requesting time extension: ","")
                                                    mposx2=mposx2.replace(" Days","")
                                                    for mposx in MyContracts[pos]['MyRequests']:
                                                        mpos+=1
                                                        if "Requesting time extension: " in mposx:
                                                            mposx=mposx.replace("Requesting time extension: ","")
                                                            mposx=mposx.replace(" Days","")
                                                            if int(mposx)==int(mposx2):#It matches. they accepted
                                                                MyContracts[pos]['Process']='Time extended'
                                                                MyContracts[pos]['time']=ConvertDate(ConvertDate(MyContracts[pos]['time'],1)+ datetime.timedelta(hours=(int(mposx)*24)),0)
                                                                MyContracts[pos]['blocks']=MyContracts[pos]['blocks']+(int(mposx)*144)
                                                                WinContracts.hide()
                                                                MyContracts[pos]['MyRequests'].pop(mpos)
                                                                WinContracts.Requests.addItem("Time extended: " + str(mposx) + " Days")
                                                                MyContracts[pos]['MyMessages'].append({'message': "Time extended: " + str(mposx) + " Days"})
                                                                MyContracts[pos]['MyRequests'].append("Time extended: " + str(mposx) + " Days")
                                                                Notification(1, "Time Extended!")
                                                                break
                                                except Exception, e:
                                                    pass
                                            MyContracts[pos]['Read'].append(body['MessageID'])
                                            if 'uid' in message:
                                                if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                                    AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])
                            continue#Ok  we did what we wanted we are not looking to sign something again.
                    if body['Process']!=contract['Process']:#Something new but is it the next step?
                        ivereadthis=0
                        if body['Process']=='Broadcast' and message['toAddress']==contract['MyBMAddress'][:16].lower() and contract['Process']=='Making Transactions PT2':
                            if contract['lock']=='0':
                                MyContracts[pos]['Process']="Broadcast"
                                MyContracts[pos]['status'] = "Broadcast"
                                try:
                                    MyContracts[pos]['tx1raw']=body['tx1raw']#This is all we need now we can lock it now
                                except:
                                    pass
                                MyContracts[pos]['lock']="1"
                                ivereadthis=1
                        if contract['Process']=='Making Transactions' or 'Market Offer' in contract['Process'] or 'MCount0' in contract['Process']:
                            if message['toAddress']==contract['MyBMAddress'][:16].lower() and body['Process'] == 'CancelTX':
                                MyContracts[pos]['lock']='1'
                                MyContracts[pos]['Process']='Cancel'
                                if 'autocancel' in AdvanceArray:
                                    DeleteOrder(MyContracts[pos]['ordernumber'])
                                    DeleteContract(MyContracts[pos])
                                    if 'uid' in message:
                                        if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                            AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])
                                    break
                                ivereadthis=1
                        if body['Process']=='Making Transactions PT2' and message['toAddress']==contract['MyBMAddress'][:16].lower() and contract['Process']=='Making Transactions':#Ok its the next step and from here there is no re-sending mail
                            if contract['lock']=='0':
                                MyContracts[pos]['lock']="1"
                                Reply={}#If anything fails we mark it in the deal with the reason and recommended action
                                Reply['Process']='Making Transactions PT2'
                                Reply['Command']='Send'
                                Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
                                Reply['TheirBMAddress']=contract['TheirBMAddress']
                                Reply['ordernumber']=contract['ordernumber']
                                MyContracts[pos]['tx5theirsig']=body['tx5theirsig']#Ok this is very exciting we are almost ready to broadcast... we will need to check these sigs
                                MyContracts[pos]['tx4theirsig']=body['tx4theirsig']
                                MyContracts[pos]['Process']="Broadcast"
                                MyContracts[pos]['status'] = "Broadcast"
                                #Lets make those last couple transactions and check for broadcast... we can broadcast later in the download loop in case of timeouts or loss of internet connection
                                if "I am" in contract['instantwhopays'] and contract['instantamount']!=0:
                                    MyContracts[pos]['Broadcast']="me"#Yeah this should have been figured out earlier and put in the original variable this can all be condensed later
                                    MyContracts[pos]['tx2raw']=body['tx2raw']
                                else:
                                    if contract['instantamount'] !=0:#Ok so there was an instant
                                        Reply['tx1raw']=MyContracts[pos]['tx1raw']
                                        MyContracts[pos]['Broadcast']="them"
                                    else:
                                        if MyContracts[pos]['mytotal']>MyContracts[pos]['theirtotal']:#Ok we pay more so we broadcast
                                            MyContracts[pos]['Broadcast']="me"
                                            MyContracts[pos]['tx2raw']=body['tx2raw']
                                        else:
                                            #What if they are exactly equal?
                                            if MyContracts[pos]['mytotal']==MyContracts[pos]['theirtotal']:
                                                if "them" in MyContracts[pos]['firstsign']:
                                                    Reply['tx1raw']=MyContracts[pos]['tx1raw']
                                                    MyContracts[pos]['Broadcast']="them"
                                                else:
                                                    MyContracts[pos]['Broadcast']="me"
                                                    MyContracts[pos]['tx2raw']=body['tx2raw']
                                            else:
                                                Reply['tx1raw']=MyContracts[pos]['tx1raw']
                                                MyContracts[pos]['Broadcast']="them"
                                #Either way, we need to make our raws and check signatures.
                                if contract['instantamount']!=0:
                                    rawtx,rspns=broadcast_tx_to_network(MyContracts[pos]['tx5theirsig'],MyContracts[pos]['tx5mysig'],MyContracts[pos]['instantinputs'],MyContracts[pos]['instantoutputs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30,skipbroadcast=1)
                                    MyContracts[pos]['tx5']=txhash(rawtx)
                                    MyContracts[pos]['tx5raw']=rawtx
                                rawtx,rspns=broadcast_tx_to_network(MyContracts[pos]['tx4theirsig'],MyContracts[pos]['tx4mysig'],MyContracts[pos]['timeinputs'],MyContracts[pos]['timeoutputs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30,skipbroadcast=1)
                                MyContracts[pos]['tx4']=txhash(rawtx)
                                MyContracts[pos]['tx4raw']=rawtx
                                Reply['Process']="Broadcast"#We dont report success. Actions are louder than words. Instead both parties are trustless and check escrow for confirmation we may be passing here
                                BitQueue.append(Reply)
                                SaveQueue()
                                ivereadthis=1
                        if body['Process']=='Making Transactions' and message['toAddress']==contract['MyBMAddress'][:16].lower() and 'Accept' in contract['Process']:#Ok its the next step and from here there is no re-sending mail
                            if contract['lock']=='0':
                                MyContracts[pos]['lock']="1"
                                if 'Market Data' in body:
                                    if 'reply' in body['Market Data']:
                                        testcon=FilterContract(body,MyContracts[pos],1)#bring in the new info
                                        if testcon!=False:
                                            MyContracts[pos]=FilterContract(body,MyContracts[pos],1)
                                Reply={}#If anything fails we mark it in the deal with the reason and recommended action
                                Reply['Process']='Making Transactions PT2'
                                Reply['Command']='Send'
                                Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
                                Reply['TheirBMAddress']=contract['TheirBMAddress']
                                Reply['ordernumber']=contract['ordernumber']
                                #As crazy as this is going to seem, this party needs to construct all of the same transactions as in the previous step not only to see if they match but so in case they have to broadcast they have everything
                                #They will send the signatures back for the response on the bomb. They can all be checked or not (fund and forget), One side may pass if they are not the ones broadcasting. If broadcasting fails or times
                                #out, the party spends the funds destined for temporary or refunds the temporary. The console will inform them if it clears to try again if declined etc.
                                MyContracts[pos]['tx5theirsig']=body['tx5theirsig']
                                MyContracts[pos]['tx4theirsig']=body['tx4theirsig']
                                MyContracts[pos]['tx3theirsig']=body['tx3theirsig']
                                MyContracts[pos]['tx3raw']=body['tx3raw']
                                MyContracts[pos]['tx3']=body['tx3']#its always nice to know out of curiousity what result they got
                                MyContracts[pos]['theirpublic2']=body['theirpublic2']#We need it to get the mscripts for their temporary
                                msss,scrip=create_multisig_from_publics(MyContracts[pos]['theirpublic'],body['theirpublic2'])#Add to watch list
                                #Need to build escrow on our own
                                #We make the temporary funding again So we have our own copy of the full transaction(I really should save the inputs but I'm getting overwhelmed with variables)
                                fundinputs=[]
                                fundoutputs=[]
                                theirs={}
                                mine={}
                                theirtotal=0
                                mytotal=0#We may have actually already saved this so may want to eventually clean the code of redundancy
                                theirtotal+=contract['theirdeposit']
                                mytotal+=contract['mydeposit']
                                if "I pay this" in contract['whopays']:
                                    mytotal+=contract['amount']
                                else:
                                    theirtotal+=contract['amount']
                                if "I am" in contract['instantwhopays'] and contract['instantamount'] !=0:
                                    mytotal+=contract['instantamount']
                                    MyContracts[pos]['Broadcast']="me"
                                    MyContracts[pos]['Process']="Making Transactions PT2"#We broadcast so we dont send the raw
                                else:
                                    theirtotal+=contract['instantamount']
                                    if contract['instantamount'] !=0:#Ok so there was an instant
                                        MyContracts[pos]['Broadcast']="them"
                                        MyContracts[pos]['Process']="Broadcast"
                                        MyContracts[pos]['status'] = "Broadcast"
                                        Reply['tx2raw']=MyContracts[pos]['tx2raw']
                                    else:
                                        if mytotal>theirtotal:#Ok we pay more so we broadcast
                                            MyContracts[pos]['Broadcast']="me"
                                            MyContracts[pos]['Process']="Making Transactions PT2"
                                        else:
                                            if MyContracts[pos]['mytotal']==MyContracts[pos]['theirtotal']:
                                                if "them" in MyContracts[pos]['firstsign']:
                                                    MyContracts[pos]['Broadcast']="them"
                                                    MyContracts[pos]['Process']="Broadcast"
                                                    MyContracts[pos]['status'] = "Broadcast"
                                                    Reply['tx2raw']=MyContracts[pos]['tx2raw']
                                                else:
                                                    MyContracts[pos]['Broadcast']="me"
                                                    MyContracts[pos]['Process']="Making Transactions PT2"
                                            else:
                                                MyContracts[pos]['Broadcast']="them"
                                                MyContracts[pos]['Process']="Broadcast"
                                                MyContracts[pos]['status'] = "Broadcast"
                                                Reply['tx2raw']=MyContracts[pos]['tx2raw']
                                #Ok lets calculate fees it should be even
                                f=0
                                if contract['instantamount'] !=0:#We will have to split a fee here
                                    f+=.5
                                f+=1#For completion or cancellation request and funding escrow both of which are split (doubles as temporary account refund)
                                if mytotal!=0:
                                    if theirtotal==0:
                                        f+=1
                                    mytotal+=int(contract['fee']*f)#They spent one funding temporary
                                else:
                                    f+=1
                                if theirtotal!=0:
                                    theirtotal+=int(contract['fee']*f)#They spent one funding temporary
                                theirs['output']=unicode(str(contract['tx1'])+":0")#If they put anything else in the temporary the funding will not work
                                theirs['value']=theirtotal
                                theirs['address']=contract['theirtemp']
                                mine['output']=unicode(str(contract['tx2'])+":0")
                                mine['value']=mytotal
                                mine['address']=contract['mytemp']#Redundant code is redundant... this will all be cleaner at some point
                                if mytotal!=0:
                                    fundinputs.append(mine)
                                if theirtotal!=0:
                                    fundinputs.append(theirs)
                                if contract['instantamount'] !=0:#If there is a refund, we do not want to depend on its transaction id for expirations so we split it
                                    escrowout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee']),'address':str(MyContracts[pos]['escrow'])}#two fees deducted so one can be added
                                    instantout={'value':int(contract['fee']+contract['instantamount']),'address':str(MyContracts[pos]['escrow'])}#Now if they screw up the id, they will have to get our permission to sign again
                                    fundoutputs.append(escrowout)
                                    fundoutputs.append(instantout)
                                else:
                                    escrowout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee']),'address':str(MyContracts[pos]['escrow'])}#its all one input
                                    fundoutputs.append(escrowout)
                                #We already had the sigs
                                if mytotal!=0:
                                    tx3,result=broadcast_contract_to_network(fundinputs,fundoutputs,MyContracts[pos]['tx3mysig'],MyContracts[pos]['mypublic'],MyContracts[pos]['mypublic2'],MyContracts[pos]['theirpublic'],MyContracts[pos]['theirpublic2'],MyContracts[pos]['tx3theirsig'],MyContracts[pos]['timestamp'], 1)
                                    MyContracts[pos]['tx3']=txhash(tx3)#now we have it we could have compared it too...
                                    MyContracts[pos]['tx3raw']=tx3

                                #Lets make the TimeoutTX and the refund and sign it. Remember we "sign first" because our public key is used first... but everything should look the same here.
                                if contract['instantamount'] !=0:#Ok we can check  vout 1 and make a tx for it
                                    instantinputs=[]
                                    instantoutputs=[]
                                    refundins={}
                                    refundout={}
                                    refundins['output']=unicode(MyContracts[pos]['tx3']+":1")
                                    refundins['value']=int(contract['fee']+contract['instantamount'])
                                    refundins['address']=contract['escrow']
                                    if "I am" in contract['instantwhopays']:
                                        tmpout={'value':int(contract['instantamount']), 'address':multisig}
                                    else:
                                        tmpout={'value':int(contract['instantamount']), 'address':MyContracts[pos]['theiraddress']}
                                    instantinputs.append(refundins)
                                    instantoutputs.append(tmpout)
                                    sigs2,result=create_sig_for_tx(instantinputs, instantoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30)#These were made earlier
                                    if result == False:
                                        MyContracts[pos]['Process']="Failed: "
                                        MyContracts[pos]['Reason']="TX5 Signature failed"
                                        return
                                    #Ok lets get the raw
                                    MyContracts[pos]['tx5mysig']=sigs2
                                    rawtx,rspns=broadcast_tx_to_network(MyContracts[pos]['tx5mysig'],MyContracts[pos]['tx5theirsig'],instantinputs,instantoutputs, MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                    MyContracts[pos]['tx5']=txhash(rawtx)
                                    MyContracts[pos]['tx5raw']=rawtx
                                    MyContracts[pos]['instantinputs']=instantinputs#Just keeping track. Not sure we will use this
                                    MyContracts[pos]['instantoutputs']=instantoutputs
                                    Reply['tx5theirsig']=sigs2
                                else:
                                    MyContracts[pos]['tx5mysig']="0"
                                    Reply['tx5theirsig']="0"
                                #TimeoutTX
                                timeinputs=[]
                                timeoutputs=[]
                                timeins={}
                                timeout={}
                                timeins['output']=unicode(MyContracts[pos]['tx3']+":0")#Its always vout 0
                                timeins['value']=int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee'])#The question of wether or not to give to miners is a good one. Since this works for POS it means we send to Bitcoineater!!
                                timeins['address']=contract['escrow']
                                if BitHaloClient==False:
                                    timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3"} #bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3 is the base58 hash of Blackcoineateradios1 for Bitcoin you can also use 1BitcoinEaterAddressDontSendf59kuE
                                else:
                                    timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"1BitcoinEaterAddressDontSendf59kuE"}
                                timeinputs.append(timeins)
                                timeoutputs.append(timeout)
                                sigs3,result=create_sig_for_tx(timeinputs, timeoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30)#These were made earlier
                                if result == False:
                                    MyContracts[pos]['Process']="Failed: "
                                    MyContracts[pos]['Reason']="TX4 Signature failed"
                                    return
                                #Blackcoin stuff... we can add the multisigs
                                if BitHaloClient==False:
                                    WatchlistQueue.append("0"+MyContracts[pos]['theirtemp'])
                                    WatchlistQueue.append("0"+MyContracts[pos]['mytemp'])
                                    WatchlistQueue.append("0"+MyContracts[pos]['escrow'])
                                #Ok lets get the raw
                                MyContracts[pos]['tx4mysig']=sigs3
                                rawtx,rspns=broadcast_tx_to_network(MyContracts[pos]['tx4mysig'],MyContracts[pos]['tx4theirsig'],timeinputs,timeoutputs, MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                MyContracts[pos]['tx4']=txhash(rawtx)
                                MyContracts[pos]['tx4raw']=rawtx
                                MyContracts[pos]['timeinputs']=timeinputs#Need it if destroyed
                                MyContracts[pos]['timeoutputs']=timeoutputs
                                Reply['tx4theirsig']=sigs3
                                MyContracts[pos]['lock']="0"
                                #If we broadcast we can lock it
                                if MyContracts[pos]['Process']=="Broadcast":
                                    if MyContracts[pos]['Broadcast']=="them":
                                        MyContracts[pos]['lock']="1"
                                BitQueue.append(Reply)#That was so sexy
                                SaveQueue()
                                ivereadthis=1
                        if body['Process']=='Accept' and message['toAddress']==contract['MyBMAddress'][:16].lower():#We can end up sending and accepting our own offer on the same computer... we need to make sure we were not the sender
                            if 'Counter' in contract['Process'] or contract['Process']=="Offer":
                                if contract['lock']=='0':#Ok we were expecting this...otherwise it may be them wanting to accept an old offer
                                    try:
                                        MyContracts[pos]['lock']="1"#If anything fails communication is effectively severed
                                        if 'Market Data' in body:
                                            if 'reply' in body['Market Data']:
                                                testcon=FilterContract(body,MyContracts[pos],1)#bring in the new info
                                                if testcon!=False:
                                                    MyContracts[pos]=FilterContract(body,MyContracts[pos],1)
                                        #We can assume that whatever we had was legitimate because from here there is nothing left to negotiate just sign. We will need more functions for data integrity I think
                                        Reply={}#If anything fails we mark it in the deal with the reason and recommended action
                                        Reply['Process']='Making Transactions'
                                        Reply['Command']='Send'
                                        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
                                        Reply['TheirBMAddress']=contract['TheirBMAddress']
                                        Reply['ordernumber']=contract['ordernumber']
                                        MyContracts[pos]['theirversion']=body['theirversion']
                                        MyContracts[pos]['theiraddress']=body['theiraddress']
                                        MyContracts[pos]['tx2']=body['tx2']
                                        MyContracts[pos]['theirpublic']=body['theirpublic']
                                        MyContracts[pos]['theirpublic2']=body['theirpublic2']#We need it to get the mscripts
                                        MyContracts[pos]['theirtemp']=body['theirtemp']
                                        MyContracts[pos]['timestamp']=body['timestamp']
                                        #Need to build escrow on our own
                                        msss,scrip=create_multisig_from_publics(body['theirpublic'],MyContracts[pos]['theirpublic2'])#Add to watch list
                                        body['escrow'],scrip=create_multisig_from_publics(body['theirpublic'],MyContracts[pos]['mypublic'])
                                        MyContracts[pos]['escrow']=body['escrow']
                                        MyContracts[pos]['firstsign']="them"
                                        MyContracts[pos]['tx3theirsig']=body['tx3theirsig']
                                        if 'tx3' in body:
                                            if MyContracts[pos]['mydeposit']==0:
                                                MyContracts[pos]['tx3']=body['tx3']

                                        #Blackcoin stuff... we can add the multisigs
                                        if BitHaloClient==False:
                                            WatchlistQueue.append("0"+MyContracts[pos]['theirtemp'])
                                            WatchlistQueue.append("0"+MyContracts[pos]['mytemp'])
                                            WatchlistQueue.append("0"+MyContracts[pos]['escrow'])
                                        #We make the temporary funding on our own. So if they sign something else it won't fund
                                        fundinputs=[]
                                        fundoutputs=[]
                                        theirs={}
                                        mine={}
                                        theirtotal=0
                                        mytotal=0
                                        theirtotal+=contract['theirdeposit']
                                        mytotal+=contract['mydeposit']
                                        if "I pay this" in contract['whopays']:
                                            mytotal+=contract['amount']
                                        else:
                                            theirtotal+=contract['amount']
                                        if "I am" in contract['instantwhopays']:
                                            mytotal+=contract['instantamount']
                                        else:
                                            theirtotal+=contract['instantamount']
                                        #Ok lets calculate fees it should be even
                                        f=0
                                        if contract['instantamount'] !=0:#We will have to split a fee here
                                            f+=.5
                                        f+=1#For completion or cancellation request and funding escrow both of which are split (doubles as temporary account refund)
                                        if mytotal!=0:
                                            if theirtotal==0:
                                                f+=1
                                            mytotal+=int(contract['fee']*f)#They spent one funding temporary
                                        else:
                                            f+=1
                                        if theirtotal!=0:
                                            theirtotal+=int(contract['fee']*f)#They spent one funding temporary
                                        theirs['output']=unicode(str(body['tx2'])+":0")#If they put anything else in the temporary the funding will not work
                                        theirs['value']=theirtotal
                                        theirs['address']=body['theirtemp']
                                        mine['output']=unicode(str(contract['tx1'])+":0")
                                        mine['value']=mytotal
                                        mine['address']=contract['mytemp']
                                        if theirtotal!=0:
                                            fundinputs.append(theirs)
                                        if mytotal!=0:
                                            fundinputs.append(mine)
                                        if contract['instantamount'] !=0:#If there is a refund, we do not want to depend on its transaction id for expirations so we split it
                                            escrowout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee']),'address':str(body['escrow'])}#two fees deducted so one can be added
                                            instantout={'value':int(contract['fee']+contract['instantamount']),'address':str(body['escrow'])}#Now if they screw up the id, they will have to get our permission to sign again
                                            fundoutputs.append(escrowout)
                                            fundoutputs.append(instantout)
                                        else:
                                            escrowout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee']),'address':str(body['escrow'])}#its all one input
                                            fundoutputs.append(escrowout)
                                        #Here we make the tx and sign manually
                                        if BitHaloClient==True:
                                            tmptx = pybit.transaction.mktx(fundinputs,fundoutputs)
                                        else:
                                            tmptx = mktx(MyContracts[pos]['timestamp'], fundinputs,fundoutputs)
                                        multi,mscrip=create_multisig_from_publics(MyContracts[pos]['mypublic'],MyContracts[pos]['mypublic2'])
                                        sigs=[]
                                        try:
                                            if mytotal!=0:
                                                ps1=0
                                                if theirtotal!=0:
                                                    ps1+=1
                                                if BitHaloClient==True:
                                                    sigg=pybit.transaction.multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate'])
                                                    sigs.append(sigg)
                                                    sigg=pybit.transaction.multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate2'])
                                                    sigs.append(sigg)
                                                else:
                                                    sigg=multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate'])
                                                    sigs.append(sigg)
                                                    sigg=multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate2'])
                                                    sigs.append(sigg)
                                        except:
                                            MyContracts[pos]['Process']="Failed: "
                                            MyContracts[pos]['Reason']="TX3 Signature failed"
                                            if 'uid' in message:
                                                if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                                    AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])                                            
                                            return
                                        Reply['tx3theirsig']=sigs
                                        #May need to go over all this a few times.contract_to_network(ins,outs,sigs,pub1,pub2, pub3, pub4,sigs2, skipbroadcast=0)
                                        if mytotal!=0:
                                            tx3,result=broadcast_contract_to_network(fundinputs,fundoutputs,body['tx3theirsig'],MyContracts[pos]['theirpublic'],MyContracts[pos]['theirpublic2'],MyContracts[pos]['mypublic'],MyContracts[pos]['mypublic2'],sigs, MyContracts[pos]['timestamp'],1)
                                            MyContracts[pos]['tx3']=txhash(tx3)#Counter party does not need tx3 raw unless he is meant to broadcast...
                                            MyContracts[pos]['tx3raw']=tx3
                                        else:
                                            MyContracts[pos]['tx3raw']=""
                                        MyContracts[pos]['tx3mysig']=sigs
                                        #Lets make the TimeoutTX and the refund and sign it. Remember they "sign first" because their public key is used first... but everything should look the same here.
                                        if contract['instantamount'] !=0:#Ok we can check  vout 1 and make a tx for it
                                            instantinputs=[]
                                            instantoutputs=[]
                                            refundins={}
                                            refundout={}
                                            refundins['output']=unicode(MyContracts[pos]['tx3']+":1")#If they put anything else in the temporary the funding will not work... both parties sign each position with a sig
                                            refundins['value']=int(contract['fee']+contract['instantamount'])
                                            refundins['address']=body['escrow']
                                            if "I am" in contract['instantwhopays']:
                                                tmpout={'value':int(contract['instantamount']), 'address':multisig}
                                            else:
                                                tmpout={'value':int(contract['instantamount']), 'address':MyContracts[pos]['theiraddress']}#Who pays this?
                                            instantinputs.append(refundins)
                                            instantoutputs.append(tmpout)
                                            sigs2,result=create_sig_for_tx(instantinputs, instantoutputs, MyContracts[pos]['myprivate'], body['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30)#These were made earlier
                                            if result == False:
                                                MyContracts[pos]['Process']="Failed: "
                                                MyContracts[pos]['Reason']="TX5 Signature failed"
                                                if 'uid' in message:
                                                    if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                                        AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])                                                
                                                return
                                            MyContracts[pos]['instantinputs']=instantinputs#Need it for next step
                                            MyContracts[pos]['instantoutputs']=instantoutputs
                                            MyContracts[pos]['tx5mysig']=sigs2
                                            Reply['tx5theirsig']=sigs2
                                        else:
                                            MyContracts[pos]['tx5mysig']="0"
                                            Reply['tx5theirsig']="0"
                                        #TimeoutTX
                                        timeinputs=[]
                                        timeoutputs=[]
                                        timeins={}
                                        timeout={}
                                        timeins['output']=unicode(MyContracts[pos]['tx3']+":0")#Its always vout 0
                                        timeins['value']=int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee'])#The question of wether or not to give to miners is a good one. Since this works for POS it means we send to Bitcoineater!!
                                        timeins['address']=body['escrow']
                                        if BitHaloClient==False:
                                            timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3"} #bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3 is the base58 hash of Blackcoineateradios1 for Bitcoin you can also use 1BitcoinEaterAddressDontSendf59kuE
                                        else:
                                            timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"1BitcoinEaterAddressDontSendf59kuE"}
                                        timeinputs.append(timeins)
                                        timeoutputs.append(timeout)
                                        sigs3,result=create_sig_for_tx(timeinputs, timeoutputs, MyContracts[pos]['myprivate'], body['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30)#These were made earlier
                                        if result == False:
                                            MyContracts[pos]['Process']="Failed: "
                                            MyContracts[pos]['Reason']="TX4 Signature failed"
                                            if 'uid' in message:
                                                if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                                    AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])                                            
                                            return
                                        MyContracts[pos]['timeinputs']=timeinputs#Need it for next step
                                        MyContracts[pos]['timeoutputs']=timeoutputs
                                        MyContracts[pos]['tx4mysig']=sigs3
                                        Reply['tx4theirsig']=sigs3
                                        Reply['tx3theirsig']=sigs#This way we can also confirm everything...check sigs etc
                                        Reply['tx3']=MyContracts[pos]['tx3']#Counter party does not need tx3 raw unless he is meant to broadcast... but why not give it out?
                                        Reply['tx3raw']=MyContracts[pos]['tx3raw']
                                        if theirtotal==0:
                                            Reply['tx3raw']=""
                                            Reply['tx3theirsig']=[]
                                        Reply['theirpublic2']=MyContracts[pos]['mypublic2']
                                        MyContracts[pos]['mytotal']=mytotal#Lets start keeping track... it makes life easier
                                        MyContracts[pos]['theirtotal']=theirtotal
                                        MyContracts[pos]['lock']="0"
                                        MyContracts[pos]['Process']="Making Transactions"#That was so sexy
                                        BitQueue.append(Reply)
                                        SaveQueue()
                                        ivereadthis=1
                                    except Exception, e:
                                        ivereadthis=1
                                        print "Exception accepting offer!"
                        if 'Counter' in body['Process']:#A counter. But is it new? Also we need to make sure it is their turn so they dont try to spam counters
                            if contract['lock']=='0':#ok it was their turn so we were expecting something
                                isvalid=CheckValidity(body)
                                if isvalid==1:
                                    if 'Counter' in contract['Process']:
                                        x=int(contract['Process'].replace('Counter', ""))
                                        y=int(body['Process'].replace('Counter', ""))
                                        if y==(x+1):#Ok it says its the next one otherwise we would not be unable to distinguish what is new
                                            body['TheirBMAddress']=contract['TheirBMAddress']
                                            body['MyBMAddress']=contract['MyBMAddress']
                                            if CurrentBlock != 0:
                                                body['currentblock']=CurrentBlock
                                            MyContracts[pos]=body #Ok so now we know what it is
                                            MyContracts[pos]['lock']='1'#Our turn
                                            #We need to clear out our old reserved inputs
                                            DeleteOrder(body['ordernumber'])
                                            updatesomething=1
                                            Notification(1, "New Counter-Offer!")
                                            ivereadthis=1
                                    if contract['Process']=='Offer' and body['Process']=='Counter0':#Everytime we treat these as an entirely new offer
                                        if CurrentBlock != 0:
                                            body['currentblock']=CurrentBlock
                                        body['TheirBMAddress']=contract['TheirBMAddress']
                                        body['MyBMAddress']=contract['MyBMAddress']
                                        MyContracts[pos]=body #Ok so now we know what it is
                                        MyContracts[pos]['lock']='1'#Our turn
                                        #We need to clear out our old reserved inputs
                                        DeleteOrder(body['ordernumber'])
                                        updatesomething=1
                                        Notification(1, "New Counter-Offer!")
                                        ivereadthis=1
                                else:
                                    ivereadthis=1
                        if contract['Process']=='Encrypted Message' and body['Process']=='Handshake':#Ok so now its time to send them the contract
                            if CurrentBlock != 0:#This only works if connected to the internet... but then again we get 10 days for each step in this version of BlackHalo
                                MyContracts[pos]['currentblock']=CurrentBlock #Since we got action on this, lets push our expiration up another 10 days
                            contract['TheirBMAddress']=body['MyBMAddress']
                            MyContracts[pos]['TheirBMAddress']=body['MyBMAddress']
                            if 'Market Data' in contract:#Its a template which was sent privately
                                MyContracts[pos]['Process']='Private Offer'
                                Step1(contract, "skip")#Skip verification of the public key since we aren't saving the private key to keep it secure
                                MyContracts[pos]['Process']='Market Order'
                            else:
                                MyContracts[pos]['Process']='Private Offer'
                                Step1(contract)#Ok send them the contract now they should have everything... if the bitmessage address is inaccurate we can send again.
                                MyContracts[pos]['Process']='Offer'#Ok lets go to the next step
                            ivereadthis=1
                        if contract['Process']=='Handshake' and body['Process']=='Private Offer':#Ok they shook our hand and sent the offer. We dont need lock here I think because it would have to be "new"
                            isvalid=CheckValidity(body)
                            if isvalid==1:
                                if "@" in body['MyBMAddress']:
                                    BitAddy=MyEmail
                                else:
                                    BitAddy=BitAddr
                                body['TheirBMAddress']=body['MyBMAddress']
                                body['MyBMAddress']=BitAddy
                                if CurrentBlock != 0:
                                    body['currentblock']=CurrentBlock
                                if body['Details']['pastebin']!="" and body['Details']['image']=="":
                                    if body['Details']['pastebin'] not in checkpastebin:
                                        checkpastebin[body['Details']['pastebin']]=""
                                        continue
                                    else:
                                        if checkpastebin[body['Details']['pastebin']]=="":
                                            continue
                                        else:
                                            if checkpastebin[body['Details']['pastebin']]=="CONTINUE":#In case we want to check more than once
                                                continue
                                            if checkpastebin[body['Details']['pastebin']]=="FALSE":
                                                checkpastebin.pop(body['Details']['pastebin'])
                                                body['Details']['pastebin']=""
                                                body['Details']['image']=""
                                            else:
                                                body['Details']['image']=checkpastebin[body['Details']['pastebin']]
                                                checkpastebin.pop(body['Details']['pastebin'])
                                #Possible delete contract and put the body in the markets list and mark private as long as we dont filter private
                                #But only do that here if we see Market Data in the body... update checkvalidity
                                if 'Market Data' in body:
                                    MyContracts.pop(pos)
                                    body['Market Data']['Private']=2
                                    body['Process']="Market Order"
                                    Markets['Orders'].append(body)
                                    Reputation(body)
                                    updatesomething=1
                                    Notification(1, "New Pending Offer!")
                                    if 'uid' in message:
                                        if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                            AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])                                    
                                    break
                                else:
                                    MyContracts[pos]=body #Ok so now we know what it is
                                    MyContracts[pos]['Process']='Received'
                                    MyContracts[pos]['lock']='1'#Our turn
                                    updatesomething=1
                                    Notification(1, "New Pending Offer!")
                                    ivereadthis=1
                            else:
                                ivereadthis=1
                        if ivereadthis==1:
                            if 'uid' in message:
                                if str(message['uid'])+"#"+body['ordernumber'] not in AdvanceArray[MyEmail]['uids']:
                                    AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+body['ordernumber'])                            
            if "ENCRYPTED:" in str(body):#It might not be for us
                NotForMe.append(txhash(str(message)))#Lets not keep trying to decrypt it if we didn't find it in our contracts
                continue
            if body['Process']=='Offer':#A new offer! Great... but are we blocking spam? And for my testing purposes I need to see if it matches our address and is new also need to make sure it is not already deleted
                #This is the original backwards compatible offer system. There are no templates supported here and it only gets here when filling out the form manaully.
                skipthis=0
                if window.FilterCustom.isChecked():#Maybe someone only wants to deal with market orders
                    skipthis=1
                if window.DisableSpamFilter.isChecked() and skipthis==0:
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    isvalid=CheckValidity(body)
                    if isvalid==0:
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    for populate in DontRepopulate:
                        if populate==body['ordernumber']:#We must have already deleted it so skip it
                            new=0
                    for contract in MyContracts:
                        if body['ordernumber']==contract['ordernumber']:#ok well we already had it or sent it
                            new=0
                    if CoinSelect['HaloName'] not in body['version']:
                        new=0
                    if new==1 and isvalid==1:
                        recv=0
                        if window.EnableEmail.isChecked():
                            GetEmailGlobals()
                            if message['toAddress']==MyEmail[:16].lower():#A match!
                                recv=1
                                Notification(1, "New Pending Offer!")
                                body['TheirBMAddress']=body['MyBMAddress']
                                body['MyBMAddress']=MyEmail
                        if window.EnableBitmessage.isChecked():
                            if message['toAddress']==BitAddr[:16].lower():#A match!
                                recv=1
                                Notification(1, "New Pending Offer!")
                                body['TheirBMAddress']=body['MyBMAddress']
                                body['MyBMAddress']=BitAddr
                        if recv==1:
                            if body['Details']['pastebin']!="" and body['Details']['image']=="":
                                if body['Details']['pastebin'] not in checkpastebin:
                                    checkpastebin[body['Details']['pastebin']]=""
                                    continue
                                else:
                                    if checkpastebin[body['Details']['pastebin']]=="":
                                        continue
                                    else:
                                        if checkpastebin[body['Details']['pastebin']]=="CONTINUE":#In case we want to check more than once
                                            continue
                                        if checkpastebin[body['Details']['pastebin']]=="FALSE":
                                            checkpastebin.pop(body['Details']['pastebin'])
                                            body['Details']['pastebin']=""
                                            body['Details']['image']=""
                                        else:
                                            body['Details']['image']=checkpastebin[body['Details']['pastebin']]
                                            checkpastebin.pop(body['Details']['pastebin'])
                            body['Process']='Received'
                            body['lock']='1'#Our turn
                            if CurrentBlock != 0:
                                body['currentblock']=CurrentBlock
                            MyContracts.append(body)#Ok lets add it
                            updatesomething=1
            try:
                if 'MCount' in body['Process']:#These can be counters or bids
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    if CheckValidity(body,1)==0:
                        print "Verification error"
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                        continue
                    if CoinSelect['HaloName'] not in body['theirversion']:
                        continue
                    Reputation(body)
                    body['oldordernumber']=body['Market Data']['oldordernumber']
                    if body['oldordernumber'] in body['ordernumber']:
                        continue
                    pss=-1
                    if body['MyBMAddress']==BitAddr or MyEmail==body['MyBMAddress']:#We are looking at our own counter.
                        continue
                    for c in MyContracts:
                        pss+=1
                        if c['Process']!="Market Order" and "MCount" not in c['Process']:
                            continue
                        if body['Process']=="MCount0":
                            if c['ordernumber']==body['oldordernumber']:
                                if 'Market Data' in c:
                                    if c['Market Data']['allowcounters']==0:
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            #We require bids because of the rapid changes in liquidity
                                            pass
                                        else:
                                            continue
                                fnd=0
                                for d in MyContracts:
                                    if d['ordernumber']==body['ordernumber']:#They sent it twice somehow, ignore
                                        fnd=1
                                if fnd==0:
                                    #Treat this like a new order we can place under our main order
                                    if body['Details']['pastebin']!="":
                                        if body['Details']['pastebin']==c['Details']['pastebin']:
                                            body['Details']['image']=c['Details']['image']
                                        else:
                                            if body['Details']['pastebin'] not in checkpastebin:
                                                checkpastebin[body['Details']['pastebin']]=""
                                                continue
                                            else:
                                                if checkpastebin[body['Details']['pastebin']]=="":
                                                    continue
                                                else:
                                                    if checkpastebin[body['Details']['pastebin']]=="CONTINUE":#In case we want to check more than once
                                                        continue
                                                    if checkpastebin[body['Details']['pastebin']]=="FALSE":
                                                        checkpastebin.pop(body['Details']['pastebin'])
                                                        body['Details']['pastebin']=""
                                                        body['Details']['image']=""
                                                    else:
                                                        body['Details']['image']=checkpastebin[body['Details']['pastebin']]
                                                        checkpastebin.pop(body['Details']['pastebin'])
                                    addy=body['TheirBMAddress']
                                    if "*"+addy[:10] in Markets['Banlist']:#The market might be blacklisted
                                        pass
                                    else:
                                        body['TheirBMAddress']=body['MyBMAddress']
                                        body['MyBMAddress']=addy
                                        body['lock']='1'
                                        newbody=FilterContract(body,c)
                                        if newbody!=False:
                                            MyContracts.append(newbody)
                                            #Autoaccept matching counter-bids/orders?
                                            mch=1
                                            if 'match' in newbody['Market Data']['reply'] and newbody['Market Data']['reply']['match']==0:
                                                mch=0
                                            res=False
                                            if 'autoaccept' in c['Market Data'] and c['Market Data']['autoaccept']==1 and mch==1 and IsUnlocked() and keysconnected=="2":
                                                try:
                                                    res=window.SendMyContract(newbody)
                                                except:
                                                    res=False
                                                    print "Autoaccept Failed"
                                                SilenceUI=0
                                                Templates.reply2={}
                                            if res==True:
                                                Notification(1, "Market Order Accepted!")
                                            else:
                                                if "Coins" in body['Market Data']['Template'] or 'StartingBid' in c['Market Data']:
                                                    Notification(1, "New Reply/Bid on Offer!")
                                                else:
                                                    Notification(1, "New Counter-Offer!")
                                            if 'StartingBid' in c['Market Data']:
                                                CheckAuction(newbody)
                                DontRepopulateThis(message, multisig, body['ordernumber'])
                        if "MCount" in body['Process'] and body['Process']!="MCount0":
                            orgordernumber=body['ordernumber']
                            if "##" in body['ordernumber']:
                                bodyord=body['ordernumber'].replace(body['ordernumber'].split("##")[0],"")
                                bodyord=bodyord.replace("##","")
                            if c['ordernumber'] == bodyord and 'oldordernumber' in c and c['oldordernumber'] != bodyord:
                                if c['lock']=='0':
                                    if 'Market Data' in c:
                                        if c['Market Data']['allowcounters']==0:
                                            continue
                                    if body['Details']['pastebin']!="":
                                        if body['Details']['pastebin']==c['Details']['pastebin']:
                                            body['Details']['image']=c['Details']['image']
                                        else:                                        
                                            if body['Details']['pastebin'] not in checkpastebin:
                                                checkpastebin[body['Details']['pastebin']]=""
                                                continue
                                            else:
                                                if checkpastebin[body['Details']['pastebin']]=="":
                                                    continue
                                                else:
                                                    if checkpastebin[body['Details']['pastebin']]=="CONTINUE":#In case we want to check more than once
                                                        continue
                                                    if checkpastebin[body['Details']['pastebin']]=="FALSE":
                                                        checkpastebin.pop(body['Details']['pastebin'])
                                                        body['Details']['pastebin']=""
                                                        body['Details']['image']=""
                                                    else:
                                                        body['Details']['image']=checkpastebin[body['Details']['pastebin']]
                                                        checkpastebin.pop(body['Details']['pastebin'])
                                    x=int(c['Process'].replace('MCount', ""))
                                    y=int(body['Process'].replace('MCount', ""))
                                    if y==(x+1):#Ok it says its the next one otherwise we would not be unable to distinguish what is new
                                        body['TheirBMAddress']=c['TheirBMAddress']
                                        body['MyBMAddress']=c['MyBMAddress']
                                        if CurrentBlock != 0:
                                            body['currentblock']=CurrentBlock
                                        if "##" in body['ordernumber']:
                                            body['ordernumber']=body['ordernumber'].replace(body['ordernumber'].split("##")[0],"")
                                            body['ordernumber']=body['ordernumber'].replace("##","")
                                        newbody=FilterContract(body,MyContracts[pss])
                                        if newbody!=False:
                                            MyContracts[pss]=newbody #Ok so now we know what it is
                                            MyContracts[pss]['lock']='1'#Our turn
                                            #We need to clear out our old reserved inputs
                                            DeleteOrder(body['ordernumber'])
                                            updatesomething=1
                                            Notification(1, "New Counter-Offer!")
                                    DontRepopulateThis(message, multisig, orgordernumber)
                if body['Process']=='Market Accept':              
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    if VerifyMarketData(body)==False:
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                        continue
                    if CoinSelect['HaloName'] not in body['theirversion']:
                        continue
                    Reputation(body)
                    myps=-1             
                    for c in MyContracts:
                        myps+=1
                        vld=0
                        cnt=0
                        #Either our original offer gets accepted or our counter got accepted
                        if c['ordernumber']==body['oldordernumber'] and c['version']==body['theirversion'] and "MCount" in c['Process']:
                            cnt=1
                            vld=1
                            try:#The rate had to be verified in some contracts, we now know they accepted it
                                MyContracts[myps]['Market Data']['rate']=MyContracts[myps]['Market Data']['reply']['rate']
                                body['Market Data']['reply']['rate']=MyContracts[myps]['Market Data']['rate']
                            except:
                                pass
                        if c['ordernumber']==body['oldordernumber'] and c['version']==body['theirversion'] and c['Process']=="Market Order":
                            vld=1
                        if vld==1:
                            DontRepopulateThis(message, multisig, body['ordernumber'])
                            accorder=json_deep_copy(c,1)
                            accorder['Market Data']['orgpublic']=body['Market Data']['orgpublic']
                            accorder['Market Data']['public']=body['Market Data']['public']
                            accorder['Process']="Market Offer"
                            accorder['MyBMAddress']=body['TheirBMAddress']#We always do this it can change from time to time
                            accorder['TheirBMAddress']=body['MyBMAddress']
                            accorder['ordernumber']=body['ordernumber']
                            if cnt!=1:#If he is replying to a counter, we don't change the old ordernumber
                                accorder['oldordernumber']=body['oldordernumber']
                            accorder['theirversion']=body['theirversion']
                            accorder['theiraddress']=body['theiraddress']
                            accorder['tx2']=body['tx2']
                            accorder['theirpublic']=body['theirpublic']
                            accorder['theirpublic2']=body['theirpublic2']#We need it to get the mscripts
                            accorder['theirtemp']=body['theirtemp']
                            accorder['timestamp']=body['timestamp']
                            #Need to build escrow on our own
                            msss,scrip=create_multisig_from_publics(body['theirpublic'],accorder['theirpublic2'])
                            body['escrow'],scrip=create_multisig_from_publics(body['theirpublic'],accorder['mypublic'])
                            accorder['escrow']=body['escrow']
                            accorder['firstsign']="them"
                            accorder['tx3theirsig']=body['tx3theirsig']
                            if 'tx3' in body:
                                if c['mydeposit']==0:
                                    accorder['tx3']=body['tx3']
                            tempord=FilterContract(body,accorder,0,1)#We want to check certain things, import accepted variables
                            if 'dontclear' in accorder['Market Data'] and c['Process']=="Market Order":#We hold a higher quantity, so no direct acceptance possible(input conflicts on multiple acceptance at once), however we can update the market of the newer quantities
                                tempord=False
                            if tempord==False:
                                print "Reply verification error"
                                float("A")
                            accorder=FilterContract(body,accorder,1)
                            if 'match' in tempord['Market Data']['reply']:#Some templates used to not have bidding criteria for example...  and "Custom" not in c['Market Data']['Template']
                                accorder['Market Data']['reply']['match']=tempord['Market Data']['reply']['match']
                            if 'rate' in tempord['Market Data'] and cnt!=1:#We may have changed it to the accepted price tracked rate
                                accorder['Market Data']['rate']=tempord['Market Data']['rate']
                            if cnt!=1:
                                MyContracts.append(accorder)#Its a new accept matching no counter
                            else:#Make sure we protect the bids matching onorders and change their order numbers
                                ps3=0
                                for o in OnOrders:
                                    if 'ordernumber' in o:
                                        if o['ordernumber']==c['ordernumber']:
                                            OnOrders[ps3]['ordernumber']=accorder['ordernumber']
                                    ps3+=1
                                MyContracts[myps]=accorder
                            if 'autoaccept' in c['Market Data'] and c['Market Data']['autoaccept']==1 or cnt==1:
                                #There are three scenarios, either they accepted the original, we accepted a counter or their counter was accepted
                                #We will also need to draft our replies here, and yet again when AcceptOffer is called on counters
                                Templates.reply2={}#We will send them whatever is needed
                                if cnt==0 and 'selected' in body['Market Data']['reply'] and "Sell Coins" in c['Market Data']['Template']:#This happens on sell coins reply to original order
                                    Templates.reply2['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
                                    try:
                                        fnd=0
                                        for cont in MyContracts:
                                            if 'oldordernumber' in body:
                                                if cont['ordernumber']==body['oldordernumber']:
                                                    fnd=1
                                                    break
                                        if fnd==1:
                                            Templates.reply2['Profiles'][body['Market Data']['reply']['selected']].append(cont['Market Data']['Profiles'][body['Market Data']['reply']['selected']][0])
                                    except:
                                        traceback.print_exc()
                                UpdateQuantity(accorder)
                                mch=1
                                if 'match' in accorder['Market Data']['reply'] and accorder['Market Data']['reply']['match']==0:
                                    mch=0
                                if mch==1 or cnt==1:#It matched our rate and quantity on the original OR we accepted a counter
                                    AcceptOffer(accorder, 2)
                                else:#They want more than our quantity or something didn't match like exchange rate, we shouldn't autoaccept here
                                    Templates.reply2={}
                                    Notification(1, "New Offer From Market!")
                                    continue
                                Templates.reply2={}
                                if 'dontclear' not in MyContracts[myps]['Market Data']:
                                    leng=len(MyContracts)
                                    i=0
                                    while i<leng:
                                        next1=1
                                        if MyContracts[i]['Process']=="Market Order":
                                            if MyContracts[i]['ordernumber']==accorder['oldordernumber']:
                                                l=0
                                                for o in OnOrders:
                                                    if 'ordernumber' in o:
                                                        if o['ordernumber']==MyContracts[i]['ordernumber']:
                                                            if cnt!=0:#They accepted the parent offer
                                                                OnOrders.pop(l)
                                                            else:
                                                                OnOrders[l]['ordernumber']=body['ordernumber']
                                                            break
                                                    l+=1
                                                RemoveFromMarket(MyContracts[i],body['ordernumber'])
                                                next1=0
                                        if MyContracts[i]['Process']=="Market Offer" or "MCount" in MyContracts[i]['Process']:
                                            if MyContracts[i]['oldordernumber']==accorder['oldordernumber'] and MyContracts[i]['ordernumber']!=accorder['ordernumber']:
                                                DeleteOrder(MyContracts[i]['ordernumber'])
                                                next1=0
                                        if next1==0:
                                            leng-=1
                                            DeleteContract(i)
                                        else:
                                            i+=1
                                i=0
                                for o in OnOrders:
                                    if 'ordernumber' in o:
                                        if o['ordernumber']==accorder['ordernumber']:
                                            if 'oldtotal' in OnOrders[i]:
                                                OnOrders[i]['total']=OnOrders[i]['oldtotal']
                                                OnOrders[i]['mychangetotal']=OnOrders[i]['oldmychangetotal']
                                    i+=1
                                Notification(1, "Market Order Accepted!")
                            else:
                                Notification(1, "New Offer From Market!")
                if body['Process']=='Market Order':
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    GetEmailGlobals()
                    private=0
                    if body['MyBMAddress']==BitAddr or MyEmail==body['MyBMAddress']:#We are looking at our own order
                        if body['TheirBMAddress'] not in str(Markets['MyMarkets']):#If we are contracting on the same computer we don't want to read orders we sent to another account. Can also say Markets['MyMarkets'].values()
                            continue
                    if body['TheirBMAddress']==BitAddr or MyEmail==body['TheirBMAddress']:#They are trying to send us the order directly.
                        if CoinSelect['HaloName'] not in body['version']:
                            continue
                        if window.EnableEmail.isChecked() and "@" in body['TheirBMAddress']:
                            pass
                        else:
                            if window.EnableBitmessage.isChecked() and "@" not in body['TheirBMAddress']:
                                pass
                            else:
                                continue
                        if window.FilterCustom.isChecked():
                            continue
                        else:
                            private=1
                    isvalid=CheckValidity(body,1)
                    if isvalid==0:
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    psss=0
                    DontForget=""
                    if isvalid==1 and '##' in body['ordernumber']:
                        for ord1 in Markets['Orders']:
                            if ord1['ordernumber'] in body['ordernumber']:
                                if ord1['theirpublic']==body['Market Data']['public']:#They must have the valid public key
                                    if ord1['Details']['image']=='': #The pastebin is being updated
                                        if body['Details']['pastebin']!="":
                                            if body['Details']['pastebin'] not in checkpastebin:
                                                checkpastebin[body['Details']['pastebin']]=""
                                                continue
                                            else:
                                                if checkpastebin[body['Details']['pastebin']]=="":
                                                    continue
                                                else:
                                                    if checkpastebin[body['Details']['pastebin']]=="CONTINUE":#In case we want to check more than once
                                                        continue
                                                    if checkpastebin[body['Details']['pastebin']]=="FALSE":
                                                        checkpastebin.pop(body['Details']['pastebin'])
                                                        body['Details']['pastebin']=""
                                                        body['Details']['image']=""
                                                    else:
                                                        body['Details']['image']=checkpastebin[body['Details']['pastebin']]
                                                        checkpastebin.pop(body['Details']['pastebin'])
                                    if Markets['Orders'][psss]['currentblock']<body['currentblock']:
                                        Markets['Orders'][psss]['currentblock']=body['currentblock']
                                new=0
                            psss+=1
                        if new==1:
                            DontForget=body['ordernumber']
                            body['ordernumber']=body['ordernumber'].replace(body['ordernumber'].split("##")[0],"")
                            body['ordernumber']=body['ordernumber'].replace("##","")
                    if isvalid==1 and new ==1:
                        if body['Details']['pastebin']!="":
                            if body['Details']['pastebin'] not in checkpastebin:
                                checkpastebin[body['Details']['pastebin']]=""
                                continue
                            else:
                                if checkpastebin[body['Details']['pastebin']]=="":
                                    continue
                                else:
                                    if checkpastebin[body['Details']['pastebin']]=="CONTINUE":#In case we want to check more than once
                                        continue
                                    if checkpastebin[body['Details']['pastebin']]=="FALSE":
                                        checkpastebin.pop(body['Details']['pastebin'])
                                        body['Details']['pastebin']=""
                                        body['Details']['image']=""
                                    else:
                                        body['Details']['image']=checkpastebin[body['Details']['pastebin']]
                                        checkpastebin.pop(body['Details']['pastebin'])
                        Reputation(body)
                        addy=body['TheirBMAddress']
                        if "*"+addy[:10] in Markets['Banlist']:#The market might be blacklisted
                            pass
                        else:
                            body['TheirBMAddress']=body['MyBMAddress']
                            body['MyBMAddress']=addy
                            body['Market Data']['Market Address']=addy
                            if private==1:
                                body['Market Data']['Private']=2
                                Notification(1, "New Pending Offer!")
                            Markets['Orders'].append(body)
                    if body['ordernumber'] not in DontRepopulate:
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    if DontForget not in DontRepopulate:
                        if DontForget!="":
                            DontRepopulate.append(DontForget)
                            DontForget=""
                if body['Process']=='Remove Order':
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    res=VerifyMarketData(body)
                    if res==False:
                        print "VERIFICATION FAILURE"
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    else:
                        mps=0
                        accnumber=""
                        if 'acc' in body:
                            accnumber=body['acc']
                        for order in Markets['Orders']:
                            #We identify the order from the verified public key involved and not by order number
                            if order['theirpublic']==body['Market Data']['public']:#Ok the orders public key matches the signature
                                xpos=0
                                try:
                                    while xpos< len(MyContracts):#Lets see if we had offers on this that are now invalid
                                        found=0
                                        if 'oldordernumber' in MyContracts[xpos] and accnumber!="":
                                            if MyContracts[xpos]['ordernumber'][:7]!=accnumber and MyContracts[xpos]['oldordernumber']==order['ordernumber']:
                                                if 'dontclear' not in MyContracts[xpos]['Market Data'] or 'clearall' in body:
                                                    if "MCount" in MyContracts[xpos]['Process'] or MyContracts[xpos]=="Market Offer":
                                                        ypos=-1
                                                        for o in OnOrders:
                                                            ypos+=1
                                                            if 'ordernumber' in o:
                                                                if 'oldordernumber' in o:
                                                                    if o['ordernumber'][:7]!=accnumber and MyContracts[xpos]['oldordernumber']==o['oldordernumber']:
                                                                        OnOrders.pop(ypos)
                                                                        break
                                                        DeleteContract(xpos)
                                                        found=1
                                        if found==0:
                                            xpos+=1
                                except:
                                    traceback.print_exc()
                                Markets['Orders'].pop(mps)
                            mps+=1
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                if body['Process']=='Ban':
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    res=VerifyMarketData(body)
                    if res==False:
                        print "VERIFICATION FAILURE"
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    else:
                        Reputation(body)

                        mod=0
                        if body['Market Data']['public']==ModeratorPublicKey:
                            mod=1
                        if body['Market Data']['public']==masterpublic:
                            mod=2
                        if mod==0:
                            if Markets['Reputation'][body['Market Data']['public']]['Reputation']['Flags'][1]+2592000<time.time(): #A month has passed they get 5 more
                                Markets['Flags']=[0,time.time()]
                            if Markets['Flags'][0]>5:
                                pass
                            else:
                                pos=0
                                for mark in Markets['Orders']:
                                    if body['banlist'][0]==mark['ordernumber']:
                                        if 'Flags' not in mark:
                                            Markets['Orders'][pos]['Flags']=1
                                        else:
                                            Markets['Orders'][pos]['Flags']+=1
                                        if Markets['Orders'][pos]['Flags']>3:
                                            try:
                                                Markets['Reputation'][Markets['Orders'][pos]['Market Data']['orgpublic']]['Reputation']['Rating']-=5
                                            except:
                                                print "Rating error"
                                            ps=0
                                            for cn in MyContracts:
                                                if cn['ordernumber']==mark['ordernnumber'] and cn['Process']=="Market Order":
                                                    DeleteContract(ps)
                                                    DeleteOrder(str(body['banlist'][0]))
                                                ps+=1
                                            Markets['Orders'].pop(pos)
                                            break
                                    pos+=1
                            #Flagging an order protects the market but your rating goes down one point
                            Markets['Reputation'][body['Market Data']['public']]['Reputation']['Flags'][0]+=1
                            Markets['Reputation'][body['Market Data']['public']]['Reputation']['Rating']-=1
                        if mod>0:
                            pos=0
                            found=0
                            if "*R*" in body['banlist'][0] and mod==2:
                                if body['banlist'][0].replace('*R*',"") in Markets['Reputation']:
                                    Markets['Reputation'][body['banlist'][0].replace('*R*',"")]['Reputation']['Rating']+=100
                                    pubs=get_ordered_pubkeys(PrivKeyFilename1)
                                    if body['banlist'][0].replace('*R*',"") in pubs:
                                        Notification(1, "You have been rewarded!")
                            for mark in Markets['Orders']:
                                if body['banlist'][0]==mark['ordernumber']:
                                    found=1
                                    try:
                                        Markets['Reputation'][Markets['Orders'][pos]['Market Data']['orgpublic']]['Reputation']['Rating']-=5
                                    except:
                                        print "Rating error"
                                    Markets['Orders'].pop(pos)
                                    break
                                pos+=1
                            if "*" not in str(body['banlist'][0]) and found==0:
                                DontRepopulate.append(str(body['banlist'][0]))
                            ps=0
                            for cn in MyContracts:
                                if cn['ordernumber']==str(body['banlist'][0]) and cn['Process']=="Market Order":
                                    DeleteContract(ps)
                                    DeleteOrder(str(body['banlist'][0]))
                                    break
                                ps+=1
                            #Flagging an order protects the market but your rating goes down one point
                            if mod==1:
                                Markets['Reputation'][body['Market Data']['public']]['Reputation']['Flags'][0]+=1
                            body['banlist'].pop(0)
                            if body['banlist']!=[]:
                                if "#" in body['banlist'][0] and "*" not in body['banlist'][0]:
                                    body['banlist'][0]=body['banlist'][0].replace("#","")
                                    if body['banlist'][0] not in Markets['Banlist']:
                                        Markets['Banlist'].append(body['banlist'][0])
                                    body['banlist'].pop(0)
                            if body['banlist']!=[] and mod==2:
                                for ban in body['banlist']:
                                    if ban not in Markets['Banlist']:
                                        Markets['Banlist'].append(ban)
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                if body['Process']=='Reputation':
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    res=VerifyMarketData(body)
                    if res==False:
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    else:
                        if CurrentBlock!=0:
                            if body['data']['block']>CurrentBlock+100:#too far into the future
                                DontRepopulateThis(message, multisig, body['ordernumber'])
                            if body['data']['block']<CurrentBlock:
                                print "Receiving reputation data"
                                AdvanceArray['repcheck'].append(body['data'])
                                DontRepopulateThis(message, multisig, body['ordernumber'])
                if body['Process']=='Market Message':
                    if body['ordernumber'] in DontRepopulate:
                        continue
                    res=VerifyMarketData(body)
                    if res==False:
                        DontRepopulateThis(message, multisig, body['ordernumber'])
                    else:
                        try:
                            pos=0                            
                            foundthis=0
                            for ord1 in Markets['Orders']:                            
                                if ord1['ordernumber'] == body['oldordernumber']:
                                    if ord1['theirpublic']==body['Market Data']['public']:#They must have the valid public key
                                        foundthis=1
                                        break
                                pos+=1
                            if foundthis==1:
                                if 'Update Quantity: ' in body['message']:
                                    if Markets['Orders'][pos]['Market Data']['Template']=='Barter':
                                        res=body['message'].replace('Update Quantity: barteritems', '')
                                        if res=='0':
                                            Markets['Orders'].pop(pos)
                                        else:
                                            Markets['Orders'][pos]['Market Data']['barteritems']=ast.literal_eval(res)
                                    else:
                                        Markets['Orders'][pos]['Market Data']['quantity']= int(body['message'].replace('Update Quantity: ', ''))
                                if 'Update Auction: ' in body['message']:
                                    Markets['Orders'][pos]['Market Data']['BestBid']= int(body['message'].replace('Update Auction: ', ''))
                                    body['amount']=int(body['message'].replace('Update Auction: ', ''))
                                    body['Market Data']={'Template':'Something','StartingBid':0}
                                    CheckAuction(body, 0)
                        except:
                            traceback.print_exc()
                            print "Error receiving message"
                        DontRepopulateThis(message, multisig, body['ordernumber'])            
            except:
                DontRepopulateThis(message, multisig, body['ordernumber'])
                print "Market Order Error"
                traceback.print_exc()
        except Exception,ex:#Eventually we may want to delete the offending email or figure out what is throwing it off
            try:
                if 'uid' in message:
                    if message['toAddress'][:16].lower()==MyEmail[:16].lower():
                        print "Adding uid to list..."
                        DontRepopulateThis(message, multisig)
            except:
                pass
            if str(ex)=="malformed string":
                pass
            if validorder != -1:
                try:
                    if MyContracts[validorder]['status'] == "offer":
                        MyContracts[validorder]['Process']='Failed: '
                        MyContracts[validorder]['Reason']="Generic problem... possibly bad data was received"
                        MyContracts[validorder]['lock']="1"
                except:
                    pass
            else:
                pass#It was just a random message not destined for BlackHalo or random data
            #I can and should do generic message failure... so we can record the order number in advance so timeouts, bad info and other things dont crash the client. Normally, a message that contains bogus info is rejected
            #But its possible the info is partially correct from someone who tries to "game" the system so a generic failure message stating the interference is a good idea. (I cant prepare for every silly way they can crash it)
    SaveContracts()
def DontRepopulateThis(message, multisig, ordernumber=""):
    global AdvanceArray
    global DontRepopulate
    global MyEmail
    if multisig not in AdvanceArray:
        AdvanceArray[multisig]={}
    if 'uids' not in AdvanceArray[multisig]:
        AdvanceArray[multisig]['uids']=[]
    if ordernumber!="":
        DontRepopulate.append(ordernumber)
    if 'uid' in message:
        if str(message['uid'])+"#"+ordernumber not in AdvanceArray[MyEmail]['uids']:
            AdvanceArray[MyEmail]['uids'].append(str(message['uid'])+"#"+ordernumber)
    if 'archive' in message:
        if 'Archive' in AdvanceArray:
            if multisig in AdvanceArray['Archive']:
                msps=0
                for mes in AdvanceArray['Archive'][multisig]:
                    try:#Preprocessing...
                        mes['toAddress']=mes['toAddress'][:16].lower()
                    except:
                        traceback.print_exc()
                        pass
                    if mes==message:
                        AdvanceArray['Archive'][multisig].pop(msps)
                    msps+=1
def Step1(contract, priv="", pub=""):#Step1 is sending the contract... we send only what is needed at each point. I take the literal because we dont want to alter the original
    contract1=json_deep_copy(contract,1)#To keep it from tampering with our other contract data
    newcontract={}
    global MyEmail, GlobalID
    newcontract['Details']=contract1['Details']
    if "@" in contract1['TheirBMAddress']:
        GetEmailGlobals()
        BitAddr=MyEmail
    else:
        if newcontract['Details']['pastebin'] != "":
            newcontract['Details']['image']=""
        BitAddr=GetfromCfg("#BitMessage#")
    #We have to reverse everything mine/theirs
    newcontract['mydeposit']=contract1['theirdeposit']
    newcontract['theirdeposit']=contract1['mydeposit']
    newcontract['timestamp']=contract1['timestamp']
    newcontract['amount']=contract1['amount']
    newcontract['whopays']=contract1['whopays']
    newcontract['instantamount']=contract1['instantamount']
    newcontract['instantwhopays']=contract1['instantwhopays']
    if newcontract['whopays']=="I pay this amount":
        newcontract['whopays']="The other party pays this amount"
    else:
        newcontract['whopays']="I pay this amount"
    if newcontract['instantwhopays']=="I am depositing this/broadcasting":
        newcontract['instantwhopays']="They are depositing this/broadcasting"
    else:
        newcontract['instantwhopays']="I am depositing this/broadcasting"
    newcontract['timeout']=contract1['timeout']
    newcontract['fee']=contract1['fee']
    newcontract['TheirBMAddress']=contract1['TheirBMAddress']#Its important to know that we Convert these later
    newcontract['MyBMAddress']=BitAddr
    if CurrentBlock != 0:
        newcontract['currentblock']=CurrentBlock
    else:
        newcontract['currentblock']=contract1['currentblock']
    newcontract['Process']=contract1['Process']
    newcontract['status']="offer"
    if BitHaloClient==True:
        newcontract['version']="BitHalo " + clientversion
        newcontract['theirversion']="BitHalo " + clientversion
    else:
        newcontract['version']=CoinSelect['HaloName'] + " " + clientversion
        newcontract['theirversion']=CoinSelect['HaloName'] + " " + clientversion
    newcontract['Command']='Send'
    newcontract['type']=contract1['type']
    newcontract['theirpublic']=contract1['mypublic']
    newcontract['ordernumber']=contract1['ordernumber']
    newcontract['theiraddress']=contract1['theiraddress']#They will see this correctly when they accept they will send their address
    newcontract['tx1']=contract1['tx1']#Send them the first txid
    newcontract['theirtemp']=contract1['mytemp']#Their tempaccount... values will be figured out separately to avoid tricks
    if 'myencrypted' in contract1:
        newcontract['theirencrypted']=contract1['myencrypted']
    if 'Market Data' in contract1:
        newcontract['Market Data']=contract1['Market Data']
        for profile in newcontract['Market Data']['Profiles']:
            if profile!="Contact":
                if "Something" not in contract1['Market Data']['Template'] and "Barter" not in contract1['Market Data']['Template'] and "Python" not in contract1['Market Data']['Template']:
                    if len(newcontract['Market Data']['Profiles'][profile])==1:
                        newcontract['Market Data']['Profiles'][profile][0]=""
    if priv!="" and priv!="skip":
        if pub!="":
            newcontract=ModerationCheck(contract1['theiraddress'],priv,newcontract, pub)
        else:
            newcontract=ModerationCheck(contract1['theiraddress'],priv,newcontract)
    if 'Market Data' in contract1 and priv!="skip":
        res=VerifyMarketData(newcontract)
        if res==True:
            pass
        else:
            print "Verification failed on sending"
            return
    global updatesomething
    updatesomething=1
    BitQueue.append(newcontract)
    SaveQueue()
    #here is some of the important variables
    """
    Order['myencrypted']
    Order['theirencrypted']
    Order['inputs']=inputs
    Order['mychange']=outputs
    Order['mychangetotal']=Total
    Order['mydeposit']=mydeposit
    Order['whopays']=whopays
    Order['instantwhopays']=instantwhopays
    Order['theirdeposit']=theirdeposit
    Order['timeout']=timeout
    Order['amount']=amount
    Order['fee']=fee
    Order['theiraddress']=address
    Order['type']="CONTRACT"
    Order['ordernumber']=os.urandom(16).encode('hex')
    Order['status']="offer"
    Order['version']="1.0"
    Order['total']=Total
    Order['mypublic']=pub
    BitAddr=GetfromCfg("#BitMessage#")
    Order['Command']='Send'
    Order['MyBMAddress']=BitAddr
    Order['TheirBMAddress']=address
    Order['Process']='Offer'
    Order['mypublic2']=pub2
    Order['myprivate']=priv
    Order['myprivate2']=priv2
    Order['currentblock']=CurrentBlock
    """
def CheckValidity(contract, market=0):
    #Eventually limit text size? Perhaps limit on outgoing. May want to serialize and deserialize orders some day
    orig=json_deep_copy(contract,1)
    newcontract={}
    try:
        if contract['mydeposit']==0 or contract['theirdeposit']==0:
            if contract['mydeposit']==0 and "I pay" in contract['whopays']:
                float("A")
            if contract['theirdeposit']==0 and "The other" in contract['whopays']:
                float("A")
            if contract['instantamount']!=0:
                float("A")
        newcontract['mydeposit']=contract['mydeposit']+1
        if newcontract['mydeposit']<1:
            print float("A")
        newcontract['theirdeposit']=contract['theirdeposit']+1
        if newcontract['theirdeposit']<1:
            print float("A")
        newcontract['timestamp']=contract['timestamp']+1
        if newcontract['timestamp']<1:
            print float("A")
        newcontract['amount']=contract['amount']+1
        if newcontract['amount']<5500:
            print float("A")
        newcontract['whopays']=contract['whopays']+"A"
        newcontract['instantamount']=contract['instantamount']+1
        if newcontract['instantamount']<1:
            print float("A")
        newcontract['instantwhopays']=contract['instantwhopays']+"A"
        newcontract['timeout']=contract['timeout']+1
        newcontract['MyBMAddress']=contract['MyBMAddress']+"A"
        newcontract['fee']=contract['fee']+1
        if newcontract['fee']<=5500:#May want to calculate in future
            print float("A")
        newcontract['TheirBMAddress']=contract['TheirBMAddress']+"A"
        newcontract['currentblock']=contract['currentblock']+1
        if newcontract['currentblock']<1:
            print float("A")
        newcontract['Process']=contract['Process']+"A"
        newcontract['status']=contract['status']
        if newcontract['status']!="offer":
            print float("A")
        newcontract['version']=contract['version']+"A"
        newcontract['Command']=contract['Command']+"A"
        newcontract['type']=contract['type']+"A"
        newcontract['theirpublic']=contract['theirpublic']+"A"
        newcontract['theirversion']=contract['theirversion']+"A"
        newcontract['ordernumber']=contract['ordernumber']+"A"
        newcontract['theiraddress']=contract['theiraddress']+"A"#They will see this correctly when they accept they will send their address
        newcontract['tx1']=contract['tx1']+"A"#Send them the first txid
        newcontract['theirtemp']=contract['theirtemp']+"A"#Their tempaccount... values will be figured out separately to avoid tricks
        newcontract['Details']=json_deep_copy(contract['Details'],1)
        newcontract['Details']['image']=contract['Details']['image']+"A"
        newcontract['Details']['description']=contract['Details']['description']+"A"
        newcontract['Details']['pastebin']=contract['Details']['pastebin']+"A"
        newcontract['Market Data']={}
        if 'Market Data' in contract:
            if contract['Market Data']['Template']!='Custom' and contract['Market Data']['Template']!='Buy Something' and  contract['Market Data']['Template']!='Sell Something' and contract['Market Data']['Template']!='Hire Someone' and contract['Market Data']['Template']!='Find Job' and contract['Market Data']['Template']!='Sell Coins' and contract['Market Data']['Template']!='Buy Coins' and contract['Market Data']['Template']!='Python' and contract['Market Data']['Template']!='Barter':
                float("A")
            newcontract['Market Data']['Payment Method']=contract['Market Data']['Payment Method']+"A"
            newcontract['Market Data']['Market Address']=contract['Market Data']['Market Address']+"A"
            if contract['theirdeposit']>0 and contract['mydeposit']>0:#We should make sure buyers see the correct style of escrow or be tricked paying too much
                if contract['theirdeposit']==contract['mydeposit'] and Decimal(contract['mydeposit'])>=Decimal(contract['amount']) and Decimal(contract['mydeposit'])<=Decimal(contract['amount']*2):
                    if contract['Market Data']['style'].replace(", Instant Refund","")!="Double Deposit":
                        float("A")
                elif contract['amount']==10000 and contract['theirdeposit']==contract['mydeposit']:
                    if contract['Market Data']['style'].replace(", Instant Refund","")!="Barter":
                        float("A")
                elif contract['amount']==10000 and contract['theirdeposit']!=contract['mydeposit']:
                    if contract['Market Data']['style'].replace(", Instant Refund","")!="Custom Barter":
                        float("A")
                else:
                    if contract['Market Data']['style'].replace(", Instant Refund","")!="Custom Deposit":
                        float("A")
                if contract['instantamount']!=0:
                    if ", Instant Refund" not in contract['Market Data']['style']:
                        float("A")
            else:
                tt=0
                if contract['amount']>0:
                    if contract['theirdeposit']==0 and "I pay" in contract['whopays'] and contract['mydeposit']>0:
                        tt=1
                        if contract['Market Data']['style']!="Guarantor":
                            float("A")
                    if contract['mydeposit']==0 and "The other" in contract['whopays'] and contract['theirdeposit']>0:
                        tt=1
                        if contract['Market Data']['style']!="Guarantor":
                            float("A")
                if tt!=1:
                    float("A")
            for type1 in contract['Market Data']['Profiles']:
                if type1 != 'Bank' and type1 != 'WU' and type1 != 'MG' and type1 != 'Cash' and type1 != 'Card' and type1 != 'Other' and type1 != 'Mail' and type1 != 'Contact':
                    float("A")
                for k in contract['Market Data']['Profiles'][type1]:
                    pass
            newcontract['Market Data']['autoaccept']=contract['Market Data']['autoaccept']+1
            newcontract['Market Data']['allowcounters']=contract['Market Data']['allowcounters']+1
            newcontract['Market Data']['allowchat']=contract['Market Data']['allowchat']+1
            newcontract['Market Data']['Private']=contract['Market Data']['Private']+1
            if 'quantity' in contract['Market Data']:
                newcontract['Market Data']['quantity']=contract['Market Data']['quantity']+1
            if 'pegsupply' in contract['Market Data']:
                newcontract['Market Data']['pegsupply']=contract['Market Data']['pegsupply']+1
            if 'reply' in contract['Market Data']:
                newcontract['Market Data']['reply']={}
                if 'message' in contract['Market Data']['reply']:
                    newcontract['Market Data']['reply']['message']=contract['Market Data']['reply']['message']+"A"
                if 'pegsupply' in contract['Market Data']['reply']:
                    newcontract['Market Data']['reply']['pegsupply']=contract['Market Data']['reply']['pegsupply']+1
                if 'Profiles' in contract['Market Data']['reply']:
                    for type1 in contract['Market Data']['reply']['Profiles']:
                        if type1 != 'Bank' and type1 != 'WU' and type1 != 'MG' and type1 != 'Cash' and type1 != 'Card' and type1 != 'Other' and type1 != 'Mail' and type1 != 'Contact':
                            float("A")
                        for k in contract['Market Data']['reply']['Profiles'][type1]:
                            pass
            if "Coins" in contract['Market Data']['Template'] or "Custom" in contract['Market Data']['Template'] or "Something" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template'] or "Hire" in contract['Market Data']['Template'] or "Python" in contract['Market Data']['Template'] or "Barter" in contract['Market Data']['Template']:
                if 'reply' in contract['Market Data']:
                    if 'rate' in contract['Market Data']['reply']:
                        newcontract['Market Data']['reply']['rate']=Decimal(contract['Market Data']['reply']['rate'])
                        if newcontract['Market Data']['reply']['rate']<0:
                            float("A")
                    newcontract['Market Data']['reply']['timestamp']=contract['Market Data']['reply']['timestamp']+1
                    if 'selected' in contract['Market Data']['reply']:
                        newcontract['Market Data']['reply']['selected']=contract['Market Data']['reply']['selected']+"A"
                    if 'higherquantity' in contract['Market Data']['reply']:
                        newcontract['Market Data']['reply']['higherquantity']=contract['Market Data']['reply']['higherquantity']+1
                if contract['Market Data']['tracking']!=0:
                    if Decimal(contract['Market Data']['maxorder'])>1 or Decimal(contract['Market Data']['maxorder'])<=0:
                        float("A")
                    if Decimal(contract['Market Data']['minorder'])>1 or Decimal(contract['Market Data']['minorder'])<=0:
                        float("A")
                    if Decimal(contract['Market Data']['maxorder'])<Decimal(contract['Market Data']['minorder']):
                        float("A")
                    if Decimal(contract['Market Data']['maxincrease'])<1:
                        float("A")
                    if Decimal(contract['Market Data']['maxdecrease'])<=0:
                        float("A")
            if 'notes' in contract['Market Data']:
                newcontract['Market Data']['notes']=contract['Market Data']['notes']+"A"
            if 'code1' in contract['Market Data']:
                newcontract['Market Data']['code1']=contract['Market Data']['code1']+"A"
            if 'code2' in contract['Market Data']:
                newcontract['Market Data']['code2']=contract['Market Data']['code2']+"A"
            if 'code3' in contract['Market Data']:
                newcontract['Market Data']['code3']=contract['Market Data']['code3']+"A"
            if 'service' in contract['Market Data']:
                newcontract['Market Data']['service']=Decimal(contract['Market Data']['service'])
                if Decimal(newcontract['Market Data']['service'])<1:
                    float("A")
            if 'mymailing' in contract['Market Data']:
                newcontract['Market Data']['mymailing']=contract['Market Data']['mymailing']+"A"
            if 'rate' in contract['Market Data']:
                newcontract['Market Data']['rate']=Decimal(contract['Market Data']['rate'])
                if newcontract['Market Data']['rate']<0:
                    float("A")
            if 'description' in contract['Market Data']:
                newcontract['Market Data']['description']=contract['Market Data']['description']+"A"
            if 'StartingBid' in contract['Market Data']:
                newcontract['Market Data']['StartingBid']=Decimal(contract['Market Data']['StartingBid'])+1
            if 'duration' in contract['Market Data']:
                newcontract['Market Data']['duration']=Decimal(contract['Market Data']['duration'])+1
            if 'countries' in contract['Market Data']:
                newcontract['Market Data']['countries']=contract['Market Data']['countries']+"A"
            if 'weight' in contract['Market Data']:
                newcontract['Market Data']['weight']=contract['Market Data']['weight']+"A"
            if 'shipping' in contract['Market Data']:
                try:
                    newcontract['Market Data']['shipping']=contract['Market Data']['shipping']+"A"
                except:
                    newcontract['Market Data']['shipping']=Decimal(contract['Market Data']['shipping'])+1
            if 'title' in contract['Market Data']:
                newcontract['Market Data']['title']=contract['Market Data']['title']+"A"
            if 'autopay' in contract['Market Data']:
                if "Find" in contract['Market Data']['Template']:
                    if contract['Market Data']['autopay']!=0:
                        float("A")
                newcontract['Market Data']['autopay']=Decimal(contract['Market Data']['autopay'])+1
            if 'requirereport' in contract['Market Data']:
                newcontract['Market Data']['requirereport']=Decimal(contract['Market Data']['requirereport'])+1
            if 'Job Length' in contract['Market Data']:
                newcontract['Market Data']['Job Length']=contract['Market Data']['Job Length']+"A"
            if 'Pay Frequency' in contract['Market Data']:
                if contract['Market Data']['Pay Frequency']!="Flat Rate" and contract['Market Data']['Pay Frequency']!="Per Milestone" and contract['Market Data']['Pay Frequency']!="Per Week" and contract['Market Data']['Pay Frequency']!="Per Month":
                    float("A")
                newcontract['Market Data']['Pay Frequency']=contract['Market Data']['Pay Frequency']+"A"
            if 'interview' in contract['Market Data']:
                newcontract['Market Data']['interview']=Decimal(contract['Market Data']['interview'])+1
            if 'resume' in contract['Market Data']:
                newcontract['Market Data']['resume']=contract['Market Data']['resume']+"A"
            if 'barteritems' in contract['Market Data']:
                newcontract['Market Data']['barteritems']=dict(json_deep_copy(contract['Market Data']['barteritems'],1))
            if 'buymultiple' in contract['Market Data']:
                newcontract['Market Data']['buymultiple']=Decimal(contract['Market Data']['buymultiple'])+1
            if 'offernotinlist' in contract['Market Data']:
                newcontract['Market Data']['offernotinlist']=Decimal(contract['Market Data']['offernotinlist'])+1
            if 'itemlimit' in contract['Market Data']:
                newcontract['Market Data']['itemlimit']=Decimal(contract['Market Data']['itemlimit'])+1
            if 'keepratio' in contract['Market Data']:
                newcontract['Market Data']['keepratio']=contract['Market Data']['keepratio']
        if 'myencrypted' in contract:
            newcontract['myencrypted']=contract['myencrypted']+"A"
        if 'theirencrypted' in contract:
            newcontract['theirencrypted']=contract['theirencrypted']+"A"            
        if market==1:
            if contract!=orig:
                for k in contract:
                    if orig[k]!=contract[k]:
                        print orig[k]
                        print contract[k]
                    if k not in orig:
                        print k, " not found"
                for k in contract['Market Data']:
                    if orig['Market Data'][k]!=contract['Market Data'][k]:
                        print k
                    if k not in orig['Market Data']:
                        print k, " not found"
            res=VerifyMarketData(contract)
            if res==False:
                pass
                print float("A")
        for k in contract:#They may try to cram in extra information but we will not allow it!
            if k not in newcontract:
                print k, "Found! Please check order."
                print float("A")
        return 1
    except Exception, e:
        traceback.print_exc()
        pass
    return 0
def VerifyMarketData(contract):
    if "*"+contract['Market Data']['ident'][:10] in Markets['Banlist'] or "*"+contract['Market Data']['ident'][-10:] in Markets['Banlist'] or "*"+contract['Market Data']['Bitmessage'][:10] in Markets['Banlist'] or "*"+contract['Market Data']['Address'][:10] in Markets['Banlist'] or contract['Market Data']['orgpublic'][:10] in Markets['Banlist'] or "*"+contract['Market Data']['orgpublic'][:10] in Markets['Banlist'] or contract['Market Data']['public'][:10] in Markets['Banlist'] or "*"+contract['Market Data']['public'][:10] in Markets['Banlist']:
        if contract['Market Data']['public']!=masterpublic and contract['Market Data']['public']!=ModeratorPublicKey:
            return False
    verify=contract['Market Data']['verify']
    cont=json_deep_copy(contract,1)
    cont['Market Data'].pop('verify')
    hash1=make_hash(cont)
    if hash1[:19] in Markets['Banlist']:
        return False
    res=highlevelcrypto.verify(hash1[:19],base64.b64decode(verify),contract['Market Data']['public'])
    if res==False:
        return False
    return True
#We should be careful to filter negotiation for each template
def FilterContract(mybody, mycontract, mode=0, check=0):
    body=json_deep_copy(mybody,1)
    contract=json_deep_copy(mycontract,1)
    try:
        newfound=1
        depchange=1
        skipdepcheck=0
        found=0
        timefound=0
        Dif=1
        if mode==0:#Normal checking for counters(which are entirely new orders), however they could be bids with different amounts
            if check==0:#Some keys may not exist if its just an accept
                if 'theircompletesig' in contract or 'mycompletesig' in contract or 'theircancelsig' in contract or 'mycancelsig' in contract or 'checkcomplete' in contract:
                    float("A")#We already checked for this, but just checking again for safe keeping.
                if body['instantamount']!=0 or body['fee']!=contract['fee'] or body['whopays']!=contract['whopays']:
                    if contract['Market Data']['Template']!="Custom":#For now those are only custom settings
                        float("A")
                if "Coins" in contract['Market Data']['Template']:#All contracts that don't allow changing deposits and time
                    depchange=0
                if "Custom" in contract['Market Data']['Template'] or "Something" in contract['Market Data']['Template'] or "Hire" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template'] or "Python" in contract['Market Data']['Template']:
                    if contract['Market Data']['tracking']==2:
                        depchange=0
                if 'keepratio' in contract['Market Data']:
                    depchange=0
                if contract['Market Data']['allowcounters']==0 and 'pegging' in CoinSelect and CoinSelect['pegging']:
                    depchange=0
                if "Barter" in contract['Market Data']['Template']:
                    if contract['amount']!=10000:
                        float("A")
                    if contract['Market Data']['tracking']==2:
                        barter=0
                        if Decimal(contract['mydeposit'])/Decimal(contract['theirdeposit'])+Decimal(.01)>Decimal(body['mydeposit'])/Decimal(body['theirdeposit']):
                            if Decimal(contract['mydeposit'])/Decimal(contract['theirdeposit'])-Decimal(.01)<Decimal(body['mydeposit'])/Decimal(body['theirdeposit']):
                                barter=1
                        if barter==0:
                            return False
                else:
                    if contract['amount']==10000:#For now we limit this amount to Barter templates
                        float("A")
                if depchange==0:
                    mydepositprop=Decimal(contract['mydeposit'])/Decimal(contract['amount'])
                    mydepositprop2=Decimal(body['mydeposit'])/Decimal(body['amount'])
                    theirdepositprop=Decimal(contract['theirdeposit'])/Decimal(contract['amount'])
                    theirdepositprop2=Decimal(body['theirdeposit'])/Decimal(body['amount'])
                    if 'shipping' in contract['Market Data'] and "Something" in contract['Market Data']['Template']:
                        if contract['Market Data']['shipping']=="Buyer Can Calculate Shipping":
                            if Decimal(contract['mydeposit'])/Decimal(contract['theirdeposit'])+Decimal(.01)>Decimal(body['mydeposit'])/Decimal(body['theirdeposit']):
                                if Decimal(contract['mydeposit'])/Decimal(contract['theirdeposit'])-Decimal(.01)<Decimal(body['mydeposit'])/Decimal(body['theirdeposit']):
                                    skipdepcheck=1
                    if body['timeout']!=contract['timeout']:
                        return False
                    if skipdepcheck==0:
                        if mydepositprop>mydepositprop2+Decimal(.01) or mydepositprop<mydepositprop2-Decimal(.01):
                            return False
                        if theirdepositprop>theirdepositprop2+Decimal(.01) or theirdepositprop<theirdepositprop2-Decimal(.01):
                            return False
                        if contract['Market Data']['style']!=body['Market Data']['style']:
                            return False
                else:
                    contract['Market Data']['style']=body['Market Data']['style']
                if contract['Market Data']['autoaccept']!=body['Market Data']['autoaccept']:
                    float("A")
                if contract['Market Data']['allowcounters']!=body['Market Data']['allowcounters']:
                    float("A")
                if contract['Market Data']['allowchat']!=body['Market Data']['allowchat']:
                    float("A")
                if contract['Market Data']['tracking']!=body['Market Data']['tracking']:
                    float("A")
                if contract['type']!=body['type']:
                    float("A")
                if contract['status']!=body['status']:
                    float("A")
                if contract['version']!=body['version']:
                    float("A")
                if contract['Market Data']['Template']!=body['Market Data']['Template']:
                    float("A")
                if 'shipping'  in contract['Market Data']:
                    if contract['Market Data']['shipping']!=body['Market Data']['shipping']:
                        float("A")
                if 'weight'  in contract['Market Data']:
                    if contract['Market Data']['weight']!=body['Market Data']['weight']:
                        float("A")                        
                if 'StartingBid'  in contract['Market Data']:
                    if contract['Market Data']['StartingBid']!=body['Market Data']['StartingBid']:
                        float("A")
                if 'countries'  in contract['Market Data']:
                    if contract['Market Data']['countries']!=body['Market Data']['countries']:
                        float("A")
                if 'keepratio'  in contract['Market Data']:
                    if contract['Market Data']['keepratio']!=body['Market Data']['keepratio']:
                        float("A")
                if 'duration' in contract['Market Data']:
                    if contract['Market Data']['duration']!=body['Market Data']['duration']:
                        float("A")
                if 'title' in contract['Market Data']:
                    if contract['Market Data']['title']!=body['Market Data']['title']:
                        float("A")
                if 'autopay' in contract['Market Data']:
                    if contract['Market Data']['autopay']!=body['Market Data']['autopay']:
                        float("A")
                if 'Pay Frequency' in contract['Market Data']:
                    if contract['Market Data']['Pay Frequency']!=body['Market Data']['Pay Frequency']:
                        float("A")
                if 'interview' in contract['Market Data']:
                    if contract['Market Data']['interview']!=body['Market Data']['interview']:
                        float("A")
                if 'code1' in contract['Market Data']:
                    if contract['Market Data']['code1']!=body['Market Data']['code1']:
                        float("A")
                if 'code2' in contract['Market Data']:
                    if contract['Market Data']['code2']!=body['Market Data']['code2']:
                        float("A")
                if 'code3' in contract['Market Data']:
                    if contract['Market Data']['code3']!=body['Market Data']['code3']:
                        float("A")

                #We check for the keys but we don't actually check all the barter data
                #because the users should pay close attention to their offers anyways
                if 'buymultiple' in contract['Market Data']:
                    if contract['Market Data']['buymultiple']!=body['Market Data']['buymultiple']:
                        float("A")
                if 'offernotinlist' in contract['Market Data']:
                    if contract['Market Data']['offernotinlist']!=body['Market Data']['offernotinlist']:
                        float("A")
                if 'itemlimit' in contract['Market Data']:
                    if contract['Market Data']['itemlimit']!=body['Market Data']['itemlimit']:
                        float("A")
                try:#We run a try catch in case some of these keys don't exist
                    if body['whopays']!=contract['whopays']:
                        newfound=0
                    if body['instantwhopays']!=contract['instantwhopays']:
                        newfound=0
                    if body['timeout']!=contract['timeout']:
                        newfound=0                            
                    if body['fee']!=contract['fee']:
                        newfound=0
                    if body['instantamount']!=0:
                        newfound=0
                    if body['Details']['pastebin']!= "" and body['Details']['pastebin']!= contract['Details']['pastebin']:
                        newfound=0
                    if body['Details']['description']!= contract['Details']['description']:
                        newfound=0
                except:
                    newfound=0
                #For other contracts, there might definitely be other things we want to match. However the above is enough for the custom contract.                    
            if 'rate' in contract['Market Data']:
                body['Market Data']['rate']=contract['Market Data']['rate']
            #The price tracking checks first for a match if requested
            try:
                if contract['Market Data']['tracking']!=0:
                    for rate in AdvanceArray['charts'][CoinSelect['name']]:
                        if Decimal(body['Market Data']['reply']['timestamp'])>Decimal(rate['starttime']) and Decimal(body['Market Data']['reply']['timestamp'])<Decimal(rate['endtime']):
                            timefound=1#For greater accuracy we can also compare to the current timestampe with a tighter range for users who are always connected
                            if Decimal(body['Market Data']['reply']['rate'])==Decimal(rate['price']):
                                if "Coins" in contract['Market Data']['Template']:
                                    found=1
                                else:                                    
                                    if (Decimal(contract['Market Data']['rate'])*Decimal(contract['amount']))/(Decimal(body['Market Data']['reply']['rate'])*Decimal(body['amount'])) > Decimal(.99) and (Decimal(contract['Market Data']['rate'])*Decimal(contract['amount']))/(Decimal(body['Market Data']['reply']['rate'])*Decimal(body['amount'])) < Decimal(1.01):
                                        found=1 #It's an offer within 1% of the original market rate and the amount offered measures correctly
                else:
                    found=1
            except:
                pass
            #If we want on Market Accept we can keep found as 1 up to this point
            if newfound==0:
                found=0#Something else didn't match
            theirpub=body['Market Data']['public']#Remember their profile but keep the original market data in tact(only process replies)
            orgpub=body['Market Data']['orgpublic']
            if 'oldordernumber' not in contract['Market Data'] and contract['Process']=="Market Order":
                contract['Market Data']['oldordernumber']=contract['ordernumber']
            resp=json_deep_copy(body['Market Data']['reply'],1)
            body['Market Data']=json_deep_copy(contract['Market Data'],1)
            body['Market Data']['reply']=resp
            body['Market Data']['public']=theirpub
            body['Market Data']['orgpublic']=orgpub
            body['Market Data']['reply']['read']=1#To prevent re-adding replies
            if 'Profiles' in body['Market Data']['reply']:
                for profile in body['Market Data']['reply']['Profiles']:
                    if len(body['Market Data']['reply']['Profiles'][profile])==1:
                        body['Market Data']['Profiles'][profile]=body['Market Data']['reply']['Profiles'][profile]
            #FOR MATCHING: All orders see this mode only for checking (even when its not a counter). This is where we decide if its a match.
            if "Coins" in contract['Market Data']['Template']:
                if found==1:
                    body['Market Data']['reply']['match']=1
                else:
                    body['Market Data']['reply']['match']=0
                if 'service' in body['Market Data']['reply']:
                    if Decimal(body['Market Data']['reply']['service'])>Decimal(body['Market Data']['service']) or 'Buy Coins' not in body['Market Data']['Template']:
                        float("A")
                    if body['Market Data']['reply']['service']!=body['Market Data']['service']:
                        body['Market Data']['service']=body['Market Data']['reply']['service']
                        body['Market Data']['reply']['match']=0
                #Need to check the proportion of deposits, the difference in market rate etc
                if contract['Market Data']['tracking']!=0:
                    if check==0:
                        Dif=(Decimal(body['Market Data']['reply']['rate'])/Decimal(contract['Market Data']['rate'])).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)
                    if Dif>1:
                        if Dif>Decimal(contract['Market Data']['maxincrease']) and contract['Market Data']['maxincrease']!="1.0000000011":
                            Dif=Decimal(contract['Market Data']['maxincrease'])
                    else:
                        if Dif<Decimal(contract['Market Data']['maxdecrease']):
                            Dif=Decimal(contract['Market Data']['maxdecrease'])
                    if contract['Market Data']['maxincrease'] == "1.000000001":#We wanted a specific price with advanced options
                        Dif=1
                        body['Market Data']['reply']['match']=1
                if check==0:#only needed for counters
                    if 'minorder' in contract['Market Data']:
                        min1=Decimal(contract['Market Data']['minorder'])
                        if body['amount'] < int((Decimal(contract['amount']))*min1):#-10 and divide by dif if tracking usd
                            return False
                        if body['amount'] > int(Decimal(contract['amount'])):#+10 and divide by dif if tracking usd
                            return False
                        if 'quantity' in contract['Market Data']:
                            if int(Decimal(body['amount']))>contract['Market Data']['quantity']:
                                print "Exceeds quantity"
                                body['Market Data']['reply']['match']=0#It will want more coins than remaining
            if "Custom" in contract['Market Data']['Template']:#Autoaccept conditions for custom orders goes here
                if found==1:
                    if contract['Market Data']['tracking']==2:
                        body['Market Data']['reply']['match']=1
                    else:
                        if contract['Market Data']['tracking']==0:
                            if body['Process']=='Market Accept':
                                body['Market Data']['reply']['match']=1
                            else:
                                body['Market Data']['reply']['match']=0
                        else:
                            body['Market Data']['reply']['match']=0 #Why should we really autoaccept if they chose to counter?
                else:
                    body['Market Data']['reply']['match']=0
            if "Python" in contract['Market Data']['Template']:
                body['Market Data']['reply']['match']=0
            if "Barter" in contract['Market Data']['Template']:
                body['Market Data']['reply']['match']=0
            if "Something" in contract['Market Data']['Template']:#Autoaccept conditions for custom orders goes here
                if 'higherquantity' in body['Market Data']['reply']:
                    found=0
                if 'shipping' in contract['Market Data'] and "Something" in contract['Market Data']['Template']:
                    if contract['Market Data']['shipping']=="Buyer Can Calculate Shipping":
                        found=0
                if found==1:
                    if contract['Market Data']['tracking']==2:
                        body['Market Data']['reply']['match']=1
                    else:
                        if contract['Market Data']['tracking']==0:
                            if body['Process']=='Market Accept':
                                body['Market Data']['reply']['match']=1
                            else:
                                body['Market Data']['reply']['match']=0
                        else:
                            body['Market Data']['reply']['match']=0 #Why should we really autoaccept if they chose to counter?
                else:
                    body['Market Data']['reply']['match']=0                    
            if "Hire" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template']:#For now no autoaccept in job templates
                body['Market Data']['reply']['match']=0
            if 'selected' in body['Market Data']['reply']:
                x=body['Market Data']['reply']['selected']+"A"
                body['Market Data']['selected']=body['Market Data']['reply']['selected']
            if 'higherquantity' in body['Market Data']['reply']:
                x=body['Market Data']['reply']['higherquantity']+1
                body['Market Data']['higherquantity']=body['Market Data']['reply']['higherquantity']
            if 'resume' in body['Market Data']['reply']:
                x=body['Market Data']['reply']['resume']+"A"
                body['Market Data']['resume']=body['Market Data']['reply']['resume']
            if 'requirereport' in body['Market Data']['reply']:
                x=body['Market Data']['reply']['requirereport']+1
                body['Market Data']['requirereport']=body['Market Data']['reply']['requirereport']
            if 'barteritems' in body['Market Data']['reply']:
                body['Market Data']['barteritems']=body['Market Data']['reply']['barteritems']
            if contract['Market Data']['tracking']!=0:
                body['Market Data']['rate']=body['Market Data']['reply']['rate']
            return body
        else:#usually this is the acceptance phase should filter both buyer and seller replies and absorb into contract
            if 'read' in body['Market Data']['reply']:
                return
            if 'selected' in body['Market Data']['reply']:
                x=body['Market Data']['reply']['selected']+"A"
                contract['Market Data']['selected']=body['Market Data']['reply']['selected']
            if 'resume' in body['Market Data']['reply']:
                x=body['Market Data']['reply']['resume']+"A"
                body['Market Data']['resume']=body['Market Data']['reply']['resume']
            body['Market Data']['reply']['read']=1
            if 'reply' in body['Market Data']:
                if 'Profiles' in body['Market Data']['reply']:
                    for type1 in body['Market Data']['reply']['Profiles']:
                        if type1 != 'Bank' and type1 != 'WU' and type1 != 'MG' and type1 != 'Cash' and type1 != 'Card' and type1 != 'Other' and type1 != 'Mail' and type1 != 'Contact':
                            float("A")
                        for k in body['Market Data']['reply']['Profiles'][type1]:
                            pass
                    for profile in body['Market Data']['reply']['Profiles']:
                        if len(body['Market Data']['reply']['Profiles'][profile])==1:
                            contract['Market Data']['Profiles'][profile]=body['Market Data']['reply']['Profiles'][profile]
                contract['Market Data']['reply']=body['Market Data']['reply']
                if 'message' in body['Market Data']['reply']:
                    x=body['Market Data']['reply']['message']+"A"
            return contract

    except:
        traceback.print_exc()
        return False
def make_hash(o):
  """
  Makes a hash from a dictionary, list, tuple or set to any level, that contains
  only other hashable types (including any lists, tuples, sets, and
  dictionaries).

  Another potential way to make hash of a dictionary is txhash(ujson.dumps(data, sort_keys=True))
  Tests have shown consistent hashing results. However it will change tuples so we stay with deepcopy
  """
  if isinstance(o, (set, tuple, list)):
    return tuple([make_hash(e) for e in o])
  elif not isinstance(o, dict):
    try:
        return txhash(str(o))
    except:
        return txhash(strIN(o))
  new_o = copy.deepcopy(o)
  for k, v in new_o.items():
    new_o[k] = make_hash(v)
  return txhash(str(tuple(frozenset(sorted(new_o.items())))))
def Reputation(contract):
    global Markets
    if contract['Market Data']['orgpublic'] not in Markets['Reputation']:
        Markets['Reputation'][contract['Market Data']['orgpublic']]={'Bitmessage':[contract['MyBMAddress']],'Address':[contract['Market Data']['Address']],'D':[contract['Market Data']['ident']], 'Reputation': {'Reviews':[],'Review Points':0,'Flags':[0,time.time()],'Rating':0}}
    else:
        if contract['MyBMAddress'] not in Markets['Reputation'][contract['Market Data']['orgpublic']]['Bitmessage']:
            Markets['Reputation'][contract['Market Data']['orgpublic']]['Bitmessage'].insert(0,contract['MyBMAddress'])
        if contract['Market Data']['Address'] not in Markets['Reputation'][contract['Market Data']['orgpublic']]['Address']:
            Markets['Reputation'][contract['Market Data']['orgpublic']]['Address'].insert(0,contract['Market Data']['Address'])
        found=0
        if contract['Market Data']['ident'] not in Markets['Reputation'][contract['Market Data']['orgpublic']]['D']:
            for rep in Markets['Reputation']:
                if Markets['Reputation'][rep]==contract['Market Data']['orgpublic']:
                    continue
                if contract['Market Data']['ident'] in Markets['Reputation'][rep]['D']:#The ident is under two accounts, lets keep it just in case someone is copying someone elses rep
                    Markets['Reputation'][contract['Market Data']['orgpublic']]['D'].insert(0,contract['Market Data']['ident'])
            try:
                Markets['Reputation'][contract['Market Data']['orgpublic']]['D'][0]=contract['Market Data']['ident']
            except:
                Markets['Reputation'][contract['Market Data']['orgpublic']]['D'].append(contract['Market Data']['ident'])
    return
def CompleteContract(contract, result, txresult):
    global HistoryDetail, BitQueue
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    if 'Market Data' in contract:
        try:        
            if 'review' in contract:            
                review=contract['review']
            else:
                review=""
            pubs=get_ordered_pubkeys(PrivKeyFilename1)
            Reply={}#txresult
            Reply['data']={'block':CurrentBlock+2,'txresult':txresult,'mypub':pubs[0],'theirpub':contract['Market Data']['orgpublic'],'tx3':contract['tx3'],'review':review}
            Reply['Process']='Reputation'
            Reply['Command']='Send'
            priv=contract['myprivate']
            pub=contract['mypublic']
            Reply['MyBMAddress']=contract['MyBMAddress']
            if 'Market Address' in contract['Market Data']:
                if "BM-" in contract['Market Data']['Market Address'] and "@" not in contract['Market Data']['Market Address']:
                    Reply['MyBMAddress']=GetfromCfg("#BitMessage#")
                    Reply['TheirBMAddress']=contract['Market Data']['Market Address']
            else:
                Reply['TheirBMAddress']=contract['TheirBMAddress']
            Reply['ordernumber']=os.urandom(16).encode('hex')
            data=ModerationCheck(multisig, priv, Reply, pub)
            if data==False:
                pass
            else:
                Reply=data
                res=VerifyMarketData(Reply)
                if res==True:
                    BitQueue.append(Reply)
                    SaveQueue()
        except:
            print "Reputation data error"
    if multisig not in HistoryDetail:
        HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
    hist2={}
    details=contract
    details['ContractResult']=result
    hist2['Amount']=str(dropzeros(Decimal(contract['amount'])/Decimal(1e8),1))
    hist2['Details']=details
    hist2['Details']['date']=ConvertDate(HaloTime,0)
    try:
        hist2['Details']['Details']['image']=""
    except:
        pass
    hist2['Type']="Contract"
    hist2['Label']=''
    if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
        HistoryDetail[multisig]=[hist2]
    else:
        HistoryDetail[multisig].insert(0,hist2)
    PopulateHistory()
#I left comments out of this because it is totally self explanitory...
#We could say in breif, farming, traction, reaction and subtraction... you are getting sleepy
def CheckEscrow():
    #Check our escrows
    global updatesomething, isdownloading, interneton, globaltxh, globaltx,globalargs, NewUser
    global MyContracts, OnOrders
    global CurrentBlock,HaloTime,timestamp
    global EscrowResults
    global HistoryDetail
    global SilenceUI
    global myblockcount
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    pos=-1
    for contract in MyContracts:
        if NewUser!=[]:
            return
        try:
            pos+=1
            if contract['status']=="Escrow":
                try:
                    hours_difference = ConvertDate(contract['time'],1) - HaloTime
                    hours_difference = hours_difference.total_seconds()/3600.0
                    hours_difference = round(hours_difference, 2)
                except:
                    hours_difference = 999999
                try:
                    blocks_difference = contract['blocks']-CurrentBlock
                except Exception, e:
                    pass #print e
                    blocks_difference = 999999
                if float(hours_difference)<0 and int(blocks_difference)<0 and 'TXcomplete' not in contract: #Time is up, we send tx4 and delete the deal
                    MyContracts[pos]['TXdestroyed']=1
                    rawtx=contract['tx4raw']
                    rspns=0
                    found=0
                    ps1=-1
                    for results in EscrowResults:
                        ps1+=1
                        if results['raw']==rawtx:
                            found=1
                            ps2=ps1
                            rspns=results['rspns']
                    if found==0:
                        rawd={}
                        rawd['BitHalo']=BitHaloClient
                        rawd['raw']=rawtx
                        rawd['sender']=multisig
                        rawd['history']=""
                        rawd['rspns']=0
                        EscrowResults.append(rawd)
                    if rspns !=0:
                        EscrowResults.pop(ps2)
                        if "TX rejected" in str(rspns):
                            MyContracts[pos]['Rejections']+=1
                            if MyContracts[pos]['Rejections']>=1:
                                CompleteContract(contract, "Destroyed",txhash(rawtx))
                                DeleteContract(pos)
                                break
                        else:
                            CompleteContract(contract, "Destroyed",txhash(rawtx))
                            DeleteContract(pos)
                            break
                if 'Market Data' in contract:
                    try:
                        if "Hire" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template']:
                            if "I pay" in contract['whopays']:
                                if 'autopay' in contract['Market Data'] and contract['Market Data']['autopay']==1:
                                    if 'billing' not in contract:
                                        if "Week" in contract['Market Data']['Pay Frequency'] or "Month" in contract['Market Data']['Pay Frequency']:
                                            mytime=ConvertDate(contract['time'], 1) - datetime.timedelta(hours=contract['timeout'])#Time the contract confirmed
                                            if "Week" in contract['Market Data']['Pay Frequency']:
                                                NewTime=mytime+ datetime.timedelta(hours=168)
                                            if "Month" in contract['Market Data']['Pay Frequency']:
                                                NewTime=addmonths(1,mytime)
                                            contract['billing']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                    curtime=datetime.datetime.utcfromtimestamp(timestamp)
                                    if 'payments' not in contract:
                                        contract['payments']={}
                                    rspns=0
                                    found=0
                                    ps1=-1
                                    for results in EscrowResults:
                                        ps1+=1
                                        if 'billing' in results:
                                            if results['billing']==str(contract['billing'])+str(contract['ordernumber']):
                                                found=1
                                                ps2=ps1
                                                rspns=results['rspns']
                                    if ConvertDate(contract['billing'], 1)<curtime:
                                        hours_difference = ConvertDate(contract['billing'], 1) - curtime
                                        hours_difference = abs(hours_difference.total_seconds()/3600.0)                              
                                        auto=1
                                        if hours_difference>24:#payment or report is late
                                            auto=0
                                            contract['autopayoff']="Late payment, please pay this invoice manually"
                                            contract['Market Data']['autopay']=0
                                        if contract['Market Data']['requirereport']==1:                                        
                                            auto=0
                                            if 'MyReports' not in contract:
                                                MyContracts[pos]['MyReports']={}
                                            if str(ConvertDate(contract['billing'], 1)) in contract['MyReports']:
                                                auto=1
                                        uptodate=1
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                                                uptodate=0
                                        if auto==1 and IsUnlocked() and uptodate==1:
                                            #The payment is submitted but delayed slightly to make sure files save
                                            #Also some information is hashed to notify the recipient the purpose of the payment
                                            burnmessage=("*E*"+txhash(str(contract['billing'])+str(contract['ordernumber'])))[:20]
                                            apicontract={'address':contract['theiraddress'],'nosplash':1,'unlock':1,'fee':0, 'notify': [contract['theiraddress'],multisig], 'burn': burnmessage}
                                            proceed=0
                                            if contract['Market Data']['tracking']==0:
                                                apicontract['amount']=str(Decimal(contract['amount'])/Decimal(1e8))
                                                proceed=1
                                            else:
                                                if 'prevrate' not in contract:
                                                    MyContracts[pos]['prevrate']=contract['Market Data']['rate']
                                                usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)
                                                if usd!="":
                                                    if Decimal(contract['prevrate'])/Decimal(usd)<Decimal(0.70) or Decimal(contract['prevrate'])/Decimal(usd)>Decimal(1.30):
                                                        contract['autopayoff']="Too much volatility in exchange rate"
                                                        contract['Market Data']['autopay']=0
                                                        #Too much volatility
                                                    else:
                                                        apicontract['amount']=str(Decimal(int((Decimal(contract['amount']))*(Decimal(contract['Market Data']['rate'])/Decimal(usd)))/Decimal(1e8)))
                                                        contract['prevrate']=usd
                                                        proceed=1
                                            if proceed==1:
                                                #We should only allow ONE calculation, otherwise payment failed and disable
                                                res=""
                                                if str(contract['billing']) not in contract['payments']:
                                                    try:
                                                        print str(apicontract)
                                                        rawtx, res = window.SendNormal(apicontract)
                                                        print res
                                                    except:
                                                        traceback.print_exc()
                                                        rawtx=False
                                                    SilenceUI=0
                                                    if "The history is not up to date" in res:
                                                        float('a')
                                                    contract['payments'][str(contract['billing'])]=rawtx
                                                else:
                                                    rawtx=contract['payments'][str(contract['billing'])]
                                                if rawtx==False:
                                                    contract['autopayoff']="Transaction creation failed"
                                                    contract['Market Data']['autopay']=0
                                                    float('a')                                        
                                                rspns=0
                                                found=0
                                                ps1=-1
                                                for results in EscrowResults:
                                                    ps1+=1
                                                    if 'billing' in results:
                                                        if results['billing']==str(contract['billing'])+str(contract['ordernumber']):
                                                            found=1
                                                            ps2=ps1
                                                            rspns=results['rspns']
                                                if found==0:
                                                    rawd={}
                                                    rawd['BitHalo']=BitHaloClient
                                                    rawd['raw']=rawtx
                                                    rawd['sender']=multisig
                                                    rawd['billing']=str(contract['billing'])+str(contract['ordernumber'])
                                                    rawd['time']=timestamp
                                                    rawd['history']=""
                                                    rawd['rspns']=0
                                                    EscrowResults.append(rawd)
                                    if rspns !=0:
                                        if "TX rejected" in str(rspns):
                                            contract['autopayoff']="TX rejected"
                                            contract['Market Data']['autopay']=0
                                            EscrowResults.pop(ps2)
                                        else:#Payment success, update billing cycle                                                
                                            mytime=ConvertDate(contract['billing'], 1)
                                            if "Week" in contract['Market Data']['Pay Frequency']:
                                                NewTime=mytime+ datetime.timedelta(hours=168)
                                            if "Month" in contract['Market Data']['Pay Frequency']:
                                                NewTime=addmonths(1,mytime)
                                            contract['billing']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                            mytime=ConvertDate(contract['time'],1)
                                            WinContracts.hide()
                                            if "Week" in contract['Market Data']['Pay Frequency']:
                                                NewTime=mytime+ datetime.timedelta(hours=168)
                                                contract['blocks']=contract['blocks']+(int(7)*144)
                                                WinContracts.Requests.addItem("Time extended: " + str(7) + " Days")
                                                contract['MyMessages'].append({'message': "Time extended: " + str(7) + " Days"})
                                                contract['MyRequests'].append("Time extended: " + str(7) + " Days")                                                        
                                            if "Month" in contract['Market Data']['Pay Frequency']:
                                                NewTime=addmonths(1,mytime)
                                                contract['blocks']=contract['blocks']+(int(31)*144)
                                                WinContracts.Requests.addItem("Time extended: " + str(1) + " Month")
                                                contract['MyMessages'].append({'message': "Time extended: " + str(1) + " Month"})
                                                contract['MyRequests'].append("Time extended: " + str(1) + " Month")
                                            WinContracts.Requests.addItem("Escrow Payment: " + rspns)
                                            contract['MyMessages'].append({'message': "Escrow Payment: " + rspns})
                                            contract['MyRequests'].append("Escrow Payment: " + rspns)
                                            contract['time']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                            Notification(1, "Automated Payment Completed!")
                                            EscrowResults.pop(ps2)
                        if "Python" in contract['Market Data']['Template']:
                            exec(validateCode(contract['Market Data']['code2']))
                    except:
                        traceback.print_exc()
                if "Complete:" in contract['Process'] or 'checkcomplete' in MyContracts[pos]:#If they dont clear it we can check
                    tt=contract['Process'].replace("Complete:*Counter party submitted first* ", "")
                    tt=tt.replace("Complete: ", "")
                    checkthis=0
                    if 'checkcomplete' not in MyContracts[pos]:
                        checkthis=1
                    else:
                        if MyContracts[pos]['checkcomplete']==1:
                            checkthis=1
                    if checkthis==0:
                        tt=MyContracts[pos]['checkcomplete'][0]
                    rspns=0
                    found=0
                    ps1=-1
                    for results in EscrowResults:
                        ps1+=1
                        if results['history']=="Check:"+tt:
                            found=1
                            ps2=ps1
                            rspns=results['rspns']
                    if found==0:
                        rawd={}
                        rawd['BitHalo']=BitHaloClient
                        rawd['history']="Check:"+tt
                        rawd['txid1']=tt
                        rawd['raw']=""
                        rawd['sender']=multisig
                        rawd['rspns']=0
                        EscrowResults.append(rawd)
                    if rspns != 0 and not isinstance(rspns, list):
                        EscrowResults.pop(ps2)
                        rspns=0                    
                    if rspns !=0:
                        leng=0
                        hist=rspns
                        leng=len(hist)
                        EscrowResults.pop(ps2)
                        if checkthis==0:
                            if leng>0:
                                MyContracts[pos]['checkcomplete'][3]=MyContracts[pos]['checkcomplete'][0]
                        if leng>0 and checkthis==1:
                            DeleteContract(pos)
                            break
                    if checkthis==0:
                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                            if ThePeg.Pegdatabase['blockcount']>myblockcount-1:
                                MyContracts[pos]['checkcomplete'][2]+=1
                        tt=MyContracts[pos]['checkcomplete'][1]
                        rspns=0
                        found=0
                        ps1=-1
                        for results in EscrowResults:
                            ps1+=1
                            if results['history']=="Check:"+tt:
                                found=1
                                ps2=ps1
                                rspns=results['rspns']
                        if found==0:
                            rawd={}
                            rawd['BitHalo']=BitHaloClient
                            rawd['history']="Check:"+tt
                            rawd['txid1']=tt
                            rawd['raw']=""
                            rawd['sender']=multisig
                            rawd['rspns']=0
                            EscrowResults.append(rawd)
                        if rspns != 0 and not isinstance(rspns, list):
                            EscrowResults.pop(ps2)
                            rspns=0                    
                        if rspns !=0:
                            leng=0
                            hist=rspns
                            leng=len(hist)
                            EscrowResults.pop(ps2)
                            if leng>0:
                                MyContracts[pos]['checkcomplete'][3]=MyContracts[pos]['checkcomplete'][1]
                if 'theircompletesig' in contract and 'TXdestroyed' not in contract:
                    if 'mycompletesig' in contract:
                        MyContracts[pos]['TXcomplete']=1
                        if "Complete:" not in contract['Process']:
                            MyContracts[pos]['Process']="Broadcasting completion"
                            inputs=[]
                            outputs=[]
                            inp={}
                            theirs={}
                            mine={}
                            theirtotal=0
                            mytotal=0
                            theirtotal+=contract['theirdeposit']
                            mytotal+=contract['mydeposit']
                            if "I pay this" in contract['whopays']:
                                theirtotal+=contract['amount']
                            else:
                                mytotal+=contract['amount']
                            inp['output']=unicode(str(contract['tx3'])+":0")
                            inp['value']=theirtotal+mytotal
                            inp['address']=contract['escrow']
                            inputs.append(inp)
                            multisig,multiscript=create_multisig_address(PrivKeyFilename1)
                            theirs={'value':int(theirtotal),'address':str(contract['theiraddress'])}#two fees deducted so one can be added
                            mine={'value':int(mytotal),'address':str(multisig)}#Now if they screw up the id, they will have to get our permission to sign again
                            if "I pay this" in contract['whopays']:
                                if mytotal>0:
                                    outputs.append(mine)
                                if theirtotal>0:
                                    outputs.append(theirs)
                            else:
                                if theirtotal>0:
                                    outputs.append(theirs)
                                if mytotal>0:
                                    outputs.append(mine)
                            pegtx=0
                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                #pegsigs['1']={'sigs':sigs,'outs':outputs}
                                supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
                                #We check here for any potential rate change. In the future this experience can be made much smoother
                                if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                                    if supply==contract['mycompletesig']['supply']:
                                        pegtx=1
                                if contract['firstsign']=="me":
                                    rawtx2,rspns=broadcast_tx_to_network(contract['mycompletesig']['2']['sigs'],contract['theircompletesig']['2']['sigs'],inputs,contract['mycompletesig']['2']['outs'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                else:
                                    rawtx2,rspns=broadcast_tx_to_network(contract['theircompletesig']['2']['sigs'],contract['mycompletesig']['2']['sigs'],inputs,contract['mycompletesig']['2']['outs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                if contract['firstsign']=="me":
                                    rawtx3,rspns=broadcast_tx_to_network(contract['mycompletesig']['1']['sigs'],contract['theircompletesig']['1']['sigs'],inputs,contract['mycompletesig']['1']['outs'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                else:
                                    rawtx3,rspns=broadcast_tx_to_network(contract['theircompletesig']['1']['sigs'],contract['mycompletesig']['1']['sigs'],inputs,contract['mycompletesig']['1']['outs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                if contract['mycompletesig']['rtot']-contract['mycompletesig']['ftot']!=0 or pegtx==1:
                                    rawtx=rawtx2
                                else:
                                    rawtx=rawtx3
                            else:
                                if contract['firstsign']=="me":
                                    rawtx2,rspns=broadcast_tx_to_network(contract['mycompletesig'],contract['theircompletesig'],inputs,outputs, MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                else:
                                    rawtx2,rspns=broadcast_tx_to_network(contract['theircompletesig'],contract['mycompletesig'],inputs,outputs, MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                rawtx=rawtx2
                                rawtx3=rawtx
                            rspns=0
                            found=0
                            ps1=-1
                            for results in EscrowResults:
                                ps1+=1
                                if results['raw']==rawtx:
                                    found=1
                                    ps2=ps1
                                    rspns=results['rspns']
                            if 'checkcomplete' in MyContracts[pos] and isinstance(MyContracts[pos]['checkcomplete'], list):
                                rspns="TX rejected:99"
                            if found==0 and rspns==0:
                                rawd={}
                                rawd['BitHalo']=BitHaloClient
                                rawd['raw']=rawtx
                                rawd['sender']=multisig
                                rawd['history']=""
                                rawd['rspns']=0
                                EscrowResults.append(rawd)
                            if rspns !=0:
                                if "TX rejected" in str(rspns):
                                    if '99' not in str(rspns):
                                        EscrowResults.pop(ps2)
                                        MyContracts[pos]['Rejectsigned']+=1
                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                        if contract['Rejectsigned']>3:
                                            if 'checkcomplete' in MyContracts[pos] and isinstance(MyContracts[pos]['checkcomplete'], list):
                                                #If we were unable to find the transactions after a while, we assume the broadcast failed
                                                if MyContracts[pos]['checkcomplete'][2]>150:
                                                    MyContracts[pos]['broadcastexpired']=1
                                                    MyContracts[pos]['Process']="Broadcast expired - please submit completion to counter-party again: " + txhash(rawtx)
                                                    Notification('Broadcast expired')
                                                    try:
                                                        MyContracts[pos].pop('mycompletesig')
                                                        MyContracts[pos].pop('theircompletesig')
                                                    except:
                                                        traceback.print_exc()
                                                if MyContracts[pos]['checkcomplete'][3]!='':
                                                    CompleteContract(contract, "Completed", MyContracts[pos]['checkcomplete'][3])
                                                    MyContracts[pos]['Process']="Complete: " + MyContracts[pos]['checkcomplete'][3]
                                                    MyContracts[pos]['checkcomplete']=1
                                            else:
                                                if 'checkcomplete' not in MyContracts[pos]:
                                                    MyContracts[pos]['checkcomplete']=[txhash(rawtx2),txhash(rawtx3),0,'']
                                    else:
                                        if contract['Rejectsigned']>5:#The counterparty probably sent it already. We will have to check the order number. This will be automatic.
                                            CompleteContract(contract, "Completed", txhash(rawtx))
                                            MyContracts[pos]['Process']="Complete:*Counter party submitted first* " + txhash(rawtx)
                                else:
                                    print str(rspns)
                                    CompleteContract(contract, "Completed", txhash(rawtx))
                                    MyContracts[pos]['Process']="Complete: " + txhash(rawtx)
                                    MyContracts[pos]['checkcomplete']=1
                                    EscrowResults.pop(ps2)
                if 'theircancelsig' in contract and 'TXdestroyed' not in contract:
                    if 'mycancelsig' in contract:
                        MyContracts[pos]['TXcomplete']=1
                        if "Complete:" not in contract['Process']:
                            MyContracts[pos]['Process']="Broadcasting cancellation"
                            inputs=[]
                            outputs=[]
                            inp={}
                            theirs={}
                            mine={}
                            theirtotal=0
                            mytotal=0
                            theirtotal+=contract['theirdeposit']
                            mytotal+=contract['mydeposit']
                            if "I pay this" in contract['whopays']:
                                mytotal+=contract['amount']
                            else:
                                theirtotal+=contract['amount']
                            inp['output']=unicode(str(contract['tx3'])+":0")
                            inp['value']=theirtotal+mytotal
                            inp['address']=contract['escrow']
                            inputs.append(inp)
                            multisig,multiscript=create_multisig_address(PrivKeyFilename1)
                            theirs={'value':int(theirtotal),'address':str(contract['theiraddress'])}#two fees deducted so one can be added
                            mine={'value':int(mytotal),'address':str(multisig)}#Now if they screw up the id, they will have to get our permission to sign again
                            if "I pay this" in contract['whopays']:
                                if mytotal>0:
                                    outputs.append(mine)
                                if theirtotal>0:
                                    outputs.append(theirs)
                            else:
                                if theirtotal>0:
                                    outputs.append(theirs)
                                if mytotal>0:
                                    outputs.append(mine)
                            pegtx=0
                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                #pegsigs['1']={'sigs':sigs,'outs':outputs}
                                supply=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
                                #We check here for any potential rate change. In the future this experience can be made much smoother
                                if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                                    if supply==contract['mycancelsig']['supply']:
                                        pegtx=1
                                if contract['firstsign']=="me":
                                    rawtx2,rspns=broadcast_tx_to_network(contract['mycancelsig']['2']['sigs'],contract['theircancelsig']['2']['sigs'],inputs,contract['mycancelsig']['2']['outs'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                else:
                                    rawtx2,rspns=broadcast_tx_to_network(contract['theircancelsig']['2']['sigs'],contract['mycancelsig']['2']['sigs'],inputs,contract['mycancelsig']['2']['outs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                if contract['firstsign']=="me":
                                    rawtx3,rspns=broadcast_tx_to_network(contract['mycancelsig']['1']['sigs'],contract['theircancelsig']['1']['sigs'],inputs,contract['mycancelsig']['1']['outs'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                else:
                                    rawtx3,rspns=broadcast_tx_to_network(contract['theircancelsig']['1']['sigs'],contract['mycancelsig']['1']['sigs'],inputs,contract['mycancelsig']['1']['outs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                if contract['mycancelsig']['rtot']-contract['mycancelsig']['ftot']!=0 or pegtx==1:
                                    rawtx=rawtx2
                                else:
                                    rawtx=rawtx3
                            else:
                                if contract['firstsign']=="me":
                                    rawtx2,rspns=broadcast_tx_to_network(contract['mycancelsig'],contract['theircancelsig'],inputs,outputs, MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                else:
                                    rawtx2,rspns=broadcast_tx_to_network(contract['theircancelsig'],contract['mycancelsig'],inputs,outputs, MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                                rawtx=rawtx2
                                rawtx3=rawtx
                            rspns=0
                            found=0
                            ps1=-1
                            for results in EscrowResults:
                                ps1+=1
                                if results['raw']==rawtx:
                                    found=1
                                    ps2=ps1
                                    rspns=results['rspns']
                            if 'checkcomplete' in MyContracts[pos] and isinstance(MyContracts[pos]['checkcomplete'], list):
                                rspns="TX rejected:99"
                            if found==0 and rspns==0:
                                rawd={}
                                rawd['BitHalo']=BitHaloClient
                                rawd['raw']=rawtx
                                rawd['sender']=multisig
                                rawd['history']=""
                                rawd['rspns']=0
                                EscrowResults.append(rawd)
                            if rspns !=0:
                                if "TX rejected" in str(rspns):
                                    if '99' not in str(rspns):
                                        EscrowResults.pop(ps2)
                                        MyContracts[pos]['Rejectsigned']+=1
                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                        if contract['Rejectsigned']>3:
                                            if 'checkcomplete' in MyContracts[pos] and isinstance(MyContracts[pos]['checkcomplete'], list):
                                                #If we were unable to find the transactions after a while, we assume the broadcast failed
                                                if MyContracts[pos]['checkcomplete'][2]>150:
                                                    MyContracts[pos]['broadcastexpired']=1
                                                    MyContracts[pos]['Process']="Broadcast expired - please submit completion to counter-party again: " + txhash(rawtx)
                                                    Notification('Broadcast expired')
                                                    try:
                                                        MyContracts[pos].pop('mycancelsig')
                                                        MyContracts[pos].pop('theircancelsig')
                                                    except:
                                                        traceback.print_exc()
                                                if MyContracts[pos]['checkcomplete'][3]!='':
                                                    CompleteContract(contract, "Refunded", MyContracts[pos]['checkcomplete'][3])
                                                    MyContracts[pos]['Process']="Complete: " + MyContracts[pos]['checkcomplete'][3]
                                                    MyContracts[pos]['checkcomplete']=1
                                            else:
                                                if 'checkcomplete' not in MyContracts[pos]:
                                                    MyContracts[pos]['checkcomplete']=[txhash(rawtx),txhash(rawtx2),0,'']
                                    else:
                                        if contract['Rejectsigned']>5:
                                            MyContracts[pos]['Process']="Complete:*Counter party submitted first* "+ txhash(rawtx)
                                            CompleteContract(contract, "Refunded",txhash(rawtx))
                                else:
                                    CompleteContract(contract, "Refunded",txhash(rawtx))
                                    MyContracts[pos]['Process']="Complete: " + txhash(rawtx)
                                    MyContracts[pos]['checkcomplete']=1
                                    EscrowResults.pop(ps2)
                if contract['Process']=='Signing again...':#If you click on it, you can send the request again we need some heichical order to avoid reading the same messages
                    if contract['tx4raw']=="0" or contract['tx4raw']=="2":#Ok we have not sent it yet theirs counts as two
                        Reply={}
                        Reply['Process']='Signing again...'#Ok we will look for the message id
                        Reply['Command']='Send'
                        Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
                        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
                        Reply['TheirBMAddress']=contract['TheirBMAddress']
                        Reply['tx3']=contract['tx3']
                        Reply['ordernumber']=contract['ordernumber']
                        #TimeoutTX
                        timeinputs=[]
                        timeoutputs=[]
                        timeins={}
                        timeout={}
                        timeins['output']=unicode(contract['tx3']+":0")#Its always vout 0
                        timeins['value']=int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee'])#The question of wether or not to give to miners is a good one. Since this works for POS it means we send to Bitcoineater!!
                        timeins['address']=contract['escrow']
                        if BitHaloClient==False:
                            timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3"} #bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3 is the base58 hash of Blackcoineateradios1 for Bitcoin you can also use 1BitcoinEaterAddressDontSendf59kuE
                        else:
                            timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"1BitcoinEaterAddressDontSendf59kuE"}
                        timeinputs.append(timeins)
                        timeoutputs.append(timeout)
                        if contract['firstsign']=="me":
                            sigs3,result=create_sig_for_tx(timeinputs, timeoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30)
                        else:
                            sigs3,result=create_sig_for_tx(timeinputs, timeoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30)
                        if result != False:
                            #Ok this is just signing so lets send it and log this
                            MyContracts[pos]['tx4mysig']=sigs3
                            MyContracts[pos]['tx4raw']=str(int(contract['tx4raw'])+1)#If its two we both signed... if it fails we(can) repeat back to zero
                            MyContracts[pos]['timeinputs']=timeinputs#Just keeping track. Not sure we will use this
                            MyContracts[pos]['timeoutputs']=timeoutputs
                            Reply['tx4theirsig']=sigs3
                            BitQueue.append(Reply)#That was so sexy
                            SaveQueue()
                    if contract['tx4raw']=="3":#Ok its all signed do we advance? Not until we have a signed tx5
                        if contract['Broadcast']=="me":
                            if contract['firstsign']=="me":
                                rawtx,rspns=broadcast_tx_to_network(MyContracts[pos]['tx4mysig'],MyContracts[pos]['tx4theirsig'],MyContracts[pos]['timeinputs'],MyContracts[pos]['timeoutputs'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                            else:
                                rawtx,rspns=broadcast_tx_to_network(MyContracts[pos]['tx4theirsig'],MyContracts[pos]['tx4mysig'],MyContracts[pos]['timeinputs'],MyContracts[pos]['timeoutputs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30, skipbroadcast=1)
                            MyContracts[pos]['tx4']=txhash(rawtx)
                        if contract['instantamount']!=0:#Need to sign one of these
                            if contract['tx5raw']=="0" or contract['tx5raw']=="2":
                                #Lets make the TimeoutTX and the refund and sign it. Remember we "sign first" because our public key is used first... but everything should look the same here.
                                if contract['instantamount'] !=0:#Ok we can check  vout 1 and make a tx for it
                                    Reply={}
                                    Reply['Process']='Signing again...'#Ok we will look for the message id
                                    Reply['Command']='Send'
                                    Reply['tx3']=contract['tx3']
                                    Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
                                    Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
                                    Reply['TheirBMAddress']=contract['TheirBMAddress']
                                    Reply['ordernumber']=contract['ordernumber']
                                    instantinputs=[]
                                    instantoutputs=[]
                                    refundins={}
                                    refundout={}
                                    refundins['output']=unicode(MyContracts[pos]['tx3']+":1")#If they put anything else in the temporary the funding will not work... both parties sign each position with a sig
                                    refundins['value']=int(contract['fee']+contract['instantamount'])
                                    refundins['address']=contract['escrow']
                                    if "I am" in contract['instantwhopays']:
                                        tmpout={'value':int(contract['instantamount']), 'address':multisig}
                                    else:
                                        tmpout={'value':int(contract['instantamount']), 'address':MyContracts[pos]['theiraddress']}
                                    instantinputs.append(refundins)
                                    instantoutputs.append(tmpout)
                                    if contract['firstsign']=="me":
                                        sigs2,result=create_sig_for_tx(instantinputs, instantoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30)
                                    else:
                                        sigs2,result=create_sig_for_tx(instantinputs, instantoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30)
                                    if result != False:#Ok because we dont coninue unless it signs correctly
                                        #Ok this is just signing so lets send it and log this
                                        MyContracts[pos]['tx5mysig']=sigs2
                                        MyContracts[pos]['tx5raw']=str(int(contract['tx5raw'])+1)#If its two we both signed... if it fails we(can) repeat back to zero
                                        MyContracts[pos]['instantinputs']=instantinputs#Just keeping track. Not sure we will use this
                                        MyContracts[pos]['instantoutputs']=instantoutputs
                                        Reply['tx5theirsig']=sigs2
                                        BitQueue.append(Reply)#That was so sexy
                                        SaveQueue()
                        else:
                            MyContracts[pos]['tx4raw']=rawtx
                            MyContracts[pos]['Process']="Signed"#On any failures from here we can use 2 step send
                            MyContracts[pos]['Fixed']=1
                        if contract['tx5raw']=="3":#Ok its all signed do we broadcast? Not until we have a signed tx4
                            if contract['Broadcast']=="me":
                                if contract['firstsign']=="me":
                                    rawtx2,rspns=broadcast_tx_to_network(MyContracts[pos]['tx5mysig'],MyContracts[pos]['tx5theirsig'],MyContracts[pos]['instantinputs'],MyContracts[pos]['instantoutputs'], MyContracts[pos]['mypublic'],MyContracts[pos]['theirpublic'], MyContracts[pos]['timestamp']+30,skipbroadcast=1)
                                else:
                                    rawtx2,rspns=broadcast_tx_to_network(MyContracts[pos]['tx5theirsig'],MyContracts[pos]['tx5mysig'],MyContracts[pos]['instantinputs'],MyContracts[pos]['instantoutputs'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30,skipbroadcast=1)
                                rspns=0
                                found=0
                                ps1=-1
                                rawtx=rawtx2
                                for results in EscrowResults:
                                    ps1+=1
                                    if results['raw']==rawtx:
                                        found=1
                                        ps2=ps1
                                        rspns=results['rspns']
                                if found==0:
                                    rawd={}
                                    rawd['BitHalo']=BitHaloClient
                                    rawd['raw']=rawtx
                                    rawd['sender']=multisig
                                    rawd['history']=""
                                    rawd['rspns']=0
                                    EscrowResults.append(rawd)
                                if rspns !=0:
                                    if "TX rejected" in str(rspns):
                                        EscrowResults.pop(ps2)#Try again later
                                    else:
                                        EscrowResults.pop(ps2)
                                        MyContracts[pos]['tx5']=txhash(rawtx2)
                                        MyContracts[pos]['tx5raw']=rawtx2
                                        MyContracts[pos]['tx4raw']=rawtx
                                        MyContracts[pos]['Process']="Signed"#On any failures from here we can use 2 step send
                                        MyContracts[pos]['Fixed']=1
                            else:
                                MyContracts[pos]['tx4raw']=rawtx
                                MyContracts[pos]['Process']="Signed"
                                MyContracts[pos]['Fixed']=1
        except:
            traceback.print_exc()
    if True:#Time to test escrows. The nice thing is, we only need to do this once and do it right once we know the id numbers we can do whatever we want.
        i=-1
        for contract in MyContracts:
            try:
                i+=1
                if contract['status']=="Broadcast":
                    if 'Result' in MyContracts[i]:#Lets start logging results and make new variables
                        pass
                    else:
                        MyContracts[i]['Read']=[]#Logging old messages
                        MyContracts[i]['Result']=0
                        MyContracts[i]['Rejections']=0
                        MyContracts[i]['mytempconfirm']="no"
                        MyContracts[i]['theirtempconfirm']="no"
                        MyContracts[i]['tx3confirm']="no"
                    if MyContracts[i]['mytempconfirm']=="no":#No confirmations both parties need to check these things
                        rspns=0
                        found=0
                        ps1=-1
                        for results in EscrowResults:
                            ps1+=1
                            if results['history']==contract['mytemp']:
                                found=1
                                ps2=ps1
                                rspns=results['rspns']
                        if found==0:
                            rawd={}
                            rawd['BitHalo']=BitHaloClient
                            rawd['history']=contract['mytemp']
                            if MyContracts[i]['firstsign']=="me":
                                rawd['txid2']=contract['tx2']
                                if contract['tx2']=="56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d":
                                    MyContracts[i]['mytempconfirm']="yes"
                            else:
                                rawd['txid1']=contract['tx1']
                                if contract['tx1']=="56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d":
                                    MyContracts[i]['mytempconfirm']="yes"
                            rawd['raw']=""
                            rawd['sender']=multisig
                            rawd['rspns']=0
                            if MyContracts[i]['mytempconfirm']!="yes":
                                EscrowResults.append(rawd)
                        if rspns != 0 and not isinstance(rspns, list):
                            EscrowResults.pop(ps2)
                            rspns=0                            
                        if rspns !=0:
                            leng=0
                            hist=rspns
                            leng=len(hist)
                            EscrowResults.pop(ps2)
                            if leng>0:
                                MyContracts[i]['mytempconfirm']="yes"
                    else:#Ok lets check theirs
                        if 'cancel' in MyContracts[i]:#Ok there was a problem and they want a refund. Not only should we attempt once but as many times as we want to try this
                            try:#They could do something weird like send satoshis and change the txid so we will need to make sure we were the sender to get the correct input
                                if MyContracts[i]['cancel']==1:#Every time they want to check a cancel we will do this until satisfied
                                    rspns=0
                                    found=0
                                    ps1=-1
                                    for results in EscrowResults:
                                        ps1+=1
                                        if results['history']==contract['mytemp']:
                                            found=1
                                            ps2=ps1
                                            rspns=results['rspns']
                                    if found==0:
                                        rawd={}
                                        rawd['BitHalo']=BitHaloClient
                                        rawd['history']=contract['mytemp']
                                        if MyContracts[i]['firstsign']=="me":
                                            rawd['txid2']=contract['tx2']
                                        else:
                                            rawd['txid1']=contract['tx1']
                                        rawd['raw']=""
                                        rawd['sender']=multisig
                                        rawd['rspns']=0
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            rawd['checkthis']=1
                                        EscrowResults.append(rawd)
                                    if rspns != 0 and not isinstance(rspns, list):
                                        EscrowResults.pop(ps2)
                                        rspns=0
                                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                        if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                                            rspns=0
                                    if rspns !=0:
                                        print 'Found cancel!'
                                        EscrowResults.pop(ps2)
                                        if True:
                                            multisig,multiscript=create_multisig_address(PrivKeyFilename1)
                                            h=rspns
                                            mytotal=0
                                            mytotal+=contract['mydeposit']
                                            if "I pay this" in contract['whopays']:
                                                mytotal+=contract['amount']
                                            if "I am" in contract['instantwhopays']:
                                                mytotal+=contract['instantamount']
                                            for t in h:
                                                try:
                                                    ins=[]
                                                    outs=[]
                                                    spendme={}
                                                    outp={}
                                                    if t['value']>=mytotal:#This is done this way to protect against malleability
                                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                            liq=json_deep_copy(t['liquidity'])
                                                        spendme['output']=t['output']
                                                        spendme['value']=t['value']
                                                        spendme['address']=t['address']
                                                        submitthis=0
                                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                            if ThePeg.Pegdatabase['blockcount']>myblockcount-1:
                                                                submitthis=1
                                                                ltot=liq['ltotal']
                                                                rtot=liq['rtotal']
                                                                ftot=0
                                                                #For now, we just freeze a buffer if we are close to a rate change
                                                                if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                                                                    ftot=liq['nfreeze']
                                                                ltot-=ftot                                                                         
                                                                rtot+=ftot
                                                                if ltot<=int(MyContracts[pos]['fee'])+1000:
                                                                    rtot+=ltot
                                                                    ltot=0
                                                                if ltot==0:
                                                                    outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':(int(spendme['value'])-int(MyContracts[pos]['fee'])),'script':address_to_script(multisig)}]
                                                                else:
                                                                    outs=[]
                                                                    if rtot!=0:
                                                                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':int(rtot),'script':address_to_script(multisig)}]
                                                                    outs.append({'value':(int(spendme['value'])-int(MyContracts[pos]['fee'])-int(rtot)),'script':address_to_script(multisig)})
                                                        else:
                                                            submitthis=1
                                                            outp={'value':int(mytotal),'address':str(multisig)}
                                                            outs.append(outp)
                                                        if submitthis==1:
                                                            ins.append(spendme)
                                                            sigs,result=create_sig_for_tx(ins, outs, contract['myprivate'], contract['mypublic'],contract['mypublic2'], MyContracts[pos]['timestamp']+30)#These were made earlier
                                                            sigs2,result=create_sig_for_tx(ins, outs, contract['myprivate2'],contract['mypublic'],contract['mypublic2'], MyContracts[pos]['timestamp']+30)#These were made earlier
                                                            rawtx,rspns=broadcast_tx_to_network(sigs,sigs2,ins,outs,contract['mypublic'],contract['mypublic2'], MyContracts[pos]['timestamp']+30,1)
                                                            rspns=0
                                                            found=0
                                                            ps1=-1
                                                            for results in EscrowResults:
                                                                ps1+=1
                                                                if results['raw']==rawtx:
                                                                    found=1
                                                                    ps2=ps1
                                                                    rspns=results['rspns']
                                                            if found==0:
                                                                rawd={}
                                                                rawd['BitHalo']=BitHaloClient
                                                                rawd['raw']=rawtx
                                                                rawd['sender']=multisig
                                                                rawd['history']=""
                                                                rawd['rspns']=0
                                                                EscrowResults.append(rawd)
                                                            if rspns !=0:
                                                                if "TX rejected" in str(rspns):
                                                                    EscrowResults.pop(ps2)
                                                                else:
                                                                    EscrowResults.pop(ps2)
                                                                    MyContracts[i]['cancel']=txhash(rawtx)
                                                        break
                                                except Exception as e:
                                                    traceback.print_exc()
                                                    print "Exception with cancel of broadcast"
                            except:
                                pass
                        if MyContracts[i]['theirtempconfirm']=="no":
                            MyContracts[i]['Rejections']=0 #For now we were only counting our rejections this will be used in tx3
                            rspns=0
                            found=0
                            ps1=-1
                            for results in EscrowResults:
                                ps1+=1
                                if results['history']==contract['theirtemp']:
                                    found=1
                                    ps2=ps1
                                    rspns=results['rspns']
                            if found==0:
                                rawd={}
                                rawd['BitHalo']=BitHaloClient
                                rawd['history']=contract['theirtemp']
                                if MyContracts[i]['firstsign']=="me":
                                    rawd['txid1']=contract['tx1']
                                    if contract['tx1']=="56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d":
                                        MyContracts[i]['theirtempconfirm']="yes"
                                else:
                                    rawd['txid2']=contract['tx2']
                                    if contract['tx2']=="56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d":
                                        MyContracts[i]['theirtempconfirm']="yes"
                                rawd['raw']=""
                                rawd['sender']=multisig
                                rawd['rspns']=0
                                if MyContracts[i]['theirtempconfirm']!="yes":
                                    EscrowResults.append(rawd)
                            if rspns != 0 and not isinstance(rspns, list):
                                EscrowResults.pop(ps2)
                                rspns=0                                
                            if rspns !=0:
                                leng=0
                                hist=rspns
                                leng=len(hist)
                                EscrowResults.pop(ps2)
                                if leng>0:
                                    MyContracts[i]['theirtempconfirm']="yes"
                    if MyContracts[i]['theirtempconfirm']=="yes":#Ok we can broadcast tx3
                        if contract['Broadcast']=="me":#Only one party should broadcast
                            if MyContracts[i]['Process']!="Success":
                                rawtx=contract['tx3raw']
                                rspns=0
                                found=0
                                ps1=-1
                                for results in EscrowResults:
                                    ps1+=1
                                    if results['raw']==rawtx:
                                        found=1
                                        ps2=ps1
                                        rspns=results['rspns']
                                if found==0:
                                    rawd={}
                                    rawd['BitHalo']=BitHaloClient
                                    rawd['raw']=rawtx
                                    rawd['sender']=multisig
                                    rawd['history']=""
                                    rawd['rspns']=0
                                    EscrowResults.append(rawd)
                                if rspns !=0:
                                    if "TX rejected" in str(rspns):
                                        EscrowResults.pop(ps2)
                                        if MyContracts[i]['Rejections']>20:
                                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                MyContracts[i]['Process']="Broadcast failed: "
                                        MyContracts[i]['Rejections']+=1
                                    else:
                                        EscrowResults.pop(ps2)
                                        MyContracts[i]['Process']="Success"
                    if MyContracts[i]['tx3confirm']=="no" and 'noescrow' not in MyContracts[i]:
                        rspns=0
                        found=0
                        ps1=-1
                        mytime=0
                        for results in EscrowResults:
                            ps1+=1
                            if results['history']==contract['escrow']:
                                found=1
                                ps2=ps1
                                rspns=results['rspns']
                                if 'time' in results:
                                    mytime=results['time']
                        if found==0:
                            rawd={}
                            rawd['BitHalo']=BitHaloClient
                            rawd['history']=contract['escrow']
                            rawd['txid3']=contract['tx3']
                            rawd['raw']=""
                            rawd['sender']=multisig
                            rawd['rspns']=0
                            EscrowResults.append(rawd)
                        if rspns != 0 and not isinstance(rspns, list):
                            EscrowResults.pop(ps2)
                            rspns=0
                        if rspns !=0:
                            leng=0
                            hist=rspns
                            leng=len(hist)
                            EscrowResults.pop(ps2)
                            if leng>0:
                                #Ok but we need to make sure it has our two outputs and if their IDs dont match we need new IDs and will request a signature
                                match=0
                                funded=0
                                inst=0
                                inps=[]
                                if MyContracts[i]['instantamount']==0:
                                    inst=1
                                for t in hist:#Calculate the  values see if they match check for the id if they dont match sign again
                                    inp={}#For two step sending we can add "putting more into escrow" later
                                    inp['output']=t['output']
                                    inp['value']=t['value']
                                    inp['address']=t['address']
                                    inps.append(inp)
                                    if t['value']==MyContracts[i]['mydeposit']+MyContracts[i]['theirdeposit']+MyContracts[i]['amount']+MyContracts[i]['fee']:#Its (probably) our main input but we should check vout in case the values are the same
                                        if t['output'][-2]+t['output'][-1]==":0":
                                            newtx3=t['output']
                                            funded=1
                                    if t['value']==MyContracts[i]['instantamount']+MyContracts[i]['fee']:
                                        if t['output'][-2]+t['output'][-1]==":1":
                                            inst=1
                                    if t['output'][:-2]==MyContracts[i]['tx3']:#Ok match everything else is great
                                        if 'time' in t:
                                            mytime=t['time']
                                        match=1
                                        if MyContracts[i]['instantamount']==0:
                                            inst=1
                                        else:
                                            inst=0
                                        if inst!=1:#We saw we had a refund so we should at least broadcast it now that we know its there.
                                            if MyContracts[i]['Broadcast']=='me':
                                                rawtx=MyContracts[i]['tx5raw']
                                                rspns=0
                                                found=0
                                                ps1=-1
                                                for results in EscrowResults:
                                                    ps1+=1
                                                    if results['raw']==rawtx:
                                                        found=1
                                                        ps2=ps1
                                                        rspns=results['rspns']
                                                if found==0:
                                                    rawd={}
                                                    rawd['BitHalo']=BitHaloClient
                                                    rawd['raw']=rawtx
                                                    rawd['sender']=multisig
                                                    rawd['history']=""
                                                    rawd['rspns']=0
                                                    EscrowResults.append(rawd)
                                                if rspns !=0:
                                                    if "TX rejected" in str(rspns):
                                                        EscrowResults.pop(ps2)
                                                        MyContracts[i]['Rejections']+=1 #Try again later we will attempt so many times and ask to sign again we dont check beyond this because 2 step send can release also
                                                        if MyContracts[i]['Rejections']==22:#Ok there is clearly a problem
                                                            MyContracts[i]['tx3']="00000000000000"
                                                    else:
                                                        EscrowResults.pop(ps2)
                                                        inst=1
                                            else:
                                                inst=1
                                        if inst==1:
                                            MyContracts[i]['Rejections']=0
                                            MyContracts[i]['tx3confirm']="yes"#WE WIN!!
                                            MyContracts[i]['status']="Escrow"
                                            Notification(1, "New Open Contract!")
                                            MyContracts[i]['Process']="Signed"
                                            if HaloTime == datetime.datetime(1970, 1, 1, 0, 0, 0, 0):
                                                MyContracts[i]['time']=(3000, 1, 1, 0, 0, 0, 0)#Need to save as tuple for ast.literal
                                            else:
                                                NewTime=HaloTime+ datetime.timedelta(hours=MyContracts[i]['timeout'])
                                                mytuple=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                                MyContracts[i]['time']=mytuple
                                            if mytime!=0:#If we found a time to agree on, we use it
                                                print "\n\nNEW TIME: ", mytime
                                                mytime=datetime.datetime.utcfromtimestamp(mytime)
                                                NewTime=mytime+ datetime.timedelta(hours=MyContracts[i]['timeout'])
                                                mytuple=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                                MyContracts[i]['time']=mytuple
                                            if CurrentBlock == 0:
                                                myblock = 9999999999999999
                                            else:
                                                myblock=int(MyContracts[i]['timeout']*6) #Not primary protocol but secondary. Both need to expire. Blocks are 10 minutes or average but not always.
                                            MyContracts[i]['blocks']=myblock+CurrentBlock
                                MyContracts[i]['Spendable']=inps
                                if match==0 and funded==1 and inst==1:#Txid was changed we will need to sign again revert to "fund and forget"
                                    if HaloTime == datetime.datetime(1970, 1, 1, 0, 0, 0, 0):
                                        MyContracts[i]['time']=(3000, 1, 1, 0, 0, 0, 0)
                                    else:
                                        NewTime=HaloTime+ datetime.timedelta(hours=MyContracts[i]['timeout'])
                                        mytuple=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                        MyContracts[i]['time']=mytuple
                                    if mytime!=0:#If we found a time to agree on, we use it
                                        mytime=datetime.datetime.utcfromtimestamp(mytime)
                                        NewTime=mytime+ datetime.timedelta(hours=MyContracts[i]['timeout'])
                                        mytuple=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                                        MyContracts[i]['time']=mytuple
                                    if CurrentBlock == 0:
                                        myblock = 9999999999999999
                                    else:
                                        myblock=int(MyContracts[i]['timeout']*6) #Not primary protocol but secondary. Both need to expire.
                                    MyContracts[i]['Rejections']=0
                                    MyContracts[i]['blocks']=myblock+CurrentBlock
                                    MyContracts[i]['tx3confirm']="yes"#We win but we need to sign again
                                    MyContracts[i]['status']="Escrow"
                                    Notification(1, "New Open Contract!")
                                    MyContracts[i]['Process']="Signing again..."
                                    MyContracts[i]['tx4raw']="0"
                                    MyContracts[i]['tx5raw']="0"
                                    MyContracts[i]['tx3']=newtx3[:-2]
                                    #We hope they dont screw this part up or our escrow will fail
                    if contract['Broadcast']=="me":
                        if contract['Process']=="Broadcast":#Ok step 1
                            skp=0
                            if contract['theirdeposit']==0:
                                skp=1
                            if txhash(contract['tx1raw'])==contract['tx1'] or skp==1:#Ok so far so good
                                if txhash(contract['tx2raw'])==contract['tx2'] or skp==1:#Ok
                                    if txhash(contract['tx3raw'])==contract['tx3'] or skp==1:#Great lets broadcast
                                        if MyContracts[i]['Result']<10:#Submit until we get it
                                            if MyContracts[i]['Rejections']>20:
                                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                    MyContracts[i]['Process']="Broadcast failed: "
                                                MyContracts[i]['Result']=10
                                            rawtx=contract['tx1raw']
                                            rspns=0
                                            found=0
                                            ps1=-1
                                            for results in EscrowResults:
                                                ps1+=1
                                                if results['raw']==rawtx:
                                                    found=1
                                                    ps2=ps1
                                                    rspns=results['rspns']
                                                    pass #print rspns
                                            skipthis=0
                                            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                                if myblockcount % ThePeg.interval < 10 or myblockcount % ThePeg.interval > ThePeg.interval-37:
                                                    if 'dontskip' not in MyContracts[i]:
                                                        skipthis = 1
                                                    #We try to avoid sending transactions within the time of a rate change. In future versions
                                                    #for faster contracts it's possible to use fund and forget or just add more change to the
                                                    #temporary account.
                                            if skipthis == 0:
                                                MyContracts[i]['dontskip'] = 1
                                            if found==0 and skipthis==0:
                                                rawd={}
                                                rawd['BitHalo']=BitHaloClient
                                                rawd['raw']=rawtx
                                                rawd['sender']=multisig
                                                rawd['history']=""
                                                rawd['rspns']=0
                                                if contract['tx1']!="56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d":
                                                    EscrowResults.append(rawd)
                                                else:
                                                    if MyContracts[i]['Result']==9 or MyContracts[i]['Result']==0:
                                                        MyContracts[i]['Result']+=1
                                            if rspns !=0:
                                                if "TX rejected" in str(rspns):
                                                    EscrowResults.pop(ps2)
                                                    pass #print rspns #It will keep trying because timeouts or other things
                                                    MyContracts[i]['Rejections']+=1#Not sure when we give up but for now I dont specify... i use this again later
                                                else:
                                                    EscrowResults.pop(ps2)
                                                    if MyContracts[i]['Result']==9 or MyContracts[i]['Result']==0:
                                                        MyContracts[i]['Result']+=1
                                                    pass #print MyContracts[i]['Result']
                                            rawtx=contract['tx2raw']
                                            rspns=0
                                            found=0
                                            ps1=-1
                                            for results in EscrowResults:
                                                ps1+=1
                                                if results['raw']==rawtx:
                                                    found=1
                                                    ps2=ps1
                                                    rspns=results['rspns']
                                            if found==0 and skipthis==0:
                                                rawd={}
                                                rawd['BitHalo']=BitHaloClient
                                                rawd['raw']=rawtx
                                                rawd['sender']=multisig
                                                rawd['history']=""
                                                rawd['rspns']=0
                                                if contract['tx2']!="56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d":
                                                    EscrowResults.append(rawd)
                                                else:
                                                    if MyContracts[i]['Result']==1 or MyContracts[i]['Result']==0:
                                                        MyContracts[i]['Result']+=9
                                            if rspns !=0:
                                                if "TX rejected" in str(rspns):
                                                    EscrowResults.pop(ps2)
                                                    MyContracts[i]['Rejections']+=1
                                                    pass #print rspns
                                                else:
                                                    EscrowResults.pop(ps2)
                                                    if MyContracts[i]['Result']==1 or MyContracts[i]['Result']==0:
                                                        MyContracts[i]['Result']+=9
                                                    pass #print rspns
                                            if MyContracts[i]['Result']==10:
                                                ps1=-1
                                                for results in EscrowResults:
                                                    ps1+=1
                                                    if results['raw']==['tx2raw'] or results['raw']==['tx1raw']:#In case one got accepted and declined later
                                                        EscrowResults.pop(ps1)
                                                        break
                                    else:
                                        MyContracts[i]['Process']= "Failed: tx3 bad signature"
                                else:
                                    MyContracts[i]['Process']= "Failed: tx2 bad signature"
                            else:
                                MyContracts[i]['Process']= "Failed: tx1 bad signature"
            except:
                traceback.print_exc()
        try:
            SaveContracts()
            SaveOtherdata()
        except:
            pass
#Convert to and from floats for Satoshis
def Satoshis(amount,sat=0):
    if sat==1:
        return str(int(amount*1e8))
    else:
        return str(Decimal(amount)/Decimal(1e8))
#Add to history
def AddToHistory(txid, vout, FROM, value, mytype, hist="", rating=""):
    global HistoryDetail
    if hist!="":
        hist2=copy.deepcopy(hist)
    else:
        hist2={}
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    skipme=0
    if multisig not in HistoryDetail:
        HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
    for det in HistoryDetail[multisig]:
        if 'txid' in det['Details']:
            if det['Details']['txid']==txid:
                skipme=1
    if skipme==0:
        details={}
        details['txid']=txid
        details['vout']=vout
        details['FROM']=FROM
        details['Amount']=str(value)
        hist2['Amount']=str(value)
        hist2['Details']=details
        hist2['Details']['date']=ConvertDate(HaloTime,0)
        if rating!="":
            hist2['Details']['rating']=rating
        hist2['Type']=mytype
        hist2['Label']=''
        if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
            HistoryDetail[multisig]=[hist2]
        else:
            HistoryDetail[multisig].insert(0,hist2)
        PopulateHistory()
#Populate the contracts list here. The history list populates only once it downloads so that cant load when BlackHalo loads
def PopulateMarkets():
    global CoinMarketCap, imagecache
    #Consider resizesection function if enhanced ui is desired
    showlist=[]
    Search=str(window.SearchEdit.text())
    show=window.ShowWhat.currentIndex()
    if show==0:
        show="Show all"
    if show==1:
        show="Selling Coins"
    if show==2:
        show="Buying Coins"
    if show==3:
        show="Selling Items"
    if show==4:
        show="Buying Items"
    if show==5:
        show="Auctions"
    if show==6:
        show="Reverse"
    if show==7:
        show="Job Offers"
    if show==8:
        show="Employee Search"
    if show==9:
        show="Barter"
    if show==10:
        show="Misc"
    show=str(show)
    if Search != "":
        for ord1 in Markets['Orders']:
            if ord1['Market Data']['Payment Method']!=CoinSelect['name']:
                if AdvanceArray['MySettings']['FilterOther']:
                    continue
            if Search.lower() in str(ord1).lower():
                if Markets['Current']=="ALL":
                    cur=CoinSelect['default market']
                else:
                    cur=Markets['Current']
                if Markets['MyMarkets'][cur] == ord1['MyBMAddress'] or Markets['Current']=="ALL":
                    if 'Private' in ord1['Market Data'] and ord1['Market Data']['Private']==0 or 'Private' not in ord1['Market Data']:
                        if "Show all" in show:
                            showlist.append(ord1)
                        if "Custom" in ord1['Market Data']['Template'] and "Misc"in show:
                            showlist.append(ord1)
                        if "Python" in ord1['Market Data']['Template'] and "Misc"in show:
                            showlist.append(ord1)
                        if "Barter" in ord1['Market Data']['Template'] and "Barter"in show:
                            showlist.append(ord1)
                        if "Sell Coins" in ord1['Market Data']['Template'] and "Selling Coins" in show:
                            showlist.append(ord1)
                        if "Buy Coins" in ord1['Market Data']['Template'] and "Buying Coins" in show:
                            showlist.append(ord1)
                        if "Sell Something" in ord1['Market Data']['Template'] and "Selling Items" in show and 'StartingBid' not in ord1['Market Data']:
                            showlist.append(ord1)
                        if "Buy Something" in ord1['Market Data']['Template'] and "Buying Items" in show and 'StartingBid' not in ord1['Market Data']:
                            showlist.append(ord1)
                        if "Sell Something" in ord1['Market Data']['Template'] and "Auctions" in show and 'StartingBid' in ord1['Market Data']:
                            showlist.append(ord1)
                        if "Buy Something" in ord1['Market Data']['Template'] and "Reverse" in show and 'StartingBid' in ord1['Market Data']:
                            showlist.append(ord1)
                        if "Hire Someone" in ord1['Market Data']['Template'] and "Job Offers" in show:
                            showlist.append(ord1)
                        if "Find Job" in ord1['Market Data']['Template'] and "Employee Search" in show:
                            showlist.append(ord1)
    else:
        for ord1 in Markets['Orders']:
            if ord1['Market Data']['Payment Method']!=CoinSelect['name']:
                if AdvanceArray['MySettings']['FilterOther']:
                    continue
            if Markets['Current']=="ALL":
                cur=CoinSelect['default market']
            else:
                cur=Markets['Current']
            if Markets['MyMarkets'][cur] == ord1['MyBMAddress'] or Markets['Current']=="ALL":
                if 'Private' in ord1['Market Data'] and ord1['Market Data']['Private']==0 or 'Private' not in ord1['Market Data']:
                    if "Show all" in show:
                        showlist.append(ord1)
                    if "Custom" in ord1['Market Data']['Template'] and "Misc"in show:
                        showlist.append(ord1)
                    if "Python" in ord1['Market Data']['Template'] and "Misc"in show:
                        showlist.append(ord1)
                    if "Barter" in ord1['Market Data']['Template'] and "Barter"in show:
                        showlist.append(ord1)
                    if "Sell Coins" in ord1['Market Data']['Template'] and "Selling Coins" in show:
                        showlist.append(ord1)
                    if "Buy Coins" in ord1['Market Data']['Template'] and "Buying Coins" in show:
                        showlist.append(ord1)
                    if "Sell Something" in ord1['Market Data']['Template'] and "Selling Items" in show and 'StartingBid' not in ord1['Market Data']:
                        showlist.append(ord1)
                    if "Buy Something" in ord1['Market Data']['Template'] and "Buying Items" in show and 'StartingBid' not in ord1['Market Data']:
                        showlist.append(ord1)
                    if "Sell Something" in ord1['Market Data']['Template'] and "Auctions" in show and 'StartingBid' in ord1['Market Data']:
                        showlist.append(ord1)
                    if "Buy Something" in ord1['Market Data']['Template'] and "Reverse" in show and 'StartingBid' in ord1['Market Data']:
                        showlist.append(ord1)
                    if "Hire Someone" in ord1['Market Data']['Template'] and "Job Offers" in show:
                        showlist.append(ord1)
                    if "Find Job" in ord1['Market Data']['Template'] and "Employee Search" in show:
                        showlist.append(ord1)
    items=[]
    #window.OfferTable.blockSignals(True)
    window.OfferTable.horizontalHeader().sectionResized.disconnect(window.fitToTable)
    if "Show all" in show or "Misc" in show:
        window.OfferTable.setColumnCount(9)
        items.append("Images")
        items.append("Type")
        items.append("Description")
        items.append("Price")
        items.append("Contact")
        items.append("Deposits")
        items.append("Duration")
        items.append("Date")
        items.append("Order Number")
    if "Selling Coins" in show:
        window.OfferTable.setColumnCount(9)
        items.append("Price Per Coin")
        items.append("Amount")
        items.append("Service Charge")
        items.append("Funding Methods")
        items.append("Deposits")
        items.append("Duration")
        items.append("Contact")
        items.append("Date")
        items.append("Order Number")
    if "Buying Coins" in show:
        window.OfferTable.setColumnCount(9)
        items.append("Price Per Coin")
        items.append("Amount")
        items.append("Service Charge")
        items.append("Funding Methods")
        items.append("Deposits")
        items.append("Duration")
        items.append("Contact")
        items.append("Date")
        items.append("Order Number")
    if "Selling Items" in show or "Auctions" in show:
        window.OfferTable.setColumnCount(9)
        items.append("Images")
        items.append("Description")
        items.append("Price")
        items.append("Shipping")
        items.append("Contact")
        items.append("Deposits")
        items.append("Duration")
        items.append("Date")
        items.append("Order Number") 
    if "Buying Items" in show or "Reverse" in show:
        window.OfferTable.setColumnCount(9)
        items.append("Images")
        items.append("Description")
        items.append("Price")
        items.append("Shipping")
        items.append("Contact")
        items.append("Deposits")
        items.append("Duration")
        items.append("Date")
        items.append("Order Number")
    if "Job Offers" in show or "Employee Search" in show:
        window.OfferTable.setColumnCount(9)
        items.append("Title")
        items.append("Description")
        items.append("Price")
        items.append("Job Length")
        items.append("Contact")
        items.append("Deposits")
        items.append("Duration")
        items.append("Date")
        items.append("Order Number")
    if "Barter" in show:
        window.OfferTable.setColumnCount(9)
        items.append("Supply")
        items.append("Demand")
        items.append("My Deposit")
        items.append("Their Deposit")
        items.append("Contact")
        items.append("Deposits")
        items.append("Duration")
        items.append("Date")
        items.append("Order Number")
    window.OfferTable.setRowCount(len(showlist))
    pos=0
    for ord1 in showlist:
        item = QtGui.QTableWidgetItem()
        window.OfferTable.setVerticalHeaderItem(pos,item)
        pos+=1
    pos=0
    for i in items:
        item = QtGui.QTableWidgetItem()
        window.OfferTable.setHorizontalHeaderItem(pos, item)
        item = window.OfferTable.horizontalHeaderItem(pos)
        item.setText(Gtranslate(i))
        pos+=1
    pos=0
    b64img=""
    rowheights={}
    global CustomColumns
    mycolumns=list(CustomColumns)
    for ord1 in showlist:        
        usd,btc=GetMarketValue(ord1['Market Data']['Payment Method'],CoinMarketCap, 0)
        #window.OfferTable.setItem(pos, 0, QtGui.QTableWidgetItem(str("<img src=\"data:image/jpeg;base64,"+b64img+"\"/>")))
        pos2=0
        window.OfferTable.setRowHeight(pos, 70)
        for i in items:
            window.OfferTable.setColumnWidth(pos2, 100)
            try:
                if items[pos2]=="Images":
                    try:
                        b64img=ord1['Details']['image']
                        if b64img=="":#make default
                            if "Coins" in ord1['Market Data']['Template']:
                                b64img="/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAvAEQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKACvPPjl8c/DP7P/AIHm8S+Jp38rf5NrZ24Bnu5iCRGgJA6AkkkAAZNeh18Z/wDBRz4T6j8XdF8I2Hh2Q3fijT1vb620QNiTULcCET+SD9+WPMbbByVZ8ZxigD528ff8FRfiXrt9KPC+maT4XsMnyw8X2u4x/tO+F/JBXJaZ/wAFH/jjY3Ikn17TtRQHPk3OlQBT7fu1U/rXzRf6fdaVeTWl7bTWd3CxSWCdCkiMOoZTyD7GoKAP1O/Zl/4KN6X8VvEdh4U8baVD4a129dYbS/tZC1ncynhYyG+aJmPAyWBPGQSM/aVfh58APgtrfjzxDaeIZ0k0XwVo1xHd6n4iuFKQQorg7I2P35mOFVFydzDoOa/cOgAooooAKr6hqNrpNlNeX1zDZ2kCl5bi4kCRxqOpZjgAe5qxX5df8FQPid4ou/ivaeCJJ57PwrZ2EN5FaoxWO8lctmV/720jYAem1iOSaAPsLxV+3r8EPCd21rL4zj1KdTgjSrWW5T/v4q7D+Bryz4rftDfAH9pvRbDTF+I114K8S6Zci90bXpLWe2ksp+md5AXaRwQWXoDkECvy1ooA/Sjxfo/xutbKzk1nwH4E/aQ8OyRKbTxDFZRPdMg4GSpBz7qGHH3s1y2lW/jyS6QeH/2OPDWnahn5LjVbLfEjev7zYB+deff8E2viJ4ltPjOvgaG5urnwprdndG+shI2y3KRMyzpg/I2QEJGM7x3Ax0HjDSvAek6hqVl4p/a08WanaW9xJA+kWlteyzLtYqY2ZpGUkYwSRigDp/ELeKv+Ew8NJ8WvFOmeIvFcV7Cvhz4T+FWX7NDdFsRzXgjG1I4zlyCWLBcbsbhX6N1+YXwxHhUwXS/CXwvqfhzwnEQPEnxU8VsDeG1LASW9oB8qSS/6sBPmbeAQOtfp7QAUUUUAFfCf7aMXh+bxzqCfEbQ73X/h6/kxw+ItA2/2j4XvjCm6NwRhoZU8qTa/BJbblhX3ZXzj+0H8EfHlx4tf4h/CfVbSHxFNZrY6x4d1ZQ9hrUCZ2B1b5d4DFcnHHRlwdwB8EL+yf4B8Vv53gz4/eDri2k+aODxGX0y4UejK2SSPXAoP7JHgjwy/m+L/AI/+CbO2T5pI9BkfU5yPRUXac/ga3PE/xP8Ahaus3Vh8Rv2dLLTfEML4uX8Ma41pEW74ijOwfgxqPQfih8IU1S2s/An7O1vqmvTPttm8S689zDv7Zic7GH1IoA9y/Y6g8MWvj/Sofhhot/p3gWKd4tT8Y+IAFvfEN35MnlWcCgYSNDumZV/55AtggZqa9bfEN/HGtf8ACNfsm+Fpbw38/l6zq1ksiz/vGxNmRkHzfe6969s/Z/8Agn8Qrzxhp/xC+LF/Y219ptvJB4f8I6IqpYaOsi7XcBflLlCV4LcE5Y8BfpqgD5I+Hn7NHxL+IvijRfEnxx8R2kmm6NOl1pvgnQ1EdhFKpyjShQFbaeg+bPdsZB+t6KKACiiigD//2Q=="
                            if "Custom" in ord1['Market Data']['Template']:
                                b64img="/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAvAEQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKAPnXx7+3h8L/h/4s1Hw9dSatqV7p8rW9xJp1orxJKpwybmdclSCDgYyOtc//wAPIvhT/wA+fiT/AMAYv/jtcJ+zbqGneHdY/aT8QX/h0+JTpWtvOllDbLNM+JrrIQEHHQEnsAT2qyP22PDZH/JDNQ/8BY//AI1QB2X/AA8i+FP/AD5+JP8AwBi/+O13fwf/AGw/h58a/FA8O6HNqFnq7xtLDb6lbCPzwoJYIVZhkAE4OOAcZwa8Wh/bT8NzTxRj4F6mS7BQEs42Y5PYeXyfaup+NWk+Dfgx8WdO+NevXNvo0Nlo6adomhW0Ijlur1vP3vKijOxEmUHGT+IVXAPqZ9Ss49QjsGuoFvpIzKlsZAJWQHBYLnJAPerNfhx4q+M/xI+M/wAfbHxz4TudRg8UzXCfYrTTzLMqMkY82DywC8W3bIyjkbSQxPJb9qvAkmuy+CtCfxPHFF4iayhOopBjYtxsHmAYJH3s9OPTigDdooooAKKKKAPif9lu68Q2Os/tKz+E7K21HxJHrhNja3j7IpJfOusBjke/cfUda0H+IH7ZCsQPhx4cYA4DCa2wfzvazf2YNH1PxBqn7TOnaNrZ8Oapca0yW+qqu42zedd/N1GO4z1GcjkVq+Hf2ffi3ea5ZR3X7RFxfWfmq1xb2N5KZniBBcJ8/B25we1AG94f+Nfxd+HGiav4v+OVn4f8JeF9OgPk2VkEkvdRuGB2RRlbh1Xpkk9h2AZl/Nf4tfG/xH+1T8Qr7xJrsaPoBYQ6Xp+CyhVfK+WP7oI64y7Ek44FdV+2j+0dbftH/FWbR01G8t/CWkXBsbW189WhmdSQ6sQAVMu1Wyckj5Qx219KfsZ/s/6F4I8ReDvEvj9Eh17XXb/hFfDzx/OFjjaQ3cifwqFX5M9Mg9SuAD1b9iL9kOL4U6e/jfxbpkH/AAmWpiOS3hliBl06NVdRk9RIyyNuHYbQeRx9d0UUAFFFFABRRRQB8I/s8L4Q1nXP2jvDPjDXrTRLDWtce3Jnv47WV18663GMuecZXsRzggg4rvPh18CPgd8JtQ1TVfDHxJtYtbutNuNPt7zUNbs51tGlXHnIihMsPc4wSO+a77xz+xZ8KfiD4ovvEGpaHPDqV85luWs7ySFJZCcs5UHAYnk4xk89Sawf+HfPwc/6BWpf+DKSgDhfgP8Asufs9fBLxB/wk7eNND8QeLGcStqM+rQQRq4zykaScZychmYHuKq+MPEWmeKf+Ci/wxudF1S01eyj0R0M1hcJPGjCK/yCUJAOCvHuK9E/4d8/Bz/oFal/4MpK7b4U/srfDj4Na9JrfhzRpE1ZozEl3d3LztEp+8E3HCkjgnGccZwTkA9cooooAKKKKAP/2Q=="
                            if "Something" in ord1['Market Data']['Template']:
                                b64img="/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAvAEQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKACivCv2xP2il/Zz+FEuqWJgl8T6lJ9k0m3nG5d/V5WHdUXJ9NxQHrXwD/w8y+NP/Pzof/gtH/xVAH650V+Rn/DzL40/8/Oh/wDgtH/xVegfAf8A4KU+MtQ+KOi2HxEn0lfCt9J9lubmG18g2rNwkxbd90NjdngKWPYUAfpnRSA5GR0paACiiigAooooA/Nr/gq94b1ubxb4L1xbO7l8PxadJbNdIjNBDOZckMRwjMCmM43beM7ePibxH8OvE3hHRtE1bWdDvtN07WoTPp9zcQsiXChip2kj2zj0ZT0INfrj+3148174c/s9XereHNRbTNQ/tG1hMyxpJlGY5GHUjsO3avXPhLfXHiH4S+CdQ1WQ3t/daLY3NxNOAWklaBGZz7liTQB+Gniz4b+J/Ax0ga9od7pZ1a1S8shcQlTPE/3SvufTryOOam8RfCrxh4T8R2Ogar4a1Oz1q+iimtbB7V/OnWRQy7FAyx5wQOQQQeQRX75vFHKVLorlTlSwBwfUV8aftUfGHxh4I/a8+DHh3RNaex0XVZ7GO8tBDE4lWW+8qXllLDcny5BHtg0AfVXw10++0n4deFbHVA41K20q1huhI25hKsKh8nudwPNdJRRQAUUUUAFFFFAHgv7a3wj8SfGz4IT+GfCttDdarJqFvOEnnWFdiE7jubjuOK+Hbf8AYc/aZtII4IL94YYlCJHH4j2qigYAADcADtX6uUUAflN/wxJ+09/0FJv/AApT/wDF1s/Db9hz466b8YvAviXxPHBf2ej61Y3c89xrK3EkcEVwkj7QSSeAeB3r9QKKACiiigAooooA/9k="
                            if "Find" in ord1['Market Data']['Template']:
                                b64img="/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAvAEQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKAGeYtYfivx94b8CWkVz4j13T9DgmYpFJqFykIkI6hdxGfwrxnxl+3B8MPBHirVNAv7nVJb7Tbh7a4NtZF4xIpwwBLDOCCM47V81+N/2h/hT8Sf2kLTxN4ntL7W/A9poX2OGzu7QtsuvMJ3eVuxjDHn1x6CgD7ZsP2gfhpql7DaWnj3w9PczMEjiTUotzsegHzda77zAK/OT4ufFL9m3X/hxr1h4U8InT/Ec1vixuV0zydkoYEHcH4GAa9d+HX7enw30L4feGdN1m61qfV7PTbe3vJRZb98yRqrndu55B570AfX4IYZFLXG/Cj4qeH/jF4Rj8ReG55ptPaZ4D9oiMbpIuMqQfYg8Z612VABRRRQAUUUUAfkP+0p8OfEulfFfxtrc+j3LaNdazdyx6jbr51vgzMcNImVVueVYhh3ArzLw94X1HxRNcJYRRlbaPzp57idIIYU3BQXkchVyWAGTySAK9B+L3jDXfB3x++IVxoWsX2jztr17ueyuGi3fv34baRkexotPizceOfDmueH/ABbqlnZm+WGSDVv7KjDiSOTdtmeCMSMpBbk7sEDjnIAOTn+GWtRWtxPE+l3wt4mmkisNWtbmURqMswjjkLEKAScA4AJPANYOkaJqPiC+jstLsLnUryThLe0haWRvoqgk19p/sv8A7K2h/YdN8UazdXGu3OqGT+zIdOUxq1ttMcsz+YBhMSEHcM5IAAPX079o/wDZwudL+F2oTeBtb1XSo7OPzH0y2uTFHKoz8pClVKnIzu6dc4BVgDpP2EvCeq+DPge+naza/Yr7+1biRrcyKzxgrHgOFJ2NxyrYI4yK+ia+X/8AgnXz+z7KT1Os3PP/AACKvqCgAooooAKKKKAPyO+Pvwm8bT/G3x1PD4Q1y4t59Zup4poNOmkjkjeVmVlZVIIIIPFcF/wqLx1/0JXiL/wVT/8AxFftdRQB81/smeL7C0+H/h7TvEEN94Z1vS7H+zFg1q3a0W4QMHLIXAyQSRweQRnnIHafHr4o6fpnw916x0hk17V5rOQLZ2cgchdpyGZQcFvuqOSWYYBr1bUdLstYtjbX9pBe25OTFcRiRc+uCMVUh8KaLb6fJYRaRYx2UnL26W6CNj6lcYNAHg/7BfhfWPCXwHFprel3ekXUuqXEy297C0UhQhFDbWAIGVPUdq+jawPCXhZ/CUNzZRX8lzpW/dZ2sy5a1XvGHz8y+gIyBxk1v0AFFFFAH//Z"
                            if "Hire" in ord1['Market Data']['Template']:
                                b64img="/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAvAEQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKAGeYtYfivx94b8CWkVz4j13T9DgmYpFJqFykIkI6hdxGfwrxnxl+3B8MPBHirVNAv7nVJb7Tbh7a4NtZF4xIpwwBLDOCCM47V81+N/2h/hT8Sf2kLTxN4ntL7W/A9poX2OGzu7QtsuvMJ3eVuxjDHn1x6CgD7ZsP2gfhpql7DaWnj3w9PczMEjiTUotzsegHzda77zAK/OT4ufFL9m3X/hxr1h4U8InT/Ec1vixuV0zydkoYEHcH4GAa9d+HX7enw30L4feGdN1m61qfV7PTbe3vJRZb98yRqrndu55B570AfX4IYZFLXG/Cj4qeH/jF4Rj8ReG55ptPaZ4D9oiMbpIuMqQfYg8Z612VABRRRQAUUUUAfkP+0p8OfEulfFfxtrc+j3LaNdazdyx6jbr51vgzMcNImVVueVYhh3ArzLw94X1HxRNcJYRRlbaPzp57idIIYU3BQXkchVyWAGTySAK9B+L3jDXfB3x++IVxoWsX2jztr17ueyuGi3fv34baRkexotPizceOfDmueH/ABbqlnZm+WGSDVv7KjDiSOTdtmeCMSMpBbk7sEDjnIAOTn+GWtRWtxPE+l3wt4mmkisNWtbmURqMswjjkLEKAScA4AJPANYOkaJqPiC+jstLsLnUryThLe0haWRvoqgk133g+Tw/8O9bXxDH4psNauLS3nEFhDp87edK8TxoGE0apsy4LZzkAjBzisvVvjX411eyaybXp7GwYYaz0pEsYGHoY4FRSPqKAP0b/YS8J6r4M+B76drNr9ivv7VuJGtzIrPGCseA4UnY3HKtgjjIr6Jr5f8A+CdfP7PspPU6zc8/8Air6goAKKKKACiiigD8jvj78JvG0/xt8dTw+ENcuLefWbqeKaDTppI5I3lZlZWVSCCCDxXBf8Ki8df9CV4i/wDBVP8A/EV+11FAH4o/8Ki8df8AQleIv/BVP/8AEUf8Ki8df9CV4i/8FU//AMRX7XUUAfOX7BXhjV/CnwGW11rTLvSbqXVLiZIL2FopChCANtYAgEqevpX0bRRQAUUUUAf/2Q=="
                            if "Barter" in ord1['Market Data']['Template']:
                                b64img="/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAvAEQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKKACivN/jr+0B4Q/Z58Jrrviu6lxNJ5Npp9mokurt+pEaEgYA5LMQo4GclQfzU/aH/wCChHjr4q6zFF4OvtR8BeHLcDbDY3Wy7uHz9+SVACB2CKcepbsAfrnRX5afB7/gqB438Jpp+neOdLtfF+mQ4jl1CH/R9QKZ+8SP3chUdAVUtjlsktX2H+0j+0pp/hj9lS7+Ifg3Womm1qGGDQ7xMEmaVsHgggSRoszFWGQYmBGRigD6Ior83f2Ofi1+058ZPFOmXEGvHVPAWm6jDHrF3q1rbKrxFw0sUcvl+Y8vlkkBSduU3FQy5/SKgAooooAKKKwPiB4hPhHwH4k10WbagdM025vfsiyeWZ/LiZ9gfB27tuM4OM5oA/J//goE66j8ZdS1We8ubu9m1K6tIRNITHHZW8dtFGkS9FUXAvQcdXD9818+658P/FHhnRtN1fV/DmraXpOpRrLZX97ZSxQXSMoZWjkZQrgqQRgngg96+gdS+HHiD4y/EP4P+JvHj/Zrf4h6x9jstDsYjDHZaRDLEp8ok/IGEshUYJODIzMZOf1D+J3jHw/8CPg3rGuXNpFDoOgacI4LCKP5GACxQQKOgDMY0HYZ5wKAPwcr2b4dfstfGH4px6Np+k+FtXh0PUAt9bX2oq9vpyo4A8/e3y8qAflBZlAwG4r6u8E/sqx6n+xJ4+8Ya1aQaj4+8Y6e/iVLkW6eZDFG32qGKHHCGUKWbbtz5oU8IK+rP2QfFNl4v/Zh+GV/YuWjTQbSzkVxh45YYxFIjDsysjAj2oA3PgB8G7D4C/CnRfBtjcG9NmrSXN6yBDczuxaR8dhk4AJJCqoycZr0SiigAooooAK83/aO1PXtK+BvjKTwxoMviXXZrFrO202FSzOZmELPtAO4IsjSFe4QjIzkekUUAfL/AMbPAafDP9n/AOFmvajGLnUfhXdaJdXD6bF5jSwRGG2vEi3AHYUYyc4z5S5xWd+1D8TNE+JP/CmfBdix1fwh48121utQvI0fyZrGKaNlgbgEeZIyZ5BXyzkc19Y0UAMSGOOERKirEq7QgGFA6Yx6V81fss6jY/Crxl47+CUttdWz6PrNxqOhSfZZPs02mzpHOqCXBHmRtIysCRngjJ3BfpiigAooooAKKKKAP//Z"
                            if "Python" in ord1['Market Data']['Template']:
                                b64img="/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAAvAEQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9U6KKbJIsUbO7BEUFmZjgAdyTQA6vi34uf8FCbjwt4o1nSvCfhSPVrTSp2tZ9UvZHERkVivCqBwSMDJGcHFfQmtftM/Czw/qM9hf+OdIhu4HKSxCYuUYHBB2gjNfnndNqsGg+L/Den/EjwSnh3xFqLX88Mty5kLbyVIbycjjGRmgD0nSv+Cmfi6O5B1Pwjotxb5GRaPNE4HflmYH8q+4PhL8UtG+Mngaw8UaG0gtLkFXhmGJIJV4eNvcHuOCMHvX40+JNDXw9qr2SanYauqqrfatNkaSFsjOAWVTkd+K+zv2XP2j/AAx+z3+zzp8niS11S7/tbXb5bdNMhSQjy4rcsW3ugA/eL3PWgD75orzH4J/tFeD/AI+WV5L4amuo7mzx9osb+IRzxg52sQrMCDjqCa9OoAKKKKACvB/22fHl94B/Z+1qfTbhrW91GWLTUmQkOiyE79pHQlFYZ9694r52/b18L3PiX9nXVZLWJpn0u7g1B1XqEUlHP4ByfwoA/K2ul8M/DPxd40gabw/4X1nW4VJBl0+wlnUY68qpHes/wnpcWueKdG02YssN5ew27lOoV3CnHvg12fxd8c6s3j7XdLsL640zRNLvprKw060maOGGKNzGuFBxuIQZP4dAAACOP9nT4pSED/hXviRP9qTTJkA+pKgD8avfFeOLwj4J8IeA5LmC71jSpr3UdT+zSCRLaa48lRb7hwWRbdS2MgF8Z4OPPn8R6tIpDapesDwQbhzn9azqAPor9gXXbjSf2lNEs4ifK1S1u7WYZ/hWB5h/49EtfqjX5s/8E7/hbqWt/Fc+NJbOSPRdFtpkiu3UhZLiRDHsU/xYRnJx049a/SagAooooAKrajp1tq1jPZXsCXNrOhjlhlXKup6girNFAHgC/sNfCeDxFDrNnpN7YXUNyt1FHb3riJHVgwwpzxkdK/Mj4mqy/EnxYrghxq12GBHfznr9tq+YfjZ+wZ4T+K/ia88Q6bq1x4V1W9bzLkQwLPbyyd38sspDHvhgCecZJoA+RPgX4u8cfETUofC+lal4J0eLTrDzhca/olltaGLaCpkNuzu20555IBJI619g/sgRaP8AF34QDXPEvhvw3f6ouoXFs00Oi20SlV2lRtVAOjdcV5vpP/BMLTYbpW1P4g3V3bd47TSlgc/RmlcfpX1t8Mfhpofwk8GWPhnw/A0On2oJ3SNueVzyzue7E/4DAFAHRWOn2ul2sdtZ20NpbRjCQwRhEUegA4FWKKKACiiigD//2Q=="
                        headerItem = QtGui.QTableWidgetItem("")
                        if txhash(b64img) not in imagecache:
                            pm=ConvertImage(b64img,"base64")
                            imagecache[txhash(b64img)]=pm
                        else:
                            pm=imagecache[txhash(b64img)]
                        if pm=="":
                            pm = QtGui.QPixmap()
                            pm.loadFromData(base64.b64decode(b64img))
                        h=pm.height()
                        w=pm.width()
                        if h > 100:
                            ratio=Decimal(100)/Decimal(h)
                            pm.scaled(int(ratio*w),int(ratio*h))
                            h=100
                        if w > 100:
                            ratio=Decimal(100)/Decimal(w)
                            pm.scaled(int(ratio*w),int(ratio*h))
                            w=100
                        headerItem.setIcon(QtGui.QIcon(QtGui.QPixmap(pm)))
                        window.OfferTable.setIconSize(QtCore.QSize(100,100))
                        window.OfferTable.setItem(pos, pos2, headerItem)
                        if h < 30:
                            h=30
                        if Markets['Sort']==[0,0]:
                            window.OfferTable.setRowHeight(pos, h)
                        rowheights[ord1['ordernumber']]=[pos,h]
                    except:
                        traceback.print_exc()
                        pass
                if items[pos2]=="Type":
                    ordtype=str(ord1['Market Data']['Template'])
                    if 'StartingBid' in ord1['Market Data'] and "Buy Something" in ordtype:
                        ordtype="Reverse Auction"
                    if 'StartingBid' in ord1['Market Data'] and "Sell Something" in ordtype:
                        ordtype="Auction"
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(ordtype))
                if items[pos2]=="Description":
                    if "Barter" in ord1['Market Data']['Template']:
                        window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(strOUT(ord1['Market Data']['notes'])))
                    else:
                        window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(strOUT(ord1['Details']['description'])))
                if items[pos2]=="Title":
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(strOUT(ord1['Market Data']['title'])))
                if items[pos2]=="Job Length":
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(strOUT(ord1['Market Data']['Job Length'])))
                Dif=1
                if usd!="" and usd !=" ":
                    if "Coins" in ord1['Market Data']['Template']:
                        if ord1['Market Data']['tracking']!=0:
                            Dif=Decimal(usd)/Decimal(ord1['Market Data']['rate'])
                            if Dif>1:
                                if Dif>Decimal(ord1['Market Data']['maxincrease']) and ord1['Market Data']['maxincrease']!="1.0000000011":
                                    Dif=Decimal(ord1['Market Data']['maxincrease'])
                            else:
                                if Dif<Decimal(ord1['Market Data']['maxdecrease']):
                                    Dif=Decimal(ord1['Market Data']['maxdecrease'])
                            if ord1['Market Data']['maxincrease'] == "1.000000001":#They wanted a specific price with advanced options
                                Dif=1
                if items[pos2]=="Price Per Coin":
                    window.OfferTable.setColumnWidth(pos2,130)
                    if ord1['Market Data']['tracking']==0:
                        window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem("$"+str(ord1['Market Data']['rate'])))
                    else:
                        if usd!="" and usd !=" ":
                            window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem("$"+str(dropzeros(Decimal(ord1['Market Data']['rate'])*Decimal(Dif),1))))
                        else:
                            window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem("$"+str(ord1['Market Data']['rate'])+"  Updating..."))
                if items[pos2]=="Price" or items[pos2]=="Amount":
                    if "Custom" in ord1['Market Data']['Template'] or "Coins" in ord1['Market Data']['Template'] or "Something" in ord1['Market Data']['Template'] or "Hire Someone" in ord1['Market Data']['Template'] or "Find Job" in ord1['Market Data']['Template'] or "Barter" in ord1['Market Data']['Template'] or "Python" in ord1['Market Data']['Template']:
                        conv=""
                        Dif2=1
                        if usd!="" and usd!=" ":
                            if "Coins" in ord1['Market Data']['Template']:
                                st=str(int(Decimal(ord1['amount'])/Decimal(1e8)*Decimal(ord1['Market Data']['rate'])*Dif*Decimal(100)))#Remove Dif if if tracking usd
                            else:
                                if 'rate' in ord1['Market Data']:
                                    Dif2=Decimal(ord1['Market Data']['rate'])/Decimal(usd)
                                if ord1['Market Data']['tracking']==0 or ord1['Market Data']['Template']=='Barter':
                                    Dif2=1
                                    st=str(int(Decimal(ord1['amount'])/Decimal(1e8)*Decimal(usd)*Decimal(100)))
                                else:                            
                                    st=str(int(Decimal(ord1['amount'])/Decimal(1e8)*Decimal(usd)*Dif2*Decimal(100)))
                            st=str(Decimal(st)/Decimal(100))
                            conv=", $"+st
                        freq=""
                        if "Hire Someone" in ord1['Market Data']['Template'] or "Find Job" in ord1['Market Data']['Template']:
                            freq=ord1['Market Data']['Pay Frequency'] + ": "
                        window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(str(freq)+str(Decimal(int((Decimal(ord1['amount'])*Dif2)))/Decimal(1e8))+conv+", "+ord1['Market Data']['Payment Method']))#Divide by dif if tracking usd
                if items[pos2]=="Supply":
                    things=''
                    for thing in ord1['Market Data']['barteritems']['supply']:
                        if things != '':
                            things += ', '
                        things+=thing
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(things))
                if items[pos2]=="Demand":
                    things=''
                    for thing in ord1['Market Data']['barteritems']['demand']:
                        if things != '':
                            things += ', '
                        things+=thing
                    if things=='':
                        things='Anything'
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(things))
                if items[pos2]=="My Deposit" or items[pos2]=="Their Deposit":
                    conv=""
                    Dif2=1
                    if items[pos2]=="My Deposit":
                        depositamount=ord1['mydeposit']
                    else:
                        depositamount=ord1['theirdeposit']
                    if usd!="" and usd!=" ":
                        if 'rate' in ord1['Market Data']:
                            Dif2=Decimal(ord1['Market Data']['rate'])/Decimal(usd)
                        if ord1['Market Data']['tracking']==0:
                            Dif2=1
                            st=str(int(Decimal(depositamount)/Decimal(1e8)*Decimal(usd)*Decimal(100)))
                        else:                            
                            st=str(int(Decimal(depositamount)/Decimal(1e8)*Decimal(usd)*Dif2*Decimal(100)))
                        st=str(Decimal(st)/Decimal(100))
                        conv=", $"+st
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(str(Decimal(int((Decimal(depositamount)*Dif2)))/Decimal(1e8))+conv+", "+ord1['Market Data']['Payment Method']))#Divide by dif if tracking usd
                if items[pos2]=="Shipping":
                    ship=""
                    try:
                        ship = Decimal(ord1['Market Data']['shipping'])
                        ship = str(ord1['Market Data']['shipping']) + " Coins(included in amount)"
                    except:
                        ship = str(ord1['Market Data']['shipping'])
                    window.OfferTable.setColumnWidth(pos2,130)
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(ship))                
                if items[pos2]=="Service Charge":
                    window.OfferTable.setColumnWidth(pos2,130)
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem("%" + str(dropzeros((Decimal(ord1['Market Data']['service'])-1)*100,1))))
                if items[pos2]=="Funding Methods":
                    window.OfferTable.setColumnWidth(pos2,130)
                    dat=""
                    if ord1['Market Data']['Profiles']['Bank']!=[]:
                        dat+="Bank Wire"
                    if ord1['Market Data']['Profiles']['WU']!=[]:
                        if dat!="":
                            dat+=", "
                        dat+="Western Union"
                    if ord1['Market Data']['Profiles']['MG']!=[]:
                        if dat!="":
                            dat+=", "
                        dat+="MoneyGram"
                    if ord1['Market Data']['Profiles']['Card']!=[]:
                        if dat!="":
                            dat+=", "
                        dat+="Prepaid Debit Card"
                    if ord1['Market Data']['Profiles']['Cash']!=[]:
                        if dat!="":
                            dat+=", "
                        dat+="Cash In The Mail"
                    if ord1['Market Data']['Profiles']['Other']!=[]:
                        if dat!="":
                            dat+=", "
                        dat+="Other"
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(dat))
                if items[pos2]=="Contact":
                    st=""
                    if "BM-" in ord1['Market Data']['Preferred']:
                        st="Bitmessage"
                    if "@" in ord1['Market Data']['Preferred']:
                        st="Email"
                    if "BM-" not in ord1['Market Data']['Preferred'] and "@" not in ord1['Market Data']['Preferred']:
                        st="Direct"
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(str(st)+"  "+ord1['theiraddress']))
                if items[pos2]=="Deposits":
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(str(ord1['Market Data']['style'])))
                if items[pos2]=="Duration":
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(str(ord1['timeout'])+ " Hours"))
                if items[pos2]=="Date":
                    t=ConvertDate(ord1['Market Data']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(str(t)))
                if items[pos2]=="Order Number":
                    window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(ord1['ordernumber']))
            except:
                window.OfferTable.setItem(pos, pos2, QtGui.QTableWidgetItem(""))
            pos2+=1
        pos+=1
    #window.OfferTable.resizeColumnsToContents()
    if mycolumns!=[]:
        pos = 0
        for width in mycolumns:
            window.OfferTable.setColumnWidth(pos,width)
            pos += 1
        CustomColumns=mycolumns
    if Markets['Sort']!=[0,0]:
        window.OfferTable.setSortingEnabled(True)
        if Markets['Sort'][0]<2:
            window.OfferTable.sortItems(Markets['Sort'][1],QtCore.Qt.AscendingOrder)
        else:
            window.OfferTable.sortItems(Markets['Sort'][1],QtCore.Qt.DescendingOrder)
        window.OfferTable.setSortingEnabled(False)
        try:
            pos=0
            col=window.OfferTable.columnCount()-1
            for ord1 in showlist:
                ordernum=str(window.OfferTable.item(pos,col).text())
                if ordernum in rowheights:
                    window.OfferTable.setRowHeight(pos, rowheights[ordernum][1])                      
                else:
                    window.OfferTable.setRowHeight(pos, 70)
                pos+=1
        except:
            traceback.print_exc()
    #window.OfferTable.blockSignals(False)
    window.OfferTable.horizontalHeader().sectionResized.connect(window.fitToTable)

def PopulateHistory():
    global HistoryDetail
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    window.FullHistory.blockSignals(True)
    window.FullHistory.verticalHeader().setVisible(False)
    if multisig not in HistoryDetail:
        HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
    i=0
    for d in HistoryDetail[multisig]:
        i+=1
    window.FullHistory.setRowCount(i)
    i=0
    for d in HistoryDetail[multisig]:
        pend=0
        window.FullHistory.setItem(i, 0, QtGui.QTableWidgetItem(d['Label']))
        newitem = QtGui.QTableWidgetItem(str(d['Type']))
        window.FullHistory.setItem(i, 2, QtGui.QTableWidgetItem(str(d['Amount'])))
        if 'Pending' in d['Details']:
            if d['Details']['Pending']==True:
                pend=1
        if 'date' in d['Details']:
            t=ConvertDate(d['Details']['date'],1)
            t=t.strftime('%m/%d/%Y')
            if pend==1:
                window.FullHistory.setItem(i, 3, QtGui.QTableWidgetItem(str("Pending    Click for more detals...")))
            else:
                window.FullHistory.setItem(i, 3, QtGui.QTableWidgetItem(str("Date: "+str(t)+"   Click for more detals...")))
        else:
            window.FullHistory.setItem(i, 3, QtGui.QTableWidgetItem(str(d['Details'])))
        app.processEvents()
        if d['Type']!='' and d['Type']:
            if d['Type']=="Exotic":
                newitem.setTextColor(QtGui.QColor(150,75,20))
            if d['Type']=="Change":
                newitem.setTextColor(QtGui.QColor(50,50,75))
            if d['Type']=="Spent":
                newitem.setTextColor(QtGui.QColor(110,18,18))
            if d['Type']=="Pay To Email":
                newitem.setTextColor(QtGui.QColor(110,110,110))
            if d['Type']=="Received":
                newitem.setTextColor(QtGui.QColor(18,110,18))
            if d['Type']=="Two Step":
                newitem.setTextColor(QtGui.QColor(130,130,20))
            if d['Type']=="Contract":
                newitem.setTextColor(QtGui.QColor(18,18,110))
        window.FullHistory.setItem(i, 1, QtGui.QTableWidgetItem(newitem))
        i+=1
    window.FullHistory.blockSignals(False)
def PopulateOpen():
    window.MyOpenContracts.clear()
    #Sent
    global NewUser
    if NewUser != []:
        return
    for c in MyContracts:
        if c['type']=="CONTRACT":
            if c['status']=="Escrow":
                tex=""
                try:
                    hours_difference = ConvertDate(c['time'],1) - HaloTime
                    hours_difference = hours_difference.total_seconds()/3600.0
                    hours_difference = str(round(hours_difference, 2))
                except:
                    hours_difference = "Loading time..."
                try:
                    blocks_difference=str(c['blocks']-CurrentBlock)
                except:
                    blocks_difference=999999
                tex+="Order: "+c['ordernumber']+"  Notifications: " +c['Process'] + "  Time Remaining: " + hours_difference + "(hours) " +blocks_difference+ "(approximate blocks)" + "  Amount: " + str(c['amount']) + "  My Deposit: " + str(c['mydeposit']) + "  Their Deposit: " + str(c['theirdeposit']) + "  Their Address: "+c['TheirBMAddress']
                                
                newitem = QtGui.QListWidgetItem()
                newitem.setText(tex)
                try:
                    newitem.setIcon(DataIcon(str(c['mypublic']),1))
                except:
                    pass
                window.MyOpenContracts.addItem(newitem)
def PopulateContracts():
    PopulateOpen()
    PopulateContacts()
    window.MyPendingOffers.clear()
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    #Sent
    global NewUser
    if NewUser != []:
        return
    try:
        for c in Markets['Orders']:
            if c['status']=="offer" and 'Private' in c['Market Data'] and c['Market Data']['Private']==2 and multisig != c['theiraddress']:
                data=" Order number: " +str(c['ordernumber']) + "  Template: " + str(c['Market Data']['Template']) + "  Their Address: " + str(c['TheirBMAddress']) + "  Amount: " + str(Satoshis(c['amount'])) + "  My Deposit: " + str(Satoshis(c['mydeposit'])) + "  Their Deposit: " + str(Satoshis(c['theirdeposit'])) + "  Instant Refund: " + str(Satoshis(c['instantamount'])) + "  Time Limit: " + str(c['timeout'])
                tex="New Offer! - Click for description and actions: " + str(data)
                newitem = QtGui.QListWidgetItem()
                newitem.setTextColor(QtGui.QColor(0,100,0))
                newitem.setText(tex)
                try:
                    newitem.setIcon(DataIcon(str(c['mypublic']),1))
                except:
                    pass
                window.MyPendingOffers.addItem(newitem)
    except:
        traceback.print_exc()
        print "Error displaying market order"
    for c in MyContracts:
        try:#Here we add some style and signals for whose turn it is.
            newitem = QtGui.QListWidgetItem()
            newitem.setTextColor(QtGui.QColor(0,0,0))
            if 'lock' in c:
                if c['lock']=='1':
                    newitem.setTextColor(QtGui.QColor(0,100,0))
                else:
                    newitem.setTextColor(QtGui.QColor(0,0,0))
            else:
                newitem.setTextColor(QtGui.QColor(0,0,0))
            if c['status']=="Broadcast" or c['Process']=="Accept" or "Making" in c['Process']:
                newitem.setTextColor(QtGui.QColor(100,0,0))
            if c['Process']=="Cancel" or "Failed" in c['Process'] or "failed" in c['Process'] or "expired" in c['Process'].lower():
                newitem.setTextColor(QtGui.QColor(45,45,45))
            newitem.setIcon(DataIcon(str(c['mypublic']),1))
        except:
            pass #Certain objects like joint account offers trip an exception since they have no Process
            #traceback.print_exc()
        if c['type']=="CONTRACT":
            if c['status']=="Broadcast":
                data=" Order number: "+str(c['ordernumber']) + "  Their Address: " + str(c['TheirBMAddress']) + "  Amount: " + str(Satoshis(c['amount'])) + "  My Deposit: " + str(Satoshis(c['mydeposit'])) + "  Their Deposit: " + str(Satoshis(c['theirdeposit'])) + "  Instant Refund: " + str(Satoshis(c['instantamount'])) + "  Time Limit: " + str(c['timeout'])+  "  Who Broadcasts: "+str(c['Broadcast'])
                tex="Broadcasting transactions - Click for description and actions: " + str(data)
                newitem.setText(tex)
                window.MyPendingOffers.addItem(newitem)
            if c['status']=="offer":
                try:
                    data=" Order number: "+str(c['ordernumber']) + "  Their Address: " + str(c['TheirBMAddress']) + "  Amount: " + str(Satoshis(c['amount'])) + "  My Deposit: " + str(Satoshis(c['mydeposit'])) + "  Their Deposit: " + str(Satoshis(c['theirdeposit'])) + "  Instant Refund: " + str(Satoshis(c['instantamount'])) + "  Time Limit: " + str(c['timeout'])
                except Exception, e:
                    try:
                        data=" Order number: "+str(c['ordernumber']) + "  Their Address: " + str(c['theiraddress']) + "  Amount: " + str(Satoshis(c['amount'])) + "  My Deposit: " + str(Satoshis(c['mydeposit'])) + "  Their Deposit: " + str(Satoshis(c['theirdeposit'])) + "  Instant Refund: " + str(Satoshis(c['instantamount'])) + "  Time Limit: " + str(c['timeout'])
                    except:
                        data=""
                tex="Sent Offer - Click for actions: " + str(data)
                if c['Process']=="Cancel":
                    tex="Offer Cancelled - Click for actions: " + str(data)
                if c['Process']=="Market Order":
                    tex="Market Order: " + str(data)
                    newitem.setText(tex)
                    window.MyPendingOffers.addItem(newitem)
                    bestbid=[0,0]
                    for con in MyContracts:
                        try:
                            newitem = QtGui.QListWidgetItem()
                            if con['lock']=='1':
                                newitem.setTextColor(QtGui.QColor(0,100,0))
                            else:
                                newitem.setTextColor(QtGui.QColor(0,0,0))
                        except:
                            pass #P2M and some things may not have 'lock'
                        if 'oldordernumber' in con:
                            if con['oldordernumber']==c['ordernumber']:
                                if 'Market Data' in con:
                                    if 'StartingBid' in con['Market Data'] and 'Something' in con['Market Data']['Template']:
                                        if 'Sell' in con['Market Data']['Template']:
                                            if con['amount']>bestbid[0]:
                                                bestbid[0]=con['amount']
                                                bestbid[1]=len(window.MyPendingOffers)
                                        if 'Buy' in con['Market Data']['Template']:
                                            if con['amount']<bestbid[0] or bestbid[0]==0:
                                                bestbid[0]=con['amount']
                                                bestbid[1]=len(window.MyPendingOffers)                                            
                                data2=" Order number: "+str(con['ordernumber']) + "  Their Address: " + str(con['TheirBMAddress']) + "  Amount: " + str(Satoshis(con['amount'])) + "  My Deposit: " + str(Satoshis(con['mydeposit'])) + "  Their Deposit: " + str(Satoshis(con['theirdeposit'])) + "  Instant Refund: " + str(Satoshis(con['instantamount'])) + "  Time Limit: " + str(con['timeout'])
                                if con['Process']=="Market Offer":
                                    tex2="      Received Matching Offer from Market - Click for actions: " + str(data2)
                                    newitem.setText(tex2)
                                    window.MyPendingOffers.addItem(newitem)
                                if "MCount" in con['Process']:
                                    if con['lock']=='1':
                                        tex2="      Received Counter-Offer from Market - Click for actions: " + str(data2)
                                        if "MCount0" in con['Process']:
                                            if 'Market Data' in con:
                                                if "Coins" in con['Market Data']['Template']:
                                                    try:
                                                        if con['Market Data']['reply']['match']==1:
                                                            tex2="      Received Matching Bid/Offer from Market - Click for actions: " + str(data2)
                                                    except:
                                                        pass
                                                    tex2="      Received Bid/Offer from Market - Click for actions: " + str(data2)
                                        newitem.setText(tex2)
                                        window.MyPendingOffers.addItem(newitem)
                                    else:
                                        tex2="      Sent Counter-Offer - Click for actions: " + str(data2)
                                        newitem.setText(tex2)
                                        window.MyPendingOffers.addItem(newitem)
                    if bestbid[0]!=0:
                        window.MyPendingOffers.item(bestbid[1]).setText(str(window.MyPendingOffers.item(bestbid[1]).text()).replace('      ','      Best Offer! - '))
                found=0
                if "MCount" in c['Process']:
                    for con in MyContracts:
                        if con['ordernumber']==c['oldordernumber']:
                            found=1
                    if found==0:
                        if c['lock']=='1':
                            tex="Received Counter-Offer from Market - Click for actions: " + str(data)
                        else:
                            tex="Sent Counter-Offer - Click for actions: " + str(data)
                            if "MCount0" in c['Process']:
                                if 'Market Data' in c:
                                    if "Coins" in c['Market Data']['Template']:
                                        tex="Sent Bid/Offer - Click for actions: " + str(data)
                if c['Process']=="Market Accept":
                    tex="Market Offer: " + str(data)
                if c['Process']=="Making Transactions" or c['Process']=="Making Transactions PT2":
                    tex="Making transactions and sending to counter-party: " + str(data)
                if c['Process']=="Accept":
                    tex="Offer accepted! Sending information to counter-party: " + str(data)
                if 'Failed:' in c['Process']:#Usually it will say why
                    tex=c['Process']+str(c['Reason'])+"  Order number: "+str(c['ordernumber']) +" "
                if c['Process']=="Expired":
                    tex="Offer Expired - Click for actions: " + str(data)
                if c['Process']=='Handshake':
                    tex="Incoming Offer... requesting handshake - Click for actions: " +str(c['ordernumber'])
                if c['Process']=='Offer':
                    tex="Sent Offer... sent offer details awaiting response - Click for actions: " + str(data)
                if c['Process']=='Encrypted Message':
                    tex="Sent Offer... sent encrypted message with Email/Bitmessage address - Click for actions: " + str(data)
                if c['Process']=='Received':
                    tex="Received Offer! - Click for description and actions: " + str(data)
                if 'Counter' in c['Process']:#Ok but is it our turn?
                    if c['lock']=='1':
                        tex="Received Counter-Offer! - Click for description and actions: " + str(data)
                    else:
                        tex="Sent Counter-Offer... sent offer details awaiting response - Click for actions: " + str(data)
                if c['Process']!="Market Order" and c['Process']!="Market Offer" and found!=1:
                    newitem.setText(tex)
                    window.MyPendingOffers.addItem(newitem)
            if c['status']=="Pay To Email":
                data=" Order number: "+str(c['ordernumber'])+ "  Their Address: " + str(c['theiraddress']) + "  Amount: " + str(Satoshis(c['amount']))
                tex="Received Pay To Email! - Password requested: " + str(data)
                newitem.setText(tex)
                newitem.setTextColor(QtGui.QColor(100,0,100))
                window.MyPendingOffers.addItem(newitem)
            if 'Joint Account' in c['status']:
                data=" Order number: "+str(c['ordernumber'])+ "  Their Address: " + str(c['TheirBMAddress'])
                if c['status']=='Joint Account Offer2':
                    tex="Joint Account Confirmed! " + str(data)
                else:
                    tex="Joint Account Offer: " + str(data)
                newitem.setText(tex)
                newitem.setTextColor(QtGui.QColor(0,0,100))
                window.MyPendingOffers.addItem(newitem)
            if c['status']=='Joint 2 Step':
                data=" Order number: "+str(c['ordernumber'])+ "  Their Address: " + str(c['TheirBMAddress'])
                tex="Received Two Step Spend Request: " + str(data)
                newitem.setText(tex)
                newitem.setTextColor(QtGui.QColor(0,100,0))
                window.MyPendingOffers.addItem(newitem)
def PopulateContacts():
    window.ContactTable.clear()
    for o in OnOrders:
        if o['type']=="History":
            if "Contacts" in o:
                for Contact in o['Contacts']:
                    if "Self:" not in Contact['Name']:
                        display=""
                        display+="Name: " + Contact['Name'] + "  Address: " + Contact['Blackcoin Address'] + "  Bitmessage: " + Contact['Bitmessage Address'] + "  Email: " + Contact['Email Address']
                        window.ContactTable.addItem(str(display))
#Backup contracts
def SaveContracts():
    global MyContracts,OnOrders
    global FileSave
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    #Contract files might get big or memory intensive, its best to keep the queue compact
    add=0
    try:
        for d in FileSave.Queue:
            if 'SaveContracts' in d:
                add=1
    except:
        pass
    if add==0:
        FileSave.Queue.append({'SaveContracts':1,'Contracts':copy.deepcopy(MyContracts),'Orders':copy.deepcopy(OnOrders),'multisig':multisig})
#Other random data such as ordernumbers that were deleted
def SaveOtherdata():
    global FileSave
    add=0
    try:
        for d in FileSave.Queue:
            if 'SaveOther' in d:
                add=1
    except:
        pass
    if add==0:
        FileSave.Queue.append({'SaveOther':1,'DontRepopulate':copy.deepcopy(DontRepopulate),'EscrowResults':copy.deepcopy(EscrowResults),'WatchlistQueue':copy.deepcopy(WatchlistQueue),'HistoryDetail':copy.deepcopy(HistoryDetail),'AdvanceArray':copy.deepcopy(AdvanceArray),'Markets':copy.deepcopy(Markets)})
def GetEmailGlobals(myname="Self"):
    global MyEmail
    global EmailPassword
    global ManualPassword
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    for o in OnOrders:
        if 'Contacts' in o:
            for contact in o['Contacts']:
                if myname!="Self":#They want a specific name
                    if myname.replace("Self:","")==contact['Email Address'].replace("Self:",""):
                        return contact['Password']
                else:
                    if contact['Name'].replace("Self:","")==multisig:
                        if 'Password' in contact:
                            if AdvanceArray['MySettings']['ManualLogin']:
                                EmailPassword=ManualPassword
                            else:
                                EmailPassword=contact['Password']
                            MyEmail=contact['Email Address']
                            return
    EmailPassword=""
    MyEmail=""
def GetEmailPassword():
    global MyEmail, ManualPassword, BMHasPW, BitMRPC
    BMHasPW=False
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    GetEmailGlobals()
    if "@" in MyEmail:
        text=""
        try:
            if AdvanceArray['MySettings']['AntiLogger']:
                AntiLogger.reset()
                AntiLogger.setWindowTitle("Please enter your Email password:")
                AntiLogger.exec_()                
                text=str(AntiLogger.inputString)
            else:
                text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter your Email password:'), QtGui.QLineEdit.Password)
                text=str(text)
        except:
            text=""            
        if text=="":
            QuestionBox("Password was invalid or blank! You will need to authenticate/add your email again.", " OK ")
            ManualPassword="*"
        else:
            try:        
                providers=[{'@gmail': {'imap':'imap.googlemail.com','smtp':'smtp.googlemail.com','port':587,'SSL':0}},{'@hotmail':{'imap':'imap-mail.outlook.com','smtp':'smtp-mail.outlook.com','port':587,'SSL':0}}, {'@outlook':{'imap':'imap-mail.outlook.com','smtp':'smtp-mail.outlook.com','port':587,'SSL':0}},{'@aol.com':{'imap':'imap.aol.com','smtp':'smtp.aol.com','port':587,'SSL':0}}]
                username = str(MyEmail)
                foundit=0
                ret=True
                for prov in providers:
                    for key, val in prov.items():
                        pass
                    if key in username.lower():
                        foundit=1
                        imapname = prov[key]['imap']
                        smtpname = prov[key]['smtp']
                        port = prov[key]['port']
                        isSSL = prov[key]['SSL']
                        break
                try:
                    connection = smtplib.SMTP(smtpname, port)
                    connection.ehlo()
                    connection.starttls()
                    headers = ["from: " + username, "subject: " + "Test", "to: " + username,"mime-version: 1.0","content-type: text/html"]
                    headers = "\r\n".join(headers)
                    connection.login(username, text)
                    connection.close()
                except Exception, e:
                    try:
                        connection.close()
                    except:
                        pass
                    ret = False
                if ret==False:
                    print str(e)
                    QuestionBox(Gtranslate("Authentication failed. Please check your password and also please make sure your email is in the list of providers. Also you may need to enable imap/smtp/applications in your email. We recommend using gmail. If you have changed IP addresses or your location recently please check to see if your email provider denied the login.\n\nReply from server:\n")+str(e), Gtranslate("OK"),1)
                    window.EmailStatus.setText("")
                    ManualPassword="*"
                else:
                    QuestionBox(Gtranslate("Authentication success!"),Gtranslate("OK"),1)
                    ManualPassword=password.EncryptWithAES("Halo Master", text)
                    try:
                        BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')
                        res=BitMRPC.StorePassword(ManualPassword, "password")
                        if res==True:
                            BMHasPW=res
                    except:
                        pass
            except:
                traceback.print_exc()
        for o in OnOrders:
            if 'Contacts' in o:
                for contact in o['Contacts']:
                    if contact['Name'].replace("Self:","")==multisig:
                        contact['Password']="*"
        AntiLogger.setWindowTitle("Enter your password:")

def OpenOtherdata(returnthis=0):
    data=""
    data2=""
    data3=""
    data4=""
    data5=""
    data6=""
    with open(os.path.join(application_path,"Other.dat"),'a+') as f:
        f.close()
    if os.stat(os.path.join(application_path,"Other.dat"))[6]==0:
        with open(os.path.join(application_path,"Other.dat"),'w') as f:
            f.write("[]"+"\n")
            f.write("[]"+'\n')
            f.write("[]"+'\n')
            f.write("{}"+'\n')
            f.write("{}"+'\n')
            f.write("{}"+'\n')
            f.flush()
            os.fsync(f)
            f.close()
    with open(os.path.join(application_path,"Other.dat"),'r') as f:
        data=f.readline().strip()
        data2=f.readline().strip()
        data3=f.readline().strip()
        data4=f.readline().strip()
        data5=f.readline().strip()
        data6=f.readline().strip()
        f.close()
    if not data or data == "":
        data="[]"
    if not data2 or data2 == "":
        data2="[]"
    if not data3 or data3 == "":
        data3="[]"
    if not data4 or data4 == "":
        data4="{}"
    if not data5 or data5 == "":
        data5="{}"
    if not data6 or data6 == "":
        data6="{}"
    try:
        data=ast.literal_eval(data)
        data2=ast.literal_eval(data2)
        data3=ast.literal_eval(data3)
        data4=ast.literal_eval(data4)
        data5=ast.literal_eval(data5)
        data6=ast.literal_eval(data6)
    except:
        #Oh no! The file got corrupted. We can load a backup.
        with open(os.path.join(application_path,"OtherBackup.dat"),'a+') as f:
            f.close()
        if os.stat(os.path.join(application_path,"OtherBackup.dat"))[6]==0:
            with open(os.path.join(application_path,"OtherBackup.dat"),'w') as f:
                f.write("[]"+"\n")
                f.write("[]"+'\n')
                f.write("[]"+'\n')
                f.write("{}"+'\n')
                f.write("{}"+'\n')
                f.write("{}"+'\n')
                f.flush()
                os.fsync(f)
                f.close()
        with open(os.path.join(application_path,"OtherBackup.dat"),'r') as f:
            data=f.readline().strip()
            data2=f.readline().strip()
            data3=f.readline().strip()
            data4=f.readline().strip()
            data5=f.readline().strip()
            data6=f.readline().strip()
            f.close()
        if not data or data == "":
            data="[]"
        if not data2 or data2 == "":
            data2="[]"
        if not data3 or data3 == "":
            data3="[]"
        if not data4 or data4 == "":
            data4="{}"
        if not data5 or data5 == "":
            data5="{}"
        if not data6 or data6 == "":
            data6="{}"
    if returnthis==0:
        return data
    if returnthis==1:
        return data2
    if returnthis==2:
        return data3
    if returnthis==3:
        return data4
    if returnthis==4:
        return data5
    else:
        return data6

#We dont want messages to get interrupted so we much constantly save them until popped
def SaveQueue():
    global FileSave
    add=0
    try:
        for d in FileSave.Queue:
            if 'SaveQueue' in d:
                add=1
    except:
        pass
    if add==0:
        FileSave.Queue.append({"SaveQueue":1,"BitQueue":copy.deepcopy(BitQueue)})
def OpenQueue():
    with open(os.path.join(application_path,"BitQueue.dat"),'a+') as f:
        f.close()
    try:
        with open(os.path.join(application_path,"BitQueue.dat"),'r') as f:
            data=f.readline()
        f.close()
    except:
        data=[]
    if data=="" or data ==[]:
        return []
    data=ast.literal_eval(data)
    return data
def OpenTranslations():
    global translations
    with open(os.path.join(application_path,"Translations.dat"),'a+') as f:
        f.close()
    if os.stat(os.path.join(application_path,"Translations.dat"))[6]==0:
        with open(os.path.join(application_path,"Translations.dat"),'w') as f:
            f.write(str(translations))
            f.flush()
            os.fsync(f)
            f.close()
    with open(os.path.join(application_path,"Translations.dat"),'r') as f:
        data=f.readline().strip()
    try:
        translations=ast.literal_eval(data)
    except:
        pass
def SaveTranslations():
    global FileSave
    global translations
    add=0
    try:
        for d in FileSave.Queue:
            if 'SaveTrans' in d:
                add=1
    except:
        pass
    if add==0:
        FileSave.Queue.append({"SaveTrans":1,"translations":copy.deepcopy(translations)})
#Reverses binary order like found in blockchain.info (why they represent a backwards hash is not really stated in their api)
def ReverseHash(res):
    res=unhexlify(res)
    st= bytearray(res)
    st.reverse()
    return hexlify(st)
#Removes trailing zeros
def dropzeros(number, st=0):
    if st==1:
        return str(number).rstrip('0').rstrip('.') if '.' in str(number) else str(number)
    mynum = Decimal(number).normalize()
    # e.g 22000 --> Decimal('2.2E+4')
    return mynum.__trunc__() if not mynum % 1 else float(mynum)
#This returns a string without scientific notation under any circumstances.
#combine this below function with dropzeros setting st to 1 if you want to also remove trailing zeros
def remove_exponent(d,showstring=1):
    x=d.quantize(Decimal('.00000001')) if d == d.to_integral() else d.normalize()
    if showstring==1:
        return '{:f}'.format(x)
    else:
        return x
#Convert date and time to tuple and back for ast literal
def ConvertDate(Content, setting):
    if setting==0:#Convert to a tuple
        HDict={}
        HDict['time']=Content
        s=str(HDict)
        r = re.search(r"""datetime(\((\d+)(,\s*\d+)*\))""", s)
        if r:
            return ast.literal_eval(r.group(1))
        else:
            return False
    if setting==1:#And back
        return datetime.datetime(*Content)
def addmonths(m,x):
    i=0
    while i<m:
        try:
            x = (x.replace(day=1) + datetime.timedelta(days=31)).replace(day=x.day)
        except ValueError:  # January 31 will return last day of February.
            x = (x + datetime.timedelta(days=31)).replace(day=1) - datetime.timedelta(days=1)
        i+=1
    return x
#Sending to the Bitcoin network
def sendBTCtx(tx):
    global BitcoinCASH
    try:
        if BitcoinCASH:
            #For BitcoinSV do as follows:
            #POST https://api.whatsonchain.com/v1/bsv/<network>/tx/raw
            url="https://rest.bitcoin.com/v2/rawtransactions/sendRawTransaction/"
            rspns = requestURL(url+str(tx))
            response=str(rspns)
            #rspns = rpost("https://cashexplorer.bitcoin.com/insight-api/tx/send",{'rawtx':tx})
            #response=rspns.text
            try:
                response = json.loads(response)
                if 'txid' in response:
                    rspns=str(response['txid'])
                else:
                    float('a')
            except:
                traceback.print_exc()
                print str(rspns.text)
                float('a')
        else:
            #Manual submission
            #print str(tx)
            #w=m.getch()
            #if w=="d":
            #    print str(txhash(str(tx)))
            #else:
            #    float('a')
            #rspns = str(txhash(str(tx)))
            if True:
                #Might need cloudflare-scrape to make blockexplorer api work
                url='https://blockexplorer.com/api/tx/send'
                rspns = rpost(url,{'rawtx':tx}).text
                print str(rspns)
                if "txid" not in str(rspns).lower():
                    if False:#Need new custom electrum library
                        rspns = ea.send_tx(tx)
                    else:
                        rspns = False
                if rspns == "" or rspns == False or " fail" in str(rspns).lower():
                    try:
                        text=str(pybit2.bci.bci_pushtx(tx))
                        if "submitted" in text.lower():
                            rspns=txhash(tx)
                            print "Transaction submitted"
                        else:
                            rspns="TX rejected"
                    except:
                        traceback.print_exc()
                        rspns="TX rejected"
                    #rs = blockcypher.pushtx(tx_hex=tx)
                    pass
                if " fail" in str(rspns).lower():
                    print str(rspns)
                    rspns = "TX rejected"
                if rspns == "" or rspns == False: #If it's False it means no connections were made. We can potentially fall back on blockchain.info pybit.pushtx commands in chainz. May need to read responses differently.
                    print str(rspns)
                    if rspns != False:
                        rspns = "TX rejected"
                    else:
                        rspns = "TX rejected: Failed to connect to any electrum server! Please try again later."
                #Some nodes say things like "transaction submitted" or can vary their responses. So best to not assume you will get a hash on a good TX.
                #if "TX rejected" not in rspns:
                #    if len(rspns) < 35 or len(rspns) > 96: #Hashes are supposed to be 64 characters in length, what is the server trying to say?
                #        print "Potentially not a hash returned in response message: ", str(rspns)
                #        rspns = "TX rejected"
                #    else:
                #        pass
    except:
        rspns = "TX rejected"
    if "rejected" in str(rspns):
        print str(tx)
    return rspns

#Splash screen while waiting.
def NetSplash(showsplash=1, lockthings=1, waitforthreads=1, checkwait=0, timelimit=1000, nogui=0, ld2=0):
    try:
        global SilenceUI
        global LockTHIS, lockdownload, lockdownload2, isdownloading
        global txsplash, iswaiting
        if checkwait==0:
            iswt=1
            iswt2=1
        else:
            iswt=0
            iswt2=iswaiting
        timeit=0
        busy=0 
        if showsplash==1:
            if SilenceUI == 1 or SilenceUI == 2:
                pass
            else:
                if nogui==0:
                    txsplash.show()
                    txsplash.repaint()
            if waitforthreads==0:
                return busy
        else:
            txsplash.hide()
            if lockthings == 1:
                lockdownload=0
                if ld2==1:
                    lockdownload2=0
                LockTHIS.pop('AP', None)            
            return busy   
        while 'BM' in LockTHIS or 'DL' in LockTHIS or 'BL' in LockTHIS or isdownloading==1 or iswt2==0:
            time.sleep(.01)
            timeit+=1
            if iswt==0:
                if timeit%10==0:
                    iswt2=iswaiting
            if timeit>timelimit:
                busy=1
                print str(LockTHIS)
                print str(iswt2)
                print str(iswt)
                break
        #You could try locking things if you want
        if 'BM' not in LockTHIS and 'DL' not in LockTHIS and 'BL' not in LockTHIS and isdownloading!=1 and iswt2==1:     
            if lockthings == 1:
                lockdownload=1
                if ld2==1:
                    lockdownload2=1
                LockTHIS['AP']=1
        return busy
    except:              
        return busy

#For locktime scripts
def serializeTime(txobj):
    o=encode(txobj,256,4)[::-1].encode('hex')
    return o

#For decoding locktime scripts
def deserializeTime(txobj):
    txobj = txobj.decode('hex')
    pos = [0]
    pos[0] += 4
    return decode(txobj[pos[0]-4:pos[0]][::-1],256)

#For finding the length of a payload
def hexlen(data):
    x= str(hex(len(data)/2))[2:]
    if len(x)==1:
        x="0"+x
    return x

#Freezing script based on a p2sh
def FreezeScript(freezetime, addressScript):
    encTime = serializeTime(int(freezetime))
    #deserializeTime(encTime.decode('hex'))
    #OP_2,BYTES of key to push, key1, BYTES of key to push, key2, OP_2(2 of 2), CHECKMULTISIG (ae)    
    lockscript = hexlen(encTime)+encTime+"b175"+addressScript
    return lockscript
def TimelockScript(locktime, before, after):
    global timestamp
    encTime = serializeTime(int(locktime))    
    #Maybe eventually the locktime can be relative and thus exclusive to the new recipient
    if CoinSelect['checksequenceverify']==True:
        encTime2 = serializeTime(abs(int(locktime-timestamp)))
        sequencescript=hexlen(encTime2)+encTime2+"b275"
    #Note that the if/else are conditionals and we haven't specified any condtional(it would go before the if statement). So users must send true or false to activate before/after
    lockscript = "63"+before+"67"+hexlen(encTime)+encTime+"b175"+after+"68"
    return lockscript
def ScriptFromPubs(pubs):
    #For now, this assumes standard uncompressed multisig pubs
    if len(pubs)==2:
        thescript="52"+"41"+pubs[0]+"41"+pubs[1]+"52"+"ae"
    return thescript

#This function is for broadcasting the funding transaction and getting its txid (tx3). The raw transaction is usually signed manually.
def broadcast_contract_to_network(ins,outs,sigs,pub1,pub2, pub3, pub4,sigs2, timest, skipbroadcast=0):#The accepting party signed at position one by the way. Pub1 and Pub2 are receiving party
    if sigs!=[]:
        msigaddr, mscript = create_multisig_from_publics(pub1,pub2)
    msigaddr2, mscript2 = create_multisig_from_publics(pub3,pub4)
    pos=0
    if BitHaloClient==True:
        finaltx = pybit.transaction.mktx(ins,outs)
        if sigs!=[]:
            finaltx = pybit.transaction.apply_multisignatures(finaltx,pos,mscript,sigs)#The position of the inputs can be looked up by address or in this case we know its position
            pos+=1
        if sigs2!=[]:
            finaltx = pybit.transaction.apply_multisignatures(finaltx,pos,mscript2,sigs2)
    else:
        finaltx = mktx(timest, ins,outs)
        if sigs!=[]:
            finaltx = apply_multisignatures(finaltx,pos,mscript,sigs)#The position of the inputs can be looked up by address or in this case we know its position
            pos+=1
        if sigs2!=[]:
            finaltx = apply_multisignatures(finaltx,pos,mscript2,sigs2)
    if skipbroadcast == 0:
        if BitHaloClient:
            rspns = sendBTCtx(finaltx)
        else:
            try:
                rspns = BLK.sendrawtransaction(finaltx)
            except:
                rspns = "TX rejected"
    else:
        rspns=""
    return finaltx, rspns
#For advanced signatures
def create_sig_for_tx(inputs, outputs, priv, pub,pub2, timest):#If they try to sign this incorrectly it will return false
    msigaddr,mscript = create_multisig_from_publics(pub,pub2)
    makescript=0
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        makescript=1
    try:
        if BitHaloClient==False:
            if makescript==1:
                tmptx = mktx_script(timest, inputs,outputs)
            else:
                tmptx = mktx(timest, inputs,outputs)
        else:
            tmptx = pybit.transaction.mktx(inputs,outputs)
    except:
        return inputs, False
    #No password protection here at least for now
    #Need to loop through inputs and see which ones we have to sign... since its a normal tx we sign all of them anyway but its good practice
    txpos=0
    sigs=[]
    for d in inputs:
        if unicode(d['address'])==unicode(msigaddr):
            if BitHaloClient == True:
                sig = pybit.transaction.multisign(tmptx.decode('hex'),txpos,mscript.decode('hex'),priv)
            else:
                sig = multisign(tmptx.decode('hex'),txpos,mscript.decode('hex'),priv)
            sigs.append(sig)
            txpos+=1
    return sigs, True

def create_sig_for_redemption(inputs, outputs, uniqueid, dir1, timest, privme=0, tmptx="", pwtext="", splashme=0, unlockthis=""):
    global NEWTxidLookup, BitcoinCASH
    msigaddr,mscript = create_multisig_address(uniqueid,dir1)
    makescript=0
    for i in inputs:
        if i['output'] in NEWTxidLookup:
            if NEWTxidLookup[i['output']]!={}:
                makescript=1    
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        makescript=1
    if inputs!=[]:
        if tmptx=="":#For submitting special transactions like staking
            try:
                if BitHaloClient == True:
                    tmptx = pybit.transaction.mktx(inputs,outputs)
                else:
                    if makescript==1:
                        tmptx = mktx_script(timest, inputs,outputs)
                    else:
                        tmptx = mktx(timest, inputs,outputs)
            except:
                traceback.print_exc()
                if privme==1:
                    return inputs, False, ""
                return inputs, False
    if pwtext=="":
        priv,check=DecryptPrivateKey(uniqueid,dir1,"0", "", unlockthis)
        if check=="3":#Looks like the password was wrong
            if privme==1:
                return inputs, False, ""        
            return inputs, False
    else:
        priv,check=DecryptPrivateKey(uniqueid,dir1,"0",pwtext, "")
        if check=="3":#Looks like the password was wrong
            if privme==1:
                return inputs, False, ""        
            return inputs, False
    if priv=="Failed":#Looks like the password was wrong
        if privme==1:
            return inputs, False, ""    
        return inputs, False            
    #Need to loop through inputs and see which ones we have to sign... since its a normal tx we sign all of them anyway but its good practice
    txpos=0
    sigs=[]
    if splashme==1:
        NetSplash(1,0,0)
    for d in inputs:
        if d['address']==unicode(msigaddr):
            sigscript=mscript
            if d['output'] in NEWTxidLookup:#Exotic Spend
                if 'script' in NEWTxidLookup[d['output']]:
                    if NEWTxidLookup[d['output']]['txid']==d['output']:                        
                        sigscript=NEWTxidLookup[d['output']]['script']
            if BitHaloClient == True:
                if not BitcoinCASH:
                    sig = pybit.transaction.multisign(tmptx.decode('hex'),txpos,sigscript.decode('hex'),priv)
                else:
                    sig = pybit2.segwit.segwit_multisign(tmptx,txpos,sigscript,priv, d['value'], 65)
            else:
                sig = multisign(tmptx.decode('hex'),txpos,sigscript.decode('hex'),priv)
            sigs.append(sig)
            txpos+=1
    if splashme==1:
        NetSplash(0,0,0)            
    if privme==1:#this is for when we need the private key for signing market orders
        return sigs, True, priv
    return sigs, True

#This function is for broadcasting contracts with two public key files
def broadcast_tx_to_network(sigs,sigs2,inputs,outputs,pub1,pub2, timest, skipbroadcast=0):#Need to look at this correctly... pos is input position and sigs are applied in order
    #We would have recorded the position we had to sign in the sigs but in this case we know they are in the same order
    msigaddr, mscript = create_multisig_from_publics(pub1,pub2)
    makescript=0
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        makescript=1
    if BitHaloClient == True:
        tx = pybit.transaction.mktx(inputs,outputs)
    else:
        if makescript==1:
            tx = mktx_script(timest, inputs,outputs)
        else:
            tx = mktx(timest, inputs,outputs)
    pos=0
    for sigid1 in sigs:#sigid1 is the users signature. They check their open key that is loaded
        sigid2=sigs2[pos]
        mysigs=[]
        mysigs.append(sigid1)
        mysigs.append(sigid2)#We dont check for a swap we do everything in a specific order(although I may add an option for it)
        if BitHaloClient == True:
            tx = pybit.transaction.apply_multisignatures(tx,pos,mscript,mysigs)
        else:
            tx = apply_multisignatures(tx,pos,mscript,mysigs)
        pos+=1
    if skipbroadcast == 0:
        if BitHaloClient:
            rspns = sendBTCtx(tx)
        else:
            try:
                rspns = BLK.sendrawtransaction(tx)
            except:
                rspns = "TX rejected"
    else:
        rspns = ""
    pass #print "Electrum server sent back:",txhash(tx),"\n",rspns
    return tx, rspns

#This function is for basic braodcasting a normal send and combining signatures
def broadcast_to_network(sigs,sigs2,inputs,outputs,uniqueid1, timest, skipbroadcast=0, tx="", splashme=0):
    global NEWTxidLookup, AdvanceArray
    #We would have recorded the position we had to sign in the sigs but in this case we know they are in the same order
    msigaddr, mscript = create_multisig_address(uniqueid1)
    makescript=0
    involvedinputs=[]
    for i in inputs:
        if i['output'] in NEWTxidLookup:
            if NEWTxidLookup[i['output']]!={}:
                makescript=1
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        makescript=1
    if tx=="":
        if BitHaloClient == True:
            tx = pybit.transaction.mktx(inputs,outputs)
        else:
            if makescript==1:
                tx = mktx_script(timest, inputs,outputs)
            else:
                tx = mktx(timest, inputs,outputs)
    ps=0
    scriptchecks={}
    for i in inputs:
        if i['output'] in NEWTxidLookup:
            if 'script' in NEWTxidLookup[i['output']]:
                if NEWTxidLookup[i['output']]['txid']==i['output']:
                    scriptchecks[ps]=NEWTxidLookup[i['output']]['script']
                    meaning=translate_script(NEWTxidLookup[i['output']]['script'])
                    if meaning!={}:
                        if meaning['type']=='Switch' or meaning['type']=='Assured Destruction':
                            involvedinputs.append(i['output'])
                            #These shared inputs could be prone to double spend if the counter party fails to notify us.

        ps+=1
    pos=0
    #It should be noted that inputs are not checked for the matching address. That can be added
    for sigid1 in sigs:#sigid1 is the users signature. They check their open key that is loaded
        sigscript=mscript
        if pos in scriptchecks:
            sigscript=scriptchecks[pos]        
        sigid2=sigs2[pos]
        mysigs=[]
        mysigs.append(sigid1)
        mysigs.append(sigid2)
        if need_swap(get_ordered_pubkeys(uniqueid1)):
            mysigs.reverse()          
        if BitHaloClient == True:
            tx = pybit.transaction.apply_multisignatures(tx,pos,sigscript,mysigs)
        else:
            tx = apply_multisignatures(tx,pos,sigscript,mysigs)
        if pos in scriptchecks:
            try:
                meaning=translate_script(sigscript)
                if meaning['type']=='Switch' or meaning['type']=='Assured Destruction':
                    tx=deserialize(tx)
                    scrip=deserialize_script(tx['ins'][pos]['script'])
                    if meaning['before']==msigaddr and 'priorclaim' in meaning:                        
                        if meaning['hashbefore']!="":
                            if meaning['hashbefore'] in AdvanceArray['hashpasswords']:
                                if hash160(AdvanceArray['hashpasswords'][meaning['hashbefore']])==meaning['hashbefore']:
                                    sg=AdvanceArray['hashpasswords'][meaning['hashbefore']].encode('hex')
                                    scrip.insert(-1,sg)                                    
                                    scrip.insert(-1,81)
                        else:
                            scrip.insert(-1,81)
                    if meaning['destination']==msigaddr and 'priorclaim' not in meaning: 
                        if meaning['hashafter']!="":
                            if meaning['hashafter'] in AdvanceArray['hashpasswords']:
                                if hash160(AdvanceArray['hashpasswords'][meaning['hashafter']])==meaning['hashafter']:
                                    sg=AdvanceArray['hashpasswords'][meaning['hashafter']].encode('hex')
                                    scrip.insert(-1,sg)
                                    scrip.insert(-1,None)
                        else:
                            scrip.insert(-1,None)
                    tx['ins'][pos]['script']=serialize_script(scrip)
                    tx=serialize(tx)
            except:
                traceback.print_exc()            
        pos+=1
    if skipbroadcast == 0:
        if splashme==1:
            busy=NetSplash(1, checkwait=1)
            if 'pegging' in CoinSelect and CoinSelect['pegging'] and TestnetPeg:
                res=ThePeg.checktransaction(tx)
                rspns="TX rejected: " + str(ThePeg.valid)
                if res==False:
                    print str(tx)
                    return tx, rspns
        if BitHaloClient:
            if splashme==1:
                NetSplash(0)
            rspns = sendBTCtx(tx)            
        else:
            try:
                rspns = BLK.sendrawtransaction(tx)
                print txhash(tx)
                if splashme==1:
                    NetSplash(0)
            except:
                if splashme==1:
                    NetSplash(0)
                rspns = "TX rejected"
                exc=traceback.format_exc()
                if "CannotSendRequest" in str(exc):
                    rspns = "TX rejected: Network busy, try again later."
                else:                    
                    if involvedinputs !=[]:                        
                        #Potential double spend?! We don't add these inputs to the wallet to avoid compulsive rescan
                        #the other party may have failed to notify or they spent at the same time.
                        res=QuestionBox('Transaction Declined! However, because you are spending exotic inputs in this transaction it is possible the other party involved already spent one of your time locked inputs or failed to notify you. Make sure you are synchronized fully so you can get their notification. If you are synchronized you can wait a few minutes for the input to clear and try again. If you tried waiting and you are fully synchronized then choose more options.', ' I will try again later ', ' More options ')
                        if res==1:
                            res=QuestionBox('Another possibility is that the counter-party spent the time locked input using custom software and did not notify you. If you want, you can investigate the individual inputs. An investigation would require you to check manually and put the inputs in question on hold until the investigation completes.', ' Investigate the inputs ', ' I will try again later ')
                            if res==0:
                                for i in involvedinputs:
                                    for nkey, nvalue in NEWTxidLookup.iteritems():
                                        if 'script' in nvalue:
                                            if 'txid' in nvalue:
                                                if nkey != nvalue['txid']:                                                
                                                    AdvanceArray[msigaddr]['investigate'][nvalue['txid']]=True
                                QuestionBox('The exotic inputs in this transaction have been placed on hold. You should be able to spend normally again. You can investigate the inputs by clicking on them in the history tab.', 'OK')
                try:                    
                    print deserialize(tx)
                    traceback.print_exc()
                except:
                    print str(tx)
    else:
        rspns = ""
    return tx, rspns
#This is for an easy way to send what is in the mempool again
def ResendTransactions():
    try:
        mempool=BLK.getrawmempool()
        for m1 in mempool:
            res=BLK.sendrawtransaction(BLK.getrawtransaction(m1))
            print "Sent: ", str(res)
            time.sleep(1)
        return mempool
    except:
        traceback.print_exc()
        return False
def mktx_kernel(timex=time.time(), amount=0, script="", *args): # [in0, in1...] or in0, in1 ...
    ins, outs = [], []
    for arg in args:
            if isinstance(arg,list):
                    for a in arg: (ins if is_inp(a) else outs).append(a)
            else:
                    (ins if is_inp(arg) else outs).append(arg)
    txobj = { "version" : 1, "time" : int(timex), "ins" : [],"outs" : [], "locktime" : 0 }
    for i in ins:
            if isinstance(i,dict) and "outpoint" in i:
                    txobj["ins"].append(i)
            else:
                    if isinstance(i,dict) and "output" in i:
                            i = i["output"]
                            txobj["ins"].append({"outpoint" : { "hash": i[:64], "index": int(i[65:]) },"script": "","sequence": 4294967295})
    txobj["outs"].append({"script": "","value": 0})
    txobj["outs"].append({"script": script,"value": 0})
    return serialize(txobj), txobj
def mktx_script(timex=time.time(), *args): # [in0, in1...] or in0, in1 ...
    ins, outs = [], []
    #Instead of setting the maximum sequence number we set it to 0 and we set the locktime to an hour before the current time. This helps in case of lock times and leaves room to pad it for Bitcoins slower blocks.
    #Just remember to spend lock times we will want to do it an hour after it becomes possible to spend.
    for arg in args:
            if isinstance(arg,list):
                    for a in arg: (ins if is_inp(a) else outs).append(a)
            else:
                    (ins if is_inp(arg) else outs).append(arg)
    if BitHaloClient == True:
        txobj = { "version" : 1, "ins" : [],"outs" : [], "locktime" : int(timex)-10 }
    else:
        txobj = { "version" : 1, "time" : int(timex), "ins" : [],"outs" : [], "locktime" : int(timex)-10 }
    for i in ins:
            if isinstance(i,dict) and "outpoint" in i:
                    txobj["ins"].append(i)
            else:
                    if isinstance(i,dict) and "output" in i:
                            i = i["output"]
                            txobj["ins"].append({"outpoint" : { "hash": i[:64], "index": int(i[65:]) },"script": "","sequence": 0})
    for o in outs:
        try:
            if isinstance(o,str): o = {
                "address": o[:o.find(':')],
                "value": int(o[o.find(':')+1:])
            }
            txobj["outs"].append({
                "script": address_to_script(o["address"]),
                "value": o["value"]
            })
        except:
            txobj["outs"].append(o)
    #txobj["outs"].append({"script": script,"value": amount})
    return serialize(txobj)
def translate_script(myscript):
    global timestamp, PrivKeyFilename1
    msig,mscr = create_multisig_address(PrivKeyFilename1,PrivKeyFiledir1)
    meaning={}    
    try:
        scr=deserialize_script(myscript)
        if str(scr[0])=="106":            
            meaning['type']="Notary/Burn"
            if len(myscript)>2:
                meaning['message']=str(unhexlify(scr[1]))
            else:
                meaning['message']=""
        if str(scr[1])=="177" and str(scr[2])=="117":
            meaning['type']="Freeze"
            meaning['timestamp']=deserializeTime(scr[0])
            if meaning['timestamp']<timestamp:
                meaning['spendable']="Yes"
            else:
                meaning['spendable']="Frozen until " + str(datetime.datetime.utcfromtimestamp(meaning['timestamp'])) + " UTC"
            if str(scr[3])=="2" and str(scr[6])=="2" and str(scr[7])=="174" and len(scr)<9:
                mymscript=serialize_script([scr[3],scr[4],scr[5],scr[6],scr[7]])
                if BitHaloClient==False:
                    msigaddr = scriptaddr(mymscript.decode('hex'))
                else:
                    msigaddr = pybit.transaction.scriptaddr(mymscript.decode('hex'))
            else:
                msigaddr = " (address type unsupported by Halo) "
            meaning['destination']=msigaddr
            meaning['description']="These coins are frozen until " + str(datetime.datetime.utcfromtimestamp(meaning['timestamp'])) + " UTC and then the address " + msigaddr + " will be able to spend them."
        if str(scr[0])=="99" and str(scr[-1])=="104":#if/else exotic spend
            ExpectedLength=1            
            meaning['hashbefore']=""
            meaning['description']=""
            meaning['type']="Switch"
            offset=0
            #Hash puzzle should check size first OP_SIZE(CODE 130, hex 82) followed by max hash size, then
            #perhaps something like OP_LESSTHANOREQUAL(CODE 161, hex a1)
            if str(scr[1])=="169":#Hash Puzzle
                if str(scr[3])!="136":#Not scripted properly
                    print "Not 136"
                    float('a')
                meaning['hashbefore']=scr[2]
                offset+=3
            if str(scr[1+offset])=="2" and str(scr[4+offset])=="2" and str(scr[5+offset])=="174" and str(scr[6+offset])=="103":
                mymscript=serialize_script([scr[1+offset],scr[2+offset],scr[3+offset],scr[4+offset],scr[5+offset]])
                if BitHaloClient==False:
                    msigaddr = scriptaddr(mymscript.decode('hex'))
                else:
                    msigaddr = pybit.transaction.scriptaddr(mymscript.decode('hex'))                
            else:
                msigaddr = " (address type unsupported by Halo) "
                print "address not right"
                float("a")#Why bother if it is not supported
            if str(scr[6+offset])!="103":#Not for Halo
                print "Not 103"
                float('a')                
            ExpectedLength+=6#It can't just be a hash puzzle, there also needs to be a recipient
            meaning['timestamp']=deserializeTime(scr[ExpectedLength+offset])
            if str(scr[ExpectedLength+offset+1])!="177" and str(scr[ExpectedLength+offset+2])!="117":
                print 'Not 177'
                float('a')
            ExpectedLength+=3
            meaning['before']=msigaddr            
            pw=0
            if meaning['hashbefore']!="":
                pw=1
                if meaning['hashbefore'] in AdvanceArray['hashpasswords']:
                    if hash160(AdvanceArray['hashpasswords'][meaning['hashbefore']])==meaning['hashbefore']:
                        pw=0#We have this password
            meaning['spendable']="No"
            if meaning['timestamp']>timestamp:#Spendable before
                if CoinSelect['checksequenceverify']==True:
                    if msigaddr==msig:
                        if pw==1:
                            meaning['spendable']="Password locked: Funds will be available if the correct password is entered before " + str(datetime.datetime.utcfromtimestamp(meaning['timestamp'])) + " UTC"
                        else:
                            meaning['spendable']="Yes"
                            meaning['priorclaim']=True
            if CoinSelect['checksequenceverify']==False:
                if msigaddr==msig:
                    if pw==1:
                        meaning['spendable']="Password locked: Funds will be available if the correct password is entered before " + str(datetime.datetime.utcfromtimestamp(meaning['timestamp'])) + " UTC"
                    else:
                        meaning['spendable']="Yes"
                        meaning['priorclaim']=True                
            meaning['description']+="These coins are owned by " + msigaddr
            if meaning['hashbefore']!="":
                meaning['description']+=" if he solves a hash puzzle (password)"
            meaning['description']+=" before the expiration date. "
            meaning['description']+= "After " + str(datetime.datetime.utcfromtimestamp(meaning['timestamp'])) + " UTC then "
            meaning['hashafter']=""
            if str(scr[10+offset])=="106":#Burn
                if str(scr[11+offset])=="104":
                    #This feature can only work in relative locktime with checksequenceverify
                    meaning['type']="Assured Destruction"
                    meaning['destination']="Burn"
                    meaning['description']+="the coins are destroyed."
                    ExpectedLength+=2
                else:
                    print "Not 104"
                    float('a')
            else:
                if str(scr[10+offset])=="169":
                    if str(scr[12+offset])!="136":#Not scripted properly
                        print "not 2nd 136"
                        float('a')
                    meaning['hashafter']=scr[11+offset]
                    offset+=3         
                if str(scr[10+offset])=="2" and str(scr[13+offset])=="2" and str(scr[14+offset])=="174" and str(scr[15+offset])=="104":
                    mymscript=serialize_script([scr[10+offset],scr[11+offset],scr[12+offset],scr[13+offset],scr[14+offset]])
                    if BitHaloClient==False:
                        msigaddr = scriptaddr(mymscript.decode('hex'))
                    else:
                        msigaddr = pybit.transaction.scriptaddr(mymscript.decode('hex'))
                else:
                    msigaddr = " (address type unsupported by Halo) "
                    print "not 2nd address"
                    float('a')
                ExpectedLength+=6#It can't just be a hash puzzle, there also needs to be a recipient                    
                meaning['destination']=msigaddr
                if CoinSelect['checksequenceverify']==False:
                    meaning['description']+="the coins are also spendable by " + msigaddr
                else:
                    meaning['description']+="the coins are owned by " + msigaddr
                pw=0
                if meaning['hashafter']!="":
                    pw=1
                    if meaning['hashafter'] in AdvanceArray['hashpasswords']:
                        if hash160(AdvanceArray['hashpasswords'][meaning['hashafter']])==meaning['hashafter']:
                            pw=0#We have this password
                if meaning['timestamp']<timestamp and meaning['spendable']!="Yes":#Spendable after and we had no prior claim to the funds
                    if msigaddr==msig:
                        if pw==1:
                            meaning['spendable']="Password locked: Funds will be available if a password is entered before " + str(datetime.datetime.utcfromtimestamp(meaning['timestamp'])) + " UTC"
                        else:
                            meaning['spendable']="Yes"
                if meaning['hashafter']!="":
                    meaning['description']+=" if he solves a hash puzzle (password)"                            
            if len(scr) != ExpectedLength+offset:#We cannot have them adding anything at the end of the script.
                print "Not Expected ",ExpectedLength+offset
                float('a')
    except:
        meaning={}
        traceback.print_exc()
        print traceback.extract_stack()
        print "Exotic script cannot be translated"
    return meaning
def SignCode(code):
    priv,check=DecryptPrivateKey(PrivKeyFilename1, PrivKeyFiledir1,"0", "", "1")
    if check=="3":
        QuestionBox("Incorrect Password!", " OK ")
        return
    try:
        db=[]
        if os.path.exists(os.path.join(application_path, 'codeSignatures.dat')):
            with open(os.path.join(application_path, 'codeSignatures.dat'),'r') as fi:
                db=ast.literal_eval(fi.readline().strip())
                fi.close()
        for mycode in code: #Code should be sent in list format so multiple files can be signed
            sig = sign(txhash(mycode), priv)
            sig = binascii.hexlify(sig)
            db.append([txhash(mycode),sig,privtopub(priv)])
        with open(os.path.join(application_path, 'codeSignatures.dat'),'w') as fi:
            fi.writelines(str(db))
            fi.flush()
            os.fsync(fi)
            fi.close()
    except:
        QuestionBox("Signature Failed!"," OK ")
        return False
    QuestionBox("The code has been signed and saved!", " OK ")
    return True
def validateCode(code):
    try:
        if os.path.exists(os.path.join(application_path, 'codeSignatures.dat')):
            with open(os.path.join(PrivKeyFiledir1, PrivKeyFilename1), 'r') as fi:
                x=fi.readline().strip()
                pub1=fi.readline().strip()
                pub2=fi.readline().strip()
                fi.close()
            with open(os.path.join(application_path, 'codeSignatures.dat'),'r') as fi:
                db=ast.literal_eval(fi.readline().strip())
                fi.close()
            for val in db:
                if val[2]==pub1 or val[2]==pub2:
                    if val[2]==pub1:
                        mypub=val[2]
                    if val[2]==pub2:
                        mypub=val[2]
                    if val[0]==txhash(code):
                        cipher = verify(txhash(code), binascii.unhexlify(val[1]), mypub)
                        if cipher:
                            return code
    except:
        traceback.print_exc()
    print "Code validation failed: " + str(txhash(code))
    return False    
#we assume: exactly two signatures are applied, which can be any
#of buyer,seller and escrow. If the order in which they are provided is
#different to that used to create the multisig address, swap is needed so
#returns True... although this function may need to be looked at more carefully
#Perhaps in the future just mark it in the file. For now if sending is rejected
#we can simply send again with the sigs reversed.
def need_swap(pubs, key1="",dir1=""):
    pos = {}
    if key1=="":
        key1=PrivKeyFilename1
    if dir1=="":
        dir1=PrivKeyFiledir1
    try:
        f = os.path.join(strOUT(dir1),strOUT(key1))
        if ".jpg" in f or ".jpeg" in f or ".png" in f:
            data=LoadHiddenImage(f)
            pos['2']=pubs.index(data[1].strip())
            pos['1']=pubs.index(data[2].strip())
            if pos['1']>pos['2']:
                return True
            return False
        else:
            with open(f,'r') as fi:
                fi.readline()
                pub=fi.readline().strip()
                pos['2']=pubs.index(pub)
                pub=fi.readline().strip()
                fi.close()
                pos['1']=pubs.index(pub)
                if pos['1']>pos['2']:
                    return True
                return False
    except:
        traceback.print_exc()
        return None

#This function is to find out if our key signs first based on how the public keys were arranged. Need to know this or else future txids are invalid and will be rejected
def AmIFirst(dir1,key):
    f = os.path.join(dir1,key)
    if ".jpg" in f or ".jpeg" in f or ".png" in f:
        data=LoadHiddenImage(f)
        if data[2].strip()<data[1].strip():
            return 1
        else:
            return 0
    else:
        with open(f,'r') as fi:
            data=fi.readlines()
            fi.close()
        if data[2].strip()<data[1].strip():
            return 1
        else:
            return 0
#Check exceptions with internet. Todo: test Tor and proxies to make sure everything is compatible
#Note to developers: This library relies on electrum and pybitcoin tools. Maybe future versions will include local blockchain storage
def internet_on():
    global internetcheck
    if internetcheck==0:
        try:
            response=requestURL('https://just-the-time.appspot.com/')
            return True
        except:
            internetcheck=1
        try:
            response=requestURL('https://ip.42.pl/raw')
            return True
        except:
            pass
    elif interneton==1:
        try:
            response=requestURL('https://ip.42.pl/raw')
            return True
        except:
            internetcheck=2
        try:
            response=requestURL('https://www.duckduckgo.com/')
            return True
        except:
            pass
    else:
        try:
            response=requestURL('https://www.duckduckgo.com/')
            return True
        except:
            internetcheck=0
        try:
            response=requestURL('https://just-the-time.appspot.com/')
            return True
        except:
            pass
    return False

###########################################################
#This section is for change functions, encryption and database handling for making change and contracts
#Here is a set of 3 functions used to encrypt and decrypt address from a 20 bit string
def hash_to_address(version, hash1):
    vh = version + hash1
    return base58.b58encode(vh + double_sha256(vh)[:4])
def decode_address(addr):
    mybytes = base58.b58decode(addr, None)
    if len(mybytes) < 25:
        mybytes = ('\0' * (25 - len(mybytes))) + mybytes
    return mybytes[:-24], mybytes[-24:-4]

def double_sha256(s):
    return SHA256.new(SHA256.new(s).digest()).digest()
#Here we make fake outputs for an encrypted message
def MakeCipherOutputs(xhex, burn=0):
    #Now we split the hex into lengths of 20. Each address will be sent one Satoshi(or the minimum for spam on the network).
    j=0
    mystr=""
    outs=[]
    if burn==1:
        text=hexlify(xhex[:(CoinSelect['6aLength'])])
        hexleng=num_to_var_int((len(text)/2)).encode('hex')
        if len(xhex)>75:
            hexleng="4c"+hexleng
        outs.append(str("6a"+hexleng+text))
        return outs
    for h in xhex:
        j+=1
        mystr+=h
        if j ==20:
            j=0
            addr=hash_to_address(("55").decode('hex'),mystr)#This can only be a maximum of twenty bits
            mystr=""
            outs.append(addr)
    #Check to see if there is a partial string. This will also be a valid address
    if mystr!="":
        length = len(mystr)
        while len(mystr)<20:#Pad it on the end
            mystr+="*"
        addr=hash_to_address(("55").decode('hex'),mystr)
        outs.append(addr)
    return outs
#Here we decode all the addresses from a list of addresses and add them to a string
def DecodeCipherOutputs(outs, burn=1):
    #We now only need to strip the zeros and ones out of the outputs
    output=""
    if burn==1:
        for out in outs:
            try:
                scr=deserialize_script(out)
                if str(scr[0])=="106":            
                    output=str(unhexlify(scr[1]))
                    break
            except:
                pass
        return output
    for out in outs:
        version, hash1 = decode_address(out)
        output +=hash1
    return output
#Here we can put a script in a burn for notifications
def ConvertScriptToOuts(myscript):
    leng=len(myscript.encode('utf-8'))
    leng=(Decimal(leng)/Decimal((CoinSelect['6aLength']-2))).quantize(Decimal('1'), rounding=ROUND_UP)
    outs=[]
    i=0
    while i<leng:
        text=myscript[:(CoinSelect['6aLength']-2)]
        myscript=myscript.replace(text,"",1)
        if myscript != "":
            text="*"+text+"*"
        else:
            text="*"+text+"#"
        hexscr=hexlify(text)        
        hexleng=num_to_var_int((len(hexscr)/2)).encode('hex')
        if len(text)>75:
            hexleng="4c"+hexleng
        outs.append({'value':5576,'script':"6a"+hexleng+hexscr})
        i+=1
    #Unfortunately many coins have rules saying you can add only one 6a per output however because we
    #can store more in 6a, we should simply add outputs
    #hash_to_address(("55").decode('hex'),"11111111111111111111") is how you generate this burn address
    x = len(outs)
    y = 0
    while y < x:
        outs.append({'value':5578,'address':"bHDNjZWrz8kZWBEqtLLJQybLEbv1EDQSGJ"})
        y+=1
    return outs
def DecodeScriptFromOuts(outs):
    try:
        myscript={}
        thescript=""
        for out in outs:
            #text=unhexlify(out['script'][4:])
            text=deserialize_script(out['script'])
            text=unhexlify(text[1])
            if text[0]=="*":
                if text[-1:]=="#" or text[-1:]=="*":
                    thescript+=text[:-1][1:]
            if text[-1:]=="#":
                break
        if thescript!="":
            myscript['script']=thescript
        return myscript
    except:
        return {}
def script_to_address2(script,vbyte=0):#for magic bytes on BIP0016
    try:
        scr=deserialize_script(script)
        if len(scr)==2 and scr[1]==172:
            return pubkey_to_address(scr[0],25)
    except:
        pass
    if re.match('^[0-9a-fA-F]*$',script):
        script = script.decode('hex')
    if script[:3] == '\x76\xa9\x14' and script[-2:] == '\x88\xac' and len(script) == 25:
        return bin_to_b58check(script[3:-2],25) # pubkey hash addresses
    else:
        return bin_to_b58check(script[2:-1],vbyte) # BIP0016 scripthash addresses
#This function just finds the difference between two lists. Including duplicates. (It was useful during tests)
def list_difference(a, b):
    count = Counter(a) # count items in a
    count.subtract(b)  # subtract items that are in b
    diff = []
    for x in a:
        if count[x] > 0:
            count[x] -= 1
            diff.append(x)
    return diff

#This function filters the orders from the spendable list and returns it as a new list
def FilterSpendable(orders,spend, filterexotic=0, filterfrozen=1):
    global OnOrders, Spendable, PrivKeyFilename1, timestamp
    multisig,mscript=create_multisig_address(PrivKeyFilename1)
    neworders=list(orders)
    spnd=json_deep_copy(spend)
    pos=-1
    for x in neworders:
        pos+=1
        if x['type']=="Spendable" or x['type']=="History":#This is just the full array we dont want to filter this
            neworders.pop(pos)
            break
    pos=-1
    for x in neworders:
        pos+=1
        if x['type']=="Spendable" or x['type']=="History":#This is just the full array we dont want to filter this
            neworders.pop(pos)
            break
    orders=list(neworders)
    filterthis=[]
    for o in orders:
        for inp in o['inputs']:
            for s in spnd:
                if inp['output']==s['output']:
                    filterthis.append(s)
    for s in spnd:
        if s['output'] in NEWTxidLookup:
            if NEWTxidLookup[s['output']]!={}:
                if filterexotic==0:
                    try:
                        meaning=translate_script(NEWTxidLookup[s['output']]['script'])
                        if meaning['spendable']!="Yes":
                            if NEWTxidLookup[s['output']]['txid'] in AdvanceArray[multisig]['ignorelist']:#They might want to clear it
                                if s['output']==NEWTxidLookup[s['output']]['txid']:                                    
                                    filterthis.append(s)                
                            else:
                                filterthis.append(s)
                        else:
                            if NEWTxidLookup[s['output']]['txid'] in AdvanceArray[multisig]['ignorelist']:#They wanted to clear this, it might be a double spend
                                if s['output']==NEWTxidLookup[s['output']]['txid']:                                    
                                    filterthis.append(s)                             
                    except:
                        pass
                else:
                    filterthis.append(s)
        if filterfrozen==1:
            if 'liquidity' in s:
                if 'frozen' in s['liquidity']:
                    if s['liquidity']['frozen']>timestamp-43200:
                        filterthis.append(s)


    length=0
    for d in spnd:
        length+=1
    i=0
    while i<length:
        next1=0
        for d in filterthis:
            try:
                gotdata = spnd[i]
            except IndexError:
                break
            if spnd[i]==d:
                spnd.remove(spnd[i])
                length=length-1
                next1=1 #don't go to the next input
        if next1 != 1:
            i=i+1
    return spnd

#This is a critical function for creating change outputs to the same address. Insead of using change addresses, BlackHalo refers to outputs that
#It conveniently chops into various denominations of bills. This is amazingly useful for multiple purchases, multiple contracts etc. Since Bitcoin
#is forced to spend 100% of every output, there is always change. In order to make lots of contracts, we need there to be lots of different sizes
#of outputs to work with. Whenever an output is allocated for a contract, we add it to a list so that it can't be spent.
def MakeChange (inputs, purchaseamount, myaddress, MAXINPUTS=25, mybuffer=0, specialtx=0):#in satoshis... it should also include the fee
    global AdvanceArray, PrivKeyFilename1
    global GlobalMaxInputs
    if GlobalMaxInputs!='':
        MAXINPUTS=GlobalMaxInputs
    multisig,mscript=create_multisig_address(PrivKeyFilename1)
    #check for minimum add input, consider higher denom than 50,000 make sure that added amounts dont go over available balance(is that already in play?)
    #This is the list of denominations if the inputs don't match the number they will be used as outputs and get lumped together. This way, there is a simple, managable system of change for version 1.0
    #The client designates a maximum of 10 for each denomination. We try to spend the loose change first. If its not enough we start from low to high until an output is higher and spend it.
    #The denominations and change protocol is not set in stone. However, this lays a foundation for a single wallet change system. Also it makes things easier for joint accounts since there is less confusion over multiple accounts and keys.
    Maxdenom = 10 #May be useful for later if we want more or less loose change
    if BitHaloClient==True:
        denom = (50000, 100000,500000,1000000,5000000,10000000,50000000,100000000,500000000, 1000000000, 5000000000)
        MAXSIZE=5000000000
    else:
        denom = (50000000,100000000,500000000,1000000000,5000000000,10000000000,50000000000,100000000000,500000000000,1000000000000,5000000000000)
        MAXSIZE=5000000000000
    DenomCount = [0,0,0,0,0,0,0,0,0,0,0]
    global Spendable
    Spendthis=[]
    Total=0
    Total2=0
    TempTotal=[0,0,0,0,0,0,0,0,0,0,0]
    denominations=json.loads(json.dumps(inputs)) #We filtered the inputs that were on orders somewhere else. We will make sure to add the new inputs to open orders at some point
    denominations = sorted(denominations, key=lambda k: k['value'])
    #This next part creates a sort of penny jar out of all the odd denominations. It is used to combine any amounts that are not of a fixed size
    #This part also looks for denominations that can be made into larger bills. This may be fine tuned to meet the demand of all types of merchants
    changecount=0#Lets not do more than 25 inputs at once
    SpendDenom=[[],[],[],[],[],[],[],[],[],[],[]]
    for d in denominations:
        j=0
        val=d['value']
        found=0
        if changecount==MAXINPUTS:
            break
        for e in denom:
            j=j+1
            if found != 1:
                if val == e:
                    if val != MAXSIZE: #This is the max size so we can't change those anyway
                        found = 1
                        DenomCount[j-1] += 1 #Counting to make sure it is not over 5
                        if DenomCount[j-1] >  Maxdenom: #We throw it in the pool with the rest of the loose change. Eventually it will become a larger bill
                            pass #print "OVERTHELIMIT:",d,e
                            SpendDenom[j-1].append(d) #We are over the limit so lets try and change the smaller bills into larger bills. Most of the time it will come right back to us(lets keep it very transparent.)
                            changecount+=1
                            TempTotal[j-1] += val
                else:
                    if j == 11: #It seems the amount is not part of our denom change matrix. Lets consider spending it.
                        if val < MAXSIZE or val > ((MAXSIZE*2)+(MAXSIZE/10)):#Since lots of large inputs could be staking, lets only spend if it's a really large amount
                            Spendthis.append(d)
                            changecount+=1
                            Total += val
    #This just checks to see if there is actually anything to break for change... it does not discriminate for denominations because i wanted to keep the accounting easier to follow in 1.0
    pos=-1
    lead=0
    for i in SpendDenom: #I was getting errors in len so I just calculate it manually
        pos+=1
        l=0+lead
        lead=0
        keep=0
        for j in i:
            l+=1
            if l>4:#We can break for change
                keep=1
        if keep==0:
            SpendDenom[pos]=[]
            TempTotal[pos]=0
        else:
            lead=int(l/5)
    l=0
    for leng in Spendthis:
        l+=1
    if l<3: #For now, we will make change pretty frequently. This function maintains the health of the account too since many satoshis cant clog up the account.
        Spendthis=[]
        Total = 0
    pos=-1
    for d in SpendDenom:
        pos+=1
        for dd in d:
            Spendthis.append(dd) #There was at least 5 so we are making larger bills.
        Total+=TempTotal[pos]
    #Ok so now we reverse the tuple
    if BitHaloClient==True:
        denom = (5000000000, 1000000000,500000000,100000000,50000000,10000000,5000000,1000000,500000, 100000, 50000)
        MAXSIZE=5000000000
    else:
        denom = (5000000000000, 1000000000000,500000000000,100000000000,50000000000,10000000000,5000000000,1000000000,500000000, 100000000, 50000000)
        MAXSIZE=5000000000000
    #if NEWTxidLookup[d['output']]['txid'] not in AdvanceArray[multisig]['ignorelist']: #We don't have to check this because anything ignored will not be found
    #Check for exotic spend pairs. 5577 is reserved for exotic spend so those get spent in pairs if applicable
    pairs=[]
    for d in Spendthis:
        if d['output'] in NEWTxidLookup:                        
            for nkey, nvalue in NEWTxidLookup.iteritems():
                if 'script' in nvalue:            
                    if 'txid' in nvalue: 
                        if nvalue['txid']!=nkey:#We found the pair
                            addme=""
                            if nvalue['txid']==d['output']:
                                addme=nkey
                            if nkey==d['output']:
                                addme=nvalue['txid']
                            if addme!="":
                                for inps in denominations:
                                    if inps['output'] not in pairs and inps not in Spendthis:
                                        if inps['output'] == addme:
                                            Spendthis.append(inps)
                                            Total += inps['value']
                                            pairs.append(inps['output'])
    #Ok lets filter out the ones we plan on spending
    i=0
    length=0
    for leng in denominations:
        length+=1
    while i<length:
        next1=0
        for d in Spendthis:
            if d['output'] == denominations[i]['output']:
                denominations.remove(denominations[i])
                length=length-1
                next1=1 #don't go to the next input
                break
        if next1 != 1:
            i=i+1
    #Finally, we subtract whats in our change jar from the total and then we look through our inputs to
    #find the biggest one that covers the remainder if it does not, we take it from the total until we cover the full amount.
    #Do not send this function an amount that cant be covered since it get stuck in a loop. Its best to check beforehand that you are not sending negative numbers or amounts without the fee considered.
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        if specialtx==1:
            denominations = sorted(denominations, key=lambda k: k['liquidity']['rtotal'])
        else:
            denominations = sorted(denominations, key=lambda k: k['liquidity']['ltotal'])
    else:
        denominations = sorted(denominations, key=lambda k: k['value'])
    pass #print "Remaining Inputs:", denominations, "\n\n"
    pairs=[]
    Total3=Total
    remainder=0
    ExoticInputs=[]
    frozentransfer=0#If an exotic address is used, it can't pay change back as liquidity
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
            if mybuffer==0:
                mybuffer=2
        if specialtx==1:
            mybuffer=0
        for d in Spendthis:
            if specialtx==1:
                Total2+=d['liquidity']['rtotal']
                remainder+=d['liquidity']['ltotal']
            else:
                Total2+=d['liquidity']['ltotal']
            #In some situations for example in contracts, a user will make a change buffer to cover changes in liquidity
            if mybuffer==1:
                Total2-=d['liquidity']['future']
            if mybuffer==2:
                Total2-=d['liquidity']['nfreeze']
            if d['output'] in NEWTxidLookup:
                for nkey, nvalue in NEWTxidLookup.iteritems():
                    if 'script' in nvalue:            
                        if 'txid' in nvalue: 
                            if nvalue['txid']!=nkey:#We found the pair
                                meaning=translate_script(nvalue['script'])
                                if meaning!={}:
                                    addthis=0
                                    if meaning['type'] == "Freeze" or meaning['type']=="Assured Destruction" or meaning['type']=="Switch":
                                        addthis=1
                                    if addthis==1:
                                        for inps in Spendthis:
                                            if inps['output'] == nvalue['txid'] and inps not in ExoticInputs:
                                                v2=inps['liquidity']['rtotal']
                                                if mybuffer==1:
                                                    v2+=inps['liquidity']['future']
                                                if mybuffer==2:
                                                    v2+=inps['liquidity']['nfreeze']
                                                frozentransfer+=v2
                                                ExoticInputs.append(inps)
        Total3=Total2
    SkipOneTime=[]
    rtx=0
    if specialtx==1:
        rtx=1
    if Total3 < purchaseamount:
        while Total3 < purchaseamount:
            length=0
            for leng in denominations:
                length+=1
            if rtx==0:
                if length==0:#No more inputs
                    float('a')
            i = 0
            found=0
            while i<length:#a way to iterate forwards and be able to modify the list
                next1=0
                #Filter out added pairs for exotic spend
                if denominations[i]['output'] in pairs:
                    denominations.remove(denominations[i])
                    length=length-1
                    next1=1 #don't go to the next input
                    found=1
                    break
                val = denominations[i]['value']
                val2=val
                skpme=0
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    if rtx==0:
                        val2=denominations[i]['liquidity']['ltotal']
                    else:
                        val2=denominations[i]['liquidity']['rtotal']
                    if mybuffer==1:
                        val2-=denominations[i]['liquidity']['future']
                    if mybuffer==2:
                        val2-=denominations[i]['liquidity']['nfreeze']
                    if 'liquidity' in denominations[i] and rtx==0:
                        if denominations[i]['liquidity']['rating'][0]<ThePeg.subpremiumrating and denominations[i] not in SkipOneTime:#It's subpremium, save it as a last resort
                            skpme=1
                if val2 >= purchaseamount-Total3 and skpme==0:
                    pass #print "Want to spend this:", denominations[i], "\nCost - total inputs so far:", purchaseamount-Total
                    if denominations[i] in SkipOneTime:
                        SkipOneTime.remove(denominations[i])
                    if denominations[i]['output'] in NEWTxidLookup:#They want to spend a potential exotic spend
                        if NEWTxidLookup[denominations[i]['output']]!={}:
                            pair=""
                            for nkey, nvalue in NEWTxidLookup.iteritems():
                                if nkey==denominations[i]['output']:
                                    if 'txid' in nvalue:
                                        if nvalue['txid']!=denominations[i]['output']:#Notification or pair found
                                            pair=nvalue['txid']
                                if 'txid' in nvalue:
                                    if nvalue['txid']==denominations[i]['output']:
                                        if nkey!=denominations[i]['output']:
                                            pair=nkey
                            if pair!="":
                                for inps in denominations:
                                    if inps['output']==pair:
                                        Spendthis.append(inps)
                                        v2=inps['value']
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            if rtx==1:
                                                v2=inps['liquidity']['rtotal']
                                            else:
                                                v2=inps['liquidity']['ltotal']
                                            if mybuffer==1:
                                                v2-=inps['liquidity']['future']
                                            if mybuffer==2:
                                                v2-=inps['liquidity']['nfreeze']
                                            if inps['output'] == nvalue['txid'] and inps not in ExoticInputs:
                                                v3=inps['liquidity']['rtotal']
                                                if mybuffer==1:
                                                    v3+=inps['liquidity']['future']
                                                if mybuffer==2:
                                                    v3+=inps['liquidity']['nfreeze']
                                                frozentransfer+=v3
                                                ExoticInputs.append(inps)
                                        Total3 += v2
                                        if rtx==1:
                                            remainder+=inps['liquidity']['ltotal']
                                        Total += inps['value']                                            
                                        pairs.append(pair)
                    Spendthis.append(denominations[i])
                    found=1
                    if rtx==1:
                        remainder+=denominations[i]['liquidity']['ltotal']
                    #Filter out that last element
                    denominations.remove(denominations[i])
                    length=length-1
                    next1=1 #don't go to the next input
                    Total3 += val2
                    Total += val
                    break
                if i+1==length or i+1==(length-len(SkipOneTime)):
                    pass #print "No denoms big enough found so I want to spend this:", denominations[i], "\nCost - total inputs so far:", purchaseamount-Total
                    if rtx==1:#wait to add the remainders and sort liquidity
                        if val2==0:
                            break
                    if 'liquidity' in denominations[i] and rtx==0:
                        if denominations[i]['liquidity']['rating'][0]<ThePeg.subpremiumrating:#It's subpremium, save it as a last resort
                            if denominations[i] not in SkipOneTime:
                                SkipOneTime.append(denominations[i])
                                i+=1
                                found=1
                                break
                            else:
                                SkipOneTime.remove(denominations[i])
                    if denominations[i]['output'] in NEWTxidLookup:#They want to spend a potential exotic spend
                        if NEWTxidLookup[denominations[i]['output']]!={}:
                            pair=""
                            for nkey, nvalue in NEWTxidLookup.iteritems():
                                if nkey==denominations[i]['output']:
                                    if 'txid' in nvalue:
                                        if nvalue['txid']!=denominations[i]['output']:#Notification or pair found
                                            pair=nvalue['txid']
                                if 'txid' in nvalue:
                                    if nvalue['txid']==denominations[i]['output']:
                                        if nkey!=denominations[i]['output']:
                                            pair=nkey
                            if pair!="":
                                for inps in denominations:
                                    if inps['output']==pair:
                                        Spendthis.append(inps)
                                        v2=inps['value']
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            if rtx==1:
                                                v2=inps['liquidity']['rtotal']
                                            else:
                                                v2=inps['liquidity']['ltotal']
                                            if mybuffer==1:
                                                v2-=inps['liquidity']['future']
                                            if mybuffer==2:
                                                v2-=inps['liquidity']['nfreeze']
                                            if inps['output'] == nvalue['txid'] and inps not in ExoticInputs:
                                                v3=inps['liquidity']['rtotal']
                                                if mybuffer==1:
                                                    v3+=inps['liquidity']['future']
                                                if mybuffer==2:
                                                    v3+=inps['liquidity']['nfreeze']
                                                frozentransfer+=v3
                                                ExoticInputs.append(inps)
                                        Total3 += v2
                                        if rtx==1:
                                            remainder+=inps['liquidity']['ltotal']
                                        Total += inps['value']
                                        pairs.append(pair)                    
                    Spendthis.append(denominations[i])
                    found=1
                    if rtx==1:
                        remainder+=denominations[i]['liquidity']['ltotal']
                    #Filter out that last element we created a second list to avoid overlap from change carried over
                    denominations.remove(denominations[i])
                    length=length-1
                    next1=1 #don't go to the next input (although this may be redundant because we break in both cases)
                    Total3 += val2
                    Total += val
                    break
                if next1 != 1:
                    i=i+1
            if found==0 and rtx==0:
                float('a')
            if found==0 and rtx==1:
                Total3+=remainder
                rtx=0
                if len(denominations)>0:
                    denominations = sorted(denominations, key=lambda k: k['liquidity']['ltotal'])
    #Priority inputs that are time locked and set to eventually trigger. For now, we will make all of them a priority
    for nkey, nvalue in NEWTxidLookup.iteritems():
        if 'script' in nvalue:
            if 'txid' in nvalue: 
                if nvalue['txid']!=nkey:#We found the pair
                    meaning=translate_script(nvalue['script'])
                    if meaning!={}:
                        addthis=0
                        if meaning['type'] == "Freeze" or meaning['type']=="Assured Destruction" or meaning['type']=="Switch":
                            addthis=1
                        if addthis==1:
                            for inps in denominations:
                                if inps['output'] not in pairs:
                                    if inps['output'] == nkey or inps['output'] == nvalue['txid']:
                                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                            if inps['output'] == nvalue['txid'] and inps not in ExoticInputs:
                                                v2=inps['liquidity']['rtotal']
                                                if mybuffer==1:
                                                    v2+=inps['liquidity']['future']
                                                if mybuffer==2:
                                                    v2+=inps['liquidity']['nfreeze']
                                                frozentransfer+=v2
                                                ExoticInputs.append(inps)
                                        Spendthis.append(inps)
                                        Total += inps['value']
                                        pairs.append(inps['output'])
    if False:
        if 'pegging' in CoinSelect and CoinSelect['pegging'] and MAXINPUTS!=0:
            for d in denominations:
                if 'frozen' in d['liquidity']:
                    Spendthis.append(d)
                    Total+=d['value']
                    denominations.remove(d)
                    break
    #Everything "on an order" is now in Spendthis
    #Ok, now we have our inputs, lets make our outputs into change from the total we got from above
    #Calculate the change.
    change = Total - purchaseamount - frozentransfer
    if change < 0:
        change = 0
    #   Get the number of elements in the tuple.
    ndenominations = len(denom)
    #   Initialize a list of counts per denomination.
    coinCount = []
    for d in denom:
        coinCount.append(0)
    #   To figure out the coins for the change, start with the largest
    #   denomination and work down to the smaller ones.
    #   Keep track of how much change is left to count out in the
    #   "remaining" variable.
    #   For each denomination, as long as remaining is greater than
    #   value of the coin, repeat adding 1 to the coin count for that
    #   denomination and subtracting the denomination value from
    #   remaining.
    #   Initialize remaining to the total amount of change.
    remaining = change
    changelist=[]
    #   deno is an index variable that keeps track of the current
    #   denomination.
    deno = 0
    #   Loop until either we have given all the change or we have
    #   run out of coin denominations to check.
    while remaining and deno < ndenominations:
        #   For one denomination, count out coins of that denomination
        #   as long as the remaining amount is greater than the denomination
        #   amount.
        i=0
        while remaining >= denom[deno]:
            i+=1
            coinCount[deno] += 1
            pass #print coinCount[deno]
            difference = remaining
            remaining -= denom[deno]
            difference = difference - remaining
            #we can construct a new output from each difference
            changelist.append(difference)
        deno += 1

    #   Report the results.
    pass #print "Total being spent:", Total
    pass #print "Cost:", purchaseamount
    pass #print "Your change is ", change + frozentransfer
    for deno in range(0, ndenominations):
        pass #print denom[deno], "coins: ", coinCount[deno]
    if remaining:
        pass #print "Left over:", remaining
    if remaining > 0:
        if remaining < 5500:#The ridiculous anti-dust minimum. We should add it to our smallest input.
            changelist.sort()
            if len(changelist) > 0:
                changelist[0]+=remaining
            else:
                changelist.append(remaining)
        else:
            changelist.append(remaining)
    #Now we need to make the outputs(very important... we need to pay ourselves)
    outputs =[]
    for v in changelist:
        out={'value':int(v),'address':str(myaddress)}
        outputs.append(out)
    #print Spendthis
    #print "TOTAL:", Total
    #print "CHANGE:", change
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        if specialtx==1:
            Spendthis = sorted(Spendthis, key=lambda k: k['liquidity']['rtotal'], reverse=True)
        if specialtx==2:
            Spendthis = sorted(Spendthis, key=lambda k: k['liquidity']['ltotal'], reverse=True)
    if frozentransfer!=0:
        inx=len(ExoticInputs)
        ftype="F"
        pos=0
        for i in ExoticInputs:
            Spendthis.remove(i)
            Spendthis.insert(0+pos, i)
            outputs.insert(0, {'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**'+str(ftype)+'**'+str(inx)))/2)).encode('hex')+hexlify('**'+str(ftype)+'**'+str(inx))})
            inx+=1
            pos+=1
        inx=len(ExoticInputs)
        for i in ExoticInputs:
            v2=i['liquidity']['rtotal']
            if mybuffer==1:
                v2+=i['liquidity']['future']
            if mybuffer==2:
                v2+=i['liquidity']['nfreeze']
            out={'value':int(v2),'address':str(myaddress)}
            outputs.insert(inx, out)
            inx+=1
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        i=0
        for s in Spendthis:
            Spendthis[i].pop('liquidity')
            i+=1
    return Spendthis,outputs,Total #This is a partial tx now... we would just need to add the other output

###########################################################
#Main menu, basic msig functions, basic fle handling functions, encryption and general key functions. The history function is here as well.
#These functions encypt and unencrypt into a jpeg or png. PNG preferred for compression and encoding reasons
def ShowImage(path1,path2):
    try:
        im=Image.open(path1)
        data=stepic.decode(im)
        try:
            mydata=ast.literal_eval(data)
            if "DO NOT LOSE, ALTER OR SHARE THIS FILE - WITHOUT THIS FILE" in mydata[0]:
                with open(os.path.join(path2,"extractedkey.private"), 'w') as f:
                    f.writelines(mydata)
                    f.flush()
                    os.fsync(f)
                    f.close()
            return
        except:
            pass
        #Get file name and save
        matchObj=re.match(r'(####)(.*?)(####)', data, re.M|re.I)
        filename="file.dat"
        try:
            filename=matchObj.group(2)
            data=data.replace(str("####"+matchObj.group(2)+"####"),"")
        except:
            traceback.print_exc()
        data=binascii.unhexlify(data)
        file=open(os.path.join(path2,filename), 'wb').write(data)
        QuestionBox("Success!", "OK")
    except Exception:
        QuestionBox("Extracting the hidden file failed! Perhaps you have the wrong image or its original contents were changed.", "OK")
        traceback.print_exc()
        pass
def HideAnyFileInImage(path,path1,filename):
    data=open(path,'rb').read()
    data=binascii.hexlify(data)
    im=Image.open(path1)
    try:
        im2=stepic.encode(im, ("####"+filename+"####"+data))
        im2.save(path1,'PNG')
        QuestionBox("File is now hidden. To unhide return to the File Menu, select Key To Image, and load the image.", "OK")
        return
    except Exception, e:
        traceback.print_exc()
        QuestionBox("File is too large to hide, please choose a larger image for hiding.", "OK")
        return
def SelectKeyForHide(path=""):
    if path=="":
        res=QuestionBox("Please choose one of the following options.","Hide Key In Image", "Hide File In Image", "Extract File/Key From Image")
        if res==0:
            restext="Open the key you wish to hide."
            resfiles="Private Key File (*.private);;All Files (*.*)"
        if res==1:
            restext="Open the file you wish to hide."
            resfiles="All Files (*.*)"
        if res==2:
            restext="Open the image you wish to extract your file or key from."
            resfiles="Image File (*.jpg *.jpeg *.png)"
        path = QtGui.QFileDialog.getOpenFileName(window,Gtranslate(restext),MacDir()+"",resfiles)
    if path=="":
        return
    file1=QtCore.QDir(path)
    filename=strOUT(strIN(QtCore.QString(file1.dirName())))
    path=strOUT(strIN(path))
    if ".jpeg" in path or ".jpg" in path or ".png" in path:
        try:
            im=Image.open(path)
            data=stepic.decode(im)
            mbox = QuestionBox("Would you like to extract the file from this image?", " Yes ", " No ")
            if mbox == 0:
                path1 = strOUT(strIN(QtGui.QFileDialog.getExistingDirectory(window,Gtranslate("Choose the directory where you want to save the file."),MacDir()+"",QtGui.QFileDialog.ShowDirsOnly)))
                if path1=="":
                    return
                try:
                    ShowImage(path, path1)
                except:
                    QuestionBox("There was an error extracting the key/image. Perhaps you have the wrong image or its original contents were changed.", "OK")
                return
            else:
                return
        except Exception, e:
            pass
    path2 = strOUT(strIN(QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Open the image you wish to use for hiding the file. PNG is preferred, both JPEG and PNG are supported."),MacDir()+"","Image File (*.jpg *.jpeg *.png)")))
    if path2=="":
        return
    if ".private" not in path:
        mbox = QuestionBox("The extension is not a key extension nor is it an encrypted image. Would you like to hide this file in an image?", " Yes " , " No ")
        if mbox == 0:
            HideAnyFileInImage(path,path2,filename)
            return
        else:
            return
    else:
        with open(path,'r') as fi:
            data=fi.readlines()
            fi.close()
        HideInImage(path2,str(data))
def HideInImage(path, data, path2=""):
    if ".jpg" not in path.lower() and ".png" not in path.lower():
        QuestionBox("Please only use JPG or PNG files for hiding keys.", "OK")
        return
    im=Image.open(path)
    im2=stepic.encode(im, data)
    if path2=="":
        im2.save(path,'PNG')
    else:
        im2.save(path2,'PNG')
    QuestionBox(Gtranslate("The file is now hidden inside ") + path, Gtranslate("OK"),1)
    if 'tip8' not in AdvanceArray:
        txt="Please note, if you send these special photos over email or the internet, there is a chance the site or email provider will try to compress them. This can result in a loss of data. So always be sure to test and make sure the photo can be read after sending and never use email or internet sites as a primary backup method for hidden keys or data."
        res=QuestionBox(txt, "  Okay, I understand  ", "  Don't show this message again  ")
        if res==1:
            AdvanceArray['tip7']=1
def LoadHiddenImage(path):
    im=Image.open(path)
    data=stepic.decode(im)
    data=ast.literal_eval(data)
    return data
def ResizeImage(path, maxsize, message=1):#Resizes an image in bytes and saves it in a backup file and returns an object to be encoded into a base64 encoded string
    output = StringIO.StringIO()
    size = os.stat(path).st_size
    im = Image.open(path)
    mquality = 90
    tup=im.size
    width=tup[0]
    height=tup[1]
    im.save(output, 'JPEG', quality=mquality)
    if size > maxsize:#Its too big lets bring the size down until it fits in the email. Also, we want to keep the network fast.
        if message==1:
            QuestionBox("The image is going to be automatically resized for the mail. If there is any hidden data inside this image, it will be not be seen. Saving a backup/new image for encoding. Also, if using Bitmessage, image attachments will take longer to send and require a high proof of work. For more images or high quality images, consider using links.", "OK")
        if SilenceUI == 1 or SilenceUI == 2:
            pass
        else:
            compresssplash.show()
            compresssplash.repaint()
        while size > maxsize:
            output = StringIO.StringIO()
            if mquality != 10:
                im.save(output, 'JPEG', quality=mquality)
                im.save(path+"backup"+".jpg",'JPEG',quality=mquality)
                mquality-=10
            else:
                mquality=90
                width=int(width*.75)
                height=int(height*.75)
                im=im.resize((width, height), Image.ANTIALIAS)
                im.save(output, 'JPEG',quality=mquality)
                im.save(path+"backup"+".jpg",'JPEG',quality=mquality)
            #bytes= base64.b64encode(output.getvalue())
            size= os.stat(path+"backup"+".jpg").st_size
        compresssplash.hide()
    #Our image is now ready to be encoded and sent
    return output
#Encrypts a private key inside a .private file
def EncryptPrivateKey(dir1="",file=""):
    QuestionBox("Important! You can give each private key a different password if you wish. If you forget any of your passwords the wallet will be useless. This is also true if you are on a joint account. If your partner forgets their password neither of you will be able to spend from the account! You can use the same password for both keys or you can choose to protect only one. Backing up the original keys in a safety deposit box is highly recommended! If you have backed up already, make sure those files don't contain your unencrypted key. Think carefully before proceeding. Passphrases are superior to passwords. (Hint: A line from your favorite book with a number on the end)", "OK")
    if file=="":
        privpath1 = QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Open the key you want to password protect/encrypt."),MacDir()+"key1.private","Private Key File (*.private *.jpg *.jpeg *.png)")
        #Convert qstring to strings
        file1=QtCore.QDir(privpath1)
        filedir1=strOUT(strIN(QtCore.QString(file1.path().replace(file1.dirName(),""))))
        file1=strOUT(strIN(QtCore.QString(file1.dirName())))
    else:
        file1=file
        filedir1=dir1
    #Open the file and store it
    f = os.path.join(filedir1,file1)
    if ".jpg" in f or ".jpeg" in f or ".png" in f:
        data=LoadHiddenImage(f)
    else:
        with open(f,'r') as fi:
            data=fi.readlines()
            fi.close()
    if 'DO NOT LOSE, ALTER OR SHARE THIS FILE - WITHOUT THIS FILE, YOUR MONEY IS AT RISK. BACK UP! YOU HAVE BEEN WARNED!' not in data[0]:
        QuestionBox("The keyfile is either encrypted or invalid. Copied file but did not create public keys.", "OK")
        return
    if "PASSWORDPROTECTED:" in data[3]:
        QuestionBox("This file is already protected.", "OK")
        return
    try:
        text, ok = QtGui.QInputDialog.getText(window, file1, Gtranslate('Enter the password for this private key:'), QtGui.QLineEdit.Password)
        if str(text)=="":
            return
        text1, ok = QtGui.QInputDialog.getText(window, file1, Gtranslate('Confirm the password for this private key:'), QtGui.QLineEdit.Password)
        if str(text) != str(text1):
            QuestionBox("The passwords typed did not match try again.", "OK")
            return
    except:
        QuestionBox("Invalid password. Please try a different password.", "OK")
        return
    key = str(text)
    encrypted = password.EncryptWithAES(key, data[3])
    data[3] = "PASSWORDPROTECTED:" + encrypted #The\n gets added again after decrypt
    #Ok we write the password
    if ".jpg" in f or ".jpeg" in f or ".png" in f:
        QuestionBox("The password will be added to the image file and saved.", "OK")
        try:
            HideInImage(f,str(data))
        except:
            QuestionBox("Error encrypting image", "OK")
    else:
        try:
            with open(f,'w') as fi:
                fi.writelines( data )
                fi.flush()
                os.fsync(fi)
                fi.close()
        except:
            QuestionBox("Error writing to keyfile", "OK")

#This function checks the keyfile for a password and returns the private key regardless. This is standard for any spending.
#Check is a variable to know wether or not we are prompting the user to decrypt it or simply checking. It returns 2 if the wallet has a password. It returns 3 if decryption failed.
def DecryptPrivateKey(key,dir1,check,text="", nolock=""):
    global unlockpasswords
    f = os.path.join(dir1,key)
    if ".jpg" in f or ".jpeg" in f or ".png" in f:
        data=LoadHiddenImage(f)
    else:
        with open(f,'r') as fi:
            data=fi.readlines()
            fi.close()
    if "PASSWORDPROTECTED:" in data[3]:
        if check == "1":
            return "","2"
        if text=="" and unlockpasswords==["",""] or nolock!="":
            if AdvanceArray['MySettings']['AntiLogger']:
                AntiLogger.setWindowTitle("Enter your password for "+str(key)+":")
                AntiLogger.reset()
                AntiLogger.exec_()                
                text=str(AntiLogger.inputString)
            else:
                text, ok = QtGui.QInputDialog.getText(window, key, Gtranslate('Enter the password for this private key:'), QtGui.QLineEdit.Password)
            if text=="":
                return "Failed", "1"
        encrypted = data[3].replace("PASSWORDPROTECTED:","")
        if unlockpasswords!=["",""] and text=="":
            text=" "
            try:
                decrypted = password.DecryptWithAES(unlockpasswords[0], encrypted)
            except:
                try:
                    decrypted = password.DecryptWithAES(unlockpasswords[1], encrypted)
                except:
                    return "Failed", "1"
        else:
            try:
                decrypted = password.DecryptWithAES(str(text), encrypted)
            except:
                return "Failed", "1"
        if "KEY: " in decrypted.strip():
            key = decrypted.strip()
            key = key.replace("KEY: ","")
            if check=="5":
                return str(text), "1"
            return key,"1"
        return decrypted.strip(),"3"
    else:
        if check=="5":
            return "none", "2"
        key=data[3].strip()
        key = key.replace("KEY: ","")
    return key,"1"

def IsUnlocked():
    global unlockpasswords, keysconnected
    if keysconnected == "0":
        return True
    k,chk=DecryptPrivateKey(PrivKeyFilename1,PrivKeyFiledir1,"1")
    if keysconnected == "1":
        if chk=="1":
            return True
        else:
            if unlockpasswords!=["",""]:
                return True
            return False
    if chk=="1":
        k,chk=DecryptPrivateKey(PrivKeyFilename2,PrivKeyFiledir2,"1")
        if chk=="1":
            return True
    if unlockpasswords!=["",""]:
        return True
    return False
def HideWindows():
    CustomForm.hide()
    MarketWindow.hide()
    OutboxWindow.hide()
    AdvancedWindow.hide()
    MyDetails.hide()
    ExplanationWindow.hide()
    WinContracts.hide()
    WinContacts.hide()
    WindowHandshake.hide()
    WindowSent.hide()
    WindowReceived.hide()
    WChangeList.hide()
    WStakeList.hide()
    Templates.Window.hide()
    P2MWindow.hide()
    MySettings.hide()
#Gets a new users data
def GetNewUser():
    global PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, NewUser, OnOrders, MyContracts, Spendable, updatesomething, globaltxh, globaltx,globalargs, skipthis, BitHaloClient, BitARGS, TxidLookup, WatchlistQueue, Biteasy, GlobalImage, GlobalID, accounttype, checkbitmessage, unlockpasswords, DontExit, NotForMe, LockTHIS, EmailCheckTime, MasterOrders, CoinSelect, BitEasyPrev, lockforspending, NEWTxidLookup, NotifyEXOTIC, exoticnotify
    EmailCheckTime-=180
    GlobalImage=""
    GlobalID=""
    window.ClearPage()
    HideWindows()
    Templates.reply={}
    Templates.order={}
    Templates.reply2={}
    Templates.Data={}
    try:#If we are switching coins
        CoinSelect=copy.deepcopy(NewUser[7])
    except:
        pass
    DataDirectory()
    if CoinSelect['name'] == "Bitcoin":
        BitHaloClient = True
        window.ContractFee.setText("0.0007")
        window.BitFee.setText("0.0007")
    else:
        BitHaloClient = False
        window.ContractFee.setText("0.02")
        window.BitFee.setText("0.02")
    window.HistorylistWidget.clear()
    while DontExit[0]==1:#Wait for Bitmessage thread
        time.sleep(.01)
    UpdateCfg('#PrivKeyFilename1#',strIN(NewUser[0]))
    UpdateCfg('#PrivKeyFilename2#',strIN(NewUser[1]))
    UpdateCfg('#PrivKeyFiledir1#',strIN(NewUser[2]))
    UpdateCfg('#PrivKeyFiledir2#',strIN(NewUser[3]))
    UpdateCfg('#keysconnected#',NewUser[4])
    UpdateCfg('#prevbalance#'," ")
    UpdateCfg('#accounttype#',str(NewUser[6]))
    PrivKeyFilename1=NewUser[0]
    PrivKeyFilename2=NewUser[1]
    PrivKeyFiledir1=NewUser[2]
    PrivKeyFiledir2=NewUser[3]
    keysconnected=NewUser[4]
    accounttype=str(NewUser[6])
    checkbitmessage=0
    Spendable=[]
    skipthis="skip"
    globaltxh=[]
    globaltx=[]
    globalargs=[]
    BitARGS=[]
    TxidLookup=[]
    NEWTxidLookup={}
    NotifyEXOTIC=False
    exoticnotify=False
    NewUser=[]
    Biteasy={}
    BitEasyPrev={}
    unlockpasswords=["",""]
    lockforspending="1"
    NotForMe=[]
    LockTHIS={}
    MasterOrders={}
    #Before we loop,lets load the old contract and order data
    i=0
    data=[]
    msig,multiscript=create_multisig_address(PrivKeyFilename1)
    if BitHaloClient == False:
        WatchlistQueue.append("1"+msig)
        SaveOtherdata()
    with open(os.path.join(application_path,"Contracts.dat"),'a+') as f:
        f.close()
    with open(os.path.join(application_path,"Contracts.dat"),'r') as f:
        data=f.readlines()
        f.close()
    found=0
    for d in data:
        if d[0]=="#":
            #Here we look for our data and see if there was any orders in it under our name. Otherwise we load them blank
            try:
                if data[i+1].strip()==msig:
                    found=1
                    if d[1]=="$":
                        MyContracts=ast.literal_eval(data[i+2].strip())
                    else:
                        MyContracts=[]
                    if d[2]=="%":
                        OnOrders=ast.literal_eval(data[i+3].strip())
                    else:
                        OnOrders=[]
                else:#For staking we will build a master list of pending orders in other accounts to prevent double spend
                    try:
                        if d[2]=="%":
                            orderlist=ast.literal_eval(data[i+3].strip())
                            pos=-1
                            for x in orderlist:
                                pos+=1
                                if x['type']=="Spendable" or x['type']=="History":
                                    orderlist.pop(pos)
                                    break
                            pos=-1
                            for x in orderlist:
                                pos+=1
                                if x['type']=="Spendable" or x['type']=="History":
                                    orderlist.pop(pos)
                                    break
                            for o in orderlist:
                                for inp in o['inputs']:
                                    MasterOrders[inp['output']]=''
                    except:
                        print "Exception building order list"
            except:
                pass #print "Exception"
        i+=1
    if found==0:
        OnOrders=[]
        MyContracts=[]
    window.MyBalance.setText(Gtranslate("(not up to date)"))
    avail=0
    mybal=""
    for o in OnOrders:
        if o['type']=="Spendable":
            Spendable=o['Spendable']
        if o['type']=="History":
            if 'balance' in o:
                UpdateCfg('#prevbalance#',str(o['balance']))
                if CoinSelect['moderngui']==0:
                    window.MyBalance.setText(str(o['balance']) + Gtranslate(" (not up to date)"))
                else:
                    window.MyBalance.setText(Gtranslate(" (not up to date)"))
                mybal= str(o['balance'])
            myhis=o['myhistory']
            for i in myhis:
                window.HistorylistWidget.addItem(str(i))
        if o['type']=="CONTRACT" or o['type']=="2STEP" or o['type']=="SPENT" or o['type']=="PAY TO EMAIL":
            avail=1
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        mybal=""
    if mybal!="":
        if avail==0:
            window.WelcomeAvailableBalance.hide()
            window.SendAvailableBalance.hide()
            window.MyBalance_4.hide()
            window.MyBalance_8.hide()
            window.Symbol_2.hide()
            window.Symbol_4.hide()
            if CoinSelect['moderngui']==0:
                window.MyBalance_3.setText(mybal + Gtranslate("(not up to date)"))
                window.MyBalance_7.setText(mybal + Gtranslate("(not up to date)"))
            else:
                window.tab.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
                window.tab.le_actualBalance.setText(mybal)
                window.SendBitcoins.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
                window.SendBitcoins.le_actualBalance.setText(mybal)
        else:
            window.WelcomeAvailableBalance.show()
            window.SendAvailableBalance.show()
            window.MyBalance_4.show()
            window.MyBalance_8.show()
            window.Symbol_2.show()
            window.Symbol_4.show()
            if CoinSelect['moderngui']==0:
                window.MyBalance_3.setText(Gtranslate("(not up to date)"))
                window.MyBalance_7.setText(Gtranslate("(not up to date)"))
                window.MyBalance_4.setText(mybal + Gtranslate("(not up to date)"))
                window.MyBalance_8.setText(mybal + Gtranslate("(not up to date)"))
            else:
                window.tab.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
                window.tab.le_actualBalance.setText("")
                window.SendBitcoins.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
                window.SendBitcoins.le_actualBalance.setText("")
                window.tab.l_availableBalance.setText(Gtranslate("Available Balance (not up to date):"))
                window.tab.le_availableBalance.setText(mybal)
                window.SendBitcoins.l_availableBalance.setText(Gtranslate("Available Balance (not up to date):"))
                window.SendBitcoins.le_availableBalance.setText(mybal)
    else:
        if CoinSelect['moderngui']==0:
            window.MyBalance_4.hide()
            window.MyBalance_3.setText(Gtranslate("(not up to date)"))
            window.MyBalance_7.setText(Gtranslate("(not up to date)"))
        else:
            window.tab.le_availableBalance.hide()
            window.tab.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
            window.tab.le_actualBalance.setText("")
            window.SendBitcoins.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
            window.SendBitcoins.le_actualBalance.setText("")
    BitAddr=GetfromCfg("#BitMessage#")
    if CoinSelect['moderngui']==0:
        window.MyAddress_3.setText(Gtranslate("BITMESSAGE: ")+ BitAddr)
    else:
        window.ReceiveBitcoins.receiveBitMessageAddressLineEdit.setText(BitAddr)
    global MyEmail, ManualPassword
    ManualPassword="*"
    if AdvanceArray['MySettings']['ManualLogin']:
        GetEmailPassword()
    GetEmailGlobals()
    if MyEmail=="":
        if CoinSelect['moderngui']==0:
            window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS(RECOMMENDED): "))
        else:
            window.ReceiveBitcoins.receiveEmailLineEdit.setText("")
    else:
        if CoinSelect['moderngui']==0:
            window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS: ")+ MyEmail)
        else:
            window.ReceiveBitcoins.receiveEmailLineEdit.setText(MyEmail)
    if 'StakedOrders' in AdvanceArray:        
        if msig in AdvanceArray['StakedOrders']:
            for ord1 in AdvanceArray['StakedOrders'][msig]:
                OnOrders.append(ord1)
            AdvanceArray['StakedOrders'][msig]=[]
    SaveContracts()
    PopulateContracts()
    PopulateHistory()
    updatesomething=1
#Finds a good directory for Mac
def MacDir():
    global MacWine
    startdir=""
    if MacWine !=0:#Save outside of the app
        try:
            if not os.path.exists("/Applications/"+CoinSelect['name']+"Data"):
                os.makedirs("/Applications/"+CoinSelect['name']+"Data")
            startdir="/Applications/"+CoinSelect['name']+"Data/"
        except:
            traceback.print_exc()
    return startdir
#Creates a new wallet and its variables    
def NewWallet(path1="", path2="", ask=0):
    global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, NewUser, updatesomething
    privpath2=""
    res=0
    if path1 != "" and path2 == "":
        res=1
    if ask==0 and path1=="":
        res=QuestionBox("Will this be a normal account or a joint account?", " Normal Account ", " Joint/Two Step Account ")
        if res==1:
            window.MakeJointAccount()
            return
    if path1=="":
        privpath1 = QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Create your first key and store it somewhere you will remember."),MacDir()+"key1.private","Private Key File (*.private)")
        if privpath1=="":
            return False #Either need to set default variables for keys on cancel or just default to no keys connected
        if res==0:
            QuestionBox("Create your second key and store it in a different directory than the first. If you wish to create only one key, you can cancel and open a wallet with a second key later.", "OK")
            privpath2 = QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Create your second key and store it somewhere you will remember. You may also cancel."),MacDir()+"key2.private","Private Key File (*.private)")
    if path1!="":
        privpath1=QtCore.QString(path1)
    if path2!="":
        privpath2=QtCore.QString(path2)
    if "pegdatabase" in str(privpath1) or "pegdatabase" in str(privpath2):
        QuestionBox("The directory you chose was not valid. Please choose a different directory.", " OK ")
        return False
    #converting between strings and qstrings
    file1=QtCore.QDir(privpath1)
    filedir1=strOUT(strIN(QtCore.QString(file1.path().replace(file1.dirName(),""))))
    file1=strOUT(strIN(QtCore.QString(file1.dirName())))
    file2=QtCore.QDir(privpath2)
    filedir2=strOUT(strIN(QtCore.QString(file2.path().replace(file2.dirName(),""))))
    file2=strOUT(strIN(QtCore.QString(file2.dirName())))
    #Don't let a user overwrite a key
    try:
        if os.path.exists(os.path.join(filedir1,file1)):
            QuestionBox("You must not overwrite an existing private key. Please try again.", " OK ")
            return False
        if privpath2!="":
            if os.path.exists(os.path.join(filedir2,file2)):
                QuestionBox("You must not overwrite an existing private key. Please try again.", " OK ")
                return False
    except:
        QuestionBox("New account failed. Please try again.", " OK ")
        return False
    #Extension check
    if ".private" not in file1:
        return False #They must have changed the extension so just return
    if privpath2=="":
        if path1=="":
            QuestionBox("You have created one private key. You will need to combine it with a second private or shared key to finish creating a new account. You can trade .share files with another party if you want a joint account.", "OK")
        #Creating the first key but leaving no keys connected. It is incomplete after all.
        addr,publickey1,privatekey1=create_tmp_address_and_store_keypair(file1,filedir1)
        if publickey1=="":
            return False
        #Making shared key. Hopefully the user will not confuse them or try to make an account with this. Will check combining same filename later
        sharefile1=file1.replace(".private",".share")
        store_share(publickey1,sharefile1,filedir1)
        return False
    #Another extension check
    if ".private" not in file2:
        return False
    #Checks for identical filenames
    if file1 == file2:
        if path1=="":
            QuestionBox("You can not pair two keys with the same filename.", "OK")
        return False #The filenames are identical
    #Ok so lets create an account normally
    #Make addresses and store them
    addr,publickey1,privatekey1=create_tmp_address_and_store_keypair(file1,filedir1)
    if publickey1=="":
        return False
    addr2,publickey2,privatekey2=create_tmp_address_and_store_keypair(file2,filedir2)
    if publickey2=="":
        return False
    sharefile1=file1.replace(".private",".share")
    sharefile2=file2.replace(".private",".share")
    store_share(publickey1,sharefile1,filedir1)
    store_share(publickey1,sharefile1,filedir2)
    store_share(publickey2,sharefile2,filedir1)
    store_share(publickey2,sharefile2,filedir2)
    #Ok we have all our files now so its time to combine the private and share files so the private keys can work independently we can also update the config file
    try:
        if path1=="":
            combined = CombineKeys(file1,filedir1,file2,filedir2,silence=False)
        else:
            combined = CombineKeys(file1,filedir1,file2,filedir2)
    except:
        traceback.print_exc()
        QuestionBox("There was an error combining the keys. Please make sure that you can locate both private key files before proceeding with your account. Also please report this to one of the developers.", "OK")
        return False        
    if combined == "0":
        return False #Something was wrong with one of the files
    window.HistorylistWidget.clear()
    NewUser=[]
    NewUser.append(file1)
    NewUser.append(file2)
    NewUser.append(filedir1)
    NewUser.append(filedir2)
    NewUser.append("2")
    NewUser.append(" ")
    NewUser.append(res)
    multi,msc=create_multisig_address(NewUser[0],NewUser[2])
    global WatchlistQueue, MyEmail
    if BitHaloClient == False:
        WatchlistQueue.append("0"+multi)
    if CoinSelect['moderngui']==0:
        window.MyAddress_7.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multi)
        window.MyAddress_2.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multi)
        window.MyAddress.setText(Gtranslate(CoinSelect['name'].upper()+": ")+ multi)
        GetEmailGlobals()
        if MyEmail=="":
            window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS(RECOMMENDED): "))
        else:
            window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS: ")+ MyEmail)
    else:
        window.tab.myAddressLineEdit.setText(multi)
        window.History.le_myAddress.setText(multi)
        window.ReceiveBitcoins.receiveCoinAddressLineEdit.setText(multi)
        GetEmailGlobals()
        if MyEmail=="":
            window.ReceiveBitcoins.receiveEmailLineEdit.setText("")
        else:
            window.ReceiveBitcoins.receiveEmailLineEdit.setText(MyEmail)
    window.KeysConnected.setText("Loading new wallet...")
    window.HistorylistWidget.clear()
    window.MyPendingOffers.clear()
    window.MyOpenContracts.clear()
    window.ContactTable.clear()
    if CoinSelect['moderngui']==0:
        window.MyAddress_3.setText(Gtranslate("BITMESSAGE: ")+ " ")
        window.MyBalance.setText(Gtranslate("(not up to date)"))
        window.WelcomeAvailableBalance.hide()
        window.SendAvailableBalance.hide()
        window.MyBalance_4.hide()
        window.MyBalance_8.hide()
        window.Symbol_2.hide()
        window.Symbol_4.hide()
        window.MyBalance_3.setText(Gtranslate("(not up to date)"))
        window.MyBalance_7.setText(Gtranslate("(not up to date)"))
    else:
        window.ReceiveBitcoins.receiveBitMessageAddressLineEdit.setText("")
        window.History.le_balance.setText(Gtranslate("(not up to date)"))
        window.tab.l_availableBalance.hide()
        window.SendBitcoins.l_availableBalance.hide()
        window.tab.le_availableBalance.hide()
        window.SendBitcoins.le_availableBalance.hide()
        window.Symbol_2.hide()
        window.Symbol_4.hide()
        window.tab.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
        window.tab.le_actualBalance.setText("")
        window.SendBitcoins.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
        window.SendBitcoins.le_actualBalance.setText("")
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    if multisig=="":
        GetNewUser()
    updatesomething=1
    SetupWizard.filedir1=filedir1
    SetupWizard.filedir2=filedir2
    SetupWizard.file1=file1
    SetupWizard.file2=file2
    return True

#Opens a wallet or key and sets its variables. Also we can combine keys into a new account.
def OpenWallet():
    global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, NewUser, updatesomething, MyEmail, WatchlistQueue
    #Check to see if this filters the directory
    res=QuestionBox("Please select the type of account you wish to open.", " Normal account ", " Shared(2FA Two Step)/Joint Account ")
    privpath1 = QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Open your first private key."),MacDir()+"key1.private","Private Key File (*.private *.jpg *.jpeg *.png)")
    if privpath1=="":
        return False
    hidden1=0
    if ".jpg" in privpath1 or ".jpeg" in privpath1 or ".png" in privpath1:
        hidden1 = 1
    #converting between strings and qstrings
    file1=QtCore.QDir(privpath1)
    filedir1=strOUT(strIN(QtCore.QString(file1.path().replace(file1.dirName(),""))))
    file1=strOUT(strIN(QtCore.QString(file1.dirName())))
    #extension check
    needspair=""
    if ".private" not in file1 and hidden1 == 0:
        return False
    #Need to make sure the key has been paired
    try:#Even if its encrypted the program will assume its valid
        if hidden1==1:
            d=LoadHiddenImage(strOUT(strIN(QtCore.QString(privpath1))))
            needspair=d[1].strip()
        else:
            f = os.path.join(filedir1,file1)
            with open(f,'r') as fi:
                fi.readline()
                needspair = fi.readline().strip()#We always put the note on the second line
                fi.close()
    except:
        traceback.print_exc()
        QuestionBox("There was an error opening the private key file.", "OK")
        return False
    if needspair == "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.":
        privpath2 = QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Please open a second share or private key to finish creating/pairing this account."),MacDir()+"key2.share","Key Files (*.private *.share  *.jpg *.jpeg *.png)")
        if privpath2=="":
            QuestionBox("The private key has not been paired yet!", "OK")
            return False
    else:
        if res==0:
            privpath2 = QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Open your second private key or cancel if you are only checking contracts or using 2 Step Sending."),MacDir()+"key2.private","Key Files (*.private *.share  *.jpg *.jpeg *.png)")
            if privpath2 == "":
                res=1
        else:
            privpath2 = ""
    hidden2=0
    if ".jpg" in privpath2 or ".jpeg" in privpath2 or ".png" in privpath2:
        hidden2 = 1
    if privpath2=="":
        #Instead of updating we make sure we are not downloading anything first we can clear the history and set the name
        NewUser=[]
        NewUser.append(file1)
        NewUser.append(" ")
        NewUser.append(filedir1)
        NewUser.append(" ")
        NewUser.append("1")
        NewUser.append(" ")
        NewUser.append(res)
        multi,msc=create_multisig_address(NewUser[0],NewUser[2])
        if CoinSelect['moderngui']==0:
            window.MyAddress_7.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multi)
            window.MyAddress_2.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multi)
            window.MyAddress.setText(Gtranslate(CoinSelect['name'].upper()+": ")+ multi)
            GetEmailGlobals()
            if MyEmail=="":
                window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS(RECOMMENDED): "))
            else:
                window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS: ")+ MyEmail)
            window.KeysConnected.setText("Loading new wallet...")
            window.HistorylistWidget.clear()
            window.MyPendingOffers.clear()
            window.MyOpenContracts.clear()
            window.ContactTable.clear()
            window.MyAddress_3.setText(Gtranslate("BITMESSAGE: ")+ " ")
            window.MyBalance.setText(Gtranslate("(not up to date)"))
            window.WelcomeAvailableBalance.hide()
            window.SendAvailableBalance.hide()
            window.MyBalance_4.hide()
            window.MyBalance_8.hide()
            window.Symbol_2.hide()
            window.Symbol_4.hide()
            window.MyBalance_3.setText(Gtranslate("(not up to date)"))
            window.MyBalance_7.setText(Gtranslate("(not up to date)"))
        else:
            window.tab.myAddressLineEdit.setText(multi)
            window.History.le_myAddress.setText(multi)
            window.ReceiveBitcoins.receiveCoinAddressLineEdit.setText(multi)
            GetEmailGlobals()
            if MyEmail=="":
                window.ReceiveBitcoins.receiveEmailLineEdit.setText("")
            else:
                window.ReceiveBitcoins.receiveEmailLineEdit.setText(MyEmail)
            window.KeysConnected.setText("Loading new wallet...")
            window.HistorylistWidget.clear()
            window.MyPendingOffers.clear()
            window.MyOpenContracts.clear()
            window.ContactTable.clear()
            window.ReceiveBitcoins.receiveBitMessageAddressLineEdit.setText("")
            window.History.le_balance.setText(Gtranslate("(not up to date)"))
            window.tab.l_availableBalance.hide()
            window.SendBitcoins.l_availableBalance.hide()
            window.tab.le_availableBalance.hide()
            window.SendBitcoins.le_availableBalance.hide()
            window.Symbol_2.hide()
            window.Symbol_4.hide()
            window.tab.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
            window.tab.le_actualBalance.setText("")
            window.SendBitcoins.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
            window.SendBitcoins.le_actualBalance.setText("")
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if BitHaloClient == False:
                WatchlistQueue.append("1"+multi)
                SaveOtherdata()
        if multisig=="":#Keys can get moved or deleted and cause errors in the config
            GetNewUser()
        updatesomething=1
        #Update()
        return True
    else:
        #Checking for hidden images
        usingimage=0
        d3=[]
        d4=[]
        file2=QtCore.QDir(privpath2)
        filedir2=strOUT(strIN(QtCore.QString(file2.path().replace(file2.dirName(),""))))
        file2=strOUT(strIN(QtCore.QString(file2.dirName())))
        try:
            if hidden1==1 or hidden2==1:
                usingimage=1
                if hidden1==1 and hidden2==0 and ".private" not in privpath2:
                    QuestionBox("When loading hidden images please only use private keys!", "OK")
                    return False
                if hidden1==1 and hidden2==0:
                    with open(os.path.join(filedir2,file2),'r') as fi:
                        d3=fi.readlines()
                        fi.close()
                if hidden2==1 and hidden1==0 and ".private" not in privpath1:
                    QuestionBox("When loading hidden images please only use private keys!", "OK")
                    return False
                if hidden2==1 and hidden1==0:
                    with open(os.path.join(filedir1,file1),'r') as fi:
                        d4=fi.readlines()
                        fi.close()
                if hidden1==1:
                    d=LoadHiddenImage(strOUT(strIN(QtCore.QString(privpath1))))
                    needspair=d[1].strip()
                    if needspair == "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.":
                        QuestionBox("The private key has not been paired yet!", "OK")
                        return False
                if hidden2==1:
                    d2=LoadHiddenImage(strOUT(strIN(QtCore.QString(privpath2))))
                    needspair=d2[1].strip()
                    if needspair == "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.":
                        QuestionBox("The private key has not been paired yet!", "OK")
                        return False
                if  d3==[] and d4==[]:
                    if d[1].strip()!=d2[2].strip():
                        QuestionBox("The keys don't match!", "OK")
                        return False
                if  d3!=[]:
                    if d[1].strip()!=d3[2].strip():
                        QuestionBox("The keys don't match!", "OK")
                        return False
                if  d4!=[]:
                    if d2[1].strip()!=d4[2].strip():
                        QuestionBox("The keys don't match!", "OK")
                        return False
        except:
            traceback.print_exc()
            QuestionBox("There was an error opening the private key file.", "OK")
            return False
        #converting between strings and qstrings
        keyscon = "2" #unless they are combining with a share file
        if '.share' in file2:
            keyscon = "1"
        if file1 == file2:
            QuestionBox("You can not pair two keys with the same filename.", "OK")
            return False
        if usingimage==0:
            if file1.replace(".private","") == file2.replace(".share",""):
                QuestionBox("You can not pair a private key with a public key that uses the same filename.", "OK")
                return False
            try:                
                combined = CombineKeys(file1,filedir1,file2,filedir2, silence=False)
            except:
                traceback.print_exc()
                QuestionBox("There was an error combining the keys. Please make sure that you can locate both private key files before proceeding with your account. Also please report this to one of the developers.", "OK")
                return False
            if combined == "0":
                return False
        #updates the cfg later since we actually need to finish downloading if we are in the middle of it. In the meantime we can change the text
        NewUser=[]
        NewUser.append(file1)
        NewUser.append(file2)
        NewUser.append(filedir1)
        NewUser.append(filedir2)
        NewUser.append(str(keyscon))
        NewUser.append(" ")
        NewUser.append(res)
        multi,msc=create_multisig_address(NewUser[0],NewUser[2])
        if BitHaloClient == False:
                WatchlistQueue.append("1"+multi)
                SaveOtherdata()
        if CoinSelect['moderngui']==0:
            window.MyAddress_7.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multi)
            window.MyAddress_2.setText(Gtranslate("YOUR "+CoinSelect['name'].upper()+" ADDRESS: ")+ multi)
            window.MyAddress.setText(Gtranslate(CoinSelect['name'].upper()+": ")+ multi)
            GetEmailGlobals()
            if MyEmail=="":
                window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS(RECOMMENDED): "))
            else:
                window.MyEmail.setText(Gtranslate("YOUR EMAIL ADDRESS: ")+ MyEmail)
            window.KeysConnected.setText("Loading new wallet...")
            window.HistorylistWidget.clear()
            window.MyPendingOffers.clear()
            window.MyOpenContracts.clear()
            window.ContactTable.clear()
            window.MyAddress_3.setText(Gtranslate("BITMESSAGE: ")+ " ")
            window.MyBalance.setText(Gtranslate("(not up to date)"))
            window.WelcomeAvailableBalance.hide()
            window.SendAvailableBalance.hide()
            window.MyBalance_4.hide()
            window.MyBalance_8.hide()
            window.Symbol_2.hide()
            window.Symbol_4.hide()
            window.MyBalance_7.setText(Gtranslate("(not up to date)"))
            window.MyBalance_3.setText(Gtranslate("(not up to date)"))
        else:
            window.tab.myAddressLineEdit.setText(multi)
            window.History.le_myAddress.setText(multi)
            window.ReceiveBitcoins.receiveCoinAddressLineEdit.setText(multi)
            GetEmailGlobals()
            if MyEmail=="":
                window.ReceiveBitcoins.receiveEmailLineEdit.setText("")
            else:
                window.ReceiveBitcoins.receiveEmailLineEdit.setText(MyEmail)
            window.KeysConnected.setText("Loading new wallet...")
            window.HistorylistWidget.clear()
            window.MyPendingOffers.clear()
            window.MyOpenContracts.clear()
            window.ContactTable.clear()
            window.ReceiveBitcoins.receiveBitMessageAddressLineEdit.setText("")
            window.History.le_balance.setText(Gtranslate("(not up to date)"))
            window.tab.l_availableBalance.hide()
            window.SendBitcoins.l_availableBalance.hide()
            window.tab.le_availableBalance.hide()
            window.SendBitcoins.le_availableBalance.hide()
            window.Symbol_2.hide()
            window.Symbol_4.hide()
            window.SendBitcoins.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
            window.SendBitcoins.le_actualBalance.setText("")
            window.tab.l_actualBalance.setText(Gtranslate("Actual Balance (not up to date):"))
            window.tab.le_actualBalance.setText("")
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if multisig=="":#Keys can get moved or deleted and cause errors in the config
            GetNewUser()
        updatesomething=1
        return True
    return True


#Checks path of connected keys and backs them up
def BackupWallet():
    global PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected     
    if keysconnected == "0":
        QuestionBox("You have no keys loaded", "OK")
        return False
    if keysconnected == "1":
        QuestionBox("Please note, there is only one key loaded. Please choose a folder to save it to. Your public key(s) will regenerated from the private key file.", "OK")
        ext=".private"
        if ".jpg" in PrivKeyFilename1:
            ext=".jpg"
        if ".jpeg" in PrivKeyFilename1:
            ext=".jpeg"
        if ".png" in PrivKeyFilename1:
            ext=".png"
        privpath1 = QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Choose a location and name for your key."),(MacDir()+"key1"+ext),"Private Key File (*.private *.jpg *.jpeg *.png)")
        if ".private" not in privpath1 and ".jpg" not in privpath1 and ".jpeg" not in privpath1 and ".png" not in privpath1:
            QuestionBox("Must have a valid path.", "OK")
            return
        if "pegdatabase" in str(privpath1):
            QuestionBox("The directory you chose was not valid. Please choose a different directory.", " OK ")
            return False
        file1 = os.path.join(PrivKeyFiledir1,PrivKeyFilename1)
        #Don't let a user overwrite a key
        try:
            if os.path.exists(strOUT(strIN(QtCore.QString(privpath1)))):
                QuestionBox("You must not overwrite an existing private key. Please try again.", " OK ")
                return False
        except:
            traceback.print_exc()
            QuestionBox("Backup failed!", " OK ")
            return False
        shutil.copyfile(file1, strOUT(strIN(QtCore.QString(privpath1))))
        #Open the private key file and see if its encrypted and create necessary public key files.
        f = os.path.join(PrivKeyFiledir1,PrivKeyFilename1)
        with open(f,'r') as fi:
            data=fi.readlines()
            fi.close()
        if 'DO NOT LOSE, ALTER OR SHARE THIS FILE - WITHOUT THIS FILE, YOUR MONEY IS AT RISK. BACK UP! YOU HAVE BEEN WARNED!' not in data[0]:
            if ext!=".private":
                QuestionBox("The keyfile has been backed up as an encrypted image.", "OK")
            return
        try:
            if data[1] != "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.\n":
                store_share(data[1].strip(),os.path.basename(strOUT(strIN(privpath1)).replace(ext,"(2nd public key).share"),os.path.dirname(strOUT(strIN(privpath1)))+"/"))
            store_share(data[2].strip(),os.path.basename(strOUT(strIN(privpath1)).replace(ext,".share"),os.path.dirname(strOUT(strIN(privpath1)))+"/"))
            QuestionBox("The keyfile has been backed up.", "OK")
        except:
            pass
    if keysconnected == "2":
        QuestionBox("Please choose a folder to save each key to. You can save them in the same folder as long as they have different names.", "OK")
        textreplace=".private"
        if ".jpg" in PrivKeyFilename1:
            textreplace=".jpg"
        if ".jpeg" in PrivKeyFilename1:
            textreplace=".jpeg"
        if ".png" in PrivKeyFilename1:
            textreplace=".png"
        textreplace2=".private"
        if ".jpg" in PrivKeyFilename2:
            textreplace2=".jpg"
        if ".jpeg" in PrivKeyFilename2:
            textreplace2=".jpeg"
        if ".png" in PrivKeyFilename2:
            textreplace2=".png"
        privpath1 = QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Choose a location and name for your key. Your public keys will also be saved here."),(MacDir()+"key1"+textreplace),"Private Key File (*.private *.jpg *.jpeg *.png)")
        privpath1=strOUT(strIN(privpath1))
        if strIN(privpath1)=="":
            return False
        privpath2 = QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Choose a location and name for your second key. Your public keys will also be saved here."),(MacDir()+"key2"+textreplace),"Private Key File (*.private *.jpg *.jpeg *.png)")
        privpath2=strOUT(strIN(privpath2))
        if strIN(privpath2)=="":
            return False
        if "pegdatabase" in str(privpath1) or "pegdatabase" in str(privpath2):
            QuestionBox("The directory you chose was not valid. Please choose a different directory.", " OK ")
            return False
        #Don't let a user overwrite a key
        try:
            if os.path.exists(privpath1) or os.path.exists(privpath2):
                QuestionBox("You must not overwrite an existing private key. Please try again.", " OK ")
                return False
        except:
            traceback.print_exc()
            QuestionBox("Backup failed!", " OK ")
            return False
        file1 = os.path.join(PrivKeyFiledir1,PrivKeyFilename1)
        shutil.copyfile(file1, privpath1)
        file2 = os.path.join(PrivKeyFiledir2,PrivKeyFilename2)
        shutil.copyfile(file2, privpath2)
        #Open the private key file and see if its encrypted and create necessary public key files.

        f = os.path.join(PrivKeyFiledir1,PrivKeyFilename1)
        with open(f,'r') as fi:
            data=fi.readlines()
            fi.close()
        if 'DO NOT LOSE, ALTER OR SHARE THIS FILE - WITHOUT THIS FILE, YOUR MONEY IS AT RISK. BACK UP! YOU HAVE BEEN WARNED!' not in data[0]:
            if textreplace!=".private":
                QuestionBox("The keyfile has been backed up as an encrypted image.", "OK")
            return
        try:
            if data[1] != "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.\n":
                store_share(data[1].strip(),os.path.basename(privpath1.replace(textreplace,"(2nd public key).share")),os.path.dirname(privpath1)+"/")
            store_share(data[2].strip(),os.path.basename(privpath1.replace(textreplace,".share")),os.path.dirname(privpath1)+"/")
            #Repeat the process
            #Open the private key file and see if its encrypted and create necessary public key files.
            f = os.path.join(PrivKeyFiledir2,PrivKeyFilename2)
            with open(f,'r') as fi:
                data2=fi.readlines()
                fi.close()
            if 'DO NOT LOSE, ALTER OR SHARE THIS FILE - WITHOUT THIS FILE, YOUR MONEY IS AT RISK. BACK UP! YOU HAVE BEEN WARNED!' not in data2[0]:
                if textreplace2!=".private":
                    QuestionBox("The keyfiles have been backed up.", "OK")
                return
            if data2[1] != "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.\n":
                store_share(data2[1].strip(),os.path.basename(privpath2.replace(textreplace2,"(2nd public key).share")),os.path.dirname(privpath2)+"/")
            store_share(data2[2].strip(),os.path.basename(privpath2.replace(textreplace2,".share")),os.path.dirname(privpath2)+"/")
            QuestionBox("The keyfiles have been backed up.", "OK")
        except:
            pass

#This function places the public keys in the private key file for making an account. This can get confusing as to which keys are associated with which account.
#Obviously one key can be used in many different multisignature accounts. Maybe we want to discourage that behavior.
def CombineKeys(key1,dir1,key2,dir2, silence=True):
    #Will need a to see if the key has been combined yet. If its encrypted, we won't find the note to join them anyway.
    #We are going to assume the first key is a private key
    alreadypaired=0
    if ".private" not in key1:
        if silence==False:
            QuestionBox("The first key needs to be a .private key file.", "OK")
        return "0"
    #Open the private key file and make sure its not already paired or encrypted
    try:
        f = os.path.join(dir1,key1)
        with open(f,'r') as fi:
            fi.readline()
            needspair = fi.readline().strip()#We always put the note on the second line
            fi.close()
        if needspair != "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.": #We will check for encrypted files later (Or maybe encrypt the private key only?)
            alreadypaired=1
    except:
        if silence==False:
            QuestionBox("There was an error opening the private key file.", "OK")
        return "0"
    if ".private" not in key2:
        if ".share" not in key2:
            if silence==False:
                QuestionBox("The second key file does not have a valid extension.", "OK")
            return "0"
        #Ok, they want to combine a private key and a public key for a joint account. Lets just ckeck and make sure it has not been paired already.
        if alreadypaired == 1:
            if silence==False:
                QuestionBox("One of the private keys is either encrypted, already paired, is invalid, or has been edited.", "OK")
            return "0"
        f = os.path.join(dir2,key2)
        with open(f,'r') as fi:
            fi.readline()
            publickey=fi.readline().strip()
            fi.close()
        f = os.path.join(dir1,key1)
        with open(f,'r') as fi:
            data=fi.readlines()
            fi.close()
        data[1]=publickey+"\n"
        data[0]=data[0].replace("BACK UP! YOU HAVE BEEN WARNED!", "BACK UP! YOU HAVE BEEN WARNED! Bitmessage key: " + CoinSelect['rpcpassword'])#For a more random but somewhat deterministic Bitmessage address
        with open(f,'w') as fi:
            fi.writelines( data )
            fi.flush()
            os.fsync(fi)
            fi.close()
        if silence==False:
            QuestionBox("Make sure you also combine the other private key with your shared key. If working with another party, you should send them your shared key as well. This way, the account can be opened using both private key files.", "OK")
        return "1" #Everything worked
    #Perhaps they are trying to combine or open two private keys.
    if ".private" not in key2:
        return "0"
    #Open the private key file and make sure its not already paired or encrypted (for new wallet creation)
    try:
        f = os.path.join(dir2,key2)
        with open(f,'r') as fi:
            fi.readline()
            needspair = fi.readline().strip()#We always put the note on the second line
            fi.close()
        if needspair != "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT.": #looks like both keys have been paired... we can probably open them but do they match?
            if alreadypaired == 1:
                f = os.path.join(dir1,key1)
                f2 = os.path.join(dir2,key2)
                with open(f,'r') as fi:
                    data1=fi.readlines()
                    fi.close()
                with open(f2,'r') as fi:
                    data2=fi.readlines()
                    fi.close()
                #Do the keys match?
                if data1[1]==data2[2]:
                    if data2[1]==data1[2]:
                        return "1"
                if silence==False:
                    QuestionBox("The public keys don't match!", "OK")
                return "0"
    except:
        if silence==False:
            QuestionBox("There was an error opening the private key file.", "OK")
        return "0"
    #A new wallet is probably being created or two parties are trading private keys(I hope not!)
    #Has it already been paired?
    if alreadypaired == 1:
        if silence==False:
            QuestionBox("One of the private keys is either encrypted, already paired, is invalid, or has been edited.", "OK")
        return "0" #At least make them combine the appropriate share files.
    #Ok, its a new wallet
    f = os.path.join(dir1,key1)
    f2 = os.path.join(dir2,key2)
    with open(f,'r') as fi:
        data1=fi.readlines()
        fi.close()
    with open(f2,'r') as fi:
        data2=fi.readlines()
        fi.close()
    #Put the public keys in each private key file
    data1[1]=data2[2]
    data2[1]=data1[2]
    data1[0]=data1[0].replace("BACK UP! YOU HAVE BEEN WARNED!", "BACK UP! YOU HAVE BEEN WARNED! Bitmessage key: " + CoinSelect['rpcpassword'])#For a more random but somewhat deterministic Bitmessage address
    data2[0]=data2[0].replace("BACK UP! YOU HAVE BEEN WARNED!", "BACK UP! YOU HAVE BEEN WARNED! Bitmessage key: " + CoinSelect['rpcpassword'])#For a more random but somewhat deterministic Bitmessage address
    with open(f,'w') as fi:
        fi.writelines( data1 )
        fi.flush()
        os.fsync(fi)
        fi.close()
    with open(f2,'w') as fi:
        fi.writelines( data2 )
        fi.flush()
        os.fsync(fi)
        fi.close()
    return "1"

#Opens system config and sets global variables
def OpenCfg():
    global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected
    cfg_path = (os.path.join(application_path,'Halo.cfg'))
    open(os.path.join(cfg_path), 'a+')
    with open(os.path.join(cfg_path), 'r') as f:
        default=f.readline().strip()
        f.close()
    if default=='':
        with open(os.path.join(cfg_path), 'a+') as f:
            f.write(defaultcfg)
            default=defaultcfg
            f.flush()
            os.fsync(f)
            f.close()
    mycfg=default
    PrivKeyFilename1 = strOUT(GetfromCfg("#PrivKeyFilename1#"))
    PrivKeyFilename2 = strOUT(GetfromCfg("#PrivKeyFilename2#"))
    PrivKeyFiledir1 = strOUT(GetfromCfg("#PrivKeyFiledir1#"))
    PrivKeyFiledir2 = strOUT(GetfromCfg("#PrivKeyFiledir2#"))
    if PrivKeyFiledir1==" ":
        PrivKeyFiledir1=""
    if PrivKeyFiledir2==" ":
        PrivKeyFiledir2=""
    keysconnected = GetfromCfg("#keysconnected#")     
    if keysconnected=="1" or keysconnected =="2":
        if not checkformultisig(PrivKeyFiledir1,PrivKeyFilename1):
            UpdateCfg('#PrivKeyFilename1#',"")
            UpdateCfg('#PrivKeyFilename2#',"")
            UpdateCfg('#PrivKeyFiledir1#',"")
            UpdateCfg('#PrivKeyFiledir2#',"")
            UpdateCfg('#keysconnected#',"0")
            PrivKeyFilename1 = strOUT(GetfromCfg("#PrivKeyFilename1#"))
            PrivKeyFilename2 = strOUT(GetfromCfg("#PrivKeyFilename2#"))
            PrivKeyFiledir1 = strOUT(GetfromCfg("#PrivKeyFiledir1#"))
            PrivKeyFiledir2 = strOUT(GetfromCfg("#PrivKeyFiledir2#"))
            if PrivKeyFiledir1==" ":
                PrivKeyFiledir1=""
            if PrivKeyFiledir2==" ":
                PrivKeyFiledir2=""
            keysconnected="0"
    if keysconnected=="2":
        if not checkformultisig(PrivKeyFiledir2,PrivKeyFilename2):
            UpdateCfg('#PrivKeyFiledir2#',"")
            UpdateCfg('#PrivKeyFilename2#',"")
            PrivKeyFilename2 = strOUT(GetfromCfg("#PrivKeyFilename2#"))
            PrivKeyFiledir2 = strOUT(GetfromCfg("#PrivKeyFiledir2#"))
            if PrivKeyFiledir2==" ":
                PrivKeyFiledir2=""
            if keysconnected=="2":
                keysconnected="1"
                UpdateCfg('#keysconnected#',"1")   

def GetfromCfg(type1, lit=0):
    global mycfg
    val = re.sub(type1, type1+r"#QQQ", mycfg)
    val = re.sub(r"(#Q.+?)(#.*)",r"\1",val)
    val = re.sub(r"(.*#QQQ)",r"",val)
    bitlist=[]
    if lit==0:
        if type1=="#BitMessage#":
            if val!=" ":#Ok there was something there
                msig,msc=create_multisig_address(PrivKeyFilename1)
                if msig == "":#ok it didnt load
                    msig = " "#This may just pull a default address
                bitlist=ast.literal_eval(val)
                val=" "
                for valuelist in bitlist:
                    if valuelist[0]==msig:#ok we found it
                        val=valuelist[1]
    return val

def UpdateCfg(type1,newval, multisig=" "):
    global  mycfg, FileSave
    if newval=="":
        newval=" "
    bitlist=[]
    if type1=="#BitMessage#":
        val=GetfromCfg("#BitMessage#",1)#The actual list needs to be seen so we can add to it.
        msig,msc=create_multisig_address(PrivKeyFilename1)
        if msig == "":#ok it was not loaded
            msig = " "
        if multisig != " ":
            msig=multisig
        if val ==" ":#Ok its a new cfg this is ok to have a bitmessage serve as a general mailbox
            entry=[]
            entry.append(msig)
            entry.append(newval)
            bitlist.append(entry)
        else:
            bitlist=ast.literal_eval(val)
            pos=0
            found=0
            for valuelist in bitlist:
                if valuelist[0]==msig:#ok we found it
                    bitlist[pos][1]=newval
                    found=1
                pos+=1
            if found==0:#Most likely
                entry=[]
                entry.append(msig)
                entry.append(newval)
                bitlist.append(entry)
        newval=str(bitlist)
    cfg_path = (os.path.join(application_path,'Halo.cfg'))
    mycfg2 = re.sub(type1, type1+r"#QQQ", mycfg)
    mycfg2 = re.sub(r"#QQ.+?#",r"!###" ,mycfg2)
    mycfg2 = re.sub(r"!##",newval ,mycfg2)
    mycfg=mycfg2
    if multisig!="1":#First run
        FileSave.Queue.append({"SaveCFG":1,"CFG":mycfg,"PATH":cfg_path})

#Adds to blockchain config
def AddToConfig(string):
    with open(os.path.join(sdir,CoinSelect['config'].lower()+".conf"),'a') as f:
        f.write("\n"+str(string))
        f.flush()
        os.fsync(f)
        f.close()

#Creates private key and stores in a file
def create_tmp_address_and_store_keypair(uniqueid,path, joint=""):
    global SALT
    priv = sha256(str(os.urandom(256)+SALT))
    pub = privtopub(priv)
    #Since users will use keys independently, we should make a note.
    #If we are being supplied a public key, we can make a joint account here
    if joint !="":
        addr=joint
    else:
        addr = "COMBINE THIS KEY WITH ANOTHER PRIVATE OR SHARE FILE TO FINISH CREATING THE ACCOUNT."
    tmpaddr = pubtoaddr(pub) #We create a temporary address out of the new private key
    #write data to file
    try:
        with open(os.path.join(path,uniqueid),'wb') as f: #changed from uniqueid+'.private'
            f.write('DO NOT LOSE, ALTER OR SHARE THIS FILE - WITHOUT THIS FILE, YOUR MONEY IS AT RISK. BACK UP! YOU HAVE BEEN WARNED!\n')
            f.write(addr+'\n')
            f.write(pub+'\n')
            f.write('KEY: '+priv+'\n')
            f.flush()
            os.fsync(f)
            f.close()
    except:
        traceback.print_exc()
        QuestionBox("Key creation failed. Make sure you have write access to the destination or try a different directory.", "OK")
        return "","",""
    #access to data at runtime for convenience
    return (tmpaddr,pub,priv)

#Stores the shared key in a file
def store_share(pubkey,uniqueid,path):
    with open(os.path.join(path,uniqueid),'wb') as f:
        f.write("THIS FILE IS SAFE TO SHARE WITH OTHERS. SEND IT TO YOUR COUNTERPARTY TO ALLOW THEM TO MAKE NEW ACCOUNTS WITH YOU.\n")
        f.write(pubkey+'\n')
        f.flush()
        os.fsync(f)
        f.close()

#Creates a 2 for 2 multisig account from two public keys. In our case, we use the back-up values in the private key file only. The share files are just for advanced users anyway.
def create_multisig_address(uniqueid1, dir1=""):
    #Maybe if they store keys on a flash drive it may slow down performance. So just check to see if the same key is being requested.
    global prevmsig, AdvanceArray
    if uniqueid1==prevmsig['ID'] and PrivKeyFiledir1==prevmsig['Dir'] and dir1=="" and prevmsig['ID']!="" and BitHaloClient == prevmsig['Halo']:
        return(prevmsig['msigaddr'],prevmsig['mscript'])
    if dir1==" ":
        dir1=""
    pubs = get_ordered_pubkeys(uniqueid1,dir1)
    if not pubs:
        return ('','')
    if BitHaloClient == True:
        mscript = pybit.transaction.mk_multisig_script(pubs,2,2)
        msigaddr = pybit.transaction.scriptaddr(mscript.decode('hex'))
    else:
        mscript = mk_multisig_script(pubs,2,2)
        msigaddr = scriptaddr(mscript.decode('hex'))
    prevmsig['ID']=uniqueid1
    if dir1!="":
        prevmsig['Dir']=dir1
    else:
        prevmsig['Dir']=PrivKeyFiledir1
    prevmsig['msigaddr']=msigaddr
    prevmsig['mscript']=mscript
    prevmsig['Halo']=BitHaloClient
    return (msigaddr,mscript)
def checkformultisig(dir1,name1,dir2="",name2=""):
    x = get_ordered_pubkeys(name1, dir1)
    y = True
    if dir2 != "":
        y = get_ordered_pubkeys(name2, dir2)
    if x == None or y == None:
        return False
    return True

#Creates an escrow multisig or a temporary multisig from two public keys
#Make sure you know what order you want them applied
def create_multisig_from_publics(pub1,pub2):
    pubs = []
    pubs.append(pub1)
    pubs.append(pub2)
    if not pubs:
        return ('','')
    if BitHaloClient == False:
        mscript = mk_multisig_script(pubs,2,2)
        msigaddr = scriptaddr(mscript.decode('hex'))
    else:
        mscript = pybit.transaction.mk_multisig_script(pubs,2,2)
        msigaddr = pybit.transaction.scriptaddr(mscript.decode('hex'))
    return (msigaddr,mscript)
#Public keys are used to make multisig. The keys are sorted and returned so that the multisig is the same each time. PrivKeyFiledir1 is the directory of our primary private key since its always the first loaded.
#Since there is single key options, the .share files are  not very useful for multisig creation. We have them backed up in each private key to avoid errors so we just open the private file instead
def get_ordered_pubkeys(uniqueid1, dir1="", sort=1, fline=0):
    pubs = []
    if dir1 == "":
        dir1=PrivKeyFiledir1
    if dir1 == " ":
        dir1=""
    firstline=""
    try:
        f = os.path.join(dir1,uniqueid1)
        if ".jpg" in uniqueid1 or ".jpeg" in uniqueid1 or ".png" in uniqueid1:
            data=LoadHiddenImage(f)
            firstline=data[0].strip()
            pubs.append(data[1].strip())
            pubs.append(data[2].strip())
        else:
            with open(f,'r') as fi:
                firstline=fi.readline().strip()
                pubs.append(fi.readline().strip())
                pubs.append(fi.readline().strip())
                fi.close()
    except:
        if fline==1:
            return None, ""
        return None
    #necessary for ensuring unique result for address
    if sort!=1:
        if fline==0:
            return pubs
        else:
            return pubs, firstline
    pubs.sort()
    if fline==0:
        return pubs
    else:
        return pubs, firstline

#This is used for when a user needs to recover lost data on a bridge TX in the GUI
def showBridgeTX():
    res = BLK.listbridgetransactions()
    return res
def addBridgeTX(txid):
    global CurrentBlock, timestamp, PrivKeyFilename1
    multisig,mscript=create_multisig_address(PrivKeyFilename1)
    txid2=txid.split(":")[0]
    txid2out=int(txid.split(":")[1])
    txdata=deserialize(BLK.getrawtransaction(txid2))
    script=txdata['outs'][txid2out]['script']
    bridgedata={'network':'','txid':txid,'to':''}
    thisisgood=0
    for bridged in ThePeg.Pegdatabase['bridgedb']['bridges']:
        try:
            if translate_script(script)['message'][5:][:64]==txhash(bridged['n'])[:64]:
                bridgedata['network']=bridged['n']
                bridgedata['to']=translate_script(script)['message'][5:][64:]
                thisisgood=1
                break
        except:
            pass
    if thisisgood!=1:
        QuestionBox("The bridge network name was not valid!", " OK ")
        return False
    amount=txdata['outs'][txid2out]['value']
    hist={}
    details={}
    details['type']="Bridge"    
    details['ordernumber']=os.urandom(16).encode('hex')
    details['total']=amount
    details['change']=0
    details['currentblock']=CurrentBlock
    details['Confirmation TXID']=txid2
    details['inputs']=[]
    details['output']=[]
    details['amount']=amount
    details['fee']=0
    details['address']=multisig
    details['script']=script
    details['bridge']=True
    details['timestamp']=timestamp
    details['version']=CoinSelect['HaloName'] + " " + clientversion
    
    hist['Details']=copy.deepcopy(details)
    hist['Type']="Bridge"
    hist['Amount']=details['amount']
    hist['Details']['date']=ConvertDate(HaloTime,0)
    hist['Details']['Pending']=False
    hist['Label']=''
    hist['script']=script
    hist['bridgedata']=copy.deepcopy(bridgedata)
    AddToHistory(txid, "", multisig, str(Decimal(amount)/Decimal(1e8)), hist['Type'], hist)
#For testing bridge
def simulateTX(toaddy="0x0", bridgedata=0):#network, to, pool, txid
    if bridgedata==0:#Make some values for testing
        mybridgedata={'network':'Goerli Testnet','pool':[1000000]*1200,'txid':txhash(os.urandom(1000)),'to':toaddy}
    else:
        mybridgedata=copy.deepcopy(bridgedata)
    ThePeg.Pegdatabase['txidreference'][mybridgedata['txid']]=ThePeg.Pegdatabase['merklenonceTX'] #For easy reference finding a TX
    ThePeg.Pegdatabase['merklelist'][str(ThePeg.Pegdatabase['merklenonceTX'])]['transactions'].append(copy.deepcopy(mybridgedata))
#A critical function that shows how to get the inputs, outputs, transactions ids, raw transactions, and whatever data that is needed. It returns the unconfirmed and confirmed balance as well.
#Everything is returned as a list of dictionaries. The unconfirmed balance and confirmed balance is sent seperately.
def get_balance_lspnr(addr_to_test,txdetails,txs,args):
    global updatesomething
    global TxidLookup
    MyHistory=[]
    SpendableList = []
    received_btc = 0.0
    unconf = 0.0
    spent= 0.0
    #Everything was downloaded in the thread so we canjust proceed... if we have exceptions for some reason after release, the downloading can be added right here...
    #unconfirmed will now be at the beginning but need to be at the end
    #unconf_args = [item for item in args if item[1]==0]
    #conf_args = [item for item in args if item[1]!=0]
    #args = conf_args +unconf_args
    #Lets get a list of outputs with their vout
    prev_outs={}
    for i,d in enumerate(txs):
        rawtx=d['result']#The client crashes here with a key error sometimes "error key result" it probably has something to do with timeout of the electrum servers
        tx=pybit.deserialize(rawtx) #the full tx
        txid=txhash(rawtx).encode('hex') #the txid
        pos = -1
        #Its important to know exactly which output and which position in each specific txid belongs to us
        for output in tx['outs']:
            SpendableOutput = {}
            pos+=1
            ispubkey,addr = \
            ea.get_address_from_output_script(output['script'].decode('hex'))
            if not addr == addr_to_test: continue
            bitcoins =  output['value'] #* 0.00000001
            prev_outs[str(txid.decode('hex'))+":"+str(pos)]=bitcoins
            myoutputtxid = txid.decode('hex') + ":" + str(pos)
            SpendableOutput['output']=unicode(myoutputtxid)
            SpendableOutput['value']=output['value']
            SpendableOutput['address']=unicode(addr)
            SpendableList.append(SpendableOutput)
    filterthis=[]
    for i,y in enumerate(txs):
        dict1= {}
        myinputs = []
        myvalues = []
        myoutputs = []
        myvouts = []
        rawtx = y['result']
        tx = pybit.deserialize(rawtx)
        txh = txhash(rawtx).encode('hex')
        dict1 ['Txid']=txh.decode('hex') #The magical txid
        for input1 in tx['ins']:
            pubkeys,signatures, addr = \
            ea.get_address_from_input_script(input1['script'].decode('hex'))
            myinputs.extend([addr])
            if not addr == addr_to_test: continue
            #we need to find which previous output is being spent - it must exist.
            #we use the same positional reference and match it with the txid
            #in this case, its fortunately defined in the index of the outpoint
            try:
                bitcoins_being_spent = prev_outs[str(input1['outpoint']['hash'])+":"+str(input1['outpoint']['index'])]
            except Exception, e:
                traceback.print_exc()
                print("failed to find the reference to which output's being spent!")
            #We have found something that was spent. We can now deduct the value and add the txid and position to a list so it doesnt become spendable later
            filterthis.append(str(input1['outpoint']['hash'])+":"+str(input1['outpoint']['index']))
            if args[i][1]==0:
                unconf -= bitcoins_being_spent
            received_btc -= bitcoins_being_spent
        pos=-1
        for output in tx['outs']:
            pos+=1
            ispubkey,addr = \
            ea.get_address_from_output_script(output['script'].decode('hex'))
            if not addr == addr_to_test: continue
            bitcoins =  output['value']
            myoutputs.append(addr)
            myvalues.append(float(Decimal(bitcoins)/Decimal(1e8)))
            myvouts.append(pos)
            #For now, lets not allow spending of unconfirmed. Perhaps in the future we can give the option to take the risk.
            if args[i][1]==0:
                myoutputtxid = txhash(rawtx) + ":" + str(pos)
                print "Filter unconfirmed: ", myoutputtxid
                filterthis.append(myoutputtxid)
                unconf += bitcoins
            received_btc +=bitcoins
        dict1 ['Inputs'] = myinputs
        dict1 ['Outputs'] = myoutputs
        dict1 ['Values'] = myvalues
        dict1 ['vout'] = myvouts
        dict1 ['FROM'] = myinputs[0]
        for val in dict1 ['Values']:
            v=int(Decimal(val)*Decimal(1e8))
            if v == 5500 or v == 5501 or v == 5499:
                skip=0
                for contract in MyContracts:
                    if contract['ordernumber']==dict1['Txid']:
                        if 'sent' in contract:
                            skip=1
                if skip==0:
                    TxidLookup.append(dict1['Txid'])
        MyHistory.append(dict1)
    length=0
    for d in SpendableList:
        length+=1
    i=0
    while i<length:
        next1=0
        for d in filterthis:
            try:
                gotdata = SpendableList[i]['output']
            except IndexError:
                break
            if SpendableList[i]['output']==unicode(d):
                #Removed from spendable
                SpendableList.remove(SpendableList[i])
                length=length-1
                next1=1 #don't go to the next input
        if next1 != 1:
            i=i+1
    MyHistory=list(reversed(MyHistory))
    received_btc=float(Decimal(received_btc)/Decimal(1e8))
    unconf=float(Decimal(unconf)/Decimal(1e8))
    pass #print "Final unconfirmed balance: ", received_btc
    pass #print "Final confirmed balance: ", received_btc - unconf
    pass #print "\n\nThe history: ", MyHistory
    return received_btc-unconf,received_btc, unconf, MyHistory, SpendableList

def GetCurrentOrder(current):
    global MyContracts
    for c in MyContracts:
        if c['ordernumber']==current:
            return json_deep_copy(c,1)
def ParseMultipay(address, amount):
    try:
        if "," not in address or "," not in amount or "@" in address:
            return [],[]
        addr=address.split(",")
        amt=amount.split(",")
        if len(amt)!=len(addr):
            amt=[]
            addr=[]
        if len(addr)==1:
            amt=[]
            addr=[]
    except:
        amt=[]
        addr=[]
    return addr,amt

def Notification(show, text):
    if window.checkBox.isChecked():
        pass
    else:
        window.notifytext=text
        if CoinSelect['moderngui']==0:
            window.commandLinkButton.setText(Gtranslate(text))
            window.commandLinkButton_3.setText(Gtranslate(text))
            window.commandLinkButton_4.setText(Gtranslate(text))
            window.commandLinkButton_5.setText(Gtranslate(text))
            window.commandLinkButton_6.setText(Gtranslate(text))
            window.commandLinkButton_7.setText(Gtranslate(text))
            window.commandLinkButton_8.setText(Gtranslate(text))
            window.commandLinkButton_9.setText(Gtranslate(text))
            window.commandLinkButton_10.setText(Gtranslate(text))
            window.commandLinkButton_11.setText(Gtranslate(text))
            if show==1:
                window.commandLinkButton.show()
                window.commandLinkButton_3.show()
                window.commandLinkButton_4.show()
                window.commandLinkButton_5.show()
                window.commandLinkButton_6.show()
                window.commandLinkButton_7.show()
                window.commandLinkButton_8.show()
                window.commandLinkButton_9.show()
                window.commandLinkButton_10.show()
                window.commandLinkButton_11.show()
            else:
                window.commandLinkButton.hide()
                window.commandLinkButton_3.hide()
                window.commandLinkButton_4.hide()
                window.commandLinkButton_5.hide()
                window.commandLinkButton_6.hide()
                window.commandLinkButton_7.hide()
                window.commandLinkButton_8.hide()
                window.commandLinkButton_9.hide()
                window.commandLinkButton_10.hide()
                window.commandLinkButton_11.hide()
        else:
            window.commandLinkButton.setText(Gtranslate(text))
            if show==1:
                window.commandLinkButton.show()
            else:
                window.commandLinkButton.hide()
def AcceptOffer(contract, rep=0):
    global MyContracts, WatchlistQueue
    multisig,mscript=create_multisig_address(PrivKeyFilename1)
    pos=0
    for c in MyContracts:
        if c['ordernumber']==contract['ordernumber']:
            break
        pos+=1
    try:
        MyContracts[pos]['lock']="1"#If anything fails communication is effectively severed
        #We can assume that whatever we had was legitimate because from here there is nothing left to negotiate just sign. We will need more functions for data integrity I think
        Reply={}#If anything fails we mark it in the deal with the reason and recommended action
        Reply['Process']='Making Transactions'
        Reply['Command']='Send'
        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
        Reply['TheirBMAddress']=contract['TheirBMAddress']
        Reply['ordernumber']=contract['ordernumber']
        if 'tx3' in contract:
            tx3=contract['tx3']
        #Blackcoin stuff... we can add the multisigs
        if BitHaloClient==False:
            WatchlistQueue.append("0"+MyContracts[pos]['theirtemp'])
            WatchlistQueue.append("0"+MyContracts[pos]['mytemp'])
            WatchlistQueue.append("0"+MyContracts[pos]['escrow'])
        #We make the temporary funding on our own. So if they sign something else it won't fund
        fundinputs=[]
        fundoutputs=[]
        theirs={}
        mine={}
        theirtotal=0
        mytotal=0
        theirtotal+=contract['theirdeposit']
        mytotal+=contract['mydeposit']
        if "I pay this" in contract['whopays']:
            mytotal+=contract['amount']
        else:
            theirtotal+=contract['amount']
        if "I am" in contract['instantwhopays']:
            mytotal+=contract['instantamount']
        else:
            theirtotal+=contract['instantamount']
        #Ok lets calculate fees it should be even
        f=0
        if contract['instantamount'] !=0:#We will have to split a fee here
            f+=.5
        f+=1#For completion or cancellation request and funding escrow both of which are split (doubles as temporary account refund)
        if mytotal!=0:
            if theirtotal==0:
                f+=1
            mytotal+=int(contract['fee']*f)#They spent one funding temporary
        else:
            f+=1
        if theirtotal!=0:
            theirtotal+=int(contract['fee']*f)#They spent one funding temporary
        theirs['output']=unicode(str(contract['tx2'])+":0")#If they put anything else in the temporary the funding will not work
        theirs['value']=theirtotal
        theirs['address']=contract['theirtemp']
        mine['output']=unicode(str(contract['tx1'])+":0")
        mine['value']=mytotal
        mine['address']=contract['mytemp']
        if theirtotal!=0:
            fundinputs.append(theirs)
        if mytotal!=0:
            fundinputs.append(mine)
        if contract['instantamount'] !=0:#If there is a refund, we do not want to depend on its transaction id for expirations so we split it
            escrowout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee']),'address':str(contract['escrow'])}#two fees deducted so one can be added
            instantout={'value':int(contract['fee']+contract['instantamount']),'address':str(contract['escrow'])}#Now if they screw up the id, they will have to get our permission to sign again
            fundoutputs.append(escrowout)
            fundoutputs.append(instantout)
        else:
            escrowout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee']),'address':str(contract['escrow'])}#its all one input
            fundoutputs.append(escrowout)
        #Here we make the tx and sign manually
        if BitHaloClient==True:
            tmptx = pybit.transaction.mktx(fundinputs,fundoutputs)
        else:
            tmptx = mktx(MyContracts[pos]['timestamp'], fundinputs,fundoutputs)
        multi,mscrip=create_multisig_from_publics(MyContracts[pos]['mypublic'],MyContracts[pos]['mypublic2'])
        sigs=[]
        try:
            if mytotal!=0:
                ps1=0
                if theirtotal!=0:
                    ps1+=1
                if BitHaloClient==True:
                    sigg=pybit.transaction.multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate'])
                    sigs.append(sigg)
                    sigg=pybit.transaction.multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate2'])
                    sigs.append(sigg)
                else:
                    sigg=multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate'])
                    sigs.append(sigg)
                    sigg=multisign(tmptx.decode('hex'),ps1,mscrip.decode('hex'),MyContracts[pos]['myprivate2'])
                    sigs.append(sigg)
        except:
            MyContracts[pos]['Process']="Failed: "
            MyContracts[pos]['Reason']="TX3 Signature failed"
            return
        Reply['tx3theirsig']=sigs
        #May need to go over all this a few times.contract_to_network(ins,outs,sigs,pub1,pub2, pub3, pub4,sigs2, skipbroadcast=0)
        if mytotal!=0:
            tx3,result=broadcast_contract_to_network(fundinputs,fundoutputs,contract['tx3theirsig'],MyContracts[pos]['theirpublic'],MyContracts[pos]['theirpublic2'],MyContracts[pos]['mypublic'],MyContracts[pos]['mypublic2'],sigs, MyContracts[pos]['timestamp'],1)
            MyContracts[pos]['tx3']=txhash(tx3)#Counter party does not need tx3 raw unless he is meant to broadcast...
        else:
            MyContracts[pos]['tx3']=tx3
        MyContracts[pos]['tx3mysig']=sigs
        MyContracts[pos]['tx3raw']=tx3

        #Lets make the TimeoutTX and the refund and sign it. Remember they "sign first" because their public key is used first... but everything should look the same here.
        if contract['instantamount'] !=0:#Ok we can check  vout 1 and make a tx for it
            instantinputs=[]
            instantoutputs=[]
            refundins={}
            refundout={}
            refundins['output']=unicode(MyContracts[pos]['tx3']+":1")#If they put anything else in the temporary the funding will not work... both parties sign each position with a sig
            refundins['value']=int(contract['fee']+contract['instantamount'])
            refundins['address']=contract['escrow']
            if "I am" in contract['instantwhopays']:
                tmpout={'value':int(contract['instantamount']), 'address':multisig}
            else:
                tmpout={'value':int(contract['instantamount']), 'address':MyContracts[pos]['theiraddress']}#Who pays this?
            instantinputs.append(refundins)
            instantoutputs.append(tmpout)
            sigs2,result=create_sig_for_tx(instantinputs, instantoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30)#These were made earlier
            if result == False:
                MyContracts[pos]['Process']="Failed: "
                MyContracts[pos]['Reason']="TX5 Signature failed"
                return
            MyContracts[pos]['instantinputs']=instantinputs#Need it for next step
            MyContracts[pos]['instantoutputs']=instantoutputs
            MyContracts[pos]['tx5mysig']=sigs2
            Reply['tx5theirsig']=sigs2
        else:
            MyContracts[pos]['tx5mysig']="0"
            Reply['tx5theirsig']="0"
        #TimeoutTX
        timeinputs=[]
        timeoutputs=[]
        timeins={}
        timeout={}
        timeins['output']=unicode(MyContracts[pos]['tx3']+":0")#Its always vout 0
        timeins['value']=int(contract['mydeposit']+contract['theirdeposit']+contract['amount']+contract['fee'])#The question of wether or not to give to miners is a good one. Since this works for POS it means we send to Bitcoineater!!
        timeins['address']=contract['escrow']
        if BitHaloClient==False:
            timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3"} #bJnV8J5v74MGctMyVSVPfGu1mGQ9nMTiB3 is the base58 hash of Blackcoineateradios1 for Bitcoin you can also use 1BitcoinEaterAddressDontSendf59kuE
        else:
            timeout={'value':int(contract['mydeposit']+contract['theirdeposit']+contract['amount']), 'address':"1BitcoinEaterAddressDontSendf59kuE"}
        timeinputs.append(timeins)
        timeoutputs.append(timeout)
        sigs3,result=create_sig_for_tx(timeinputs, timeoutputs, MyContracts[pos]['myprivate'], MyContracts[pos]['theirpublic'],MyContracts[pos]['mypublic'], MyContracts[pos]['timestamp']+30)#These were made earlier
        if result == False:
            MyContracts[pos]['Process']="Failed: "
            MyContracts[pos]['Reason']="TX4 Signature failed"
            return
        MyContracts[pos]['timeinputs']=timeinputs#Need it for next step
        MyContracts[pos]['timeoutputs']=timeoutputs
        MyContracts[pos]['tx4mysig']=sigs3
        Reply['tx4theirsig']=sigs3
        Reply['tx3theirsig']=sigs#This way we can also confirm everything...check sigs etc
        if mytotal!=0:
            Reply['tx3']=txhash(tx3)#Counter party does not need tx3 raw unless he is meant to broadcast... but why not give it out?
        else:
            Reply['tx3']=tx3
        Reply['tx3raw']=tx3
        Reply['theirpublic2']=MyContracts[pos]['mypublic2']
        if theirtotal==0:#They should not be able to broadcast before we are ready if they have nothing invested
            Reply['tx3theirsig']=[]
            Reply['tx3raw']=""
        if rep==1:
            Reply['Market Data']={}
            Reply['Market Data']['reply']=json_deep_copy(Templates.reply,1)#Original reply
        if rep==2:
            Reply['Market Data']={}
            Reply['Market Data']['reply']=json_deep_copy(Templates.reply2,1)#Offeror reply
        MyContracts[pos]['mytotal']=mytotal#Lets start keeping track... it makes life easier
        MyContracts[pos]['theirtotal']=theirtotal
        MyContracts[pos]['lock']="0"
        MyContracts[pos]['Process']="Making Transactions"#That was so sexy
        BitQueue.append(Reply)
        SaveQueue()
        return True
    except Exception, e:
        traceback.print_exc()
    return False
def RemoveFromMarket(order, accnumber=""):
    print traceback.extract_stack()
    multisig,mscript=create_multisig_address(PrivKeyFilename1)
    Reply={}
    Reply['acc']=accnumber[:7]
    if 'dontclear' not in order['Market Data']:#There is no more quantity
        Reply['clearall']=1
    Reply['Process']='Remove Order'
    Reply['Command']='Send'
    priv=order['myprivate']
    pub=order['mypublic']
    Reply['MyBMAddress']=order['MyBMAddress']
    bmaddy=order['TheirBMAddress']
    if 'Market Data' in order:
        if 'Market Address' in order['Market Data']:
            if "BM-" in order['Market Data']['Market Address'] and "@" not in order['Market Data']['Market Address']:
                Reply['MyBMAddress']=GetfromCfg("#BitMessage#")
                bmaddy=order['Market Data']['Market Address']
    Reply['TheirBMAddress']=bmaddy
    Reply['ordernumber']=os.urandom(16).encode('hex')
    data=ModerationCheck(multisig, priv, Reply, pub)
    if data==False:
        return
    Reply=data
    res=VerifyMarketData(Reply)
    if res==True:
        BitQueue.append(Reply)
        SaveQueue()
def Resubmit(contract):
    global BitQueue, CurrentBlock, OnOrders, MyContracts
    if contract['Process']=="Market Order":
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        origpublic=get_ordered_pubkeys(PrivKeyFilename1, "", 0)[1]
        priv=contract['myprivate']
        pub=contract['mypublic']
        cblock=9999999999999999
        if CurrentBlock!=0:
            cblock=CurrentBlock
        i=0
        for c in MyContracts:
            if c['ordernumber']==contract['ordernumber']:
                ordernumber=str(contract['ordernumber'])
                MyContracts[i]['ordernumber']=os.urandom(16).encode('hex')+"##"+MyContracts[i]['ordernumber']
                MyContracts[i]['currentblock']=cblock
                break
            i+=1
        j=0
        for o in OnOrders:
            if 'ordernumber' in o:
                if o['ordernumber']==ordernumber:
                    break
            j+=1
        data=ModerationCheck(multisig, priv, MyContracts[i], pub, origpublic)
        if data==False:
            MyContracts[i]['ordernumber']=ordernumber
            return
        Reply=data
        res=VerifyMarketData(Reply)
        if res==True:
            Step1(Reply, priv, pub)
            MyContracts[i]['ordernumber']=ordernumber
            try:
                OnOrders[j]['currentblock']=cblock
            except:
                print "Order Index Not Found... is this a guarantor?"
        else:
            MyContracts[i]['ordernumber']=ordernumber
    else:#Should we obtain the private key here instead?!
        if 'Market Data' in contract:
            AmFirst=AmIFirst(PrivKeyFiledir1,PrivKeyFilename1)
            if AmFirst==1:
                priv,check=DecryptPrivateKey(PrivKeyFilename1,PrivKeyFiledir1,"0", "", lockforspending)
            else:
                if keysconnected!="2":
                    QuestionBox("You need both keys connected to resubmit this order.", "OK")
                    return
                priv,check=DecryptPrivateKey(PrivKeyFilename2,PrivKeyFiledir2,"0", "", lockforspending)
            Step1(contract, priv)
        else:
            Step1(contract)
timedseconds=300
class TimedMessageBox(QtGui.QMessageBox):#For situations where we don't want to hang the gui
    @QtCore.pyqtSlot()
    def timeoutSlot(self):

        #This is to avoid UnboundLocalError
        global timedseconds

        #Decrease seconds here
        timedseconds -= 1

        #Update QMessageBox text here
        #QtGui.QMessageBox.setText(self,"QMessageBox will close after "+QtCore.QString.number(timedseconds)+" seconds")
        #If reached 0,close the messagebox
        if timedseconds==0:
            timedseconds=300
            self.done(99)

def QuestionBox(text,button1,button2="",button3="", notrans=0,timed=0, defres=0):
    global SilenceUI
    if SilenceUI==1:#This tells which box to check when questioned
        return 0
    if SilenceUI==2:
        return 1
    if button2==1:
        button2=""
        notrans=1
    if button3==1:
        button3=""
        notrans=1
    if timed==0:
        msgBox = QtGui.QMessageBox()
    else:
        msgBox = TimedMessageBox()
    msgBox.setWindowTitle(CoinSelect['HaloName'])
    msgBox.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))

    if CoinSelect['moderngui']==1:
        qss_main = open(application_path+'/gui/styles/bay/messagebox.css', 'r')
        msgBox.setStyleSheet(qss_main.read()+"\nQMessageBox {background-color:#ffffff;}")

    #There is also norole and rejectrole however setting them all them same disables escape functions
    if notrans==0:
        msgBox.setText(Gtranslate(text, mylang))
    else:
        msgBox.setText(text)
    if notrans==0:
        msgBox.addButton(QtGui.QPushButton(Gtranslate(button1, mylang)), QtGui.QMessageBox.YesRole)
    else:
        msgBox.addButton(button1, QtGui.QMessageBox.YesRole)
    if button2!="":
        if notrans==0:
            msgBox.addButton(QtGui.QPushButton(Gtranslate(button2, mylang)), QtGui.QMessageBox.YesRole)
        else:
            msgBox.addButton(button2, QtGui.QMessageBox.YesRole)
    if button3!="":
        if notrans==0:
            msgBox.addButton(QtGui.QPushButton(Gtranslate(button3, mylang)), QtGui.QMessageBox.YesRole)
        else:
            msgBox.addButton(button3, QtGui.QMessageBox.YesRole)
    if timed==0:
        response = msgBox.exec_()
    else:
        response=defres
        timer = QtCore.QTimer()
        msgBox.connect(timer,QtCore.SIGNAL("timeout()"),msgBox,QtCore.SLOT("timeoutSlot()"))
        timer.start(1000)
        newres=msgBox.exec_()
        if newres!=99:
            response=newres
    return response
def DeleteContract(contract):
    global MyContracts, DontRepopulate
    print "\nREMOVING CONTRACT:"
    print traceback.extract_stack()
    #Can delete by position, ordernumber or contract
    Priv=""
    try:
        test=contract+1
        if MyContracts[contract]['ordernumber'] not in DontRepopulate:
            DontRepopulate.append(MyContracts[contract]['ordernumber'])
        if 'myprivate' in MyContracts[contract]:
            Priv=MyContracts[contract]['myprivate']
        if 'MyBMAddress' in MyContracts[contract]:
            if "@" in MyContracts[contract]['MyBMAddress']:
                CleanInboxOrder(MyContracts[contract]['ordernumber'], Priv)
        MyContracts.pop(contract)
        return True
    except:
        try:
            test=contract+"A"
            i=0
            for c in MyContracts:
                if c['ordernumber']==contract:
                    if c['ordernumber'] not in DontRepopulate:
                        DontRepopulate.append(c['ordernumber'])
                    if 'myprivate' in MyContracts[i]:
                        Priv=MyContracts[i]['myprivate']
                    if 'MyBMAddress' in MyContracts[i]:
                        if "@" in MyContracts[i]['MyBMAddress']:
                            CleanInboxOrder(MyContracts[i]['ordernumber'], Priv)
                    MyContracts.pop(i)
                    return True
                i+=1
        except:
            try:
                i=0
                for c in MyContracts:
                    if c['ordernumber']==contract['ordernumber']:
                        if c['ordernumber'] not in DontRepopulate:
                            DontRepopulate.append(c['ordernumber'])
                        if 'myprivate' in MyContracts[i]:
                            Priv=MyContracts[i]['myprivate']
                        if 'MyBMAddress' in MyContracts[i]:
                            if "@" in MyContracts[i]['MyBMAddress']:
                                CleanInboxOrder(MyContracts[i]['ordernumber'], Priv)
                        MyContracts.pop(i)
                        return True
                    i+=1
            except:
                pass
    return False
def DeleteOrder(ordernumber):
    print "\nREMOVING ORDER:"
    print traceback.extract_stack()
    global OnOrders
    o=-1
    for order in OnOrders:#The time we keep contracts in our inputs is before escrow funds because the inputs are tied on orders
        o+=1
        if 'ordernumber' in order:
            if order['ordernumber']==ordernumber:
                OnOrders.pop(o)
                break
def UpdateQuantity(order):
    global MyContracts
    try:
        pos=0
        fnd=0
        for c in MyContracts:
            if 'oldordernumber' in order:
                if c['ordernumber']==order['oldordernumber']:
                    fnd=1
                    break
            pos+=1
        if 'quantity' in c['Market Data'] and fnd==1:
            if "Coins" in c['Market Data']['Template']:
                if c['Market Data']['quantity']<=order['amount']:
                    myps=0
                    for c in MyContracts:
                        if 'oldordernumber' in c:
                            if c['oldordernumber']==MyContracts[pos]['ordernumber'] or c['ordernumber']==MyContracts[pos]['ordernumber']:
                                if 'dontclear' in MyContracts[myps]['Market Data']:
                                    MyContracts[myps]['Market Data'].pop("dontclear")
                        myps+=1
                MyContracts[pos]['Market Data']['quantity']-=order['amount']
                MessageMarkets('Update Quantity: ' + str(MyContracts[pos]['Market Data']['quantity']), c)
                return True
            if "Something" in c['Market Data']['Template']:
                if 'higherquantity' in order['Market Data']:
                    MyContracts[pos]['Market Data']['quantity']-=int(order['Market Data']['higherquantity'])
                else:
                    MyContracts[pos]['Market Data']['quantity']-=1
                if MyContracts[pos]['Market Data']['quantity'] <= 0:
                    MyContracts[pos]['Market Data']['quantity'] = 0
                    myps=0
                    for c in MyContracts:
                        if 'oldordernumber' in c:
                            if c['oldordernumber']==MyContracts[pos]['ordernumber'] or c['ordernumber']==MyContracts[pos]['ordernumber']:
                                if 'dontclear' in MyContracts[myps]['Market Data']:
                                    MyContracts[myps]['Market Data'].pop("dontclear")
                        myps+=1
                MessageMarkets('Update Quantity: ' + str(MyContracts[pos]['Market Data']['quantity']), c)
                return True
        if fnd==1 and c['Market Data']['Template']=="Barter":
            try:
                thingstopop=[]
                for item in MyContracts[pos]['Market Data']['barteritems']['demand']:
                    if item in order['Market Data']['barteritems']['demand'] and MyContracts[pos]['Market Data']['barteritems']['demand'][item]['EstValueSelect']==order['Market Data']['barteritems']['demand'][item]['EstValueSelect']:
                        try:
                            if order['Market Data']['barteritems']['demand'][item]['EstValueSelect']!=1:
                                q=MyContracts[pos]['Market Data']['barteritems']['demand'][item]['AddQuantityBox']
                                MyContracts[pos]['Market Data']['barteritems']['demand'][item]['AddQuantityBox']=str((Decimal(q)-Decimal(order['Market Data']['barteritems']['demand'][item]['quantity'])).quantize(Decimal('.0001')))
                            else:
                                q=MyContracts[pos]['Market Data']['barteritems']['demand'][item]['AddQuantityBox']
                                MyContracts[pos]['Market Data']['barteritems']['demand'][item]['AddQuantityBox']=str(int(Decimal(q)-Decimal(order['Market Data']['barteritems']['demand'][item]['quantity'])))                        
                            if Decimal(MyContracts[pos]['Market Data']['barteritems']['demand'][item]['AddQuantityBox'])<=Decimal(0):
                                thingstopop.append(item)
                        except:
                            pass
                for item in thingstopop:
                    MyContracts[pos]['Market Data']['barteritems']['demand'].pop(item)
            except:
                traceback.print_exc()
            try:
                thingstopop=[]
                for item in MyContracts[pos]['Market Data']['barteritems']['supply']:
                    if item in order['Market Data']['barteritems']['supply'] and MyContracts[pos]['Market Data']['barteritems']['supply'][item]['EstValueSelect']==order['Market Data']['barteritems']['supply'][item]['EstValueSelect']:
                        try:
                            if order['Market Data']['barteritems']['supply'][item]['EstValueSelect']!=1:
                                q=MyContracts[pos]['Market Data']['barteritems']['supply'][item]['AddQuantityBox']
                                MyContracts[pos]['Market Data']['barteritems']['supply'][item]['AddQuantityBox']=str((Decimal(q)-Decimal(order['Market Data']['barteritems']['supply'][item]['quantity'])).quantize(Decimal('.0001')))
                            else:
                                q=MyContracts[pos]['Market Data']['barteritems']['supply'][item]['AddQuantityBox']
                                MyContracts[pos]['Market Data']['barteritems']['supply'][item]['AddQuantityBox']=str(int(Decimal(q)-Decimal(order['Market Data']['barteritems']['supply'][item]['quantity'])))
                            if Decimal(MyContracts[pos]['Market Data']['barteritems']['supply'][item]['AddQuantityBox'])<=Decimal(0):
                                thingstopop.append(item)
                        except:
                            pass
                for item in thingstopop:
                    MyContracts[pos]['Market Data']['barteritems']['supply'].pop(item)
            except:
                traceback.print_exc()
            dmd=1
            if MyContracts[pos]['Market Data']['barteritems']['demand'] == {} and MyContracts[pos]['Market Data']['offernotinlist'] == 0:
                dmd=0
            if MyContracts[pos]['Market Data']['barteritems']['supply'] == {} or dmd==0:
                myps=0
                for c in MyContracts:
                    if 'oldordernumber' in c:
                        if c['oldordernumber']==MyContracts[pos]['ordernumber'] or c['ordernumber']==MyContracts[pos]['ordernumber']:
                            if 'dontclear' in MyContracts[myps]['Market Data']:
                                MyContracts[myps]['Market Data'].pop("dontclear")
                    myps+=1
                MessageMarkets('Update Quantity: ' + 'barteritems' + '0', c)
            else:
                MessageMarkets('Update Quantity: ' + 'barteritems' + str(MyContracts[pos]['Market Data']['barteritems']), c)
            return True
        return True                                
    except:
        traceback.print_exc()
        return False
def CheckAuction(contract, findbestbid=1):
    global MyContracts
    try:
        if 'StartingBid' in contract['Market Data'] and 'Something' in contract['Market Data']['Template']:
            oldordernumber=""
            thebestbid=1
            found=0
            if 'oldordernumber' in contract:
                oldordernumber=contract['oldordernumber']
            if 'oldordernumber' in contract['Market Data']:
                oldordernumber=contract['Market Data']['oldordernumber']
            for c in MyContracts:
                if c['ordernumber']==oldordernumber:
                    orgcontract=c
                    continue
                if c['ordernumber']==contract['ordernumber']:
                    continue                    
                oldordernumber2=""
                if 'oldordernumber' in c:
                    oldordernumber2=c['oldordernumber']
                if 'oldordernumber' in c['Market Data']:
                    oldordernumber2=c['Market Data']['oldordernumber']
                if oldordernumber2=="":
                    continue
                if oldordernumber==oldordernumber2:
                    if 'Sell' in c['Market Data']['Template']:
                        if c['amount']>=contract['amount']:
                            if contract['Market Data']['Template'] == "Something" and c['amount']==contract['amount']:
                                pass #We were told this was the best bid so if it's equal to our original offer we might update
                            else:
                                thebestbid=0
                    if 'Buy' in c['Market Data']['Template']:
                        if c['amount']<=contract['amount']:
                            if contract['Market Data']['Template'] == "Something" and c['amount']==contract['amount']:
                                pass #We were told this was the best bid so if it's equal to our original offer we might update
                            else:                            
                                thebestbid=0
            if thebestbid==1:
                for c in MyContracts:                  
                    oldordernumber2=""
                    if 'oldordernumber' in c:
                        oldordernumber2=c['oldordernumber']
                    if 'oldordernumber' in c['Market Data']:
                        oldordernumber2=c['Market Data']['oldordernumber']
                    if oldordernumber2=="":
                        continue
                    if oldordernumber==oldordernumber2:
                        found=1
                        c['Market Data']['BestBid']=contract['amount']
            if findbestbid==1 and found==1:
                MessageMarkets('Update Auction: ' + str(contract['amount']), orgcontract)
            return True
    except:
        traceback.print_exc()
        return False
class MyConsole(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(700, 500)
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.printarea = QtGui.QListWidget(Form)
        self.printarea.setGeometry(QtCore.QRect(10, 10, 680, 480))
        self.printarea.setFont(font)
        self.printarea.setObjectName(_fromUtf8("printarea"))        
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        ApplyCSS(self)
        self.amrunning=False
    def retranslateUi(self, Form):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def updatethis(self):
        global debug
        if debug==0:
            debug = Debugger()
            sys.stdout = debug
            sys.stderr = debug
        recent=debug.content[-50:]
        Console.printarea.clear()
        for i in recent:
            Console.printarea.addItem(str(i))
def ChangeLanguage(init=0):
    global langlist
    global mylang
    langselect=QtGui.QDialog()
    langselect.resize(270, 125)
    font = QtGui.QFont()
    font.setPixelSize(15)
    langselect.LangSelect = QtGui.QComboBox(langselect)
    langselect.LangSelect.setGeometry(QtCore.QRect(10, 10, 250, 30))
    langselect.LangSelect.setMaximumSize(QtCore.QSize(300, 16777215))
    langselect.LangSelect.setFont(font)
    langselect.LangSelect.setObjectName(_fromUtf8("LangSelect"))
    langselect.LangSelect.addItem(_fromUtf8("Select Language..."))
    langselect.LangSelect.addItem(_fromUtf8("English(default)"))

    langselect.LangLabel = QtGui.QLabel(langselect)
    langselect.LangLabel.setGeometry(QtCore.QRect(10, 45, 250, 30))
    langselect.LangLabel.setMaximumSize(QtCore.QSize(300, 16777215))
    langselect.LangLabel.setFont(font)
    langselect.LangLabel.setObjectName(_fromUtf8("LangButton"))
    langselect.LangLabel.setText(Gtranslate(" Hello World! ",mylang,init))

    langselect.LangButton = QtGui.QPushButton(langselect)
    langselect.LangButton.setGeometry(QtCore.QRect(10, 85, 75, 30))
    langselect.LangButton.setMaximumSize(QtCore.QSize(300, 16777215))
    langselect.LangButton.setFont(font)
    langselect.LangButton.setObjectName(_fromUtf8("LangButton"))
    langselect.LangButton.setText(" Apply ")
    def Langclick():
        try:
            if CoinSelect['moderngui']==1:
                window.setupMyFonts(window)
            window.retranslateUi(window)
            retranslateUi2()
        except:
            pass
        langselect.accept()
    def Langchg():
        global mylang
        ind=langselect.LangSelect.currentIndex()
        if ind==0:
            return
        elif ind==1:
            mylang="DEFAULT"
        else:
            cur=str(langselect.LangSelect.currentText())
            for l in langlist:
                if langlist[l]==cur:
                    mylang=l
                    break
        UpdateCfg('#language#',mylang, str(init))
        try:
            window.language=mylang
        except:
            pass
        langselect.LangLabel.setText(Gtranslate("Hello World!",mylang, init))
        return

    langselect.LangButton.clicked.connect(Langclick)
    langselect.LangSelect.connect(langselect.LangSelect,QtCore.SIGNAL("currentIndexChanged(int)"),Langchg)
    langl=[]
    current=""
    for l in langlist:
        langl.append(langlist[l])
        if l==mylang:
            current=langlist[l]
    langl.sort()
    i=2
    j=0
    for l in langl:
        if langl==current:
            j=i
        langselect.LangSelect.addItem(_fromUtf8(l))
        i+=1
    if mylang=="0":
        mylang="DEFAULT"
        UpdateCfg('#language#',mylang, str(init))
    else:
        langselect.LangSelect.blockSignals(True)
        if mylang=="DEFAULT":
            langselect.LangSelect.setCurrentIndex(1)
        else:
            langselect.LangSelect.setCurrentIndex(j)
        langselect.LangSelect.blockSignals(False)
    langselect.setWindowTitle(CoinSelect['HaloName'])
    langselect.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
    langselect.exec_()

def TranslationEditor(init=0):
    global langlist
    global mylang
    global translations
    langselect=QtGui.QDialog()    
    langselect.resize(500, 500)
    langselect.index=0
    langselect.index2=0
    font = QtGui.QFont()
    font.setPixelSize(15)
    OriginalTransLabel = QtGui.QLabel(langselect)
    OriginalTransLabel.setGeometry(QtCore.QRect(10, 10, 250, 30))
    OriginalTransLabel.setMaximumSize(QtCore.QSize(300, 16777215))
    OriginalTransLabel.setFont(font)
    OriginalTransLabel.setObjectName(_fromUtf8("OriginalTransLabel"))
    OriginalTransLabel.setText("English")

    NewTransLabel = QtGui.QLabel(langselect)
    NewTransLabel.setGeometry(QtCore.QRect(10, 210, 250, 30))
    NewTransLabel.setMaximumSize(QtCore.QSize(300, 16777215))
    NewTransLabel.setFont(font)
    NewTransLabel.setObjectName(_fromUtf8("NewTransLabel"))
    if mylang=="DEFAULT" or mylang=="en":
        QuestionBox("You are using the default language of English. There are no translations to edit!","OK")
        return
    NewTransLabel.setText(langlist[mylang])

    OriginalTrans = QtGui.QTextEdit(langselect)
    OriginalTrans.setGeometry(QtCore.QRect(10, 45, 480, 150))
    OriginalTrans.setMaximumSize(QtCore.QSize(480, 16777215))
    OriginalTrans.setFont(font)
    OriginalTrans.setObjectName(_fromUtf8("OriginalTrans"))
    OriginalTrans.setReadOnly(True)


    NewTrans = QtGui.QTextEdit(langselect)
    NewTrans.setGeometry(QtCore.QRect(10, 245, 480, 150))
    NewTrans.setMaximumSize(QtCore.QSize(480, 16777215))
    NewTrans.setFont(font)
    NewTrans.setObjectName(_fromUtf8("NewTrans"))


    Search = QtGui.QLabel(langselect)
    Search.setGeometry(QtCore.QRect(10, 210, 250, 30))
    Search.setMaximumSize(QtCore.QSize(300, 16777215))
    Search.setFont(font)
    Search.setObjectName(_fromUtf8("Search"))
    Search.setText(langlist[mylang])

    AutoTranslate = QtGui.QPushButton(langselect)
    AutoTranslate.setGeometry(QtCore.QRect(10, 410, 150, 30))
    AutoTranslate.setMaximumSize(QtCore.QSize(300, 16777215))
    AutoTranslate.setFont(font)
    AutoTranslate.setObjectName(_fromUtf8("Translate Online"))
    AutoTranslate.setText(" Translate Online ")

    Save = QtGui.QPushButton(langselect)
    Save.setGeometry(QtCore.QRect(10, 450, 150, 30))
    Save.setMaximumSize(QtCore.QSize(300, 16777215))
    Save.setFont(font)
    Save.setObjectName(_fromUtf8("Save"))
    Save.setText(" Save Translation ")

    Next = QtGui.QPushButton(langselect)
    Next.setGeometry(QtCore.QRect(330, 450, 150, 30))
    Next.setMaximumSize(QtCore.QSize(300, 16777215))
    Next.setFont(font)
    Next.setObjectName(_fromUtf8("Next"))
    Next.setText(" Next ")

    Prev = QtGui.QPushButton(langselect)
    Prev.setGeometry(QtCore.QRect(170, 450, 150, 30))
    Prev.setMaximumSize(QtCore.QSize(300, 16777215))
    Prev.setFont(font)
    Prev.setObjectName(_fromUtf8("Back"))
    Prev.setText(" Back ")

    def ShowTrans():
        if window.translist!=[]:
            OriginalTrans.setText(window.translist[langselect.index2])
            if window.translist[langselect.index2] in translations[mylang]:
                NewTrans.setText(strOUT(translations[mylang][window.translist[langselect.index2]]))
            else:
                NewTrans.setText("")
        if window.translist==[]:
            OriginalTrans.setText(translations[mylang].keys()[langselect.index])
            NewTrans.setText(strOUT(translations[mylang][translations[mylang].keys()[langselect.index]]))

    def SaveTrans():
        if window.translist!=[]:
            translations[mylang][window.translist[langselect.index2]]=strIN(NewTrans.toPlainText())
            window.translist.pop(langselect.index2)
            if langselect.index2 == len(window.translist):
                langselect.index2-=1
            if len(window.translist) > 0:
                ShowTrans()
        if window.translist==[]:
            translations[mylang][translations[mylang].keys()[langselect.index]]=strIN(NewTrans.toPlainText())
            NextClick()
            ShowTrans()
        return

    def NextClick():
        if window.translist!=[]:
            if langselect.index2+1!=len(window.translist):
                langselect.index2+=1        
        if window.translist==[]:
            if langselect.index+1!=len(translations[mylang].keys()):
                langselect.index+=1
        ShowTrans()
    def PrevClick():
        if window.translist!=[]:
            if langselect.index2!=0:
                langselect.index2-=1
        if window.translist==[]:
            if langselect.index!=0:
                langselect.index-=1
        ShowTrans()
    def AutomaticTranslation():
        try:
            if window.translist!=[]:
                text=window.translist[langselect.index2]
            else:
                text=translations[mylang].keys()[langselect.index]
            NewTrans.setText(translateInParts(text, mylang))
        except:
            traceback.print_exc()

    ApplyCSS(langselect,0,0)
    ShowTrans()
    Save.clicked.connect(SaveTrans)
    Next.clicked.connect(NextClick)
    Prev.clicked.connect(PrevClick)
    AutoTranslate.clicked.connect(AutomaticTranslation)

    langselect.setWindowTitle("Translation Editor - Powered by Yandex and Google Translate")
    langselect.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
    langselect.exec_()
    SaveTranslations()
def translateInParts(txt, lang):
    global gcodes
    global langlist
    x=0
    txt2=""
    origtxt=txt
    while x != 50:
        res = gtranslate2.GoogleTrans().query(txt, lang_to=gcodes[langlist[lang]])
        txt=txt.replace(res[0],'',1)
        txt2+=res[2]
        x+=1
        test=txt.replace(' ','')
        if len(test)==0:
            txt=''
        print "TEXT REMAINING: ", str(len(txt))
        if len(txt)==0:
            break
        if x==50:
            print "Iteration too long"
            float('a')
    print repr(txt2)
    return txt2
def Gtranslate(txt, lang="", init=0):
    global mylang
    global translations
    if txt=="":
        return txt
    if lang=="":
        lang=mylang
    if mylang=="DEFAULT" or mylang=="en":
        return txt
    if len(txt)>50 and YandexAPI == "":
        window.translist.append(txt)
        print "text too long(translate this manually)"
        print txt
        return txt
    try:
        if lang in translations:
            if txt in translations[lang]:
                translateThis=ast.literal_eval(translations[lang][txt])
                if translateThis!=txt:
                    return QtCore.QString.fromUtf8(translateThis)
        else:
            translations[lang]={}
        if YandexAPI != "":            
            resp = gstrans.translate(txt, lang) #Yandex
            resp = resp['text'][0]
        else:
            resp = translateInParts(txt, lang) #Google translate in parts            
        langtext = QtGui.QLabel()
        langtext.setText(resp)
        x=langtext.text()
        st=repr(x)
        st=st.replace("PyQt4.QtCore.QString(","")[:-1]
        translateThis=ast.literal_eval(st)
        translations[lang][txt]=st
        if init==0:#File thread not loaded yet
            SaveTranslations()
        return QtCore.QString.fromUtf8(translateThis)
    except:
        print traceback.extract_stack()
        traceback.print_exc()
        return txt
def strIN(st, rep=1):#For input from QStrings and files, dictionary objects we wrote to
    try:
        if st=="":
            return ""
        if "PyQt4.QtCore.QString(" in repr(st[0:21]):
            st=repr(st)
            st=st[21:][:-1]
        if st[0]=='u' and st[1]=="'" or st[0]=='u' and st[1]=='"':
            if rep==1:
                return st
            else:
                return ast.literal_eval(st)
        st1=repr(st)
        if st1[0]=='u' and st1[1]=="'" or st1[0]=='u' and st1[1]=='"':
            if rep==1:
                return st1
            else:
                return ast.literal_eval(st1)
        return st
    except:
        return ""
def strOUT(st):#For output to unicode QStrings or files
    try:
        if st=="":
            return st
        if st[0]=='u' and st[1]=="'" or st[0]=='u' and st[1]=='"':
            return ast.literal_eval(st)
        else:
            st1=repr(st)
            if st1[0]=='u' and st1[1]=="'" or st1[0]=='u' and st1[1]=='"':
                return ast.literal_eval(st1)
            return st
    except:
        return ""
def DebugExec():
    global dwindow
    try:
        text=""
        consolecommand=str(dwindow.InputWin.toPlainText())
        exec(consolecommand)# in globals(), locals()   ... we used to use this when it was nested
        dwindow.OutputWin.setText(text)
    except:
        dwindow.OutputWin.setText(str(traceback.format_exc()))
    return
def CountVotes(addy, start, finish):
    global LockTHIS, BLK, lockdownload, isdownloading
    timeit=0
    busy=0
    burn=0
    if 'pegging' in CoinSelect and CoinSelect['pegging']:
        burn=1
    addy=MakeCipherOutputs(addy,burn)
    addy=str(addy[0])    
    while 'BM' in LockTHIS or 'DL' in LockTHIS or 'BL' in LockTHIS or isdownloading==1:
        time.sleep(.01)
        timeit+=1
        if timeit>1000:
            busy=1
            break
    if 'BM' not in LockTHIS and 'DL' not in LockTHIS and 'BL' not in LockTHIS and isdownloading!=1:
        lockdownload=1
        LockTHIS['AP']=1
        res=False
        MySettings.CountProgress.show()
        orgstart=start
        nodivide=0
        if finish==start:
            nodivide=1
        try:
            votecount=0
            val=0
            fails=0
            while start <= finish:
                if fails>10:
                    float("a")
                nextone=1
                if MySettings.stopcount==1:
                    print "Voting Counting Stopped"
                    break
                try:
                    hsh=BLK.getblockhash(start)
                except:
                    time.sleep(1)
                    fails+=1
                    nextone=0
                try:
                    block=BLK.getblock(hsh)
                except:
                    time.sleep(1)
                    fails+=1
                    nextone=0
                try:
                    trans=deserialize(BLK.getrawtransaction(block['tx'][1]))
                except:
                    time.sleep(1)                
                    fails+=1
                    nextone=0
                for out in trans['outs']:
                    if burn==0:
                        if address_to_script(addy) == out['script']:
                            votecount+=1
                            break
                    else:
                        if addy==out['script']:
                            votecount+=1
                            break
                if nodivide==1:
                    val=100
                else:
                    val=int(((Decimal(start)-Decimal(orgstart))/(Decimal(finish)-Decimal(orgstart)))*Decimal(100))
                MySettings.CountProgress.setValue(val)
                app.processEvents()
                if nextone==1:
                    start+=1
            res=str(votecount)
        except:
            traceback.print_exc()
        MySettings.CountProgress.setValue(val)
        app.processEvents()
        try:
            LockTHIS.pop('AP', None)
        except:
            pass
        lockdownload=0
        return res
    lockdownload=0
    if busy==1:
        return "The blockchain is busy, please try again later."
    return False
def MessageMarkets(message, cont):
    global BitQueue
    multisig,multiscript=create_multisig_address(PrivKeyFilename1)
    contract=copy.deepcopy(cont)
    if 'Market Data' in contract:
        pubs=get_ordered_pubkeys(PrivKeyFilename1)
        Reply={}#txresult        
        Reply['Process']='Market Message'
        Reply['message']=message
        Reply['Command']='Send'
        try:
            Reply['oldordernumber']=contract['oldordernumber']
        except:
            Reply['oldordernumber']=contract['ordernumber']
        Reply['MyBMAddress']=contract['MyBMAddress']

        priv=contract['myprivate']
        pub=contract['mypublic']        

        if 'Market Address' in contract['Market Data']:
            #if "BM-" in contract['Market Data']['Market Address'] and "@" not in contract['Market Data']['Market Address']:
            Reply['MyBMAddress']=GetfromCfg("#BitMessage#")
            Reply['TheirBMAddress']=contract['Market Data']['Market Address']
        else:
            Reply['TheirBMAddress']=contract['TheirBMAddress']
        Reply['ordernumber']=os.urandom(16).encode('hex')
        data=ModerationCheck(multisig, priv, Reply, pub)
        if data==False:
            pass
        else:
            Reply=data
            res=VerifyMarketData(Reply)
            if res==True:
                BitQueue.append(Reply)
                SaveQueue()    
def ApplyCSS(mywindow, other=1, font=1):
    global mylang
    if CoinSelect['moderngui']==1:
        qss_main = open(application_path+'/gui/styles/bay/generic.css', 'r')
        mywindow.setStyleSheet(qss_main.read())
        if other==1:
            t=mywindow.findChildren(QtGui.QTextEdit)
            for thing in t:
                thing.setStyleSheet(qss_main.read())
            t=mywindow.findChildren(QtGui.QLineEdit)
            for thing in t:
                thing.setStyleSheet(qss_main.read())
        if mylang=="DEFAULT" or mylang=="en":
            if font==1:
                t=mywindow.findChildren(QtGui.QLabel)
                for thing in t:
                    s = thing.font()
                    s.setFamily("Roboto")
                    thing.setFont(s)                
import time
import webbrowser
import sys
from PyQt4 import QtGui, QtCore

#########################
#Custom buttons and forms
#yes i know more "global" variables... will change this later
ContactSelected = {}
ContractSelected = {}
PendingSelected = {}

#def getObject(qobj, name):
#    return qobj.findChild((QtGui.QLabel,QtGui.QTextEdit,QtGui.QComboBox,QtGui.QLineEdit,QtGui.QPushButton,QtGui.QCheckBox),name)
#The call below doesn't work because while iterating every object returned for whatever reason gets assigned the same function call as the most current object.
#So eventually can exchange exec calls for template setups so be explicit or solve how to safely interact with return values. In the meantime, exec calls are an iterative way to handle hundreds of objects.
#getObject(self.Window,"DepositSettings"+spos).connect(getObject(self.Window,"DepositSettings"+spos),QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.StandardDepositChange(spos))

#protectOBF1
class TemplateWindow(QtGui.QWidget):
    def setup_Ui(self, Dialog):
        global AdvanceArray
        self.Window=ATemplates.MyForm()
        ApplyCSS(self.Window, 1, 1)
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        Dialog.setWindowTitle(CoinSelect['HaloName'])
        self.dropdowns=["MyDepositUSD", "TheirDepositUSD", "TimeLimitDays"]
        self.boxes=["MyDepositBox","TheirDepositBox","TimeLimitBox"]
        self.mytext=["MyDepositText","TheirDepositText","TimeLimitText"]
        self.buttons=["SaveContinue","ClearForm"]
        self.checked=["SaveFuture","SupplyAdditional"]
        self.hideoninit=["ContactSelectConfirm","ContactEdit","ContactConfirm","MailingSelectConfirm","AddressEdit","MailingConfirm","BankSelectConfirm","BankEdit","BankConfirm","WUSelectConfirm","WUEdit","WUConfirm","MGSelectConfirm","MGEdit","MGConfirm","DebitSelectConfirm","DebitEdit","DebitConfirm","OtherSelectConfirm","OtherEdit","OtherConfirm"]
        self.defaulthidden=["MaxIncreaseSell","MaxDecreaseSell","PriceTrackingTitle","LimitOrderText1","MaxIncreaseSellBox","MaxDecreaseSellBox","MinOrderSell","MaxOrderSell","MinOrderSellBox","MaxOrderSellBox","ServiceChargeBox","Price","PriceBox","PriceUSD","PriceTrackingTitle2","LimitOrderText2","PriceText2","PriceBox2","PriceUSD2","perc1","perc2","perc3","perc4","perc5","perc6","perc7","perc8","perc9","MaxIncreaseBuy","MaxDecreaseBuy","MaxIncreaseBuyBox","MaxDecreaseBuyBox","MinOrderBuy","MaxOrderBuy","MinOrderBuyBox","MaxOrderBuyBox","DurationSellText","DurationSellBox","DurationSellDays","BidSellText","BidSellBox","BidSellUSD","ShipToSellBox","ShipToTextSell","WeightSellSelect","RateSellUSD","WeightSellBox","RateSellBox2","WeightSellText","RateSellText","DurationBuyText","DurationBuyBox","DurationBuyDays","BidBuyText","BidBuyBox","BidBuyUSD","ShipToBuyBox","ShipToBuyText", "MaxItems","MaxItemsBox","AddShipToBox","AddShipToText","AddMaxSizeBox","AddMaxSizeUSD","SetMinBox","SetMinUSD","SetMaxBox","SetMaxUSD","DepositServiceBox","perc10","DepositServiceSelect"]
        self.defaultchecked=["BankWireCheck","BankWireCheck2","WUCheck","WUCheck2","AcceptOneCheck","AcceptTempCheck","AcceptFullCheck","AcceptInterviewCheck","ShippingCityBuy","OfferNotInList","BuyMultiple"]
        self.pos=0
        self.returntoconfirm=0
        self.dontremoveonupdate=0
        self.cashmail=0
        self.rate=""
        self.Data={}
        self.order={}
        self.readonly=0
        self.Dif=0
        self.reply={}
        self.reply2={}
        self.orgamount=""
        self.orgmydeposit=""
        self.orgtheirdeposit=""
        self.orghours=""
        self.barteritems={'supply':{},'demand':{}}
        self.barteritems2={'supply':{},'demand':{}}
        self.origin=0
        self.originwindow=0
        self.barterwindow=1
        self.evenbarter=1
        i=1
        while i<10:
            if i!=8:
                self.defaultchecked.append(self.checked[0]+str(i))
            self.defaultchecked.append(self.checked[1]+str(i))
            if i==1:
                j=""
            else:
                j=str(i)
            self.defaulthidden.append(self.dropdowns[0]+str(j))
            self.defaulthidden.append(self.dropdowns[1]+str(j))
            self.defaulthidden.append(self.dropdowns[2]+str(j))
            self.defaulthidden.append(self.boxes[0]+str(j))
            self.defaulthidden.append(self.boxes[1]+str(j))
            self.defaulthidden.append(self.boxes[2]+str(j))
            self.defaulthidden.append(self.mytext[0]+str(j))
            self.defaulthidden.append(self.mytext[1]+str(j))
            self.defaulthidden.append(self.mytext[2]+str(j))
            i+=1
        pos=0
        for obj in self.dropdowns:
            pos2=1
            while pos2<10:
                spos=str(pos2)
                if spos=="1":
                    spos=""
                if pos<2:
                    exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+spos)+".connect(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+spos)+",QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.DepositChange('"+re.sub(r"[^A-Za-z0-9_]+", '',obj+spos)+"'))\n")
                    if pos==1:
                        exec("self.Window."+"DepositSettings"+re.sub(r"[^A-Za-z0-9_]+", '',spos)+".connect(self.Window."+"DepositSettings"+re.sub(r"[^A-Za-z0-9_]+", '',spos)+",QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.StandardDepositChange('"+re.sub(r"[^A-Za-z0-9_]+", '',spos)+"'))\n")
                        if spos=="":
                            spos="1"
                        if spos!="8":
                            exec("self.Window."+"SaveContinue"+re.sub(r"[^A-Za-z0-9_]+", '',spos)+".clicked.connect(lambda: Templates.SaveAndContinue('"+re.sub(r"[^A-Za-z0-9_]+", '',spos)+"'))\n")
                            exec("self.Window."+"ClearForm"+re.sub(r"[^A-Za-z0-9_]+", '',spos)+".clicked.connect(lambda: Templates.ClearMyForm('"+re.sub(r"[^A-Za-z0-9_]+", '',spos)+"'))\n")
                else:
                    exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+spos)+".connect(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+spos)+",QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.DaysChange('"+re.sub(r"[^A-Za-z0-9_]+", '',obj+spos)+"'))\n")
                pos2+=1
            pos+=1
        pos=1
        while pos<9:
            exec("self.Window.Save"+re.sub(r"[^A-Za-z0-9_]+", '',str(pos))+".clicked.connect(lambda: Templates.SaveProfile("+str(pos-1)+"))\n")
            exec("self.Window.Create"+re.sub(r"[^A-Za-z0-9_]+", '',str(pos))+".clicked.connect(lambda: Templates.CreateProfile("+str(pos-1)+"))\n")
            exec("self.Window.Update"+re.sub(r"[^A-Za-z0-9_]+", '',str(pos))+".clicked.connect(lambda: Templates.UpdateProfile("+str(pos-1)+"))\n")
            exec("self.Window.Remove"+re.sub(r"[^A-Za-z0-9_]+", '',str(pos))+".clicked.connect(lambda: Templates.RemoveProfile("+str(pos-1)+"))\n")
            pos+=1
        exec("self.Window.BankEdit.clicked.connect(lambda: Templates.EditConfirm(1))\n")
        exec("self.Window.WUEdit.clicked.connect(lambda: Templates.EditConfirm(2))\n")
        exec("self.Window.MGEdit.clicked.connect(lambda: Templates.EditConfirm(3))\n")
        exec("self.Window.DebitEdit.clicked.connect(lambda: Templates.EditConfirm(4))\n")
        exec("self.Window.OtherEdit.clicked.connect(lambda: Templates.EditConfirm(5))\n")
        exec("self.Window.AddressEdit.clicked.connect(lambda: Templates.EditConfirm(7))\n")
        exec("self.Window.ContactEdit.clicked.connect(lambda: Templates.EditConfirm(8))\n")
        exec("self.Window.ShowAdvancedCash.clicked.connect(lambda: Templates.ShowAdvanced('ShowAdvancedCash'))\n")
        exec("self.Window.ShowAdvancedCashBuy.clicked.connect(lambda: Templates.ShowAdvanced('ShowAdvancedCashBuy'))\n")
        exec("self.Window.sendspacelink.clicked.connect(lambda: Templates.SendSpace())\n")
        exec("self.Window.Link2.clicked.connect(lambda: Templates.SendSpace())\n")
        exec("self.Window.imgurlink.clicked.connect(lambda: Templates.imgur())\n")
        exec("self.Window.BuyMultiple.clicked.connect(lambda: Templates.ShowAdvanced('BuyMultiple'))\n")
        exec("self.Window.ConfirmOrder.clicked.connect(lambda: Templates.Confirm())\n")
        exec("self.Window.Delete.clicked.connect(lambda: Templates.Delete())\n")
        exec("self.Window.AutoAcceptValid.clicked.connect(lambda: Templates.AutoInfo())\n")
        exec("self.Window.Button1.clicked.connect(lambda: Templates.Button1())\n")
        exec("self.Window.Button2.clicked.connect(lambda: Templates.Button2())\n")

        exec("self.Window.Accept.clicked.connect(lambda: Templates.MakeOrder(0))\n")
        exec("self.Window.Counter.clicked.connect(lambda: Templates.MakeOrder(1))\n")
        exec("self.Window.Drop1.connect(self.Window.Drop1,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(1))\n")
        exec("self.Window.Drop2.connect(self.Window.Drop2,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(2))\n")
        exec("self.Window.Drop3.connect(self.Window.Drop3,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(3))\n")
        exec("self.Window.Drop4.connect(self.Window.Drop4,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(4))\n")
        exec("self.Window.DepositSettings10.connect(self.Window.DepositSettings10,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(5))\n")
        exec("self.Window.MyDepositUSD10.connect(self.Window.MyDepositUSD10,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(6))\n")
        exec("self.Window.TheirDepositUSD10.connect(self.Window.TheirDepositUSD10,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(7))\n")
        exec("self.Window.TimeLimitDays10.connect(self.Window.TimeLimitDays10,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(8))\n")
        exec("self.Window.SelectContact.connect(self.Window.SelectContact,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeOrderIndex(9))\n")

        exec("self.Window.SellAttachImage.clicked.connect(lambda: window.AddImage('Sell'))\n")
        exec("self.Window.BuyAttachImage.clicked.connect(lambda: window.AddImage('Buy'))\n")
        exec("self.Window.AttachImagePython.clicked.connect(lambda: window.AddImage('Python'))\n")
        exec("self.Window.ExplainSellCash.clicked.connect(lambda: window.Explain(10))\n")
        exec("self.Window.ExplainCashBuy.clicked.connect(lambda: window.Explain(11))\n")
        exec("self.Window.ExplainHire.clicked.connect(lambda: window.Explain(12))\n")
        exec("self.Window.ExplainFind.clicked.connect(lambda: window.Explain(13))\n")
        exec("self.Window.ExplainSell.clicked.connect(lambda: window.Explain(14))\n")
        exec("self.Window.ExplainBuy.clicked.connect(lambda: window.Explain(15))\n")
        exec("self.Window.ExplainBarter.clicked.connect(lambda: window.Explain(16))\n")
        exec("self.Window.ExplainBarterOffer.clicked.connect(lambda: window.Explain(17))\n")
        exec("self.Window.ExplainPython.clicked.connect(lambda: window.Explain(18))\n")
        exec("self.Window.MarketExplanation.clicked.connect(lambda: window.Explain(19))\n")
        exec("self.Window.LoadFormPython.clicked.connect(lambda: Templates.PythonCodePath(0))\n")
        exec("self.Window.LoadMyPython.clicked.connect(lambda: Templates.PythonCodePath(1))\n")
        exec("self.Window.LoadTheirPython.clicked.connect(lambda: Templates.PythonCodePath(2))\n")
        exec("self.Window.PythonSelect.connect(self.Window.PythonSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.PythonIndex(0))\n")
        exec("self.Window.AddItemSupply.clicked.connect(lambda: Templates.ShowItem(0))\n")
        exec("self.Window.AddItemDemand.clicked.connect(lambda: Templates.ShowItem(1))\n")
        exec("self.Window.MyOfferNotInList.clicked.connect(lambda: Templates.ShowItem(2))\n")
        exec("self.Window.AddItemToList.clicked.connect(lambda: Templates.AddItem())\n")
        exec("self.Window.RemoveItemFromList.clicked.connect(lambda: Templates.RemoveItem())\n")
        exec("self.Window.AddShippingSelect.connect(self.Window.AddShippingSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.AddMaxSizeSelect.connect(self.Window.AddMaxSizeSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.EstValueSelect.connect(self.Window.EstValueSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.SetMinSelect.connect(self.Window.SetMinSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.SetMaxSelect.connect(self.Window.SetMaxSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.QuantitySelect.connect(self.Window.QuantitySelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.MakeOfferBarter.clicked.connect(lambda: Templates.OfferBarter(1))\n")
        exec("self.Window.CancelBarter.clicked.connect(lambda: Templates.OfferBarter(0))\n")

        exec("self.Window.SetMaxSelect.connect(self.Window.SetMaxSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.SetMaxSelect.connect(self.Window.SetMaxSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.SetMaxSelect.connect(self.Window.SetMaxSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")
        exec("self.Window.SetMaxSelect.connect(self.Window.SetMaxSelect,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")

        exec("self.Window.RequestAll.connect(self.Window.RequestAll,QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeBarterIndex())\n")

        QtCore.QObject.connect(self.Window.SupplyBox, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.SupplyClick)
        QtCore.QObject.connect(self.Window.DemandBox, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.DemandClick)

        QtCore.QObject.connect(self.Window.TheirSupplyBox, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.SupplyClick2)
        QtCore.QObject.connect(self.Window.TheirDemandBox, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.DemandClick2)

        QtCore.QObject.connect(self.Window.MyDemandBox, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.SupplyClick3)
        QtCore.QObject.connect(self.Window.MySupplyBox, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.DemandClick3)

        self.objlist=["WireSelect","WUSelect","MGSelect","DebitSelect","OtherFundSelect","CashMailSelect","MailingSelect","ContactSelect","ContactSelectConfirm","MailingSelectConfirm","BankSelectConfirm","WUSelectConfirm","MGSelectConfirm","DebitSelectConfirm","OtherSelectConfirm"]
        for obj in self.objlist:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".connect(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+",QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ChangeIndex('"+re.sub(r"[^A-Za-z0-9_]+", '',obj)+"'))\n")
        self.objcombos=["MaxIncreaseBuy", "MaxDecreaseBuy", "MinOrderBuy", "MaxOrderBuy", "MaxIncreaseSell", "MaxDecreaseSell", "MinOrderSell", "MaxOrderSell", "RateBox", "RateBox2", "AmountUSD2", "AmountUSD", "ServiceCharge", "JobUSD", "JobSelect1", "SellSelect", "BuyoutSellUSD", "BidSellUSD", "CountrySellSelect", "ShippingSellSelect", "ShipCountryBuy", "BuySelect", "BuyoutBuyUSD", "BidBuyUSD", "RequestAll", "AddShippingSelect", "EstValueUSD", "AddMaxSizeSelect", "SetMinSelect", "SetMaxSelect", "EstValueSelect", "DepositServiceSelect", "SentToSelect", "FindUSD"]
        for obj in self.objcombos:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".connect(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+",QtCore.SIGNAL('currentIndexChanged(int)'),lambda: Templates.ShowAdvanced('"+re.sub(r"[^A-Za-z0-9_]+", '',obj)+"'))\n")

    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setup_Ui(self)
    def retranslateUi(self):
        self.Window.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.Window.setWindowTitle(CoinSelect['HaloName'])
    def SendSpace(self):
        webbrowser.open("https://www.sendspace.com")
    def imgur(self):
        webbrowser.open("https://www.imgur.com")
    def PythonCodePath(self,box):
        QuestionBox("Please open the file to your python code.", " OK ")
        path = QtGui.QFileDialog.getOpenFileName(self.Window,Gtranslate("Please open your python file."),MacDir()+"","Python (*.py)")
        if box==0:
            self.Window.CodeOfferFormBox.setText(path)
        if box==1:
            self.Window.CodeDuringEscrow.setText(path)
        if box==2:
            self.Window.CodeEscrowWindow.setText(path)
    def PythonIndex(self,populate=1):
        if populate==1:
            self.Window.PythonSelect.blockSignals(True)        
            self.Window.PythonSelect.clear()
            try:
                self.Window.PythonSelect.addItem(('Select a contract...'))
                self.Window.PythonSelect.addItem(('Custom Python Contract'))
                for c in ApprovedContracts:
                    self.Window.PythonSelect.addItem((ApprovedContracts[c]['name']))
                self.Window.PythonSelect.setCurrentIndex(0)
            except:
                traceback.print_exc()
                print "Error populating Python Index"
            self.Window.PythonSelect.blockSignals(False)
        else:
            if self.Window.PythonSelect.currentIndex() > 1:
                for c in ApprovedContracts:
                    if ApprovedContracts[c]['name']==self.Window.PythonSelect.currentText():
                        break
                if os.name == 'nt':
                    adir=os.path.join(application_path+"\\"+'custom',ApprovedContracts[c]['file1'])
                else:
                    adir=os.path.join(application_path+"/"+'custom',ApprovedContracts[c]['file1']) #Its probably Linux.
                if os.name == 'nt':
                    bdir=os.path.join(application_path+"\\"+'custom',ApprovedContracts[c]['file2'])
                else:
                    bdir=os.path.join(application_path+"/"+'custom',ApprovedContracts[c]['file2']) #Its probably Linux.
                if os.name == 'nt':
                    cdir=os.path.join(application_path+"\\"+'custom',ApprovedContracts[c]['file3'])
                else:
                    cdir=os.path.join(application_path+"/"+'custom',ApprovedContracts[c]['file3']) #Its probably Linux.
                self.Window.CodeOfferFormBox.setText(adir)
                self.Window.CodeDuringEscrow.setText(bdir)
                self.Window.CodeEscrowWindow.setText(cdir)
                path = strOUT(strIN(self.Window.CodeOfferFormBox.text()))
                if path=="":
                    return
                try:
                    with open(path,'r') as f:
                        text=f.readlines()
                        f.close()
                except:
                    QuestionBox("Error loading Python file", " OK ")
                text2=''
                for t in text:
                    text2+=t
                h1 = text2
                path = strOUT(strIN(self.Window.CodeDuringEscrow.text()))
                if path=="":
                    return
                try:
                    with open(path,'r') as f:
                        text=f.readlines()
                        f.close()
                except:
                    QuestionBox("Error loading Python file", " OK ")
                text2=''
                for t in text:
                    text2+=t
                h2 = text2
                path = strOUT(strIN(self.Window.CodeEscrowWindow.text()))
                if path=="":
                    return
                try:
                    with open(path,'r') as f:
                        text=f.readlines()
                        f.close()
                except:
                    QuestionBox("Error loading Python file", " OK ")
                text2=''
                for t in text:
                    text2+=t
                h3 = text2
                if txhash(h1+h2+h3)!=c:
                    QuestionBox("The hash does not match the code. Please make sure that the code has not been changed from it's original text.", " OK ")
                    print txhash(h1+h2+h3)
                    self.Window.CodeOfferFormBox.clear()
                    self.Window.CodeDuringEscrow.clear()
                    self.Window.CodeEscrowWindow.clear()
                    self.Window.PythonSelect.blockSignals(True)
                    self.Window.PythonSelect.setCurrentIndex(0)
                    self.Window.PythonSelect.blockSignals(False)
                    return
            else:
                self.Window.CodeOfferFormBox.clear()
                self.Window.CodeDuringEscrow.clear()
                self.Window.CodeEscrowWindow.clear()
    def ShowItem(self, origin, item='', tracked=0):
        self.Window.DepositServiceBox.hide()
        self.Window.DepositServiceSelect.hide()
        self.Window.perc10.hide()

        self.Window.AddShipToText.hide()
        self.Window.AddShipToBox.hide()
        self.Window.AddMaxSizeBox.hide()
        self.Window.AddMaxSizeUSD.hide()
        self.Window.SetMinBox.hide()
        self.Window.SetMinUSD.hide()
        self.Window.SetMaxBox.hide()
        self.Window.SetMaxUSD.hide()
        self.Window.AddQuantityText.hide()
        self.Window.AddQuantityBox.hide()
        self.Window.QuantitySelect.hide()
        self.Window.SetMinSelect.show()
        self.Window.SetMaxSelect.show()

        self.Window.AddItemToList.show()
        self.Window.RemoveItemFromList.show()
        self.Window.RemoveItemFromList.setText("Remove Item")
        if self.originwindow==1:
            self.Window.AddItemToList.hide()
            self.Window.RemoveItemFromList.hide()

        self.origin=origin
        returnpage=14
        if origin==2 or origin>4:
            returnpage=16
            if origin>8:
                self.Window.RemoveItemFromList.show()
                self.Window.RemoveItemFromList.setText("Return")
                returnpage=19
        if origin==0 or origin==1 or origin==2:
            self.ClearItem()
            self.Window.EstValueBox.setReadOnly(False)
            self.Window.SetMinBox.setReadOnly(False)
            self.Window.SetMaxBox.setReadOnly(False)
            if origin==2:
                self.Window.SetMinSelect.hide()
                self.Window.SetMaxSelect.hide()
        else:
            try:
                if origin==3 or origin==5 or origin==7 or origin==9:
                    myitem=self.barteritems['supply'][item]
                if origin==4 or origin==6 or origin==8 or origin==10:
                    myitem=self.barteritems['demand'][item]
                self.Window.AddShippingSelect.setCurrentIndex(myitem['AddShippingSelect'])
                self.Window.EstValueSelect.setCurrentIndex(myitem['EstValueSelect'])
                self.Window.AddMaxSizeSelect.setCurrentIndex(myitem['AddMaxSizeSelect'])
                self.Window.SetMinSelect.setCurrentIndex(myitem['SetMinSelect'])
                self.Window.SetMaxSelect.setCurrentIndex(myitem['SetMaxSelect'])
                self.Window.DepositServiceSelect.setCurrentIndex(myitem['DepositServiceSelect'])
                self.Window.QuantitySelect.setCurrentIndex(myitem['QuantitySelect'])
                self.Window.AddMaxSizeUSD.setCurrentIndex(myitem['AddMaxSizeUSD'])
                self.Window.EstValueUSD.setCurrentIndex(myitem['EstValueUSD'])
                self.Window.SetMinUSD.setCurrentIndex(myitem['SetMinUSD'])
                self.Window.SetMaxUSD.setCurrentIndex(myitem['SetMaxUSD'])
                self.ChangeBarterIndex()

                self.Window.AddTitleBox.setText(myitem['AddTitleBox'])
                self.Window.AddDescriptionBox.setText(myitem['AddDescriptionBox'])
                self.Window.AddShipToBox.setText(myitem['AddShipToBox'])                
                self.Window.AddLinkImagesBox.setText(myitem['AddLinkImagesBox'])
                
                self.Window.EstValueBox.setReadOnly(False)
                self.Window.SetMinBox.setReadOnly(False)
                self.Window.SetMaxBox.setReadOnly(False)
                self.Window.EstValueBox.setText(myitem['EstValueBox'])
                if self.origin==5 or self.origin==7 or self.origin>8:
                    self.Window.EstValueBox.setReadOnly(True)
                    self.Window.SetMinBox.setReadOnly(True)
                    self.Window.SetMaxBox.setReadOnly(True)
                self.Window.AddMaxSizeBox.setText(myitem['AddMaxSizeBox'])
                self.Window.SetMinBox.setText(myitem['SetMinBox'])
                self.Window.SetMaxBox.setText(myitem['SetMaxBox'])

                self.Window.AddQuantityBox.setText(myitem['AddQuantityBox'])
                self.Window.DepositServiceBox.setText(myitem['DepositServiceBox'])
                if origin>4 and origin<9:
                    if 'ActualValue' not in myitem:
                        if myitem['EstValueUSD']==0:
                            myitem['ActualValue']=int((Decimal(myitem['EstValueBox'])/Decimal(self.order['Market Data']['rate']))*Decimal(1e8))
                        else:
                            myitem['ActualValue']=int((Decimal(myitem['EstValueBox'])*Decimal(1e8)))
                if tracked==1 or tracked==2:
                    if 'ActualValue' in myitem:
                        if self.order['Market Data']['tracking']==1:
                            if self.rate=='':
                                QuestionBox('Please wait for the exchange rate to load.', ' OK ')
                                return
                            Dif=(Decimal(self.order['Market Data']['rate'])/Decimal(self.rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)
                            if self.Window.EstValueUSD.currentIndex()==0:
                                st=str(int(Decimal(myitem['ActualValue'])/Decimal(1e8)*Decimal(self.rate)*Decimal(Dif)*Decimal(100)))
                                st=str(Decimal(st)/Decimal(100))
                            else:
                                st=str(((Decimal(myitem['ActualValue'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001')))
                            self.Window.EstValueBox.setText(st)
                            if self.Window.SetMinSelect.currentIndex()!=0:
                                if self.Window.SetMinUSD.currentIndex()==1:
                                    st=str(((Decimal(myitem['SetMinBox']))*Dif).quantize(Decimal('.00000001')))
                                    self.Window.SetMinBox.setText(st)
                            if self.Window.SetMaxSelect.currentIndex()!=0:
                                if self.Window.SetMaxUSD.currentIndex()==1:
                                    st=str(((Decimal(myitem['SetMaxBox']))*Dif).quantize(Decimal('.00000001')))
                                    self.Window.SetMaxBox.setText(st)
                        else:
                            if self.Window.EstValueUSD.currentIndex()==0:
                                st=str(int(Decimal(myitem['ActualValue'])/Decimal(1e8)*Decimal(self.rate)*Decimal(100)))
                                st=str(Decimal(st)/Decimal(100))
                            else:
                                st=str(((Decimal(myitem['ActualValue'])/Decimal(1e8))).quantize(Decimal('.00000001')))
                            self.Window.EstValueBox.setText(st)
                            Dif=(Decimal(self.rate)/Decimal(self.order['Market Data']['rate'])).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)
                            if self.Window.SetMinSelect.currentIndex()!=0:
                                if self.Window.SetMinUSD.currentIndex()==0:
                                    st=str(((Decimal(myitem['SetMinBox']))*Dif).quantize(Decimal('.01')))
                                    self.Window.SetMinBox.setText(st)
                            if self.Window.SetMaxSelect.currentIndex()!=0:
                                if self.Window.SetMaxUSD.currentIndex()==0:
                                    st=str(((Decimal(myitem['SetMaxBox']))*Dif).quantize(Decimal('.01')))
                                    self.Window.SetMaxBox.setText(st)
                self.Window.AddMeetupCheck.setCheckState(myitem['AddMeetupCheck'])

                self.barteritems['selected']=myitem['AddTitleBox']
            except:
                traceback.print_exc()
                return
        Templates.Window.Pages.setCurrentIndex(15)
        if self.origin<9:
            response=Templates.Window.exec_()
            Templates.Window.show()
            Templates.Window.Pages.setCurrentIndex(returnpage)
        else:
            Templates.Window.show()
    def ClearItem(self):
        self.Window.AddTitleBox.clear()
        self.Window.AddDescriptionBox.clear()
        self.Window.AddShipToBox.clear()
        self.Window.AddMaxSizeBox.clear()
        self.Window.AddLinkImagesBox.clear()
        self.Window.AddDescriptionBox.clear()
        self.Window.EstValueBox.clear()
        self.Window.SetMinBox.clear()
        self.Window.SetMaxBox.clear()
        self.Window.AddQuantityBox.clear()
        self.Window.DepositServiceBox.clear()

        self.Window.EstValueUSD.setCurrentIndex(0)
        self.Window.EstValueSelect.setCurrentIndex(0)
        self.Window.AddShippingSelect.setCurrentIndex(0)
        self.Window.AddMaxSizeSelect.setCurrentIndex(0)
        self.Window.AddMaxSizeUSD.setCurrentIndex(0)
        self.Window.SetMinSelect.setCurrentIndex(0)
        self.Window.SetMinUSD.setCurrentIndex(0)
        self.Window.SetMaxSelect.setCurrentIndex(0)
        self.Window.SetMaxUSD.setCurrentIndex(0)
        self.Window.QuantitySelect.setCurrentIndex(0)
        self.Window.DepositServiceSelect.setCurrentIndex(0)

        self.Window.AddMeetupCheck.setCheckState(0)
        self.ChangeBarterIndex()
    def AddItem(self,item=''):
        myitem={}
        myitem['AddTitleBox']=strOUT(strIN(self.Window.AddTitleBox.text()))
        myitem['AddDescriptionBox']=strOUT(strIN(self.Window.AddDescriptionBox.toPlainText()))
        myitem['AddShipToBox']=strOUT(strIN(self.Window.AddShipToBox.text()))        
        myitem['AddLinkImagesBox']=strOUT(strIN(self.Window.AddLinkImagesBox.text()))
        try:            
            myitem['AddMaxSizeBox']=strOUT(strIN(self.Window.AddMaxSizeBox.text()))
            myitem['EstValueBox']=strOUT(strIN(self.Window.EstValueBox.text()))
            orgvalue=myitem['EstValueBox']
            myitem['SetMinBox']=strOUT(strIN(self.Window.SetMinBox.text()))
            orgmin=myitem['SetMinBox']
            myitem['SetMaxBox']=strOUT(strIN(self.Window.SetMaxBox.text()))
            orgmax=myitem['SetMaxBox']
            myitem['AddQuantityBox']=strOUT(strIN(self.Window.AddQuantityBox.text()))
            myitem['DepositServiceBox']=strOUT(strIN(self.Window.DepositServiceBox.text()))
            x=Decimal(myitem['EstValueBox'])
            if myitem['SetMaxBox']!='':
                x=Decimal(myitem['SetMaxBox'])
            if myitem['SetMinBox']!='':
                x=Decimal(myitem['SetMinBox'])
            if myitem['AddMaxSizeBox']!='':
                x=Decimal(myitem['AddMaxSizeBox'])
            if myitem['AddQuantityBox']!='':
                x=Decimal(myitem['AddQuantityBox'])
            if myitem['DepositServiceBox']!='':
                x=Decimal(myitem['DepositServiceBox'])
        except:
            traceback.print_exc()
            QuestionBox('Value error adding item.', ' OK ')
            return
        myitem['EstValueUSD']=self.Window.EstValueUSD.currentIndex()
        myitem['AddMaxSizeUSD']=self.Window.AddMaxSizeUSD.currentIndex()
        myitem['SetMinUSD']=self.Window.SetMinUSD.currentIndex()
        myitem['SetMaxUSD']=self.Window.SetMaxUSD.currentIndex()
        myitem['QuantitySelect']=self.Window.QuantitySelect.currentIndex()
        myitem['AddShippingSelect']=self.Window.AddShippingSelect.currentIndex()
        myitem['EstValueSelect']=self.Window.EstValueSelect.currentIndex()
        myitem['AddMaxSizeSelect']=self.Window.AddMaxSizeSelect.currentIndex()
        myitem['SetMinSelect']=self.Window.SetMinSelect.currentIndex()
        myitem['SetMaxSelect']=self.Window.SetMaxSelect.currentIndex()
        myitem['DepositServiceSelect']=self.Window.DepositServiceSelect.currentIndex()

        myitem['AddMeetupCheck']=self.Window.AddMeetupCheck.checkState()

        if myitem['EstValueSelect']==0:
            QuestionBox('Please select an option for estimated value.', ' OK ')
            return
        if myitem['AddQuantityBox']=='':
            if myitem['EstValueSelect']==1 or myitem['EstValueSelect']==2 or myitem['EstValueSelect']==3:
                QuestionBox('The quantity is blank.', ' OK ')
                return
        if self.origin==2 or self.origin==5 or self.origin==6 or self.origin==7 or self.origin==8:
            if 'ActualValue' not in myitem:
                rt=self.order['Market Data']['rate']
                if self.origin==2:
                    if self.order['Market Data']['tracking']==0:
                        rt=self.rate
                if myitem['EstValueUSD']==0:
                    myitem['ActualValue']=int((Decimal(myitem['EstValueBox'])/Decimal(rt))*Decimal(1e8))
                else:
                    myitem['ActualValue']=int((Decimal(myitem['EstValueBox'])*Decimal(1e8)))
        res=self.TestHighValue(0, myitem)
        if res==False:
            print "High value failed"
            return
        if self.origin==0 or self.origin==3:
            if myitem['AddTitleBox'] in self.barteritems['supply']:
                res=QuestionBox('Item is already in the list. Replace it?', ' Yes ', ' No ')
                if res==1:
                    return
            self.barteritems['supply'][myitem['AddTitleBox']]=myitem
        if self.origin==1 or self.origin==4:
            if myitem['AddTitleBox'] in self.barteritems['demand']:
                res=QuestionBox('Item is already in the list. Replace it?', ' Yes ', ' No ')
                if res==1:
                    return
            self.barteritems['demand'][myitem['AddTitleBox']]=myitem
        if self.origin==5 or self.origin==7:
            if self.order['Market Data']['buymultiple']==0:
                if len(self.barteritems2['supply'])==1:
                    QuestionBox('This offer does not allow you to barter multiple items.', ' OK ')
                    return
            if 'itemlimit' in self.order['Market Data'] and self.order['Market Data']['itemlimit']==len(self.barteritems2['supply']):
                QuestionBox('This offer has a limit to the number of items you may request once and you are currently at this limit.', ' OK ')
                return
            myitem['EstValueBox']=self.barteritems['supply'][myitem['AddTitleBox']]['EstValueBox']
            myitem['SetMinBox']=self.barteritems['supply'][myitem['AddTitleBox']]['SetMinBox']
            myitem['SetMaxBox']=self.barteritems['supply'][myitem['AddTitleBox']]['SetMaxBox']
            myitem['ActualValue']=self.barteritems['supply'][myitem['AddTitleBox']]['ActualValue']
            if myitem['AddTitleBox'] not in self.barteritems['supply'] or myitem!=self.barteritems['supply'][myitem['AddTitleBox']]:
                QuestionBox('You are not allowed to modify what they are supplying. You are allowed to simply add the item and in some cases request a higher quantity after adding the item.', ' OK ')
                return
            myitem['EstValueBox']=orgvalue
            myitem['SetMinBox']=orgmin
            myitem['SetMaxBox']=orgmax
            myitem=self.CalculateBarter(myitem)
            if myitem==False:
                return
            self.barteritems2['supply'][myitem['AddTitleBox']]=myitem
            self.PopulateBarter(1)
        if self.origin==2 or self.origin==6 or self.origin==8:
            if myitem['AddTitleBox'] in self.barteritems['demand'] and myitem['AddTitleBox'] in self.barteritems2['demand']:
                res=QuestionBox('Item is already in the list. Replace it?', ' Yes ', ' No ')
                if res==1:
                    return
            if myitem['AddTitleBox'] not in self.barteritems['demand']:
                if self.order['Market Data']['offernotinlist']==0:
                    res=QuestionBox('This offer does not allow you to offer items that are not already in the list. This also means you can not modify the title of the item. The item should be similar to the original offer.', ' OK ')
                    if res==1:
                        return
                self.barteritems['demand'][myitem['AddTitleBox']]=myitem
            myitem=self.CalculateBarter(myitem)
            if myitem==False:
                return
            self.barteritems2['demand'][myitem['AddTitleBox']]=myitem
            self.PopulateBarter(1)
        self.Window.accept()
        self.Window.show()
        #returnpage=14
        #if self.origin==2:
        #    returnpage=16
        #Templates.Window.Pages.setCurrentIndex(returnpage)
        self.PopulateBarter()
    def RemoveItem(self):
        try:
            if self.origin==3:
                self.barteritems['supply'].pop(self.barteritems['selected'])
            if self.origin==4:
                self.barteritems['demand'].pop(self.barteritems['selected'])
            if self.origin==5:
                self.barteritems2['supply'].pop(self.barteritems['selected'])
            if self.origin==6:
                self.barteritems2['demand'].pop(self.barteritems['selected'])
            if self.origin==7:
                self.barteritems2['supply'].pop(self.barteritems['selected'])
            if self.origin==8:
                self.barteritems2['demand'].pop(self.barteritems['selected'])
            if self.origin>8:
                Templates.Window.Pages.setCurrentIndex(14)
                return
        except:
            pass
        self.Window.accept()
        self.Window.show()
        if self.origin>4:
            self.PopulateBarter(1)
        self.PopulateBarter()
    def ChangeBarterIndex(self):
        if self.Window.RequestAll==0:
            self.Window.MaxItems.hide()
            self.Window.MaxItemsBox.hide()
        else:
            self.Window.MaxItems.show()
            self.Window.MaxItemsBox.show()
        if self.Window.EstValueSelect.currentIndex()!=1 and self.Window.EstValueSelect.currentIndex()!=2 and self.Window.EstValueSelect.currentIndex()!=3:
            self.Window.AddShippingText.hide()
            self.Window.AddShippingSelect.hide()
            self.Window.AddShipToText.hide()
            self.Window.AddShipToBox.hide()
            self.Window.AddMeetupCheck.hide()
            self.Window.AddMaximumShipText.hide()
            self.Window.AddMaxSizeSelect.hide()
            self.Window.AddMaxSizeSelect.setCurrentIndex(0)
            self.Window.AddMaxSizeBox.hide()
            self.Window.AddMaxSizeBox.clear()
            self.Window.AddMaxSizeUSD.hide()
        else:
            self.Window.AddShippingText.show()
            self.Window.AddShippingSelect.show()            
            self.Window.AddShipToText.show()
            self.Window.AddShipToBox.show()            
            self.Window.AddMeetupCheck.show()
            self.Window.AddMaximumShipText.show()
            self.Window.AddMaxSizeSelect.show()
            self.Window.AddMaxSizeBox.show()
            self.Window.AddMaxSizeUSD.show()
        if self.Window.AddShippingSelect.currentIndex()==0:
            self.Window.AddShipToText.hide()
            self.Window.AddShipToBox.hide()
        else:
            self.Window.AddShipToText.show()
            self.Window.AddShipToBox.show()
        if self.Window.AddMaxSizeSelect.currentIndex()==0:
            self.Window.AddMaxSizeBox.hide()
            self.Window.AddMaxSizeUSD.hide()
        else:
            self.Window.AddMaxSizeBox.show()
            self.Window.AddMaxSizeUSD.show()

        self.Window.AddQuantityText.hide()
        self.Window.AddQuantityBox.hide()
        self.Window.QuantitySelect.hide()
        if self.Window.EstValueSelect.currentIndex()==1:
            self.Window.AddQuantityText.show()
            self.Window.AddQuantityBox.show()
            self.Window.QuantitySelect.show()
            self.Window.QuantitySelect.setCurrentIndex(2)
        if self.Window.EstValueSelect.currentIndex()==2:
            self.Window.AddQuantityText.show()
            self.Window.AddQuantityBox.show()
            self.Window.QuantitySelect.show()
            self.Window.QuantitySelect.setCurrentIndex(0)
        if self.Window.EstValueSelect.currentIndex()==3:
            self.Window.AddQuantityText.show()
            self.Window.AddQuantityBox.show()
            self.Window.QuantitySelect.show()
            self.Window.QuantitySelect.setCurrentIndex(1)

        if self.Window.SetMinSelect.currentIndex()==0:
            self.Window.SetMinBox.hide()
            self.Window.SetMinUSD.hide()
        else:
            self.Window.SetMinBox.show()
            self.Window.SetMinUSD.show()
        if self.Window.SetMaxSelect.currentIndex()==0:
            self.Window.SetMaxBox.hide()
            self.Window.SetMaxUSD.hide()
        else:
            self.Window.SetMaxBox.show()
            self.Window.SetMaxUSD.show()
        if self.Window.EstValueSelect.currentIndex()!=1 and self.Window.EstValueSelect.currentIndex()!=2 and self.Window.EstValueSelect.currentIndex()!=3:
            self.Window.AddShippingText.hide()
            self.Window.AddShippingSelect.hide()
            self.Window.AddShipToText.hide()
            self.Window.AddShipToBox.hide()
            self.Window.AddMeetupCheck.hide()
            self.Window.AddMaximumShipText.hide()
            self.Window.AddMaxSizeSelect.hide()
            self.Window.AddMaxSizeSelect.setCurrentIndex(0)
            self.Window.AddMaxSizeBox.hide()
            self.Window.AddMaxSizeBox.clear()
            self.Window.AddMaxSizeUSD.hide()
    def PopulateBarter(self, thewindow=0):
        self.originwindow=0
        self.Window.NotesBox7.clear()
        self.Window.NotesBox8.clear()
        if thewindow==0 or thewindow==2:
            self.Window.RequestAll.show()
            self.Window.BuyMultiple.show()
            self.Window.OfferNotInList.show()
            self.Window.AddItemSupply.show()
            self.Window.AddItemDemand.show()
            
            self.Window.SupplyBox.clear()
            self.Window.DemandBox.clear()
            lst=[]
            for item in self.barteritems['supply']:
                lst.append(item)
            lst.sort()
            for l in lst:
                newitem = QtGui.QListWidgetItem()
                newitem.setText(l)
                self.Window.SupplyBox.addItem(newitem)
            lst=[]
            for item in self.barteritems['demand']:
                lst.append(item)
            lst.sort()
            for l in lst:
                newitem = QtGui.QListWidgetItem()
                newitem.setText(l)
                self.Window.DemandBox.addItem(newitem)
            if thewindow==2:
                self.originwindow=1
                self.Window.RequestAll.hide()
                self.Window.AddItemSupply.hide()
                self.Window.AddItemDemand.hide()
                self.Window.MaxItems.hide()
                self.Window.MaxItemsBox.hide()

                self.Window.SupplyAdditional7.hide()
                self.Window.SaveFuture7.hide()
                self.Window.ClearForm7.hide()
                self.Window.SaveContinue7.hide()
                self.Window.NotesBox7.setText(self.order['Market Data']['notes'].replace("\n","<br />"))
                try:
                    self.Window.DepositSettings7.setCurrentIndex(1)
                    self.Window.DepositSettings7.setCurrentIndex(0)
                except:
                    pass
                self.Window.DepositSettings7.hide()

                if 'itemlimit' in self.order['Market Data']:
                    self.Window.MaxItems.hide()
                    self.Window.MaxItemsBox.setText(str(self.order['Market Data']['itemlimit']))
                if self.order['Market Data']['offernotinlist']==1:
                    self.Window.OfferNotInList.setCheckState(2)
                else:
                    self.Window.OfferNotInList.setCheckState(0)
                if self.order['Market Data']['buymultiple']==1:
                    self.Window.BuyMultiple.setCheckState(2)
                else:
                    self.Window.BuyMultiple.setCheckState(0)
                if self.mode!=1:
                    self.Window.SupplyBox.clear()
                    self.Window.DemandBox.clear()
                    summary=[]
                    total=0
                    lst=[]
                    for item in self.barteritems['supply']:
                        lst.append(item)
                    lst.sort()
                    for l in lst:
                        item=self.barteritems['supply'][l]
                        if item['EstValueSelect']!=1:
                            item=self.CalculateBarter(item,item['quantityusd'])
                        else:
                            item=self.CalculateBarter(item,item['quantity'])
                        total+=int(item['amount'])
                        if self.rate=='':
                            amt=" - Coins: " + str((Decimal(int(item['amount'])/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                        else:
                            amt=" - USD: " + str(((Decimal(int(item['amount'])/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                        summary.append(l+' '+item['quantitytext']+amt)
                        newitem = QtGui.QListWidgetItem()
                        newitem.setText(l)
                        self.Window.SupplyBox.addItem(newitem)
                    if lst!=[]:
                        newitem = QtGui.QListWidgetItem()
                        if self.rate=='':
                            newitem.setText('Total in coins: ' + str((Decimal(total)/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                        else:
                            newitem.setText('Total in USD: ' + str(((Decimal(total)/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                        newitem.setData(QtCore.Qt.UserRole, 1)
                        self.Window.SupplyBox.addItem(newitem)
                        newitem = QtGui.QListWidgetItem()
                        newitem.setText('Summary of items:')
                        newitem.setData(QtCore.Qt.UserRole, 1)
                        self.Window.SupplyBox.addItem(newitem)
                        for s in summary:
                            newitem = QtGui.QListWidgetItem()
                            newitem.setText(s)
                            newitem.setData(QtCore.Qt.UserRole, 1)
                            self.Window.SupplyBox.addItem(newitem)

                    summary=[]
                    total=0
                    lst=[]
                    for item in self.barteritems['demand']:
                        lst.append(item)
                    lst.sort()
                    for l in lst:
                        item=self.barteritems['demand'][l]
                        if item['EstValueSelect']!=1:
                            item=self.CalculateBarter(item,item['quantityusd'])
                        else:
                            item=self.CalculateBarter(item,item['quantity'])
                        total+=int(item['amount'])
                        if self.rate=='':
                            amt=" - Coins: " + str((Decimal(int(item['amount'])/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                        else:
                            amt=" - USD: " + str(((Decimal(int(item['amount'])/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                        summary.append(l+' '+item['quantitytext']+amt)
                        newitem = QtGui.QListWidgetItem()
                        newitem.setText(l)
                        self.Window.DemandBox.addItem(newitem)
                    if lst!=[]:
                        newitem = QtGui.QListWidgetItem()
                        if self.rate=='':
                            newitem.setText('Total in coins: ' + str((Decimal(total)/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                        else:
                            newitem.setText('Total in USD: ' + str(((Decimal(total)/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                        newitem.setData(QtCore.Qt.UserRole, 1)
                        self.Window.DemandBox.addItem(newitem)
                        newitem = QtGui.QListWidgetItem()
                        newitem.setText('Summary of items:')
                        newitem.setData(QtCore.Qt.UserRole, 1)
                        self.Window.DemandBox.addItem(newitem)
                        for s in summary:
                            newitem = QtGui.QListWidgetItem()
                            newitem.setText(s)
                            newitem.setData(QtCore.Qt.UserRole, 1)
                            self.Window.DemandBox.addItem(newitem)
        else:
            self.Window.MySupplyBox.clear()
            self.Window.MyDemandBox.clear()
            self.Window.TheirSupplyBox.clear()
            self.Window.TheirDemandBox.clear()
            self.Window.NotesBox8.clear()
            self.Window.NotesBox8.clear()
            self.Window.SupplyAdditional8.hide()
            self.evenbarter=1
            self.Window.NotesBox8.setText(self.order['Market Data']['notes'].replace("\n","<br />"))
            if self.order['Market Data']['offernotinlist']==1:
                self.Window.MyOfferNotInList.show()
            else:
                self.Window.MyOfferNotInList.hide()
            lst=[]
            lst2=[]
            for item in self.barteritems['supply']:
                if item in self.barteritems2['supply']:
                    lst2.append(item)
                else:
                    lst.append(item)
            lst.sort()
            lst2.sort()
            for l in lst:
                newitem = QtGui.QListWidgetItem()
                newitem.setText(l)
                self.Window.TheirSupplyBox.addItem(newitem)
            summary=[]
            total=0
            for l in lst2:
                total+=int(self.barteritems2['supply'][l]['amount'])
                if self.rate=='':
                    amt=" - Coins: " + str((Decimal(int(self.barteritems2['supply'][l]['amount'])/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                else:
                    amt=" - USD: " + str(((Decimal(int(self.barteritems2['supply'][l]['amount'])/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                summary.append(l+' '+self.barteritems2['supply'][l]['quantitytext']+amt)
                newitem = QtGui.QListWidgetItem()
                newitem.setText(l)
                self.Window.MyDemandBox.addItem(newitem)
            if lst2!=[]:
                newitem = QtGui.QListWidgetItem()
                if self.rate=='':
                    newitem.setText('Total in coins: ' + str((Decimal(total)/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                else:
                    newitem.setText('Total in USD: ' + str(((Decimal(total)/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                newitem.setData(QtCore.Qt.UserRole, 1)
                self.Window.MyDemandBox.addItem(newitem)
                newitem = QtGui.QListWidgetItem()
                newitem.setText('Summary of items:')
                newitem.setData(QtCore.Qt.UserRole, 1)
                self.Window.MyDemandBox.addItem(newitem)
                for s in summary:
                    newitem = QtGui.QListWidgetItem()
                    newitem.setText(s)
                    newitem.setData(QtCore.Qt.UserRole, 1)
                    self.Window.MyDemandBox.addItem(newitem)
            lst=[]
            lst2=[]
            for item in self.barteritems['demand']:
                if item in self.barteritems2['demand']:
                    lst2.append(item)
                else:
                    lst.append(item)
            lst.sort()
            lst2.sort()
            for l in lst:
                newitem = QtGui.QListWidgetItem()
                newitem.setText(l)
                self.Window.TheirDemandBox.addItem(newitem)
            summary=[]
            total2=0
            for l in lst2:
                total2+=int(self.barteritems2['demand'][l]['amount'])
                if self.rate=='':
                    amt=" - Coins: " + str((Decimal(int(self.barteritems2['demand'][l]['amount'])/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                else:
                    amt=" - USD: " + str(((Decimal(int(self.barteritems2['demand'][l]['amount'])/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                summary.append(l+' '+self.barteritems2['demand'][l]['quantitytext']+amt)
                newitem = QtGui.QListWidgetItem()
                newitem.setText(l)
                self.Window.MySupplyBox.addItem(newitem)
            if lst2!=[]:
                newitem = QtGui.QListWidgetItem()
                if self.rate=='':
                    newitem.setText('Total in coins: ' + str((Decimal(total2)/Decimal(1e8)).quantize(Decimal('0.00000001'))))
                else:
                    newitem.setText('Total in USD: ' + str(((Decimal(total2)/Decimal(1e8))*Decimal(self.rate)).quantize(Decimal('0.01'))))
                newitem.setData(QtCore.Qt.UserRole, 1)
                self.Window.MySupplyBox.addItem(newitem)
                newitem = QtGui.QListWidgetItem()
                newitem.setText('Summary of items:')
                newitem.setData(QtCore.Qt.UserRole, 1)
                self.Window.MySupplyBox.addItem(newitem)
                for s in summary:
                    newitem = QtGui.QListWidgetItem()
                    newitem.setText(s)
                    newitem.setData(QtCore.Qt.UserRole, 1)
                    self.Window.MySupplyBox.addItem(newitem)
            if Decimal(total2)*Decimal(1.05)<Decimal(total) or Decimal(total2)*Decimal(0.95)>Decimal(total):
                self.evenbarter=0
    def CalculateBarter(self, myitem2, quantity=''):
        #Dif=(Decimal(self.order['Market Data']['rate'])/Decimal(self.rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)
        myitem=json_deep_copy(myitem2,1)
        rt=self.rate
        if myitem['EstValueUSD']==0:
            actual=str(int(Decimal(myitem['EstValueBox'])/Decimal(rt)*Decimal(1e8)))
        else:
            actual=str(int(Decimal(myitem['EstValueBox'])*Decimal(1e8)))
        minord=''
        minquantity=''
        maxord=''
        maxquantity=''
        if myitem['SetMinSelect']!=0:
            if myitem['SetMinUSD']==0:
                minord=str(int(Decimal(myitem['SetMinBox'])/Decimal(rt)*Decimal(1e8)))
            if myitem['SetMinUSD']==1:
                minord=str(int(Decimal(myitem['SetMinBox'])*Decimal(1e8)))
            if myitem['SetMinUSD']==2:
                minquantity=myitem['SetMinBox']
        if myitem['SetMaxSelect']!=0:
            if myitem['SetMaxUSD']==0:
                maxord=str(int(Decimal(myitem['SetMaxBox'])/Decimal(rt)*Decimal(1e8)))
            if myitem['SetMaxUSD']==1:
                maxord=str(int(Decimal(myitem['SetMaxBox'])*Decimal(1e8)))
            if myitem['SetMaxUSD']==2:
                maxquantity=myitem['SetMaxBox']
        if self.rate!='':
            denom=' in dollars'
        else:
            denom=' in coins'
        if myitem['EstValueSelect']!=1:
            if quantity=='':
                text, ok = QtGui.QInputDialog.getText(self.Window, "Halo", Gtranslate('Please enter how much of this item you would like to barter '+denom+'.'))
                try:
                    text=Decimal(str(text))
                    myitem['quantityusd']=str(text)
                except:
                    QuestionBox('The amount was not valid.', ' OK ')
                    return False
            else:
                try:
                    text=Decimal(str(myitem['quantityusd']))
                except:
                    QuestionBox('Error calculating barter data.', ' OK ')
                    return False
            if self.rate!='':
                myitem['amount']=str(int((text*Decimal(1e8))/Decimal(self.rate)))
            else:
                myitem['amount']=str(int(text*Decimal(1e8)))
            if myitem['SetMinSelect']!=0:
                if myitem['SetMinUSD']==2:
                    if text<Decimal(minquantity):
                        QuestionBox('The amount you entered was lower than the minimum order.', ' OK ')
                        return False
                else:
                    if Decimal(myitem['amount'])*Decimal(1.02)<Decimal(minord):
                        QuestionBox('The amount you entered was lower than the minimum order.', ' OK ')
                        return False
            if myitem['SetMaxSelect']!=0:
                if myitem['SetMaxUSD']==2:
                    if text>Decimal(maxquantity):
                        QuestionBox('The amount you entered was higher than the maximum order.', ' OK ')
                        return False
                else:
                    if Decimal(myitem['amount'])*Decimal(0.98)>Decimal(maxord):
                        QuestionBox('The amount you entered was higher than the maximum order.', ' OK ')
                        return False
            if myitem['EstValueSelect']>3:
                if myitem['EstValueSelect']==4:
                    t='days'
                if myitem['EstValueSelect']==5:
                    t='weeks'
                if myitem['EstValueSelect']==6:
                    t='months'
                cost=self.ConvertBarterToCoins(actual,1,t)#Cost per day
                myitem['quantity']=str((Decimal(myitem['amount'])/Decimal(cost)).quantize(Decimal('.0001')))
                myitem['quantitytext']=myitem['quantity'] + ' days of service.'
            else:
                if myitem['EstValueSelect']==2:
                    t='kg'
                if myitem['EstValueSelect']==3:
                    t='lbs'
                myitem['quantity']=str((Decimal(myitem['amount'])/Decimal(actual)).quantize(Decimal('.0001')))
                myitem['quantitytext']=myitem['quantity'] + ' ' + t + ' of goods.'
        else:
            if Decimal(myitem['AddQuantityBox'])>Decimal(1):
                if quantity=='':
                    text, ok = QtGui.QInputDialog.getText(self.Window, "Halo", Gtranslate('Please enter how much of this item you would like to order.'))
                    try:
                        text=Decimal(str(text))
                    except:
                        QuestionBox('The amount was not valid.', ' OK ')
                        return False
                else:
                    text=Decimal(quantity)
            else:
                text=Decimal(1)
            myitem['amount']=str(int(Decimal(actual)*text))
            myitem['quantity']=str(text)
            myitem['quantitytext']=myitem['quantity'] + ' items.'
            if myitem['SetMinSelect']!=0:
                if myitem['SetMinUSD']==2:
                    if text<Decimal(minquantity):
                        QuestionBox('The amount you entered was lower than the minimum order.', ' OK ')
                        return False
                else:
                    if Decimal(myitem['amount'])*Decimal(1.02)<Decimal(minord):
                        QuestionBox('The amount you entered was lower than the minimum order.', ' OK ')
                        return False
            if myitem['SetMaxSelect']!=0:
                if myitem['SetMaxUSD']==2:
                    if text>Decimal(maxquantity):
                        QuestionBox('The amount you entered was higher than the maximum order.', ' OK ')
                        return False
                else:
                    if Decimal(myitem['amount'])*Decimal(0.98)>Decimal(maxord):
                        QuestionBox('The amount you entered was higher than the maximum order.', ' OK ')
                        return False
        return myitem
    def SupplyClick(self, item):
        if item.data(QtCore.Qt.UserRole).toPyObject()==1:
            return
        if self.originwindow==0:
            self.ShowItem(3, strOUT(strIN(item.text())))
        else:
            self.ShowItem(9, strOUT(strIN(item.text())))
    def DemandClick(self, item):
        if item.data(QtCore.Qt.UserRole).toPyObject()==1:
            return
        if self.originwindow==0:
            self.ShowItem(4, strOUT(strIN(item.text())))
        else:
            self.ShowItem(10, strOUT(strIN(item.text())))
    def SupplyClick2(self, item):
        self.ShowItem(5, strOUT(strIN(item.text())), 1)
    def DemandClick2(self, item):
        self.ShowItem(6, strOUT(strIN(item.text())), 1)
    def SupplyClick3(self, item):
        if item.data(QtCore.Qt.UserRole).toPyObject()==1:
            return
        self.ShowItem(7, strOUT(strIN(item.text())), 1)
    def DemandClick3(self, item):
        if item.data(QtCore.Qt.UserRole).toPyObject()==1:
            return
        self.ShowItem(8, strOUT(strIN(item.text())), 1)
    def PoundsToKilos(self, lbs, val=0):
        if val==1:
            return str(int(Decimal(lbs)/Decimal(0.453592)))
        return str((Decimal(0.453592)*Decimal(lbs)).quantize(Decimal('.00000001')))
    def ConvertBarterToCoins(self, amount, quantity, quantitytype):
        daily=0
        #Results are satoshis and the amount of quantity requested is assumed to be either days or kgs
        if quantitytype=='days':
            daily=amount
        if quantitytype=='weeks':
            daily=Decimal(amount)/Decimal(7)
        if quantitytype=='months':
            daily=Decimal(amount)/Decimal(30)
        if daily!=0:
            return str(int(Decimal(daily)*Decimal(quantity)))
        if quantitytype=='lbs':
            return str(int(Decimal(self.PoundsToKilos(amount, 1))*Decimal(quantity)))
        if quantitytype=='kgs':
            return str(int(Decimal(amount)*Decimal(quantity)))
    def OfferBarter(self,mode):
        if mode==0:
            self.Window.hide()
            return False
        else:            
            self.barteritems=json_deep_copy(self.barteritems2,1)
            if self.barteritems['supply']=={}:
                QuestionBox('The supply list is empty.', ' OK ')
                self.Window.hide()
                return
            if self.barteritems['demand']=={}:
                QuestionBox('The demand list is empty.', ' OK ')
                self.Window.hide()
                return
            self.barterwindow=0
            try:
                Templates.showorder(self.order)
            except:
                traceback.print_exc()
                self.barterwindow=1
    def TestHighValue(self, highvalue, myitem, ui=1):
        try:       
            highvalue1=0
            highvalue2=0
            minval=0
            if myitem['AddQuantityBox']!='':
                try:
                    x=Decimal(myitem['AddQuantityBox'])
                except:
                    if ui==1:
                        QuestionBox('The quantity was not valid.', ' OK ')
                    return False
            if myitem['SetMaxSelect']!=0 or myitem['SetMinSelect']!=0:
                try:
                    if myitem['SetMinSelect']!=0:
                        if myitem['SetMinUSD']==0:
                            minval=int(Decimal(self.rate)*Decimal(myitem['SetMinBox'])*Decimal(1e8))
                        if myitem['SetMinUSD']==1:
                            minval=int(Decimal(myitem['SetMinBox'])*Decimal(1e8))
                        if myitem['SetMinUSD']==2:
                            minval=int(Decimal(myitem['SetMinBox'])*Decimal(highvalue))
                    if myitem['SetMaxSelect']!=0:
                        if myitem['SetMaxUSD']==0:
                            highvalue1=int(Decimal(self.rate)*Decimal(myitem['SetMaxBox'])*Decimal(1e8))
                        if myitem['SetMaxUSD']==1:
                            highvalue1=int(Decimal(myitem['SetMaxBox'])*Decimal(1e8))
                        if myitem['SetMaxUSD']==2:
                            highvalue1=int(Decimal(myitem['SetMaxBox'])*Decimal(highvalue))
                        if Decimal(minval)>Decimal(highvalue1):
                            if highvalue!=0:
                                float('a')
                except:
                    traceback.print_exc()
                    if ui==1:
                        QuestionBox('Order sizes are not valid.', ' OK ')
                    return False
            if myitem['AddMaxSizeSelect']==1:
                if myitem['AddMaxSizeUSD']==0:
                    highvalue2=int(Decimal(self.rate)*Decimal(myitem['AddMaxSizeBox'])*Decimal(1e8))
                if myitem['AddMaxSizeUSD']==1:
                    highvalue2=int(Decimal(myitem['AddMaxSizeBox'])*Decimal(1e8))
                fnd=1
                if myitem['AddMaxSizeUSD']==2:
                    fnd=0
                    if myitem['EstValueSelect']==2:
                        fnd=1
                        highvalue2=int(Decimal(highvalue)*Decimal(myitem['AddMaxSizeBox']))
                    if myitem['EstValueSelect']==3:
                        fnd=1
                        highvalue2=int(Decimal(self.PoundsToKilos(highvalue,1))*Decimal(myitem['AddMaxSizeBox']))
                if myitem['AddMaxSizeUSD']==3:
                    fnd=0
                    if myitem['EstValueSelect']==2:
                        fnd=1
                        highvalue2=int(Decimal(highvalue)*Decimal(self.PoundsToKilos(myitem['AddMaxSizeBox'])))
                    if myitem['EstValueSelect']==3:
                        fnd=1
                        highvalue2=int(Decimal(highvalue)*Decimal(myitem['AddMaxSizeBox']))
                if fnd!=1:
                    if ui==1:
                        QuestionBox('Your shipping options are not valid.', ' OK ')
                    return False
                if highvalue2<highvalue:
                    highvalue=highvalue2
            else:
                if minval>highvalue:
                    highvalue=minval
            if highvalue==0:
                return True
            return highvalue
        except:
            traceback.print_exc()
            return False
    def Button1(self):
        try:
            w = QtGui.QDialog()
            w.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
            w.setWindowTitle(CoinSelect['HaloName'])
            pic = QtGui.QLabel(w)
            #pm = QtGui.QPixmap()
            #pm.loadFromData(base64.b64decode(self.order['Details']['image']))
            pm = ConvertImage(self.order['Details']['image'])
            pic.setPixmap(pm)
            w.resize(pm.width(),pm.height())
            if pm.width()<20 or pm.height()<20:
                return
            a=w.exec_()
        except:
            traceback.print_exc()
    def Button2(self):
        global globfont
        if self.Button2Text=="Show User Profile":
            self.Button2Text="Show Details"
            details=self.data4
        else:
            self.Button2Text="Show User Profile"
            details=self.data3
        self.Window.Button2.setText(Gtranslate(self.Button2Text))
        self.Window.Display2.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'"+globfont+"\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+details+"</span></p></body></html>")
    def AutoInfo(self):
        global AdvanceArray
        if 'tip3' not in AdvanceArray:
            res=QuestionBox("When auto-accepting orders, especially when price tracking, if you want the software to sign for you it is recommended that you unlock your wallet. Unlocking temporarily stores any passwords in memory if applicable. If you wish to qualify the people you contract with first and double check exchange rates then this feature is not recommended.", " Thanks! ", " Do not show this message again. ")
            if res==1:
                AdvanceArray['tip3']=1
    def ShowAdvanced(self, obj, clear=0):
        hide=0
        hdlater=0
        hdlater2=0
        for obj1 in self.objcombos:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj1)+".blockSignals(True)\n")
        if obj=="default": # or obj=="EstValueUSD" 
            if clear==0:
                index=self.Window.EstValueUSD.currentIndex()
                self.Window.SetMinUSD.setCurrentIndex(index)
                self.Window.SetMinBox.clear()
                self.Window.SetMaxUSD.setCurrentIndex(index)
                self.Window.SetMaxBox.clear()
        #if obj=="BuyMultiple" or obj=="default":
        #    if self.Window.BuyMultiple.checkState()==2:
        #        self.Window.RequestAll.setCurrentIndex(0)
        #        self.Window.RequestAll.show()
        #    else:
        #        self.Window.RequestAll.setCurrentIndex(0)
        #        self.Window.RequestAll.hide()
        if obj=="SellSelect" or obj=="default":
            if self.Window.SellSelect.currentIndex()==0:
                self.Window.SellQuantityBox.setText("1")
                self.Window.SellQuantityBox.show()
                self.Window.SellQuantity.show()
                self.Window.BuyoutSellText.setText("Amount:")
                self.Window.BuyoutSellText.setGeometry(QtCore.QRect(0, 260, 111, 31))
                self.Window.BidSellText.hide()
                self.Window.BidSellBox.hide()
                self.Window.BidSellUSD.hide()
                self.Window.DurationSellText.hide()
                self.Window.DurationSellBox.hide()
                self.Window.DurationSellDays.hide()
            else:
                self.Window.SellQuantityBox.hide()
                self.Window.SellQuantity.hide()
                self.Window.BuyoutSellText.setText("Buyout Price:")
                self.Window.BuyoutSellText.setGeometry(QtCore.QRect(0, 260, 112, 31))#Need to resize to automatically adjust font
                self.Window.BidSellText.show()
                self.Window.BidSellBox.show()
                self.Window.BidSellUSD.show()
                self.Window.DurationSellText.show()
                self.Window.DurationSellBox.show()
                self.Window.DurationSellDays.show()
        if obj=="BuySelect" or obj=="default":
            if self.Window.BuySelect.currentIndex()==0:
                self.Window.BuyoutBuyText.setText("Amount:")
                self.Window.BidBuyText.hide()
                self.Window.BidBuyBox.hide()
                self.Window.BidBuyUSD.hide()
                self.Window.DurationBuyText.hide()
                self.Window.DurationBuyBox.hide()
                self.Window.DurationBuyDays.hide()
            else:
                self.Window.BuyoutBuyText.setText("Buyout Price:")
                self.Window.BidBuyText.show()
                self.Window.BidBuyBox.show()
                self.Window.BidBuyUSD.show()
                self.Window.DurationBuyText.show()
                self.Window.DurationBuyBox.show()
                self.Window.DurationBuyDays.show()
        if obj=="JobSelect1" or obj=="default":
            if self.Window.JobSelect1.currentIndex()==1:
                self.Window.RateSelect1.setCurrentIndex(2)
                self.Window.JobRate.setCurrentIndex(3)
            elif self.Window.JobSelect1.currentIndex()==2:
                self.Window.RateSelect1.setCurrentIndex(2)
                self.Window.JobRate.setCurrentIndex(3)
            else:
                self.Window.RateSelect1.setCurrentIndex(0)
                self.Window.JobRate.setCurrentIndex(0)
        if obj=="AmountUSD" or obj=="default":
            if clear==0:
                index=self.Window.AmountUSD.currentIndex()
                self.Window.MyDepositUSD.setCurrentIndex(index)
                self.Window.MyDepositBox.clear()
                self.Window.TheirDepositUSD.setCurrentIndex(index)
                self.Window.TheirDepositBox.clear()
        if obj=="AmountUSD2" or obj=="default":
            if clear==0:
                index=self.Window.AmountUSD2.currentIndex()
                self.Window.MyDepositUSD2.setCurrentIndex(index)
                self.Window.MyDepositBox2.clear()
                self.Window.TheirDepositUSD2.setCurrentIndex(index)
                self.Window.TheirDepositBox2.clear()
        if obj=="JobUSD" or obj=="default":
            if clear==0:
                index=self.Window.JobUSD.currentIndex()
                self.Window.MyDepositUSD3.setCurrentIndex(index)
                self.Window.MyDepositBox3.clear()
                self.Window.TheirDepositUSD3.setCurrentIndex(index)
                self.Window.TheirDepositBox3.clear()
        if obj=="FindUSD" or obj=="default":
            if clear==0:
                index=self.Window.FindUSD.currentIndex()
                self.Window.MyDepositUSD4.setCurrentIndex(index)
                self.Window.MyDepositBox4.clear()
                self.Window.TheirDepositUSD4.setCurrentIndex(index)
                self.Window.TheirDepositBox4.clear()
        if obj=="BuyoutSellUSD" or obj=="default":
            if clear==0:
                index=self.Window.BuyoutSellUSD.currentIndex()
                self.Window.BidSellUSD.setCurrentIndex(index)
                self.Window.MyDepositUSD5.setCurrentIndex(index)
                self.Window.RateSellUSD.setCurrentIndex(index)
                self.Window.MyDepositBox5.clear()
                self.Window.TheirDepositUSD5.setCurrentIndex(index)
                self.Window.TheirDepositBox5.clear()
        if obj=="BidSellUSD" or obj=="default":
            if clear==0:
                index=self.Window.BidSellUSD.currentIndex()
                self.Window.BuyoutSellUSD.setCurrentIndex(index)
                self.Window.MyDepositUSD5.setCurrentIndex(index)
                self.Window.RateSellUSD.setCurrentIndex(index)
                self.Window.MyDepositBox5.clear()
                self.Window.TheirDepositUSD5.setCurrentIndex(index)
                self.Window.TheirDepositBox5.clear()
        if obj=="BuyoutBuyUSD" or obj=="default":
            if clear==0:
                index=self.Window.BuyoutBuyUSD.currentIndex()
                self.Window.BidBuyUSD.setCurrentIndex(index)
                self.Window.MyDepositUSD6.setCurrentIndex(index)
                self.Window.MyDepositBox6.clear()
                self.Window.TheirDepositUSD6.setCurrentIndex(index)
                self.Window.TheirDepositBox6.clear()
        if obj=="BidBuyUSD" or obj=="default":
            if clear==0:
                index=self.Window.BidBuyUSD.currentIndex()
                self.Window.BuyoutSellUSD.setCurrentIndex(index)
                self.Window.MyDepositUSD6.setCurrentIndex(index)
                self.Window.MyDepositBox6.clear()
                self.Window.TheirDepositUSD6.setCurrentIndex(index)
                self.Window.TheirDepositBox6.clear()

        if self.Window.RateBox.currentIndex()==1 or self.rate=="":
            self.Window.Price.show()
            self.Window.PriceBox.show()
            self.Window.PriceUSD.show()
            self.Window.RateBox.setCurrentIndex(1)
            if self.rate!="":
                hdlater=1
        else:
            self.Window.RateBox.setCurrentIndex(0)
            self.Window.Price.hide()
            self.Window.PriceBox.hide()
            self.Window.PriceUSD.hide()
        if self.Window.ShowAdvancedCash.checkState()==2:
            self.Window.PriceTrackingTitle.show()
            self.Window.MaxIncreaseSell.show()
            self.Window.MaxDecreaseSell.show()
            self.Window.LimitOrderText1.show()
            self.Window.MinOrderSell.show()
            self.Window.MaxOrderSell.show()
            if hdlater==1:
                self.Window.PriceTrackingTitle.hide()
                self.Window.MaxIncreaseSell.hide()
                self.Window.MaxDecreaseSell.hide()
        else:
            self.Window.PriceTrackingTitle.hide()
            self.Window.MaxIncreaseSell.hide()
            self.Window.MaxDecreaseSell.hide()
            self.Window.LimitOrderText1.hide()
            self.Window.MinOrderSell.hide()
            self.Window.MaxOrderSell.hide()
            hide=1
        if self.Window.MaxIncreaseSell.currentIndex()==2 and hide==0 and hdlater!=1:
            self.Window.MaxIncreaseSellBox.show()
            self.Window.perc1.show()
        else:
            self.Window.MaxIncreaseSellBox.hide()
            self.Window.perc1.hide()
        if self.Window.MaxDecreaseSell.currentIndex()==3 and hide==0 and hdlater!=1:
            self.Window.MaxDecreaseSellBox.show()
            self.Window.perc2.show()
        else:
            self.Window.MaxDecreaseSellBox.hide()
            self.Window.perc2.hide()
        if self.Window.MinOrderSell.currentIndex()==3 and hide==0:
            self.Window.MinOrderSellBox.show()
            self.Window.perc3.show()
        else:
            self.Window.MinOrderSellBox.hide()
            self.Window.perc3.hide()
        if self.Window.MaxOrderSell.currentIndex()==3 and hide==0:
            self.Window.MaxOrderSellBox.show()
            self.Window.perc4.show()
        else:
            self.Window.MaxOrderSellBox.hide()
            self.Window.perc4.hide()
        if self.Window.ServiceCharge.currentIndex()==5:
            self.Window.ServiceChargeBox.show()
            self.Window.perc5.show()
        else:
            self.Window.ServiceChargeBox.hide()
            self.Window.perc5.hide()

        if self.Window.RateBox2.currentIndex()==1 or self.rate == "":
            self.Window.PriceText2.show()
            self.Window.PriceBox2.show()
            self.Window.PriceUSD2.show()
            self.Window.RateBox2.setCurrentIndex(1)
            if self.rate!="":
                hdlater2=1
        else:
            self.Window.RateBox2.setCurrentIndex(0)
            self.Window.PriceText2.hide()
            self.Window.PriceBox2.hide()
            self.Window.PriceUSD2.hide()
        hide=0
        if self.Window.ShowAdvancedCashBuy.checkState()==2:
            self.Window.PriceTrackingTitle2.show()
            self.Window.MaxIncreaseBuy.show()
            self.Window.MaxDecreaseBuy.show()
            self.Window.LimitOrderText2.show()
            self.Window.MinOrderBuy.show()
            self.Window.MaxOrderBuy.show()
            if hdlater2==1:
                self.Window.PriceTrackingTitle2.hide()
                self.Window.MaxIncreaseBuy.hide()
                self.Window.MaxDecreaseBuy.hide()
        else:
            self.Window.PriceTrackingTitle2.hide()
            self.Window.MaxIncreaseBuy.hide()
            self.Window.MaxDecreaseBuy.hide()
            self.Window.LimitOrderText2.hide()
            self.Window.MinOrderBuy.hide()
            self.Window.MaxOrderBuy.hide()
            hide=1
        if self.Window.MaxIncreaseBuy.currentIndex()==1 and hide==0 and hdlater2 != 1:
            self.Window.MaxIncreaseBuyBox.show()
            self.Window.perc6.show()
        else:
            self.Window.MaxIncreaseBuyBox.hide()
            self.Window.perc6.hide()
        if self.Window.MaxDecreaseBuy.currentIndex()==2 and hide==0 and hdlater2 != 1:
            self.Window.MaxDecreaseBuyBox.show()
            self.Window.perc7.show()
        else:
            self.Window.MaxDecreaseBuyBox.hide()
            self.Window.perc7.hide()
        if self.Window.MinOrderBuy.currentIndex()==3 and hide==0:
            self.Window.MinOrderBuyBox.show()
            self.Window.perc8.show()
        else:
            self.Window.MinOrderBuyBox.hide()
            self.Window.perc8.hide()
        if self.Window.MaxOrderBuy.currentIndex()==3 and hide==0:
            self.Window.MaxOrderBuyBox.show()
            self.Window.perc9.show()
        else:
            self.Window.MaxOrderBuyBox.hide()
            self.Window.perc9.hide()
        if self.Window.CountrySellSelect.currentIndex()==0:
            self.Window.ShipToTextSell.hide()
            self.Window.ShipToSellBox.hide()
        else:
            self.Window.ShipToTextSell.show()
            self.Window.ShipToSellBox.show()
        if self.Window.ShipCountryBuy.currentIndex()==0:
            self.Window.ShipToBuyText.hide()
            self.Window.ShipToBuyBox.hide()
        else:
            self.Window.ShipToBuyText.show()
            self.Window.ShipToBuyBox.show()
        if self.Window.ShippingSellSelect.currentIndex()==0 or self.Window.ShippingSellSelect.currentIndex()==2 or self.Window.ShippingSellSelect.currentIndex()==4:
            self.Window.RateSellText.hide()
            self.Window.RateSellBox2.hide()
            self.Window.RateSellUSD.hide()
            self.Window.WeightSellText.hide()
            self.Window.WeightSellBox.hide()
            self.Window.WeightSellSelect.hide()
        elif self.Window.ShippingSellSelect.currentIndex()==1:
            self.Window.RateSellText.show()
            self.Window.RateSellBox2.show()
            self.Window.RateSellUSD.show()
            self.Window.WeightSellText.hide()
            self.Window.WeightSellBox.hide()
            self.Window.WeightSellSelect.hide()
        else:
            self.Window.RateSellText.hide()
            self.Window.RateSellBox2.hide()
            self.Window.RateSellUSD.hide()
            self.Window.WeightSellText.show()
            self.Window.WeightSellBox.show()
            self.Window.WeightSellSelect.show()
        if self.Window.RequestAll.currentIndex()==0:
            self.Window.MaxItems.hide()
            self.Window.MaxItemsBox.hide()
        else:
            self.Window.MaxItems.show()
            self.Window.MaxItemsBox.show()
        setting=self.Window.SentToSelect.itemData(self.Window.SentToSelect.currentIndex()).toInt()[0]
        if setting==9999999:#"Private Email/BitMessage/Coin Address..."
            self.Window.SendToAddress.show()
        else:
            self.Window.SendToAddress.hide()
        #if self.Window.AddShippingSelect.currentIndex()==1:
        #    self.Window.AddShipToText.show()
        #    self.Window.AddShipToBox.show()
        #else:
        #    self.Window.AddShipToText.hide()
        #    self.Window.AddShipToBox.hide()
        #if self.Window.AddMaxSizeSelect.currentIndex()==1:
        #    self.Window.AddMaxSizeBox.show()
        #    self.Window.AddMaxSizeUSD.show()
        #else:
        #    self.Window.AddMaxSizeBox.hide()
        #    self.Window.AddMaxSizeUSD.hide()
        #if self.Window.SetMinSelect.currentIndex()==0:
        #    self.Window.SetMinBox.hide()
        #    self.Window.SetMinUSD.hide()
        #else:
        #    self.Window.SetMinBox.show()
        #    self.Window.SetMinUSD.show()
        #if self.Window.SetMaxSelect.currentIndex()==0:
        #    self.Window.SetMaxBox.hide()
        #    self.Window.SetMaxUSD.hide()
        #else:
        #    self.Window.SetMaxBox.show()
        #    self.Window.SetMaxUSD.show()
        #if self.Window.DepositServiceSelect.currentIndex()==0:
        #    self.Window.DepositServiceBox.hide()
        #    self.Window.perc10.hide()
        #else:
        #    self.Window.DepositServiceBox.show()
        #    self.Window.perc10.show()
        """
        if obj=="SetMinUSD" or obj=="default":
            self.Window.SetMinUSD.setItemText(2, ("Quantity"))
            self.Window.SetMaxUSD.setItemText(2, ("Quantity"))
            if clear==0:
                self.Window.AddQuantityBox.clear()
            if self.Window.EstValueSelect.currentIndex()>3:
                self.Window.DepositServiceSelect.show()
                self.Window.DepositServiceBox.show()
                self.Window.perc10.show()
            else:
                self.Window.DepositServiceSelect.hide()
                self.Window.DepositServiceBox.hide()
                self.Window.perc10.hide()
            if self.Window.EstValueSelect.currentIndex()==1:
                index=self.Window.EstValueUSD.currentIndex()
                self.Window.SetMinUSD.setCurrentIndex(index)
                self.Window.SetMaxUSD.setCurrentIndex(index)
            if self.Window.EstValueSelect.currentIndex()>1:
                self.Window.SetMinUSD.setCurrentIndex(2)
                self.Window.SetMaxUSD.setCurrentIndex(2)
                #Need to consider changing on UI translation
                #text=str(self.Window.EstValueSelect.currentText()).replace("per ","")
                #text+="(s)"
                #self.Window.SetMinUSD.setItemText(2, text)
                #self.Window.SetMaxUSD.setItemText(2, text)
        """
        if obj!="default":
            for obj1 in self.objcombos:
                exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj1)+".blockSignals(False)\n")
        if hdlater==1:
            pass
        if hdlater2==1:
            pass
    def InitializeWindow(self, page, clear=0):
        global Spendable
        global AdvanceArray, GlobalImage, GlobalID
        
        self.Window.RequestAll.show()
        self.Window.AddItemSupply.show()
        self.Window.AddItemDemand.show()
        self.Window.RequestAll.setCurrentIndex(0)
        self.Window.SupplyAdditional7.show()
        self.Window.SaveFuture7.show()
        self.Window.ClearForm7.show()
        self.Window.SaveContinue7.show()
        self.Window.DepositSettings7.show()

        if clear==0:
            GlobalImage=""
            GlobalID=""
            self.Window.SellImageBox.clear()
            self.Window.BuyImageBox.clear()
            self.Window.PythonImageBox.clear()
            self.Window.AllowPriceTracking.hide()
            self.Window.AllowPriceTracking.setCheckState(0)
            self.Window.AutoAcceptValid.show()
            self.Window.AutoAcceptValid.setCheckState(0)            
            self.Window.AllowCounters.setCheckState(0)              
            self.Window.ContractSummary.setText("Contract:  ")
            self.Window.AmountSummary.setText("Amount:  ")
            self.Window.MyDepositSummary.setText("My Deposit:  ")
            self.Window.TheirDepositSummary.setText("Their Deposit:  ")
            self.Window.TimeLimitSummary.setText("Time Limit:  ")
            for h in self.hideoninit:
                exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',h)+".hide()\n")
        for h in self.defaulthidden:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',h)+".hide()\n")
        for h in self.defaultchecked:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',h)+".setCheckState(2)\n")
        for obj1 in self.objlist:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj1)+".blockSignals(True)\n")
        for obj1 in self.objcombos:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj1)+".blockSignals(True)\n")
        if interneton==1:
            self.rate, btc=GetMarketValue(CoinSelect['name'],CoinMarketCap)
        else:
            QuestionBox("Exchange rate not loaded, please wait until connected to the internet.", "OK")
            self.Window.hide()
            return False
        self.ShowAdvanced("default")
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        self.savedpages=[]
        if clear==0:
            self.cashmail=0
            self.additional=0
            self.Data={}
        self.returntoconfirm=0
        self.dontremoveonupdate=0

        self.Window.ExchangeRate.setText("Exchange Rate: $"+self.rate)
        self.Window.ExchangeRate2.setText("Exchange Rate: $"+self.rate)
        self.barteritems={'supply':{},'demand':{}}
        self.PopulateBarter()
        self.PythonIndex()
        if multisig not in AdvanceArray:
            AdvanceArray[multisig]={}
        try:
            if "savedpages" in AdvanceArray[multisig]:
                self.savedpages=AdvanceArray[multisig]['savedpages']
        except:
            print "Exception loading forms"
        try:
            if "savedbarter" in AdvanceArray[multisig]:
                self.barteritems=AdvanceArray[multisig]['savedbarter']
                self.PopulateBarter()
        except:
            print "Exception loading saved barter"            
        if self.savedpages==[]:
            self.savedpages.append({"saved":0,"dropdowns":{"RateBox":"","PriceUSD":"","AmountUSD":"","ServiceCharge":"","MinOrderSell":"","MaxOrderSell":"","MaxIncreaseSell":"","MaxDecreaseSell":""},"numberboxes":{"PriceBox":"","AmountBox":"","ServiceChargeBox":"","MinOrderSellBox":"","MaxOrderSellBox":"","MaxIncreaseSellBox":"","MaxDecreaseSellBox":""},"textboxes":{},"checkboxes":{"BankWireCheck":"","MoneyGramCheck":"","CashMailCheck":"","WUCheck":"","DebitCheck":"","OtherCheck":"","ShowAdvancedCash":""},"lists":{},"image":{}})
            self.savedpages.append({"saved":0,"dropdowns":{"RateBox2":"","PriceUSD2":"","AmountUSD2":"","ServiceCharge2":"","MinOrderBuy":"","MaxOrderBuy":"","MaxIncreaseBuy":"","MaxDecreaseBuy":""},"numberboxes":{"PriceBox2":"","AmountBox2":"","MinOrderBuyBox":"","MaxOrderBuyBox":"","MaxIncreaseBuyBox":"","MaxDecreaseBuyBox":""},"textboxes":{},"checkboxes":{"BankWireCheck2":"","MoneyGramCheck2":"","CashMail2":"","WUCheck2":"","DebitCheck2":"","OtherCheck2":"","ShowAdvancedCashBuy":""},"lists":{},"image":{}})
            self.savedpages.append({"saved":0,"dropdowns":{"JobSelect1":"","RateSelect1":"","JobUSD":"","JobRate":""},"numberboxes":{"JobAmount1":""},"textboxes":{"JobTitleBox1":"","DescriptionBox2":""},"checkboxes":{"EnableAutoPayCheck":"","RequireReportCheck":"","RequireResumeCheck":"","RequestInterviewCheck":""},"lists":{},"image":{}})
            self.savedpages.append({"saved":0,"dropdowns":{"FindUSD":"","FindRate":""},"numberboxes":{"FindAmount":""},"textboxes":{"LinkResumeBox":"","JobTitleBox2":"","DescriptionBox2_2":""},"checkboxes":{"AcceptOneCheck":"","AcceptTempCheck":"","AcceptFullCheck":"","AcceptInterviewCheck":""},"lists":{},"image":{}})
            self.savedpages.append({"saved":0,"dropdowns":{"SellSelect":"","ShippingSellSelect":"","DurationSellDays":"","BidSellUSD":"","BuyoutSellUSD":"","CountrySellSelect":"","RateSellUSD":"","WeightSellSelect":""},"numberboxes":{"DurationSellBox":"","BidSellBox":"","BuyoutSellBox":"","SellQuantityBox":"","RateSellBox2":"","WeightSellBox":""},"textboxes":{"ShipToSellBox":"","DescriptionSellBox":""},"checkboxes":{},"lists":{},"image":{"SellImageBox":""}})
            self.savedpages.append({"saved":0,"dropdowns":{"BuySelect":"","DurationBuyDays":"","BidBuyUSD":"","BuyoutBuyUSD":"","ShipCountryBuy":""},"numberboxes":{"DurationBuyBox":"","BidBuyBox":"","BuyoutBuyBox":""},"textboxes":{"ShipToBuyBox":"","DescriptionBuyBox":""},"checkboxes":{"ShippingCityBuy":"","LocalPickupBuy":""},"lists":{},"image":{"BuyImageBox":""}})
            self.savedpages.append({"saved":0,"dropdowns":{"RequestAll":""},"numberboxes":{"MaxItemsBox":""},"textboxes":{},"checkboxes":{"BuyMultiple":"","OfferNotInList":""},"lists":{"SupplyBox":[],"DemandBox":[]},"image":{}})
            self.savedpages.append({"saved":0,"dropdowns":{"PythonSelect":"","PythonUSD":"","PythonWhoPays":""},"numberboxes":{},"textboxes":{"DescriptionPythonBox":"","CodeOfferFormBox":"","CodeDuringEscrow":"","CodeEscrowWindow":"","PythonAmountBox":""},"checkboxes":{},"lists":{},"image":{"PythonImageBox":""}})
            i=1
            while i<10:
                if i!=8:
                    j=str(i)
                    if i==9:
                        i-=1
                    self.savedpages[i-1]['checkboxes'][self.checked[0]+j]=""
                    self.savedpages[i-1]['checkboxes'][self.checked[1]+j]=""
                    self.savedpages[i-1]['textboxes']['NotesBox'+j]=""
                    if i==1:
                        j=""
                    self.savedpages[i-1]['dropdowns'][self.dropdowns[0]+j]=""
                    self.savedpages[i-1]['dropdowns'][self.dropdowns[1]+j]=""
                    self.savedpages[i-1]['dropdowns'][self.dropdowns[2]+j]=""
                    self.savedpages[i-1]['dropdowns']['DepositSettings'+j]=""
                    self.savedpages[i-1]['numberboxes'][self.boxes[0]+j]=""
                    self.savedpages[i-1]['numberboxes'][self.boxes[1]+j]=""
                    self.savedpages[i-1]['numberboxes'][self.boxes[2]+j]=""
                    if i==8:
                        i+=1
                i+=1
            AdvanceArray[multisig]['savedpages']=self.savedpages
        if AdvanceArray[multisig]['savedpages'][page]['saved']==1 or clear==1:#Load the page
            self.pos=page
            for self.savevar in self.savedpages[page]['dropdowns']:
                if clear==1:
                    exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".setCurrentIndex(0)\n")
                else:
                    exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".setCurrentIndex(self.savedpages[self.pos]['dropdowns']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"'])\n")
            for self.savevar in self.savedpages[page]['checkboxes']:
                if clear==1:
                    exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".setCheckState(0)\n")
                else:
                    exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".setCheckState(self.savedpages[self.pos]['checkboxes']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"'])\n")
            for self.savevar in self.savedpages[page]['numberboxes']:
                try:
                    if clear==1:
                        exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".clear()\n")
                    else:
                        exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".setText(self.savedpages[self.pos]['numberboxes']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"'])\n")
                except:
                    traceback.print_exc()
                    QuestionBox("Error loading previously saved form.","OK")
            for self.savevar in self.savedpages[page]['textboxes']:
                try:
                    if clear==1:
                        exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".clear()\n")
                    else:
                        exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".setText(self.savedpages[self.pos]['textboxes']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"'])\n")
                except:
                    traceback.print_exc()
                    QuestionBox("Error loading previously saved form.","OK")
            if self.pos==7:
                self.pos+=1
            self.pos+=1
            if self.pos==1:
                self.pos=""
            self.StandardDepositChange(str(self.pos))
            pg=int(page)
            pg+=1
            if pg==8:
                pg+=1
            exec("self.Window.SaveFuture"+re.sub(r"[^A-Za-z0-9_]+", '',str(pg))+".setCheckState(2)\n")
            #Different defaults
            if clear==1:
                self.barteritems={'supply':{},'demand':{}}
                self.PopulateBarter()
                self.Window.ServiceCharge2.setCurrentIndex(1)
        else:
            #Different defaults
            self.Window.ServiceCharge2.setCurrentIndex(1)

            pg=int(page)
            #Is this a new account
            balance=GetfromCfg("#prevbalance#")
            if len(Spendable)<1 and Decimal(balance)==0:
                if int(page)==1:#Buy coins, we can request guarantor
                    self.Window.DepositSettings2.setCurrentIndex(2)
            pg+=1
            if pg==8:
                pg+=1
            exec("self.Window.SaveFuture"+re.sub(r"[^A-Za-z0-9_]+", '',str(pg))+".setCheckState(0)\n")
        if self.rate=="":
            self.Window.RateBox.setCurrentIndex(1)
            self.Window.ExchangeRate.setText("Exchange Rate: Not loaded")
            self.Window.ExchangeRate2.setText("Exchange Rate: Not loaded")       
        if clear==1:
            self.Window.SendToAddress.show()
        self.ShowAdvanced("default", 1)
        for obj1 in self.objlist:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj1)+".blockSignals(False)\n")
        for obj1 in self.objcombos:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj1)+".blockSignals(False)\n")
        return True
    def ClearMyForm(self,pos,save=0):
        orgpos=pos
        pos=int(pos)
        if pos==9:
            pos-=1
        pos-=1
        self.InitializeWindow(pos, 1)
        for h in self.defaulthidden:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',h)+".hide()\n")
        for h in self.defaultchecked:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',h)+".setCheckState(2)\n")
        if save==1:
            exec("self.Window.SaveFuture"+re.sub(r"[^A-Za-z0-9_]+", '',str(orgpos))+".setCheckState(0)\n")
    def ChangeIndex(self, obj):
        global AdvanceArray
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        for obj1 in self.objlist:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj1)+".blockSignals(True)\n")
        try:
            exec("self.index=self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".currentIndex()\n")
            if obj == "WireSelect" or obj == "BankSelectConfirm":
                save=AdvanceArray[multisig]['Profiles']['Bank'][self.index]
                AdvanceArray[multisig]['Profiles']['Bank'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['Bank'].insert(0,save)
            if obj == "WUSelect" or obj == "WUSelectConfirm":
                save=AdvanceArray[multisig]['Profiles']['WU'][self.index]
                AdvanceArray[multisig]['Profiles']['WU'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['WU'].insert(0,save)
            if obj == "MGSelect" or obj == "MGSelectConfirm":
                save=AdvanceArray[multisig]['Profiles']['MG'][self.index]
                AdvanceArray[multisig]['Profiles']['MG'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['MG'].insert(0,save)
            if obj == "DebitSelect" or obj == "DebitSelectConfirm":
                save=AdvanceArray[multisig]['Profiles']['Card'][self.index]
                AdvanceArray[multisig]['Profiles']['Card'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['Card'].insert(0,save)
            if obj == "CashMailSelect" or obj == "MailingSelectConfirm" and self.cashmail == 1:
                save=AdvanceArray[multisig]['Profiles']['Cash'][self.index]
                AdvanceArray[multisig]['Profiles']['Cash'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['Cash'].insert(0,save)
            if obj == "MailingSelect" or obj == "MailingSelectConfirm" and self.cashmail != 1:
                save=AdvanceArray[multisig]['Profiles']['Cash'][self.index]
                AdvanceArray[multisig]['Profiles']['Cash'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['Cash'].insert(0,save)
            if obj == "OtherFundSelect" or obj == "OtherSelectConfirm":
                save=AdvanceArray[multisig]['Profiles']['Other'][self.index]
                AdvanceArray[multisig]['Profiles']['Other'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['Other'].insert(0,save)
            if obj == "ContactSelect" or obj == "ContactSelectConfirm":
                save=AdvanceArray[multisig]['Profiles']['Contact'][self.index]
                AdvanceArray[multisig]['Profiles']['Contact'].pop(self.index)
                AdvanceArray[multisig]['Profiles']['Contact'].insert(0,save)
        except:
            traceback.print_exc()
        self.LoadProfiles()
    def EditConfirm(self, page=0):
        if self.cashmail==1 and page == 7:
            page-=1
        self.Window.Pages.setCurrentIndex(page)
        self.returntoconfirm=1
        self.LoadProfiles()
        response = Templates.Window.exec_()
    def ClearProfiles(self):
        self.Window.WireSelect.clear()
        self.Window.BankSelectConfirm.clear()
        self.Window.WUSelect.clear()
        self.Window.WUSelectConfirm.clear()
        self.Window.MGSelect.clear()
        self.Window.MGSelectConfirm.clear()
        self.Window.DebitSelect.clear()
        self.Window.DebitSelectConfirm.clear()
        self.Window.OtherFundSelect.clear()
        self.Window.OtherSelectConfirm.clear()
        self.Window.CashMailSelect.clear()
        self.Window.MailingSelect.clear()
        self.Window.MailingSelectConfirm.clear()
        self.Window.ContactSelect.clear()
        self.Window.ContactSelectConfirm.clear()

        self.Window.BankBox.clear()
        self.Window.AccountBox.clear()
        self.Window.RoutingBox.clear()
        self.Window.NameBox.clear()
        self.Window.OtherBox.clear()

        self.Window.NameBox1.clear()
        self.Window.PhoneBox1.clear()
        self.Window.CountryBox1.clear()
        self.Window.Pickup1.clear()
        self.Window.OtherBox2.clear()
        self.Window.Secret1.setCheckState(0)

        self.Window.NameBox2.clear()
        self.Window.PhoneBox2.clear()
        self.Window.CountryBox2.clear()
        self.Window.FundsPickup2.clear()
        self.Window.OtherBox3.clear()
        self.Window.Secret2.setCheckState(0)

        self.Window.DebitBox.clear()

        self.Window.OtherFundBox.clear()

        self.Window.NameCashBox.clear()
        self.Window.PhoneCashBox.clear()
        self.Window.CountryCashBox.clear()
        self.Window.CityCashBox.clear()
        self.Window.StateCashBox.clear()
        self.Window.ZipCashBox.clear()
        self.Window.AddressCashBox.clear()
        self.Window.OtherInfoCashBox.clear()
        self.Window.InsuranceCheckCash.setCheckState(0)

        self.Window.NameMailBox.clear()
        self.Window.PhoneMailBox.clear()
        self.Window.CountryMailBox.clear()
        self.Window.CityMailBox.clear()
        self.Window.StateMailBox.clear()
        self.Window.ZipMailBox.clear()
        self.Window.AddressMailBox.clear()
        self.Window.OtherMailBox.clear()
        self.Window.InsuranceMailCheck.setCheckState(0)

        self.Window.EmailContactBox.clear()
        self.Window.PhoneContactBox.clear()
        self.Window.IRCContactBox.clear()
        self.Window.ToxContactBox.clear()
        self.Window.OtherContactBox.clear()
    def UpdateProfile(self,index=0):
        res=self.SaveProfile(index)
        return True
    def CreateProfile(self,index=0):
        global AdvanceArray
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if self.dontremoveonupdate==1:
            self.UpdateProfile(index)
            return
        self.LoadProfiles()
        for obj in self.objlist:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".blockSignals(True)\n")
        self.ClearProfiles()
        self.dontremoveonupdate=1
    def RemoveProfile(self, index=0, next1=0):
        global AdvanceArray
        if self.dontremoveonupdate==1:
            return True
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if index==0:
            if AdvanceArray[multisig]['Profiles']['Bank']!=[]:
                AdvanceArray[multisig]['Profiles']['Bank'].pop(0+next1)
        if index==1:
            if AdvanceArray[multisig]['Profiles']['WU']!=[]:
                AdvanceArray[multisig]['Profiles']['WU'].pop(0+next1)
        if index==2:
            if AdvanceArray[multisig]['Profiles']['MG']!=[]:
                AdvanceArray[multisig]['Profiles']['MG'].pop(0+next1)
        if index==3:
            if AdvanceArray[multisig]['Profiles']['Card']!=[]:
                AdvanceArray[multisig]['Profiles']['Card'].pop(0+next1)
        if index==4:
            if AdvanceArray[multisig]['Profiles']['Other']!=[]:
                AdvanceArray[multisig]['Profiles']['Other'].pop(0+next1)
        if index==5:
            if AdvanceArray[multisig]['Profiles']['Cash']!=[]:
                AdvanceArray[multisig]['Profiles']['Cash'].pop(0+next1)
        if index==6:
            if AdvanceArray[multisig]['Profiles']['Mail']!=[]:
                AdvanceArray[multisig]['Profiles']['Mail'].pop(0+next1)
        if index==7:
            if AdvanceArray[multisig]['Profiles']['Contact']!=[]:
                AdvanceArray[multisig]['Profiles']['Contact'].pop(0+next1)
        self.LoadProfiles()
    def LoadProfiles(self):
        global AdvanceArray
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if 'Profiles' not in AdvanceArray[multisig]:
            AdvanceArray[multisig]['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
        for obj in self.objlist:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".blockSignals(True)\n")
        self.ClearProfiles()
        for profile in AdvanceArray[multisig]['Profiles']:
            if AdvanceArray[multisig]['Profiles'][profile]!=[]:
                if profile == "Bank":
                    self.Window.BankBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['bankname'])
                    self.Window.AccountBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['account'])
                    self.Window.RoutingBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['routing'])
                    self.Window.NameBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['name'])
                    self.Window.OtherBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['other'])
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.WireSelect.addItem(i['string'].replace("\n", "  "))
                        self.Window.BankSelectConfirm.addItem(i['string'].replace("\n", "  "))
                if profile == "WU":
                    self.Window.NameBox1.setText(AdvanceArray[multisig]['Profiles'][profile][0]['name'])
                    self.Window.PhoneBox1.setText(AdvanceArray[multisig]['Profiles'][profile][0]['phone'])
                    self.Window.CountryBox1.setText(AdvanceArray[multisig]['Profiles'][profile][0]['country'])
                    self.Window.Pickup1.setText(AdvanceArray[multisig]['Profiles'][profile][0]['city'])
                    self.Window.OtherBox2.setText(AdvanceArray[multisig]['Profiles'][profile][0]['other'])
                    if AdvanceArray[multisig]['Profiles'][profile][0]['secret']=="":
                        self.Window.Secret1.setCheckState(0)
                    else:
                        self.Window.Secret1.setCheckState(2)
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.WUSelect.addItem(i['string'].replace("\n", "  "))
                        self.Window.WUSelectConfirm.addItem(i['string'].replace("\n", "  "))
                if profile == "MG":
                    self.Window.NameBox2.setText(AdvanceArray[multisig]['Profiles'][profile][0]['name'])
                    self.Window.PhoneBox2.setText(AdvanceArray[multisig]['Profiles'][profile][0]['phone'])
                    self.Window.CountryBox2.setText(AdvanceArray[multisig]['Profiles'][profile][0]['country'])
                    self.Window.FundsPickup2.setText(AdvanceArray[multisig]['Profiles'][profile][0]['city'])
                    self.Window.OtherBox3.setText(AdvanceArray[multisig]['Profiles'][profile][0]['other'])
                    if AdvanceArray[multisig]['Profiles'][profile][0]['secret']=="":
                        self.Window.Secret2.setCheckState(0)
                    else:
                        self.Window.Secret2.setCheckState(2)
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.MGSelect.addItem(i['string'].replace("\n", "  "))
                        self.Window.MGSelectConfirm.addItem(i['string'].replace("\n", "  "))
                if profile == "Card":
                    self.Window.DebitBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['string'])
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.DebitSelect.addItem(i['string'].replace("\n", "  "))
                        self.Window.DebitSelectConfirm.addItem(i['string'].replace("\n", "  "))
                if profile == "Other":
                    self.Window.OtherFundBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['string'])
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.OtherFundSelect.addItem(i['string'].replace("\n", "  "))
                        self.Window.OtherSelectConfirm.addItem(i['string'].replace("\n", "  "))
                if profile == "Cash":
                    self.Window.NameCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['name'])
                    self.Window.PhoneCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['phone'])
                    self.Window.CountryCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['country'])
                    self.Window.CityCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['city'])
                    self.Window.StateCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['state'])
                    self.Window.ZipCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['zip'])
                    self.Window.AddressCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['address'])
                    self.Window.OtherInfoCashBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['other'])
                    if AdvanceArray[multisig]['Profiles'][profile][0]['insurance']=="":
                        self.Window.InsuranceCheckCash.setCheckState(0)
                    else:
                        self.Window.InsuranceCheckCash.setCheckState(2)
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.CashMailSelect.addItem(i['string'].replace("\n", "  "))
                        if self.cashmail==1:
                            self.Window.MailingSelectConfirm.addItem(i['string'].replace("\n", "  "))
                if profile == "Mail":
                    self.Window.NameMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['name'])
                    self.Window.PhoneMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['phone'])
                    self.Window.CountryMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['country'])
                    self.Window.CityMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['city'])
                    self.Window.StateMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['state'])
                    self.Window.ZipMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['zip'])
                    self.Window.AddressMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['address'])
                    self.Window.OtherMailBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['other'])
                    if AdvanceArray[multisig]['Profiles'][profile][0]['insurance']=="":
                        self.Window.InsuranceMailCheck.setCheckState(0)
                    else:
                        self.Window.InsuranceMailCheck.setCheckState(2)
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.MailingSelect.addItem(i['string'].replace("\n", "  "))
                        if self.cashmail==0:
                            self.Window.MailingSelectConfirm.addItem(i['string'].replace("\n", "  "))
                if profile == "Contact":
                    self.Window.EmailContactBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['email'])
                    self.Window.PhoneContactBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['phone'])
                    self.Window.IRCContactBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['irc'])
                    self.Window.ToxContactBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['tox'])
                    self.Window.OtherContactBox.setText(AdvanceArray[multisig]['Profiles'][profile][0]['other'])
                    for i in AdvanceArray[multisig]['Profiles'][profile]:
                        self.Window.ContactSelect.addItem(i['string'].replace("\n", "  "))
                        self.Window.ContactSelectConfirm.addItem(i['string'].replace("\n", "  "))
        for obj in self.objlist:
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".setCurrentIndex(0)\n")
            exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".blockSignals(False)\n")
    def SaveProfile(self, index=0):
        global AdvanceArray
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        #Come up with return to confirm protocol so its not adding new one each time
        if 'Profiles' not in AdvanceArray[multisig]:
            AdvanceArray[multisig]['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
        if index==0:
            Profile={}
            Profile['bankname']=strOUT(strIN(self.Window.BankBox.text()))
            Profile['account']=strOUT(strIN(self.Window.AccountBox.text()))
            if Profile['bankname']=="" or Profile['account']=="":
                QuestionBox("You must supply the name of the bank and account number","OK")
                return False
            mystr="Bank Name:\n"+Profile['bankname']+"\n\nAccount Number:\n"+Profile['account']
            Profile['routing']=strOUT(strIN(self.Window.RoutingBox.text()))
            if Profile['routing'] != "":
                mystr += "\n\nRouting Number:\n" + Profile['routing']
            Profile['name']=strOUT(strIN(self.Window.NameBox.text()))
            if Profile['name'] != "":
                mystr += "\n\nName on Account:\n" + Profile['name']
            Profile['other']=strOUT(strIN(self.Window.OtherBox.toPlainText()))
            if Profile['other'] != "":
                mystr += "\n\nOther Information and Special Instructions:\n" + Profile['other']
            Profile['string']=mystr
            AdvanceArray[multisig]['Profiles']['Bank'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['Bank'])>1:
                    AdvanceArray[multisig]['Profiles']['Bank'].pop(1)
        if index==1:
            Profile={}
            Profile['name']=strOUT(strIN(self.Window.NameBox1.text()))
            Profile['phone']=strOUT(strIN(self.Window.PhoneBox1.text()))
            Profile['country']=strOUT(strIN(self.Window.CountryBox1.text()))
            Profile['city']=strOUT(strIN(self.Window.Pickup1.text()))
            Profile['other']=strOUT(strIN(self.Window.OtherBox2.toPlainText()))
            Secret=""
            if self.Window.Secret1.isChecked():
                Secret="Please include a secret question and answer."
            Profile['secret']=Secret
            if Profile['name']=="" and Profile['phone']=="" and Profile['country']=="" and Profile['city']=="" and Profile['other']=="":
                QuestionBox("All the fields are blank, please fill out enough of the form to continue.","OK")
                return False
            mystr=""
            if Profile['name'] != "":
                mystr += "Send Western Union to:\n" + Profile['name'] + "\n\n"
            if Profile['phone'] != "":
                mystr += "Phone Number:\n" + Profile['phone'] + "\n\n"
            if Profile['country'] != "":
                mystr += "Country:\n" + Profile['country'] + "\n\n"
            if Profile['city'] != "":
                mystr += "City:\n" + Profile['city'] + "\n\n"
            if Secret != "":
                mystr += Secret + "\n\n"
            if Profile['other'] != "":
                mystr += "Other Information and Special Instructions:\n" + Profile['other']
            Profile['string']=mystr
            AdvanceArray[multisig]['Profiles']['WU'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['WU'])>1:
                    AdvanceArray[multisig]['Profiles']['WU'].pop(1)
        if index==2:
            Profile={}
            Profile['name']=strOUT(strIN(self.Window.NameBox2.text()))
            Profile['phone']=strOUT(strIN(self.Window.PhoneBox2.text()))
            Profile['country']=strOUT(strIN(self.Window.CountryBox2.text()))
            Profile['city']=strOUT(strIN(self.Window.FundsPickup2.text()))
            Profile['other']=strOUT(strIN(self.Window.OtherBox3.toPlainText()))
            Secret=""
            if self.Window.Secret2.isChecked():
                Secret="Please include a secret question and answer."
            Profile['secret']=Secret
            if Profile['name']=="" and Profile['phone']=="" and Profile['country']=="" and Profile['city']=="" and Profile['other']=="":
                QuestionBox("All the fields are blank, please fill out enough of the form to continue.","OK")
                return False
            mystr=""
            if Profile['name'] != "":
                mystr += "Send MoneyGram to:\n" + Profile['name'] + "\n\n"
            if Profile['phone'] != "":
                mystr += "Phone Number:\n" + Profile['phone'] + "\n\n"
            if Profile['country'] != "":
                mystr += "Country:\n" + Profile['country'] + "\n\n"
            if Profile['city'] != "":
                mystr += "City:\n" + Profile['city'] + "\n\n"
            if Secret != "":
                mystr += Secret + "\n\n"
            if Profile['other'] != "":
                mystr += "Other Information and Special Instructions:\n" + Profile['other']
            Profile['string']=mystr
            AdvanceArray[multisig]['Profiles']['MG'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['MG'])>1:
                    AdvanceArray[multisig]['Profiles']['MG'].pop(1)
        if index==3:
            Profile={}
            Profile['string']=strOUT(strIN(self.Window.DebitBox.toPlainText()))
            if Profile['string']=="":
                QuestionBox("Please Fill Out Profile", "OK")
                return False
            AdvanceArray[multisig]['Profiles']['Card'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['Card'])>1:
                    AdvanceArray[multisig]['Profiles']['Card'].pop(1)
        if index==4:
            Profile={}
            Profile['string']=strOUT(strIN(self.Window.OtherFundBox.toPlainText()))
            if Profile['string']=="":
                QuestionBox("Please Fill Out Profile", "OK")
                return False
            AdvanceArray[multisig]['Profiles']['Other'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['Other'])>1:
                    AdvanceArray[multisig]['Profiles']['Other'].pop(1)
        if index==5:
            Profile={}
            Profile['name']=strOUT(strIN(self.Window.NameCashBox.text()))
            Profile['phone']=strOUT(strIN(self.Window.PhoneCashBox.text()))
            Profile['country']=strOUT(strIN(self.Window.CountryCashBox.text()))
            Profile['city']=strOUT(strIN(self.Window.CityCashBox.text()))
            Profile['state']=strOUT(strIN(self.Window.StateCashBox.text()))
            Profile['zip']=strOUT(strIN(self.Window.ZipCashBox.text()))
            Profile['address']=strOUT(strIN(self.Window.AddressCashBox.toPlainText()))
            Profile['other']=strOUT(strIN(self.Window.OtherInfoCashBox.toPlainText()))
            Insurance=""
            if self.Window.InsuranceCheckCash.isChecked():
                Insurace="Insurance is requested on this package."
            Profile['insurance']=Insurance
            if Profile['name']=="" and Profile['phone']=="" and Profile['country']=="" and Profile['city']=="" and Profile['other']=="":
                QuestionBox("All the fields are blank, please fill out enough of the form to continue.","OK")
                return False
            mystr=""
            if Profile['name'] != "":
                mystr += "Send Cash to:\n" + Profile['name'] + "\n\n"
            if Profile['phone'] != "":
                mystr += "Phone Number:\n" + Profile['phone'] + "\n\n"
            if Profile['country'] != "":
                mystr += "Country:\n" + Profile['country'] + "\n\n"
            if Profile['city'] != "":
                mystr += "City:\n" + Profile['city'] + "\n\n"
            if Profile['state'] != "":
                mystr += "State:\n" + Profile['state'] + "\n\n"
            if Profile['zip'] != "":
                mystr += "Zip:\n" + Profile['zip'] + "\n\n"
            if Profile['address'] != "":
                mystr += "Address:\n" + Profile['address'] + "\n\n"
            if Insurance != "":
                mystr += Insurance + "\n\n"
            if Profile['other'] != "":
                mystr += "Other Information and Special Instructions:\n" + Profile['other']
            Profile['string']=mystr
            AdvanceArray[multisig]['Profiles']['Cash'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['Cash'])>1:
                    AdvanceArray[multisig]['Profiles']['Cash'].pop(1)
        if index==6:
            Profile={}
            Profile['name']=strOUT(strIN(self.Window.NameMailBox.text()))
            Profile['phone']=strOUT(strIN(self.Window.PhoneMailBox.text()))
            Profile['country']=strOUT(strIN(self.Window.CountryMailBox.text()))
            Profile['city']=strOUT(strIN(self.Window.CityMailBox.text()))
            Profile['state']=strOUT(strIN(self.Window.StateMailBox.text()))
            Profile['zip']=strOUT(strIN(self.Window.ZipMailBox.text()))
            Profile['address']=strOUT(strIN(self.Window.AddressMailBox.toPlainText()))
            Profile['other']=strOUT(strIN(self.Window.OtherMailBox.toPlainText()))
            Insurance=""
            if self.Window.InsuranceMailCheck.isChecked():
                Insurance="Insurance Requested"
            Profile['insurance']=Insurance
            if Profile['country']=="" or Profile['city']=="" or Profile['address']=="":
                QuestionBox("Please fill out enough of the form to continue.","OK")
                return False
            mystr=""
            if Profile['name'] != "":
                mystr += "Name:\n" + Profile['name'] + "\n\n"
            if Profile['country'] != "":
                mystr += "Country:\n" + Profile['country'] + "\n\n"
            if Profile['city'] != "":
                mystr += "City:\n" + Profile['city'] + "\n\n"
            if Profile['state'] != "":
                mystr += "State:\n" + Profile['state'] + "\n\n"
            if Profile['zip'] != "":
                mystr += "Zip:\n" + Profile['zip'] + "\n\n"
            if Profile['address'] != "":
                mystr += "Address:\n" + Profile['address'] + "\n\n"
            if Profile['phone'] != "":
                mystr += "Phone Number:\n" + Profile['phone'] + "\n\n"
            if Insurance != "":
                mystr += Insurance + "\n\n"
            if Profile['other'] != "":
                mystr += "Other Information and Special Instructions:\n" + Profile['other']
            Profile['string']=mystr
            AdvanceArray[multisig]['Profiles']['Mail'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['Mail'])>1:
                    AdvanceArray[multisig]['Profiles']['Mail'].pop(1)
        if index==7:
            Profile={}
            Profile['email']=strOUT(strIN(self.Window.EmailContactBox.text()))
            Profile['phone']=strOUT(strIN(self.Window.PhoneContactBox.text()))
            Profile['irc']=strOUT(strIN(self.Window.IRCContactBox.text()))
            Profile['tox']=strOUT(strIN(self.Window.ToxContactBox.text()))
            Profile['other']=strOUT(strIN(self.Window.OtherContactBox.toPlainText()))
            if Profile['email']=="" and Profile['phone']=="" and Profile['irc']=="" and Profile['tox']=="" and Profile['other']=="":
                print Profile
                QuestionBox("Please fill out enough of the form to continue.","OK")
                return False
            mystr=""
            if Profile['email'] != "":
                mystr += "Name:\n" + Profile['email'] + "\n\n"
            if Profile['phone'] != "":
                mystr += "Phone:\n" + Profile['phone'] + "\n\n"
            if Profile['irc'] != "":
                mystr += "IRC Chat:\n" + Profile['irc'] + "\n\n"
            if Profile['tox'] != "":
                mystr += "Tox:\n" + Profile['tox'] + "\n\n"
            if Profile['other'] != "":
                mystr += "Other Contact Information:\n" + Profile['other']
            Profile['string']=mystr
            AdvanceArray[multisig]['Profiles']['Contact'].insert(0, Profile)
            if self.returntoconfirm==1 and self.dontremoveonupdate==0:
                if len(AdvanceArray[multisig]['Profiles']['Contact'])>1:
                    AdvanceArray[multisig]['Profiles']['Contact'].pop(1)
        self.LoadProfiles()
        self.dontremoveonupdate=0
        if self.returntoconfirm>0:
            self.Window.Pages.setCurrentIndex(18)
            self.returntoconfirm=0
        self.Window.accept()
        self.Window.show()
        return True
    def RateCheck(self):
        try:
            return str(Decimal(self.rate)), str(Decimal(0))
        except:
            res=QuestionBox("Exchange rate not loaded yet. To price track and use all the features of this template, you must be able to compare your rate to the rate accepted to verify valid offers. You may try again later or you may also enter the fiat rate manually.", "Try Again Later", "Enter Rate Manually")
            if res==0:
                return False, ""
            if res==1:
                text, ok = QtGui.QInputDialog.getText(self.Window, "Halo", Gtranslate('Please enter the exchange rate for ') + CoinSelect['name'] + Gtranslate(' in dollars.\nYou can find this rate online. Please be as precise as possible.'))
                try:
                    a=float(Decimal(str(text)))
                except:
                    QuestionBox("The rate you entered was invalid.", "OK")                         
                    return False, ""
                usd=Decimal(str(text))
                if usd<=0:
                    QuestionBox("The rate you entered was invalid.", "OK")
                    return False, ""
                usd=str(usd)
                self.rate=usd
                btc=str(Decimal(0))
                return usd, btc
    def SaveAndContinue(self,pos,cont=0):
        global AdvanceArray
        #variables are written to self so the obfuscator will protect them
        guarantornotice=0
        self.savevar=0
        exec("if self.Window.SaveFuture"+re.sub(r"[^A-Za-z0-9_]+", '',str(pos))+".checkState() == 2:self.savevar=1\n")
        orgpos=pos
        pos=int(pos)
        if pos==9:
            pos-=1
        self.pos=pos
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if self.savevar == 1 or cont==1:
            for self.savevar in self.savedpages[pos-1]['dropdowns']:
                exec("self.savedpages[self.pos-1]['dropdowns']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"']=self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".currentIndex()\n")
            for self.savevar in self.savedpages[pos-1]['checkboxes']:
                exec("self.savedpages[self.pos-1]['checkboxes']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"']=self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".checkState()\n")
            for self.savevar in self.savedpages[pos-1]['numberboxes']:
                try:
                    exec("self.savedpages[self.pos-1]['numberboxes']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"']=str(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".text())\n")
                    exec("x=str(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".text())\n")
                    exec("if x!='':x=Decimal(x)\n")
                except:
                    traceback.print_exc()
                    QuestionBox("Expected a number but got something else. Please check the form.","OK")
                    return
            for self.savevar in self.savedpages[pos-1]['textboxes']:
                try:
                    exec("self.savedpages[self.pos-1]['textboxes']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"']=strOUT(strIN(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".text()))\n")
                except:
                    exec("self.savedpages[self.pos-1]['textboxes']['"+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+"']=strOUT(strIN(self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',self.savevar)+".toPlainText()))\n")
            self.savedpages[pos-1]['saved']=1
            AdvanceArray[multisig]['savedpages'][pos-1]=self.savedpages[pos-1]
            if pos-1==6:
                AdvanceArray[multisig]['savedbarter']=self.barteritems
        else:
            self.savedpages[pos-1]['saved']=1
            if pos-1==6:
                try:
                    AdvanceArray[multisig].pop('savedbarter')
                except:
                    pass
            AdvanceArray[multisig]['savedpages'][pos-1]['saved']=0
        if cont==0:
            self.LoadProfiles()
            self.dontremoveonupdate=0
            self.additional=0
            exec("if self.Window.SupplyAdditional"+re.sub(r"[^A-Za-z0-9_]+", '',str(orgpos))+".isChecked():self.additional=1\n")
            exec("self.Data['notes']=strOUT(strIN(self.Window.NotesBox"+re.sub(r"[^A-Za-z0-9_]+", '',str(orgpos))+".toPlainText()))\n")
            self.Data['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
            self.Data['tracking']=0
            self.Data['rate']=""
            exchangeratenotify=0
            if pos-1==0:
                if self.Window.DebitCheck.isChecked() or self.Window.OtherCheck.isChecked():
                    if 'tip1' not in AdvanceArray:
                        if self.Window.DebitCheck.isChecked():
                            txt="You have chosen a Prepaid Debit Card. Some of these cards use unorthodox funding methods. For your privacy, the card information is withheld until escrow has funded. So, please briefly describe the method of funding it in the notes."
                        if self.Window.OtherCheck.isChecked():
                            txt="You have chosen 'Other' as a payment method. For your privacy, this information is withheld until escrow has funded. So, please briefly describe the method of funding in the notes to make the buyers aware (for example paypal, credit card, etc)."
                        res=QuestionBox(txt, "  Okay, I will change that now  ", "  Don't show this message again  ")
                        if res==1:
                            AdvanceArray['tip1']=1
                        else:
                            return
                found=0
                if self.Window.BankWireCheck.isChecked():
                    found=1
                    self.Window.BankSelectConfirm.show()
                    self.Window.BankEdit.show()
                    self.Window.BankConfirm.show()
                    if AdvanceArray[multisig]['Profiles']['Bank']==[]:
                        self.Window.Pages.setCurrentIndex(1)
                        response=Templates.Window.exec_()
                        if response==0:
                            return
                    self.Data['Profiles']['Bank'].append(AdvanceArray[multisig]['Profiles']['Bank'][0]['string'])
                if self.Window.WUCheck.isChecked():
                    found=1
                    self.Window.WUSelectConfirm.show()
                    self.Window.WUEdit.show()
                    self.Window.WUConfirm.show()
                    if AdvanceArray[multisig]['Profiles']['WU']==[]:
                        self.Window.Pages.setCurrentIndex(2)
                        response=Templates.Window.exec_()
                        if response==0:
                            return
                    self.Data['Profiles']['WU'].append(AdvanceArray[multisig]['Profiles']['WU'][0]['string'])
                if self.Window.MoneyGramCheck.isChecked():
                    found=1
                    self.Window.MGSelectConfirm.show()
                    self.Window.MGEdit.show()
                    self.Window.MGConfirm.show()
                    if AdvanceArray[multisig]['Profiles']['MG']==[]:
                        self.Window.Pages.setCurrentIndex(3)
                        response=Templates.Window.exec_()
                        if response==0:
                            return
                    self.Data['Profiles']['MG'].append(AdvanceArray[multisig]['Profiles']['MG'][0]['string'])
                if self.Window.DebitCheck.isChecked():
                    found=1
                    self.Window.DebitSelectConfirm.show()
                    self.Window.DebitEdit.show()
                    self.Window.DebitConfirm.show()
                    if AdvanceArray[multisig]['Profiles']['Card']==[]:
                        self.Window.Pages.setCurrentIndex(4)
                        response=Templates.Window.exec_()
                        if response==0:
                            return
                    self.Data['Profiles']['Card'].append(AdvanceArray[multisig]['Profiles']['Card'][0]['string'])
                if self.Window.OtherCheck.isChecked():
                    found=1
                    self.Window.OtherSelectConfirm.show()
                    self.Window.OtherEdit.show()
                    self.Window.OtherConfirm.show()
                    if AdvanceArray[multisig]['Profiles']['Other']==[]:
                        self.Window.Pages.setCurrentIndex(5)
                        response=Templates.Window.exec_()
                        if response==0:
                            return
                    self.Data['Profiles']['Other'].append(AdvanceArray[multisig]['Profiles']['Other'][0]['string'])
                if self.Window.CashMailCheck.isChecked():
                    self.Window.MailingSelectConfirm.show()
                    self.Window.AddressEdit.show()
                    self.Window.MailingConfirm.show()
                    self.cashmail=1
                    found=1
                    if AdvanceArray[multisig]['Profiles']['Cash']==[]:
                        self.Window.Pages.setCurrentIndex(6)
                        response=Templates.Window.exec_()
                        if response==0:
                            return
                    self.Data['Profiles']['Cash'].append(AdvanceArray[multisig]['Profiles']['Cash'][0]['string'])
                if found==0:
                    QuestionBox("You must choose at least one payment option", "OK")
                    return
                pricebox=0
                if self.Window.RateBox.currentIndex()==0:
                    rate=Decimal(self.rate)
                else:
                    rate=Decimal(str(self.Window.PriceBox.text()))
                    pricebox=1
                self.Data['Template']="Sell Coins"
                self.Data['rate']=str(rate)
                if self.Window.ShowAdvancedCash.isChecked():
                    self.Data['dontclear']=1
                    self.Data['tracking']=1
                    if pricebox==0:
                        if self.Window.MaxIncreaseSell.currentIndex()==0:
                            self.Data['maxincrease']=str("1.25")
                        elif self.Window.MaxIncreaseSell.currentIndex()==1:
                            self.Data['maxincrease']=str("1.0000000011")#No limit
                        else:
                            self.Data['maxincrease']=str(Decimal(1+abs(Decimal(str(self.Window.MaxIncreaseSellBox.text()))/Decimal(100))))
                        if self.Window.MaxDecreaseSell.currentIndex()!=3:
                            if self.Window.MaxDecreaseSell.currentIndex()==0:
                                self.Data['maxdecrease']=str(Decimal(1-abs(Decimal(str("5"))/Decimal(100))))
                            if self.Window.MaxDecreaseSell.currentIndex()==1:
                                self.Data['maxdecrease']=str(Decimal(1-abs(Decimal(str("10"))/Decimal(100))))
                            if self.Window.MaxDecreaseSell.currentIndex()==2:
                                self.Data['maxdecrease']=str(Decimal(1-abs(Decimal(str("15"))/Decimal(100))))
                        else:
                            self.Data['maxdecrease']=str(Decimal(1-abs(Decimal(str(self.Window.MaxDecreaseSellBox.text()))/Decimal(100))))
                    else:
                        self.Data['maxincrease']=str("1.000000001")#No change
                        self.Data['maxdecrease']=str("0.000000001")#No change
                    if self.Window.MinOrderSell.currentIndex()!=3:
                        if self.Window.MinOrderSell.currentIndex()==0:
                            self.Data['minorder']=str(abs(Decimal(str("25"))/Decimal(100)))
                        if self.Window.MinOrderSell.currentIndex()==1:
                            self.Data['minorder']=str(abs(Decimal(str("50"))/Decimal(100)))
                        if self.Window.MinOrderSell.currentIndex()==2:
                            self.Data['minorder']=str(abs(Decimal(str("100"))/Decimal(100)))
                    else:
                        self.Data['minorder']=str(abs(Decimal(str(self.Window.MinOrderSellBox.text()))/Decimal(100)))
                    if self.Window.MaxOrderSell.currentIndex()!=3:
                        if self.Window.MaxOrderSell.currentIndex()==0:
                            self.Data['maxorder']=str(abs(Decimal(str("100"))/Decimal(100)))
                        if self.Window.MaxOrderSell.currentIndex()==1:
                            self.Data['maxorder']=str(abs(Decimal(str("50"))/Decimal(100)))
                        if self.Window.MaxOrderSell.currentIndex()==2:
                            self.Data['maxorder']=str(abs(Decimal(str("25"))/Decimal(100)))
                    else:
                        self.Data['maxorder']=str(abs(Decimal(str(self.Window.MaxOrderSellBox.text()))/Decimal(100)))
                    if Decimal(self.Data['maxorder'])>1:
                        QuestionBox("The maximum order size entered was higher than 100%. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['minorder'])>1:
                        QuestionBox("The minimum order size entered was higher than 100%. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['maxorder'])<Decimal(self.Data['minorder']):
                        QuestionBox("The maximum order is less than the minimum order. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['maxincrease'])<1:
                        QuestionBox("The maximum increase is incorrect. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['maxdecrease'])<=0:
                        QuestionBox("The maximum decrease is incorrect. Please check the value and try again.", "OK")
                        return
                maxorder=1
                customdeposit=0
                if self.Data['tracking']==1:
                    maxorder=Decimal(self.Data['maxorder'])
                if self.Window.ServiceCharge.currentIndex()==5:
                    self.Data['service']=str(Decimal(1+abs(Decimal(str(self.Window.ServiceChargeBox.text()))/Decimal(100))))
                else:
                    if self.Window.ServiceCharge.currentIndex()==0:
                        self.Data['service']=str(Decimal(1+Decimal(str("2"))/Decimal(100)))
                    else:
                        self.Data['service']=str(Decimal(1+Decimal(str(self.Window.ServiceCharge.currentIndex()*5))/Decimal(100)))
                if self.Window.AmountUSD.currentIndex()==0:
                    self.Data['supplyusd']=str(self.Window.AmountBox.text())
                    self.Data['totalusd']=str((Decimal(self.Data['supplyusd'])*Decimal(maxorder)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                    self.Data['amount']=str(((Decimal(str(self.Window.AmountBox.text()))/Decimal(rate))*maxorder).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))
                else:
                    self.Data['supplyusd']=str((Decimal(str(self.Window.AmountBox.text()))*rate).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                    self.Data['totalusd']=str((Decimal(self.Data['supplyusd'])*Decimal(maxorder)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                    self.Data['amount']=str(dropzeros((Decimal(str(self.Window.AmountBox.text()))*maxorder).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))
                self.Data['quantity']=int((Decimal(self.Data['amount'])/maxorder)*Decimal(1e8))
                if self.Window.DepositSettings.currentIndex()!=1:
                    self.Data['mydeposit']=str(dropzeros((Decimal(self.Data['amount'])*Decimal(self.Data['service'])).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))
                    self.Data['theirdeposit']=str(dropzeros((Decimal(self.Data['amount'])*Decimal(self.Data['service'])).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))
                    if self.Window.DepositSettings.currentIndex()==2:
                        guarantornotice=1
                        self.Data['theirdeposit']="0"
                    self.Data['timelimit']="336"
                else:
                    customdeposit=1
                self.Window.AllowCounters.hide()#We already allow partial bids.
                self.Window.AllowChat.setCheckState(2)
            if pos-1==1:
                if self.Window.OtherCheck2.isChecked():
                    if 'tip6' not in AdvanceArray:
                        try:
                            if str(self.Data['notes'])=='':
                                txt="If you chose to pay with an uncommon payment method it is not as secure as a regular bank wire or a money order. You should describe your alternate funding method in the notes."
                                res=QuestionBox(txt, "  Okay, I will do that now  ", "  Don't show this message again  ")
                                if res==1:
                                    AdvanceArray['tip6']=1
                                else:
                                    return
                        except:
                            print 'Exception in notes'
                found=0
                if self.Window.BankWireCheck2.isChecked():
                    found=1
                    self.Data['Profiles']['Bank'].append('')
                if self.Window.WUCheck2.isChecked():
                    found=1
                    self.Data['Profiles']['WU'].append('')
                if self.Window.MoneyGramCheck2.isChecked():
                    found=1
                    self.Data['Profiles']['MG'].append('')
                if self.Window.DebitCheck2.isChecked():
                    found=1
                    self.Data['Profiles']['Card'].append('')
                if self.Window.OtherCheck2.isChecked():
                    found=1
                    self.Data['Profiles']['Other'].append('')
                if self.Window.CashMail2.isChecked():
                    self.cashmail=1
                    found=1
                    self.Data['Profiles']['Cash'].append('')
                if found==0:
                    QuestionBox("You must choose at least one payment option", "OK")
                    return
                pricebox=0
                if self.Window.RateBox2.currentIndex()==0:
                    rate=Decimal(self.rate)
                else:
                    rate=Decimal(str(self.Window.PriceBox2.text()))
                    pricebox=1
                self.Data['Template']="Buy Coins"
                self.Data['rate']=str(rate)
                if self.Window.ShowAdvancedCashBuy.isChecked():
                    self.Data['dontclear']=1
                    self.Data['tracking']=1
                    if 'tip7' not in AdvanceArray:
                        txt="Depending on the market rate and your advanced settings, when tracking the market price you may have to come up with more or less cash to complete your purchase."
                        res=QuestionBox(txt, "  Okay, I understand  ", "  Don't show this message again  ")
                        if res==1:
                            AdvanceArray['tip7']=1
                    if pricebox==0:
                        if self.Window.MaxIncreaseBuy.currentIndex()==0:
                            self.Data['maxincrease']=str("1.05")
                        else:
                            self.Data['maxincrease']=str(Decimal(1+abs(Decimal(str(self.Window.MaxIncreaseBuyBox.text()))/Decimal(100))))
                        if self.Window.MaxDecreaseBuy.currentIndex()!=2:
                            if self.Window.MaxDecreaseBuy.currentIndex()==0:
                                self.Data['maxdecrease']=str(Decimal(1-abs(Decimal(str("25"))/Decimal(100))))
                            if self.Window.MaxDecreaseBuy.currentIndex()==1:
                               self.Data['maxdecrease']=str("0.000000001")
                        else:
                            self.Data['maxdecrease']=str(Decimal(1-abs(Decimal(str(self.Window.MaxDecreaseBuyBox.text()))/Decimal(100))))
                    else:
                        self.Data['maxincrease']=str("1.000000001")#No change
                        self.Data['maxdecrease']=str("0.000000001")#No change
                    if self.Window.MinOrderBuy.currentIndex()!=3:
                        if self.Window.MinOrderBuy.currentIndex()==0:
                            self.Data['minorder']=str(abs(Decimal(str("25"))/Decimal(100)))
                        if self.Window.MinOrderBuy.currentIndex()==1:
                            self.Data['minorder']=str(abs(Decimal(str("50"))/Decimal(100)))
                        if self.Window.MinOrderBuy.currentIndex()==2:
                            self.Data['minorder']=str(abs(Decimal(str("100"))/Decimal(100)))
                    else:
                        self.Data['minorder']=str(abs(Decimal(str(self.Window.MinOrderBuyBox.text()))/Decimal(100)))
                    if self.Window.MaxOrderBuy.currentIndex()!=3:
                        if self.Window.MaxOrderBuy.currentIndex()==0:
                            self.Data['maxorder']=str(abs(Decimal(str("100"))/Decimal(100)))
                        if self.Window.MaxOrderBuy.currentIndex()==1:
                            self.Data['maxorder']=str(abs(Decimal(str("50"))/Decimal(100)))
                        if self.Window.MaxOrderBuy.currentIndex()==2:
                            self.Data['maxorder']=str(abs(Decimal(str("25"))/Decimal(100)))
                    else:
                        self.Data['maxorder']=str(abs(Decimal(str(self.Window.MaxOrderBuyBox.text()))/Decimal(100)))
                    if Decimal(self.Data['maxorder'])>1:
                        QuestionBox("The maximum order size entered was higher than 100%. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['minorder'])>1:
                        QuestionBox("The minimum order size entered was higher than 100%. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['maxorder'])<Decimal(self.Data['minorder']):
                        QuestionBox("The maximum order is less than the minimum order. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['maxincrease'])<1:
                        QuestionBox("The maximum increase is incorrect. Please check the value and try again.", "OK")
                        return
                    if Decimal(self.Data['maxdecrease'])<=0:
                        QuestionBox("The maximum decrease is incorrect. Please check the value and try again.", "OK")
                        return
                maxorder=1
                customdeposit=0
                if self.Data['tracking']==1:
                    maxorder=Decimal(self.Data['maxorder'])
                if self.Window.ServiceCharge2.currentIndex()==0:
                    self.Data['service']=str(Decimal(1+abs(Decimal(str("2"))/Decimal(100))))
                else:
                    self.Data['service']=str(Decimal(1+Decimal(str(self.Window.ServiceCharge2.currentIndex()*5))/Decimal(100)))
                if self.Window.AmountUSD2.currentIndex()==0:
                    self.Data['supplyusd']=str(self.Window.AmountBox2.text())
                    self.Data['totalusd']=str((Decimal(self.Data['supplyusd'])*Decimal(maxorder)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                    self.Data['amount']=str(((Decimal(str(self.Window.AmountBox2.text()))/Decimal(rate))*maxorder).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))
                else:
                    self.Data['supplyusd']=str((Decimal(str(self.Window.AmountBox2.text()))*rate).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                    self.Data['totalusd']=str((Decimal(self.Data['supplyusd'])*Decimal(maxorder)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                    self.Data['amount']=str(dropzeros((Decimal(str(self.Window.AmountBox2.text()))*maxorder).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))
                self.Data['quantity']=int((Decimal(self.Data['amount'])/maxorder)*Decimal(1e8))
                if self.Window.DepositSettings2.currentIndex()!=1:
                    self.Data['mydeposit']=str(dropzeros((Decimal(self.Data['amount'])*Decimal(self.Data['service'])).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))
                    self.Data['theirdeposit']=str(dropzeros((Decimal(self.Data['amount'])*Decimal(self.Data['service'])).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))
                    if self.Window.DepositSettings2.currentIndex()==2:
                        guarantornotice=1
                        self.Data['mydeposit']="0"
                    self.Data['timelimit']="336"
                else:
                    customdeposit=1
                self.Window.AllowCounters.hide()#We already allow partial bids.
                self.Window.AllowChat.setCheckState(2)
            if pos-1==4:
                customdeposit=0
                usd,btc=self.RateCheck()
                if usd==False:
                    return
                rate=usd
                self.Data['Template']="Sell Something"
                self.Data['rate']=str(rate)
                self.Data['description'] = strOUT(strIN(self.Window.DescriptionSellBox.toPlainText()))
                if self.Window.SellSelect.currentIndex()==0:
                    try:
                        if int(self.Window.SellQuantityBox.text())>1:
                            self.Data['quantity']=int(self.Window.SellQuantityBox.text())
                            self.Data['dontclear']=1
                    except:
                        pass
                test=0
                if self.Window.ShippingSellSelect.currentIndex()==0:
                    self.Data['shipping']="Free Shipping"
                if self.Window.ShippingSellSelect.currentIndex()==1: 
                    if self.Window.RateSellUSD.currentIndex()==0:
                        test=1
                    if self.Data['rate']!="" and self.Window.RateSellUSD.currentIndex()==0:
                        exchangeratenotify=1
                        self.Data['shipping']=str(dropzeros(abs((Decimal(str(self.Window.RateSellBox2.text()))/Decimal(rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                    if self.Window.RateSellUSD.currentIndex()==1:
                        self.Data['shipping']=str(dropzeros(abs((Decimal(str(self.Window.RateSellBox2.text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))                        
                if self.Window.ShippingSellSelect.currentIndex()==2:
                    self.Data['shipping']="Buyer Pays During Escrow"
                if self.Window.ShippingSellSelect.currentIndex()==3:
                    self.Data['shipping']="Buyer Can Calculate Shipping"
                    if str(self.Window.WeightSellBox.text())!="":
                        try:
                            if self.Window.WeightSellSelect.currentIndex()==0:
                                measurement="Kilograms"
                            else:
                                measurement="Pounds"
                            self.Data['weight']=str(Decimal(str(self.Window.WeightSellBox.text())))+" "+measurement
                        except:
                            pass
                    self.Window.MailingSelectConfirm.show()
                    self.Window.AddressEdit.show()
                    self.Window.MailingConfirm.show()                              
                    if AdvanceArray[multisig]['Profiles']['Mail']==[]:
                        QuestionBox("Since you have requested that the buyer calculate the rate of shipping in their offer, please supply some mailing information so that they can correctly estimate the cost.", " OK ")
                        self.Window.Pages.setCurrentIndex(7)                                    
                        response=Templates.Window.exec_()
                        if response==0:
                            return
                    self.Data['Profiles']['Mail'].append(AdvanceArray[multisig]['Profiles']['Mail'][0]['string'])
                if self.Window.ShippingSellSelect.currentIndex()==4:
                    self.Data['shipping']="No Shipping / Local Delivery"
                if self.Window.CountrySellSelect.currentIndex()==1:
                    self.Data['countries']=strOUT(strIN(self.Window.ShipToSellBox.text()))
                if self.Window.SellSelect.currentIndex()==0 and self.Window.BuyoutSellUSD.currentIndex()==0:
                    test=1
                if self.Window.SellSelect.currentIndex()==1: 
                    if self.Window.BuyoutSellUSD.currentIndex()==0 or self.Window.BidSellUSD.currentIndex()==0:
                        test=1
                    if self.Data['rate']!="" and self.Window.BidSellUSD.currentIndex()==0:
                        exchangeratenotify=1
                        self.Data['StartingBid']=str(dropzeros(abs((Decimal(str(self.Window.BidSellBox.text()))/Decimal(rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                    if self.Window.BidSellUSD.currentIndex()==1:
                        self.Data['StartingBid']=str(dropzeros(abs((Decimal(str(self.Window.BidSellBox.text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                    self.Data['StartingBid']=abs(int(Decimal(self.Data['StartingBid'])*Decimal(1e8)))
                    self.Data['duration']=Decimal(str(self.Window.DurationSellBox.text())).quantize(Decimal('.01'))
                    if self.Data['duration']<=Decimal(0):
                        QuestionBox("Not a valid duration."," OK ")
                    if self.Window.DurationSellDays.currentIndex()==0:
                        self.Data['duration']*=Decimal(24)
                    self.Data['duration']=str(self.Data['duration'])
                if test==1 and self.Data['rate']=="":
                    QuestionBox("Exchange rate not loaded. Please choose to pay in coins instead of dollars and calculate the coin amount manually.", "OK")
                    return False
                try:
                    ship=Decimal(self.Data['shipping'])
                except:
                    ship=Decimal(0)
                if self.Window.BuyoutSellUSD.currentIndex()==0:
                    exchangeratenotify=1
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.BuyoutSellBox.text()))/Decimal(rate))+ship).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                else:
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.BuyoutSellBox.text())))+ship).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                if 'StartingBid' in self.Data:
                    if Decimal(self.Data['StartingBid'])/Decimal(1e8)>=Decimal(self.Data['amount']):
                        QuestionBox("The starting bid must be lower than the buyout price for an auction.", " OK ")
                        return
                if self.Window.DepositSettings5.currentIndex()==0:
                    self.Data['mydeposit']=self.Data['amount']
                    self.Data['theirdeposit']=self.Data['amount']
                if self.Window.DepositSettings5.currentIndex()==1:
                    customdeposit=1
                if self.Window.DepositSettings5.currentIndex()==2:
                    self.Data['mydeposit']="0"
                    self.Data['theirdeposit']=self.Data['amount']
                    guarantornotice=1
                self.Data['timelimit']="1080"
                try:
                    self.Data['totalusd']=str((Decimal(self.Data['amount'])*Decimal(rate)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                except:
                    self.Data['totalusd']="(not available)"                
                if self.Window.SellSelect.currentIndex()==1:
                    self.Window.AllowCounters.hide()#Auctions are bids.
                    self.Window.AutoAcceptValid.hide()#Auto Accept Auctions!? Would we do this on timeout?
                    self.Window.AllowCounters.setCheckState(2)
                else:
                    self.Window.AutoAcceptValid.show()
                    self.Window.AllowCounters.show()
                self.Window.AllowChat.setCheckState(2)
                self.Window.AllowPriceTracking.show()
                self.Window.AllowPriceTracking.setCheckState(2)
            if pos-1==5:
                customdeposit=0
                usd,btc=self.RateCheck()
                if usd==False:
                    return
                rate=usd
                self.Data['Template']="Buy Something"
                self.Data['rate']=str(rate)
                self.Data['description'] = strOUT(strIN(self.Window.DescriptionBuyBox.toPlainText()))
                if self.Window.BuySelect.currentIndex()==0:
                    pass
                test=0
                self.Data['shipping']="Seller Estimates Shipping"
                if self.Window.LocalPickupBuy.isChecked():
                    self.Data['shipping']="No Shipping / Local Delivery"
                self.Window.MailingSelectConfirm.show()
                self.Window.AddressEdit.show()
                self.Window.MailingConfirm.show()                              
                if AdvanceArray[multisig]['Profiles']['Mail']==[]:
                    QuestionBox("Please supply some mailing information so that the seller can know where to send the product.", " OK ")
                    self.Window.Pages.setCurrentIndex(7)                                    
                    response=Templates.Window.exec_()
                    if response==0:
                        return
                self.Data['Profiles']['Mail'].append(AdvanceArray[multisig]['Profiles']['Mail'][0]['string'])
                if self.Window.ShipCountryBuy.currentIndex()==1:
                    self.Data['countries']=strOUT(strIN(self.Window.ShipToBuyBox.text()))
                if self.Window.BuySelect.currentIndex()==0 and self.Window.BuyoutBuyUSD.currentIndex()==0:
                    test=1
                if self.Window.BuySelect.currentIndex()==1: 
                    if self.Window.BuyoutBuyUSD.currentIndex()==0 or self.Window.BidBuyUSD.currentIndex()==0:
                        test=1
                    if self.Data['rate']!="" and self.Window.BidBuyUSD.currentIndex()==0:
                        exchangeratenotify=1
                        self.Data['StartingBid']=str(dropzeros(abs((Decimal(str(self.Window.BidBuyBox.text()))/Decimal(rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                    if self.Window.BidBuyUSD.currentIndex()==1:
                        self.Data['StartingBid']=str(dropzeros(abs((Decimal(str(self.Window.BidBuyBox.text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                    self.Data['StartingBid']=abs(int(Decimal(self.Data['StartingBid'])*Decimal(1e8)))
                    self.Data['duration']=Decimal(str(self.Window.DurationBuyBox.text())).quantize(Decimal('.01'))
                    if self.Data['duration']<=Decimal(0):
                        QuestionBox("Not a valid duration."," OK ")
                    if self.Window.DurationBuyDays.currentIndex()==0:
                        self.Data['duration']*=Decimal(24)
                    self.Data['duration']=str(self.Data['duration'])
                if test==1 and self.Data['rate']=="":
                    QuestionBox("Exchange rate not loaded. Please choose to pay in coins instead of dollars and calculate the coin amount manually.", "OK")
                    return False
                ship=Decimal(0)
                if self.Window.BuyoutBuyUSD.currentIndex()==0:
                    exchangeratenotify=1
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.BuyoutBuyBox.text()))/Decimal(rate))+ship).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                else:
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.BuyoutBuyBox.text())))+ship).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                if 'StartingBid' in self.Data:
                    if Decimal(self.Data['StartingBid'])/Decimal(1e8)<=Decimal(self.Data['amount']):
                        QuestionBox("The starting bid must be greater than the buyout price for a reverse auction.", " OK ")
                        return                
                if self.Window.DepositSettings6.currentIndex()==0:
                    self.Data['mydeposit']=self.Data['amount']
                    self.Data['theirdeposit']=self.Data['amount']
                if self.Window.DepositSettings6.currentIndex()==1:
                    customdeposit=1
                if self.Window.DepositSettings6.currentIndex()==2:
                    self.Data['mydeposit']=self.Data['amount']
                    self.Data['theirdeposit']="0"
                    guarantornotice=1
                self.Data['timelimit']="1080"
                try:
                    self.Data['totalusd']=str((Decimal(self.Data['amount'])*Decimal(rate)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                except:
                    self.Data['totalusd']="(not available)"
                #Buyer should allow bids, they may not know the item or shipping until offer
                self.Window.AllowCounters.hide()
                self.Window.AutoAcceptValid.hide()
                self.Window.AllowCounters.setCheckState(2)
                self.Window.AllowChat.setCheckState(2)

                self.Window.AllowPriceTracking.show()
                self.Window.AllowPriceTracking.setCheckState(2)            
            if pos-1==2:
                customdeposit=0
                usd,btc=self.RateCheck()
                if usd==False:
                    return
                rate=usd
                self.Data['Template']="Hire Someone"
                self.Data['rate']=str(rate)
                self.Data['title'] = strOUT(strIN(self.Window.JobTitleBox1.text()))
                self.Data['description'] = strOUT(strIN(self.Window.DescriptionBox2.toPlainText()))
                if self.Window.JobSelect1.currentIndex()==0:
                    self.Data['Job Length']="One Time Job"
                if self.Window.JobSelect1.currentIndex()==1:
                    self.Data['Job Length']="Part Time Job"
                if self.Window.JobSelect1.currentIndex()==2:
                    self.Data['Job Length']="Full Time Job"
                if self.Window.RateSelect1.currentIndex()==0:
                    self.Data['Pay Frequency']="Flat Rate"
                    self.Data['timelimit']="1080"
                if self.Window.RateSelect1.currentIndex()==1:
                    self.Data['Pay Frequency']="Per Milestone"
                    self.Data['timelimit']="1080"
                if self.Window.RateSelect1.currentIndex()==2:
                    self.Data['Pay Frequency']="Per Week"
                    self.Data['timelimit']="720"
                if self.Window.RateSelect1.currentIndex()==3:
                    self.Data['Pay Frequency']="Per Month"
                    self.Data['timelimit']="1440"
                self.Data['autopay']=0
                if self.Window.EnableAutoPayCheck.isChecked():
                    if self.Data['Job Length']=="One Time":
                        QuestionBox("The program does not allow automated payment on one time jobs.", " OK ")
                        return
                    if self.Data['Pay Frequency']=="Per Milestone" or self.Data['Pay Frequency']=="Flat Rate":
                        QuestionBox("The program does not allow automated payment with jobs that are flat rate or that pay by the milestone.", " OK ")
                        return
                    if 'autopaynotify' not in AdvanceArray:
                        res=QuestionBox("Please be advised that automated payments require your account to be unlocked and for funds to be available. If you are tracking the price to dollars, the amount you pay in coins can change as the price tracks. Both parties will want to review those rates independently. You can always decide to disable automated payments in escrow if you change your mind. It is highly recommended that automated payments are made in combination with requiring reports. This way the other party will not get paid without sending the report.", " OK ", " Do not show this message again. ")
                        if res==1:
                            AdvanceArray['autopaynotify']=1
                    self.Data['autopay']=1
                self.Data['requirereport']=0
                if self.Window.RequireReportCheck.isChecked():
                    if self.Data['Pay Frequency']=="Flat Rate":
                        QuestionBox("The program does not allow requiring reports on flat rate contracts.", " OK ")
                        return
                    self.Data['requirereport']=1
                self.Data['interview']=0
                if self.Window.RequestInterviewCheck.isChecked():
                    if 'interviewnotify' not in AdvanceArray:
                        res=QuestionBox("Remember that when requesting an interview, it's best to have a way for them to contact you in advance. Consider giving them a way to do video interviews or phone calls and perhaps even use a scheduler.", " OK ", " Do not show this message again. ")
                        if res==1:
                            AdvanceArray['interviewnotify']=1                    
                    self.Data['interview']=1
                self.Data['resume']="0"
                if self.Window.RequireResumeCheck.isChecked():
                    self.Data['resume']="1"
                
                if self.Window.JobUSD.currentIndex()==0:
                    exchangeratenotify=1
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.JobAmount1.text()))/Decimal(rate))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                else:
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.JobAmount1.text())))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                
                if self.Window.DepositSettings3.currentIndex()==0:
                    self.Data['mydeposit']=self.Data['amount']
                    self.Data['theirdeposit']=self.Data['amount']
                if self.Window.DepositSettings3.currentIndex()==1:
                    customdeposit=1
                if self.Window.DepositSettings3.currentIndex()==2:
                    self.Data['mydeposit']=self.Data['amount']
                    self.Data['theirdeposit']="0"
                    guarantornotice=1
                try:
                    self.Data['totalusd']=str((Decimal(self.Data['amount'])*Decimal(rate)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                except:
                    self.Data['totalusd']="(not available)"
                #Autoaccept is not needed for this template
                self.Window.AutoAcceptValid.hide()
                self.Window.AllowCounters.setCheckState(2)
                self.Window.AllowChat.setCheckState(2)

                self.Window.AllowPriceTracking.show()
                self.Window.AllowPriceTracking.setCheckState(2)
            if pos-1==3:
                customdeposit=0
                usd,btc=self.RateCheck()
                if usd==False:
                    return
                rate=usd
                self.Data['Template']="Find Job"
                self.Data['rate']=str(rate)
                self.Data['title'] = strOUT(strIN(self.Window.JobTitleBox2.text()))
                self.Data['description'] = strOUT(strIN(self.Window.DescriptionBox2_2.toPlainText()))
                self.Data['Job Length']=""
                if self.Window.AcceptOneCheck.isChecked():
                    self.Data['Job Length']="One Time Job"
                if self.Window.AcceptTempCheck.isChecked():
                    if self.Data['Job Length']!="":
                        self.Data['Job Length']+=", "
                    self.Data['Job Length']+="Part Time Jobs"
                if self.Window.AcceptFullCheck.isChecked():
                    if self.Data['Job Length']!="":
                        self.Data['Job Length']+=", "                    
                    self.Data['Job Length']+="Full Time Jobs"
                if self.Data['Job Length']=="":
                    QuestionBox("Please choose what type of jobs you are willing to accept before proceeding.", " OK ")
                    return
                if self.Window.FindRate.currentIndex()==0:
                    self.Data['Pay Frequency']="Flat Rate"
                    self.Data['timelimit']="1080"
                if self.Window.FindRate.currentIndex()==1:
                    self.Data['Pay Frequency']="Per Milestone"
                    self.Data['timelimit']="1080"
                if self.Window.FindRate.currentIndex()==2:
                    self.Data['Pay Frequency']="Per Week"
                    self.Data['timelimit']="720"
                if self.Window.FindRate.currentIndex()==3:
                    self.Data['Pay Frequency']="Per Month"
                    self.Data['timelimit']="1440"
                self.Data['autopay']=0
                self.Data['requirereport']=0
                self.Data['interview']=0
                if self.Window.AcceptInterviewCheck.isChecked():
                    if 'interviewnotify' not in AdvanceArray:
                        res=QuestionBox("Remember that when requesting an interview, it's best to have a way for them to contact you in advance. Consider giving them a way to do video interviews or phone calls and perhaps even use a scheduler.", " OK ", " Do not show this message again. ")
                        if res==1:
                            AdvanceArray['interviewnotify']=1                    
                    self.Data['interview']=1
                self.Data['resume']=strOUT(strIN(self.Window.LinkResumeBox.text()))
                if self.Data['resume']=="":
                    self.Data['resume']="0"
                
                if self.Window.FindUSD.currentIndex()==0:
                    exchangeratenotify=1
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.FindAmount.text()))/Decimal(rate))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                else:
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.FindAmount.text())))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                
                if self.Window.DepositSettings4.currentIndex()==0:
                    self.Data['mydeposit']=self.Data['amount']
                    self.Data['theirdeposit']=self.Data['amount']
                if self.Window.DepositSettings4.currentIndex()==1:
                    customdeposit=1
                if self.Window.DepositSettings4.currentIndex()==2:
                    self.Data['theirdeposit']=self.Data['amount']
                    self.Data['mydeposit']="0"
                    guarantornotice=1
                try:
                    self.Data['totalusd']=str((Decimal(self.Data['amount'])*Decimal(rate)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                except:
                    self.Data['totalusd']="(not available)"
                #Autoaccept is not needed for this template
                self.Window.AutoAcceptValid.hide()
                self.Window.AllowCounters.setCheckState(2)
                self.Window.AllowChat.setCheckState(2)

                self.Window.AllowPriceTracking.show()
                self.Window.AllowPriceTracking.setCheckState(2)
            if pos-1==7:
                customdeposit=0
                usd,btc=self.RateCheck()
                if usd==False:
                    return
                rate=usd
                self.Data['Template']="Python"
                self.Data['rate']=str(rate)
                path = strOUT(strIN(self.Window.CodeOfferFormBox.text()))
                if path=="":
                    return
                try:
                    with open(path,'r') as f:
                        text=f.readlines()
                        f.close()
                except:
                    QuestionBox("Error loading Python file", " OK ")
                text2=''
                for t in text:
                    text2+=t
                self.Data['code1'] = text2
                path = strOUT(strIN(self.Window.CodeDuringEscrow.text()))
                if path=="":
                    return
                try:
                    with open(path,'r') as f:
                        text=f.readlines()
                        f.close()
                except:
                    QuestionBox("Error loading Python file", " OK ")
                text2=''
                for t in text:
                    text2+=t
                self.Data['code2'] = text2
                path = strOUT(strIN(self.Window.CodeEscrowWindow.text()))
                if path=="":
                    return
                try:
                    with open(path,'r') as f:
                        text=f.readlines()
                        f.close()
                except:
                    QuestionBox("Error loading Python file", " OK ")
                text2=''
                for t in text:
                    text2+=t
                self.Data['code3'] = text2
                self.Data['description'] = strOUT(strIN(self.Window.DescriptionPythonBox.toPlainText()))
                self.Data['timelimit']="720"                
                if self.Window.PythonUSD.currentIndex()==0:
                    exchangeratenotify=1
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.PythonAmountBox.text()))/Decimal(rate))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                else:
                    self.Data['amount']=str(dropzeros(abs(((Decimal(str(self.Window.PythonAmountBox.text())))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))))
                
                if self.Window.DepositSettings9.currentIndex()==0:
                    self.Data['mydeposit']=self.Data['amount']
                    self.Data['theirdeposit']=self.Data['amount']
                if self.Window.DepositSettings9.currentIndex()==1:
                    customdeposit=1
                if self.Window.DepositSettings9.currentIndex()==2:
                    self.Data['theirdeposit']="0"
                    self.Data['mydeposit']=self.Data['amount']
                    guarantornotice=1
                if self.Window.DepositSettings9.currentIndex()==3:
                    self.Data['theirdeposit']=self.Data['amount']
                    self.Data['mydeposit']="0"
                    guarantornotice=1
                try:
                    self.Data['totalusd']=str((Decimal(self.Data['amount'])*Decimal(rate)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                except:
                    self.Data['totalusd']="(not available)"
                #Autoaccept is not needed for this template
                self.Window.AutoAcceptValid.hide()
                self.Window.AllowCounters.setCheckState(2)
                self.Window.AllowChat.setCheckState(2)
                if 'pythontip' not in AdvanceArray:
                    res=QuestionBox("Please be aware of the risks of Python contracts. It is your responsibility to audit the code of each of these custom contracts especially ones that are not in the list of known contracts. However even known contracts should be audited by the users as there could be a variety of content creators and this code is open source and always subject to change.", " I understand ", " Do not show this message again. ")
                    if res==1:
                        AdvanceArray['pythontip']=1
                QuestionBox("You will now be asked to sign all of the requested code so that your computer is authorized to run it.", " OK ")
                SignCode([self.Data['code1'],self.Data['code2'],self.Data['code3']])
                self.Window.AllowPriceTracking.show()
                self.Window.AllowPriceTracking.setCheckState(2)
            if pos-1==6:
                customdeposit=0
                usd,btc=self.RateCheck()
                if usd==False:
                    return
                rate=usd
                self.Data['Template']="Barter"
                self.Data['rate']=str(rate)
                if self.barteritems['supply']=={}:
                    QuestionBox('You have not listed anything to barter', ' OK ')
                    return
                self.Data['dontclear']=1
                totalmerch=0
                totaldemand=0
                highest=0
                besttitle=''
                for item in self.barteritems['supply']:
                    myitem=self.barteritems['supply'][item]
                    if self.barteritems['supply'][item]['EstValueUSD']==0:
                        self.barteritems['supply'][item]['ActualValue']=int((Decimal(self.barteritems['supply'][item]['EstValueBox'])/Decimal(self.Data['rate']))*Decimal(1e8))
                    else:
                        self.barteritems['supply'][item]['ActualValue']=int((Decimal(self.barteritems['supply'][item]['EstValueBox'])*Decimal(1e8)))
                    highvalue=self.barteritems['supply'][item]['ActualValue']
                    highvalue=self.TestHighValue(highvalue, myitem)
                    if highvalue==False:
                        return
                    if highvalue>highest:
                        highest=highvalue
                        besttitle=item
                    totalmerch+=self.barteritems['supply'][item]['ActualValue']
                for item in self.barteritems['demand']:
                    myitem=self.barteritems['demand'][item]
                    if self.barteritems['demand'][item]['EstValueUSD']==0:
                        self.barteritems['demand'][item]['ActualValue']=int((Decimal(self.barteritems['demand'][item]['EstValueBox'])/Decimal(self.Data['rate']))*Decimal(1e8))
                    else:
                        self.barteritems['demand'][item]['ActualValue']=int((Decimal(self.barteritems['demand'][item]['EstValueBox'])*Decimal(1e8)))
                    highvalue=self.barteritems['demand'][item]['ActualValue']
                    highvalue=self.TestHighValue(highvalue, myitem)
                    if highvalue==False:
                        return
                    if highvalue>highest:
                        highest=highvalue
                        besttitle=item
                    totaldemand+=self.barteritems['demand'][item]['ActualValue']
                print str(highest), besttitle
                self.Data['barteritems']=self.barteritems
                self.Data['buymultiple']=0
                self.Data['offernotinlist']=0
                if self.Window.BuyMultiple.isChecked():
                    self.Data['buymultiple']=1
                if self.Window.OfferNotInList.isChecked():
                    self.Data['offernotinlist']=1
                else:
                    if self.barteritems['demand']=={}:
                        QuestionBox('If you do not have anything on your demand list then you should allow users to offer things that are not in your list', ' OK ')
                        return
                if self.Window.RequestAll.currentIndex()!=0:
                    self.Data['itemlimit']=int(self.Window.MaxItemsBox.text())
                self.Data['timelimit']="720"
                self.Data['amount']=str('0.0001')
                
                if self.Window.DepositSettings7.currentIndex()==0:
                    self.Data['mydeposit']=str((Decimal(highest*2)/Decimal(1e8)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))
                    self.Data['theirdeposit']=str((Decimal(highest*2)/Decimal(1e8)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))
                if self.Window.DepositSettings7.currentIndex()==1:
                    customdeposit=1
                try:
                    self.Data['totalusd']=str((Decimal(self.Data['amount'])*Decimal(rate)).quantize(Decimal('.01'), rounding=ROUND_HALF_UP))
                except:
                    self.Data['totalusd']="(not available)"
                #Autoaccept is not needed for this template
                self.Window.AutoAcceptValid.hide()
                self.Window.AllowCounters.setCheckState(2)
                self.Window.AllowCounters.hide()
                self.Window.AllowChat.setCheckState(2)
                self.Window.AllowPriceTracking.show()
                self.Window.AllowPriceTracking.setCheckState(2)
            print "POS " + str(pos-1)
            if exchangeratenotify==1:
                QuestionBox(Gtranslate("Please confirm the exchange rate online:\n")+"USD:"+self.rate+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this."), Gtranslate("OK"),1)
            if guarantornotice==1:
                if 'tip4' not in AdvanceArray:
                    res=QuestionBox("Guarantor contracts give new buyers and sellers a chance to enter the market and for example, buy their first coins and can be useful for bulk buyers, seller and merchants. This gives anyone the ability to trust you but puts your funds at risk if they are untrustworthy. You can also request a guarantor if you are new to the markets. However, please know the risks here. It is recommended you know your customer and develop methods to screen them so you know they are trustworthy. Auto-accepting is definitely not recommended in these contracts. If you understand the risks/benefits to these contracts please continue. Otherwise you should choose the recommended deposit settings.", " Thanks! ", " Do not show this message again. ")
                    if res==1:
                        AdvanceArray['tip4']=1
            if customdeposit==1:
                mpos=orgpos
                if mpos=="1":
                    mpos=""
                exec("if self.Window.MyDepositUSD"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".currentIndex()==0:self.Data['mydeposit']=str((Decimal(str(self.Window.MyDepositBox"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".text()))/Decimal(rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))\n")
                exec("if self.Window.MyDepositUSD"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".currentIndex()==1:self.Data['mydeposit']=str((Decimal(str(self.Window.MyDepositBox"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))\n")
                exec("if self.Window.TheirDepositUSD"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".currentIndex()==0:self.Data['theirdeposit']=str((Decimal(str(self.Window.TheirDepositBox"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".text()))/Decimal(rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))\n")
                exec("if self.Window.TheirDepositUSD"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".currentIndex()==1:self.Data['theirdeposit']=str((Decimal(str(self.Window.TheirDepositBox"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP))\n")
                exec("if self.Window.TimeLimitDays"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".currentIndex()==0:self.Data['timelimit']=str(int(Decimal(str(self.Window.TimeLimitBox"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".text()))*Decimal(24)))\n")
                exec("if self.Window.TimeLimitDays"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".currentIndex()==1:self.Data['timelimit']=str(int(Decimal(str(self.Window.TimeLimitBox"+re.sub(r"[^A-Za-z0-9_]+", '',str(mpos))+".text()))))\n")
                self.Data['mydeposit']=str(dropzeros(self.Data['mydeposit'],1))
                self.Data['theirdeposit']=str(dropzeros(self.Data['theirdeposit'],1))
                if Decimal(self.Data['mydeposit'])<Decimal(0.00005500) or Decimal(self.Data['theirdeposit'])<Decimal(0.00005500):
                    QuestionBox("The minimum deposit for custom deposits is 5500 satoshis", "OK")
                    return
                if int(self.Data['timelimit'])<62:
                    res=QuestionBox("The time limit was set to less than 3 days. Its recommended you leave a reasonable amount of time to complete the contract to prevent loss. Are you sure you want to do this?", "Yes", "No")
                    if res==1:
                        return
            if 'code1' in self.Data and "Python" in self.Data['Template']:
                firstform=0
                try:
                    exec(validateCode(self.Data['code1']))
                except:
                    QuestionBox("Code execution failed", " OK ")
                    traceback.print_exc()
                    return
            if self.additional==1:
                self.Window.ContactSelectConfirm.show()
                self.Window.ContactEdit.show()
                self.Window.ContactConfirm.show()
                if AdvanceArray[multisig]['Profiles']['Contact']==[]:
                    self.Window.Pages.setCurrentIndex(8)
                    response=Templates.Window.exec_()
                    if response==0:
                        return
                self.Data['Profiles']['Contact'].append(AdvanceArray[multisig]['Profiles']['Contact'][0]['string'])
            self.Window.SentToSelect.clear()
            mps=0
            for market in Markets['MyMarkets']:
                self.Window.SentToSelect.addItem(market)
                self.Window.SentToSelect.setItemData(mps,QtCore.QVariant(mps))
                mps+=1
            if Markets['Current']=="ALL":
                mark=CoinSelect['default market']
            else:
                mark=Markets['Current']
            self.Window.SentToSelect.addItem("Private Email/BitMessage/Coin Address...")
            self.Window.SentToSelect.setItemData(mps,QtCore.QVariant(9999999))
            index = self.Window.SentToSelect.findText(mark, QtCore.Qt.MatchFixedString)
            self.Window.SentToSelect.setCurrentIndex(index)
            self.Window.ContractSummary.setText("Contract:  " + self.Data['Template'])
            self.Window.AmountSummary.setText("Amount:  " + self.Data['amount'] + "  ($" + self.Data['totalusd'] + ")")
            self.Window.MyDepositSummary.setText("My Deposit:  " + self.Data['mydeposit'])
            self.Window.TheirDepositSummary.setText("Their Deposit:  " + self.Data['theirdeposit'])
            self.Window.TimeLimitSummary.setText("Time Limit:  " + str(Decimal(self.Data['timelimit'])/Decimal(24)) + "  Days")
            #After you are done processing... DOES THIS INTERFERE WITH CONFIRM TO DEFAULTS?
            self.LoadProfiles()
            self.ClearMyForm(orgpos,1)
            self.Window.Pages.setCurrentIndex(18)
    def Confirm(self):
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        self.Data['autoaccept']=0
        self.Data['allowcounters']=0
        self.Data['allowchat']=0
        self.Data['Private']=0
        text=str(self.Window.SentToSelect.currentText())
        setting=self.Window.SentToSelect.itemData(self.Window.SentToSelect.currentIndex()).toInt()[0]
        if setting==9999999:#"Private Email/BitMessage/Coin Address...":
            text=str(self.Window.SendToAddress.text())
            self.Data['Private']=1
            if 'dontclear' in self.Data:
                self.Data.pop('dontclear')
        else:
            text=Markets['MyMarkets'][text]
        window.ContractTo.setText("Market Order: "+text)
        window.ContractAmount.setText(self.Data['amount'])
        window.InstantAmount.setText("")
        window.YouDeposit.setText(self.Data['mydeposit'])
        window.TheyDeposit.setText(self.Data['theirdeposit'])
        window.ContractTime.setText(self.Data['timelimit'])
        if 'description' not in self.Data:
            window.DescriptionBox.setText(self.Data['notes'])
        else:
            window.DescriptionBox.setText(self.Data['description'])
            self.Data['description']=""
        window.ImageBox.setText("")
        if GlobalID!="":
            window.ImageBox.setText("Image Attached")
        if self.Window.AllowPriceTracking.isChecked():
            self.Data['tracking']=1        
        window.InstantWhoPays.setCurrentIndex(0)
        window.DaysMultiplier.setCurrentIndex(1)

        if self.Window.AllowChat.isChecked():
            self.Data['allowchat']=1
        if self.Window.AutoAcceptValid.isChecked():
            self.Data['autoaccept']=1
        if self.Window.AllowCounters.isChecked():
            self.Data['allowcounters']=1

        if self.Data['Template']=="Sell Coins":
            window.WhoPays.setCurrentIndex(0)
            self.Data['allowcounters']=0
        if self.Data['Template']=="Buy Coins":
            window.WhoPays.setCurrentIndex(1)
            self.Data['allowcounters']=0
        if self.Data['Template']=="Sell Something":
            if 'quantity' in self.Data:
                if self.Data['quantity']>1:
                    if self.Data['allowcounters']==0:
                        self.Data['allowcounters']=1
                        self.Data['keepratio']=1#They might want more than one item
            window.WhoPays.setCurrentIndex(1)
        if self.Data['Template']=="Buy Something":
            window.WhoPays.setCurrentIndex(0)
        if self.Data['Template']=="Hire Someone":
            window.WhoPays.setCurrentIndex(0)
        if self.Data['Template']=="Find Job":
            window.WhoPays.setCurrentIndex(1)
        if "Python" in self.Data['Template']:
            if self.Window.PythonWhoPays.currentIndex()==0:
                window.WhoPays.setCurrentIndex(0)
            else:
                window.WhoPays.setCurrentIndex(1)
        if self.Data['Template']=="Barter":
            window.WhoPays.setCurrentIndex(0)
        if self.Data['tracking']!=0:
            self.Data['allowcounters']=1
            if "Something" in self.Data['Template'] or "Hire" in self.Data['Template'] or "Find" in self.Data['Template'] or "Python" in self.Data['Template'] or "Barter" in self.Data['Template']:
                if self.Window.AllowCounters.isChecked():
                    pass
                else:
                    self.Data['tracking']=2#Counters must maintain the same ratio                
                self.Data['maxincrease']="1.0000000011"
                self.Data['maxdecrease']="0.000000001"
                self.Data['maxorder']="1"
                self.Data['minorder']="1" 

        if len(self.Data['Profiles']['Contact'])>0:
            self.Data['Profiles']['Contact']=[AdvanceArray[multisig]['Profiles']['Contact'][0]['string']]
        if self.Data['Template']=="Sell Coins":
            if len(self.Data['Profiles']['Bank'])>0:
                self.Data['Profiles']['Bank']=[AdvanceArray[multisig]['Profiles']['Bank'][0]['string']]
            if len(self.Data['Profiles']['WU'])>0:
                self.Data['Profiles']['WU']=[AdvanceArray[multisig]['Profiles']['WU'][0]['string']]
            if len(self.Data['Profiles']['MG'])>0:
                self.Data['Profiles']['MG']=[AdvanceArray[multisig]['Profiles']['MG'][0]['string']]
            if len(self.Data['Profiles']['Card'])>0:
                self.Data['Profiles']['Card']=[AdvanceArray[multisig]['Profiles']['Card'][0]['string']]
            if len(self.Data['Profiles']['Other'])>0:
                self.Data['Profiles']['Other']=[AdvanceArray[multisig]['Profiles']['Other'][0]['string']]
            if len(self.Data['Profiles']['Cash'])>0:
                self.Data['Profiles']['Cash']=[AdvanceArray[multisig]['Profiles']['Cash'][0]['string']]
        self.Window.hide()
        window.Tabs.setCurrentIndex(5)
        window.SendMyContract()
        window.ClearPage()
    def StandardDepositChange(self,pos):
        exec("self.index=self.Window.DepositSettings"+re.sub(r"[^A-Za-z0-9_]+", '',pos)+".currentIndex()\n")
        for obj in self.dropdowns:
            if self.index!=1:
                exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+pos)+".hide()\n")
            else:
                exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+pos)+".show()\n")
        for obj in self.boxes:
            if self.index!=1:
                exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+pos)+".hide()\n")
            else:
                exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj+pos)+".show()\n")
        if self.index!=1:
            exec("self.Window."+"MyDepositText"+re.sub(r"[^A-Za-z0-9_]+", '',pos)+".hide()\n")
            exec("self.Window."+"TheirDepositText"+re.sub(r"[^A-Za-z0-9_]+", '',pos)+".hide()\n")
            exec("self.Window."+"TimeLimitText"+re.sub(r"[^A-Za-z0-9_]+", '',pos)+".hide()\n")
        else:
            exec("self.Window."+"MyDepositText"+re.sub(r"[^A-Za-z0-9_]+", '',pos)+".show()\n")
            exec("self.Window."+"TheirDepositText"+re.sub(r"[^A-Za-z0-9_]+", '',pos)+".show()\n")
            exec("self.Window."+"TimeLimitText"+re.sub(r"[^A-Za-z0-9_]+", '',pos)+".show()\n")
    def DaysChange(self, obj):
        pass
    def DepositChange(self, obj):
        exec("index=self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".currentIndex()\n")
        if "Their" in obj:
            obj=obj.replace("Their","My")
        else:
            obj=obj.replace("My","Their")
        exec("self.Window."+re.sub(r"[^A-Za-z0-9_]+", '',obj)+".setCurrentIndex(index)\n")
    def Delete(self):
        #Ok they want to clear it... lets find the order in spendable and remove it
        res=QuestionBox("Are you sure you want to delete this offer?", "Yes", "No")
        if res==1:
            return
        global updatesomething, OnOrders
        BitAddr=GetfromCfg("#BitMessage#")
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        DeleteOrder(self.order['ordernumber'])
        leng=len(MyContracts)
        i=0
        while i<leng:
            next1=1
            if MyContracts[i]['Process']=="Market Order":
                if MyContracts[i]['ordernumber']==self.order['ordernumber']:
                    DeleteOrder(MyContracts[i]['ordernumber'])
                    if 'dontclear' in MyContracts[i]['Market Data']:
                        MyContracts[i]['Market Data'].pop('dontclear')
                    RemoveFromMarket(MyContracts[i])
                    next1=0
            if MyContracts[i]['Process']=="Market Offer" or "MCount" in MyContracts[i]['Process']:
                if MyContracts[i]['oldordernumber']==self.order['ordernumber']:
                    DeleteOrder(MyContracts[i]['ordernumber'])
                    next1=0
            if next1==0:
                leng-=1
                DeleteContract(i)
            else:
                i+=1
        i=0
        for ord1 in Markets['Orders']:
            if ord1['ordernumber']==self.order['ordernumber'] and 'Private' in self.order['Market Data'] and self.order['Market Data']['Private']==2:
                Markets['Orders'].pop(i)
                break
            i+=1
        DeleteContract(self.order)
        updatesomething=1
        self.Window.hide()
    def MakeOrder(self, counter, usd=""):
        global AdvanceArray
        global PendingSelected
        global timestamp
        #mode 0 is when you first see the offer, 1 is frozen for sending, 2 is where you can accept but its final and 3 is sent for counters(the offeree), mode 4 is escrow
        if self.mode==4:
            if "Coins" in self.order['Market Data']['Template'] or "Custom" in self.order['Market Data']['Template'] or "Python" in self.order['Market Data']['Template'] or "Barter" in self.order['Market Data']['Template']:
                WinContracts.showme(1)
            return
        if self.mode==1 or self.mode==3:
            PendingSelected=json_deep_copy(self.order,1)
            WindowSent.SendAgain()
            self.Window.hide()
            PendingSelected={}
            return
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if self.order['theiraddress']==multisig:
            QuestionBox("You can not accept your own order", "OK")
            return
        if self.order['Market Data']['style']!="Double Deposit" and self.order['Market Data']['style']!="Barter":
            if 'tip5' not in AdvanceArray:
                res=QuestionBox("This order has a custom deposit. Please make sure you are familiar with how the deposits work before proceeding. You are solely responsible for your own contracts. Make sure you understand the theory behind Halo and read over the entire contract before proceeding."," Thanks ", " Do not show this message again. ")
                if res==1:
                    AdvanceArray['tip5']=1
        if "Something" in self.order['Market Data']['Template']:
            if "Sell" in self.order['Market Data']['Template']:
                if "I pay" not in self.order["whopays"]:
                    if 'higherquantity' in self.order['Market Data']:
                        if 'tiphq' not in AdvanceArray:
                            res=QuestionBox("A higher quantity was requested. Please ensure that deposits are high enough to cover large shippments or that you have a secure deliver method in place."," Thanks ", " Do not show this message again. ")
                            if res==1:
                                AdvanceArray['tiphq']=1
            try:
                timeremaining = (Decimal(self.order['timestamp']) + Decimal(self.order['Market Data']['duration'])*60*60) - Decimal(timestamp)
                if timeremaining>Decimal(0):
                    timeremaining = Decimal(int(Decimal((timeremaining/60)/60)*Decimal(100)))/Decimal(100)
                else:
                    timeremaining=Decimal(0)
            except:
                timeremaining=Decimal(0)
        accept=0
        timeout=self.order['timeout']
        message=strOUT(strIN(self.Window.TextBox1.toPlainText()))
        self.reply['message']=message
        if 'dontclear' in self.order['Market Data']:#We must bid here to avoid double spending
            if "Something" not in self.order['Market Data']['Template']:
                self.readonly=0
        if self.mode==2:
            if 'selected' in self.order['Market Data']['reply'] and self.order['Market Data']['Template']=="Sell Coins":#The original offer was accepted(we were the offeror)
                self.reply['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
                try:
                    fnd=0
                    for c in MyContracts:
                        if 'oldordernumber' in self.order:
                            if c['ordernumber']==self.order['oldordernumber']:
                                fnd=1
                                break
                    if fnd==1:
                        self.reply['Profiles'][self.order['Market Data']['reply']['selected']].append(c['Market Data']['Profiles'][self.order['Market Data']['reply']['selected']][0])
                except:
                    traceback.print_exc()
            self.Accept()
            return
        if message!="":
            if self.Window.SupplyAdditional10.checkState()!=2:
                if 'tip2' not in AdvanceArray:
                    res=QuestionBox("If you send them a personal message with your order, we recommend you include additional contact information.", " Ok, thanks ", " Don't show this message again ")
                    if res==1:
                        AdvanceArray['tip2']=1
                    else:
                        return
        if self.Window.SupplyAdditional10.isChecked():
            if AdvanceArray[multisig]['Profiles']['Contact']==[]:
                Templates.Window.Pages.setCurrentIndex(8)
                Templates.LoadProfiles()
                Templates.dontremoveonupdate=0
                Templates.returntoconfirm=0
                response=Templates.Window.exec_()
                Templates.Window.hide()
                if response==0:
                    QuestionBox("You requested to supply additional information. In order to continue you must set up a profile.", "OK")
                    return                
                self.reply['Profiles']['Contact'].append(AdvanceArray[multisig]['Profiles']['Contact'][0]['string'])
            else:
                inx=self.Window.SelectContact.currentIndex()
                self.reply['Profiles']['Contact'].append(AdvanceArray[multisig]['Profiles']['Contact'][inx]['string'])
        if self.rate=="" or self.rate==" ":
            if self.order['Market Data']['tracking']!=0:
                QuestionBox("The exchange rate has not loaded and they have enabled price tracking, please wait for the rate to load.", "OK")
                return        
        if "Coins" in self.order['Market Data']['Template']:#mode 0
            if self.Window.Drop3.currentIndex()==0:
                QuestionBox("Please select your preferred form of payment", "OK")
                return
            else:
                text=str(self.Window.Drop3.currentText())
                if text=="Payment: Bank Wire":
                    self.reply['selected']='Bank'
                    indx=1
                if text=="Payment: Western Union":
                    self.reply['selected']='WU'
                    indx=2
                if text=="Payment: MoneyGram":
                    self.reply['selected']='MG'
                    indx=3
                if text=="Payment: Prepaid Card":
                    self.reply['selected']='Card'
                    indx=4
                if text=="Payment: Other":
                    self.reply['selected']='Other'
                    indx=5
                if text=="Payment: Cash In The Mail":
                    self.reply['selected']='Cash'
                    indx=6
            if self.rate != "" and self.rate != " ":
                if self.order['Market Data']['tracking']==1:
                    self.reply['rate']=self.rate
            else:
                self.reply['rate']=self.order['Market Data']['rate']
            if self.order['Market Data']['Template']=="Buy Coins":
                if self.Window.Drop2.currentIndex()==1:
                    self.readonly=0
                    try:
                        self.reply['service']=str(abs(1+(Decimal(str(self.Window.Box2.text()))/Decimal(100))))
                        if Decimal(self.reply['service'])>Decimal(self.order['Market Data']['service']):
                            QuestionBox("The service charge must be less than or equal to the original offer.","OK")
                            return
                    except:
                        traceback.print_exc()
                        QuestionBox("The service charge must be a valid number","OK")
                        return
                Templates.Window.Pages.setCurrentIndex(indx)
                Templates.LoadProfiles()
                Templates.dontremoveonupdate=0
                Templates.returntoconfirm=1
                response=Templates.Window.exec_()
                Templates.returntoconfirm=0
                Templates.Window.hide()                
                if response==0 or AdvanceArray[multisig]['Profiles'][self.reply['selected']]==[]:
                    QuestionBox("In order to continue you must set up a profile.", "OK")
                    return
                self.reply['Profiles'][self.reply['selected']].append(AdvanceArray[multisig]['Profiles'][self.reply['selected']][0]['string'])
            if self.readonly==1:
                amount=int(Decimal(self.order['amount']))
                mydeposit=int(Decimal(self.order['mydeposit']))
                theirdeposit=int(Decimal(self.order['theirdeposit']))
                accept=1
            else:
                if self.Window.USD1.currentIndex()==0:
                    if self.rate != "" and self.rate != " ":
                        val=Decimal(str(self.Window.Box1.text()))
                        if val!=(Decimal(self.order['amount'])/Decimal(1e8)*self.Dif*Decimal(self.order['Market Data']['rate'])).quantize(Decimal('.01')):
                            amount=int((val*Decimal(1e8))/(self.Dif*Decimal(self.order['Market Data']['rate'])))
                        else:
                            amount=self.order['amount']
                            #self.readonly=1
                            #accept=1
                        #Buying
                        #if Decimal(str(self.Window.Box1.text()))!=(Decimal(self.order['amount'])/Decimal(1e8)/self.Dif*Decimal(self.rate)).quantize(Decimal('.01')):
                        #    amount=int(Decimal(str(self.Window.Box1.text()))/Decimal(self.rate)*Decimal(1e8))
                        #else:
                        #    #Nothing changed, the dollar box rounded up
                        #    self.readonly=1
                        #    amount=int((Decimal(self.order['amount'])/Decimal(1e8)/self.Dif)*Decimal(1e8))
                    else:
                        QuestionBox("Please set your amount in Coins or wait for exchange rate to load", "OK")
                        return
                else:
                    amount=int(Decimal(str(self.Window.Box1.text()))*Decimal(1e8))
                if self.readonly==1:
                    pass#Tracking usd is below but divide perhaps instead
                    #amount=int((Decimal(self.order['amount'])/Decimal(1e8)*self.Dif)*Decimal(1e8))
                    #mydeposit=int(Decimal(str(self.Window.MyDepositBox10.text()))*Decimal(1e8))
                    #theirdeposit=int(Decimal(str(self.Window.TheirDepositBox10.text()))*Decimal(1e8))
                else:
                    if 'minorder' in self.order['Market Data']:
                        min1=Decimal(self.order['Market Data']['minorder'])
                        if amount < int(Decimal(self.order['amount'])*min1):
                            QuestionBox("Your order is below the minimum order. Please enter a higher amount", "OK")
                            return
                    if amount > self.order['amount']:#int(Decimal(self.order['amount'])*self.Dif):
                        QuestionBox("Your order is above the maximum order. Please enter a lower amount", "OK")
                        return
                    proportion=Decimal(amount)/Decimal(self.order['amount'])
                    if self.order['Market Data']['style']=="Double Deposit":
                        mydeposit=int(Decimal(amount)*Decimal(self.order['Market Data']['service']))
                        theirdeposit=int(Decimal(amount)*Decimal(self.order['Market Data']['service']))
                    else:
                        mydeposit=int(Decimal(self.order['mydeposit'])*proportion)
                        theirdeposit=int(Decimal(self.order['theirdeposit'])*proportion)
        ratechange=0
        exchangeratenotify=0
        notifymultiplier=0
        if self.order['Market Data']['Template']=="Custom" or self.order['Market Data']['Template']=="Python" or self.order['Market Data']['Template']=="Barter":
            if self.order['Market Data']['Template']=="Python":
                acceptform=1
                try:
                    exec(validateCode(self.order['Market Data']['code1']))
                except:
                    QuestionBox("Code execution failed", " OK ")
                    traceback.print_exc()
                    return
            if "Barter" in self.order['Market Data']['Template']:
                if counter==1:
                    self.reply['barteritems']=self.order['Market Data']['barteritems']
                amount=int(Decimal(self.order['amount']))
                mydeposit=int(Decimal(self.order['mydeposit']))
                theirdeposit=int(Decimal(self.order['theirdeposit']))
            else:
                amount=int(Decimal(self.order['amount'])*Decimal(self.Dif))
                mydeposit=int(Decimal(self.order['mydeposit'])*Decimal(self.Dif))
                theirdeposit=int(Decimal(self.order['theirdeposit'])*Decimal(self.Dif))
            if self.order['Market Data']['tracking']!=0:
                self.reply['rate']=self.rate            
            if counter==1:                
                accept=0
            else:
                accept=1
                if self.Dif != 1:
                    ratechange=1
                    accept=0
        if "Something" in self.order['Market Data']['Template']:
            shipping=0
            amount=int(Decimal(self.order['amount'])*Decimal(self.Dif))
            mydeposit=int(Decimal(self.order['mydeposit'])*Decimal(self.Dif))
            theirdeposit=int(Decimal(self.order['theirdeposit'])*Decimal(self.Dif))
            orgamount=amount
            if "Sell" in self.order['Market Data']['Template']:
                if "I pay" in self.order["whopays"]:
                    if 'StartingBid' in self.order['Market Data']:#Auction
                        if self.Window.Drop1.currentIndex()==0:
                            if 'auctiontip' not in AdvanceArray and timeremaining!=Decimal(0):
                                res=QuestionBox("Would you like to accept the buyout price on this auction or would you prefer to bid on this auction? When you choose to bid, the form will automatically display an amount 10 percent above the highest current bid. However, you are free to counter-offer any amount you like as long as it is above the starting bid.", " Accept Buyout Price ", " Let me bid on this ", " Do not show this message again. ")
                                if res==1:
                                    self.Window.Drop1.setCurrentIndex(1)
                                    return
                                if res==2:
                                    AdvanceArray['auctiontip']=1
                        else:
                            if timeremaining==Decimal(0):
                                QuestionBox("The time for bidding has expired on this auction. You can still offer the buyout price.", " OK ")
                                self.Window.Drop1.setCurrentIndex(0)
                                return
                    Templates.Window.Pages.setCurrentIndex(7)
                    Templates.LoadProfiles()
                    Templates.dontremoveonupdate=0
                    Templates.returntoconfirm=1
                    response=Templates.Window.exec_()
                    Templates.returntoconfirm=0
                    Templates.Window.hide()
                    Templates.LoadProfiles()                    
                    if response==0:
                        QuestionBox("You need to supply the seller with shipping information to continue.", "OK")
                        return
                    self.reply['Profiles']['Mail'].append(AdvanceArray[multisig]['Profiles']['Mail'][0]['string']) 
                    self.reply['mymailing']=AdvanceArray[multisig]['Profiles']['Mail'][0]['string']
            if "Buy" in self.order['Market Data']['Template']:
                if "I pay" not in self.order["whopays"]:
                    if 'StartingBid' in self.order['Market Data']:#Auction
                        if self.Window.Drop1.currentIndex()==0:
                            if 'auctiontip2' not in AdvanceArray and timeremaining!=Decimal(0):
                                res=QuestionBox("Would you like to accept the buyout price on this reverse auction or would you prefer to bid on this reverse auction? When you choose to bid, the form will automatically display an amount 10 percent below the lowest current bid. However, you are free to counter-offer any amount you like as long as it is below the starting bid.", " Accept Buyout Price ", " Let me bid on this ", " Do not show this message again. ")
                                if res==1:
                                    self.Window.Drop1.setCurrentIndex(1)
                                    return
                                if res==2:
                                    AdvanceArray['auctiontip2']=1
                        else:
                            if timeremaining==Decimal(0):
                                QuestionBox("The time for bidding has expired on this auction. You can still offer the buyout price.", " OK ")
                                self.Window.Drop1.setCurrentIndex(0)
                                return
            if self.readonly==0:#They decided to counter in the boxes
                accept=0
                if str(self.Window.Box1.text())!="":
                    setting=self.Window.Drop1.itemData(self.Window.Drop1.currentIndex()).toInt()[0]
                    if setting==998:#They want to order a higher quantity
                        try:                            
                            multiplier=abs(int(self.Window.Box1.text()))
                            if multiplier>1:
                                notifymultiplier=1
                                amount*=multiplier
                                #We also multiply deposits even though multiple shippments may be needed
                                mydeposit*=multiplier
                                theirdeposit*=multiplier
                                self.reply['higherquantity']=multiplier
                        except:
                            QuestionBox("Invalid quantity, must be an integer!", "OK")
                            return                            
                    if setting==999:                        
                        try:
                            if self.Window.USD1.currentIndex()==0:
                                if self.rate=="" or self.rate==" ":
                                    QuestionBox("The exchange rate has not loaded. Please enter your amount in coins instead of dollars or wait for the rate to load.", "OK")
                                    return
                                exchangeratenotify=1
                                amount=dropzeros(abs((Decimal(str(self.Window.Box1.text()))/Decimal(self.rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)))
                                amount=int(amount*1e8)
                            else:
                                amount=dropzeros(abs((Decimal(str(self.Window.Box1.text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)))
                                amount=int(amount*1e8)                           
                        except:
                            QuestionBox("Invalid amount!", "OK")
                            return
                        if self.Window.DepositSettings10.itemData(self.Window.DepositSettings10.currentIndex()).toInt()[0]==0:
                            if amount != orgamount:
                                if 'proportiontip' not in AdvanceArray:
                                    res3=QuestionBox("Since you have made a counter-offer, the deposits will be automatically adjusted to maintain their proportion to the amount.", " OK ", " Do not show this message again. ")
                                    if res3==1:
                                        AdvanceArray['proportiontip']=1
                                ratio=Decimal(amount)/Decimal(orgamount)
                                mydeposit=int(Decimal(mydeposit)*Decimal(ratio))
                                theirdeposit=int(Decimal(theirdeposit)*Decimal(ratio))
                setting=self.Window.DepositSettings10.itemData(self.Window.DepositSettings10.currentIndex()).toInt()[0]
                if setting==999:
                    notifymultiplier=0
                    thesame=0
                    if str(self.Window.MyDepositBox10.text())==self.orgmydeposit and str(self.Window.TheirDepositBox10.text())==self.orgtheirdeposit and str(self.Window.TimeLimitBox10.text())==self.orghours and self.Window.MyDepositUSD10.currentIndex()==1 and self.Window.TheirDepositUSD10.currentIndex()==1 and self.Window.TimeLimitDays10.currentIndex()==1:
                        thesame=1
                    if thesame==0:
                        try:
                            if self.Window.MyDepositUSD10.currentIndex()==0:
                                if self.rate=="" or self.rate==" ":
                                    QuestionBox("The exchange rate has not loaded. Please enter your amount in coins instead of dollars or wait for the rate to load.", "OK")
                                    return
                                exchangeratenotify=1
                                mydeposit=dropzeros(abs((Decimal(str(self.Window.MyDepositBox10.text()))/Decimal(self.rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)))
                                mydeposit=int(mydeposit*1e8)
                            else:
                                mydeposit=dropzeros(abs((Decimal(str(self.Window.MyDepositBox10.text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)))
                                mydeposit=int(mydeposit*1e8)                            
                        except:
                            QuestionBox("Invalid deposit amount!", "OK")
                            return
                        try:
                            if self.Window.TheirDepositUSD10.currentIndex()==0:
                                if self.rate=="" or self.rate==" ":
                                    QuestionBox("The exchange rate has not loaded. Please enter your amount in coins instead of dollars or wait for the rate to load.", "OK")
                                    return
                                exchangeratenotify=1
                                theirdeposit=dropzeros(abs((Decimal(str(self.Window.TheirDepositBox10.text()))/Decimal(self.rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)))
                                theirdeposit=int(theirdeposit*1e8)
                            else:
                                theirdeposit=dropzeros(abs((Decimal(str(self.Window.TheirDepositBox10.text()))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)))
                                theirdeposit=int(theirdeposit*1e8)                            
                        except:
                            QuestionBox("Invalid deposit amount!", "OK")
                            return
                        try:
                            if self.Window.TimeLimitDays10.currentIndex()==0:
                                timeout=int(Decimal(str(self.Window.TimeLimitBox10.text()))*Decimal(24))
                            else:
                                timeout=int(Decimal(str(self.Window.TimeLimitBox10.text())))
                        except:
                            QuestionBox("Invalid time limit!", "OK")
                            return
            if "I pay" in self.order["whopays"]:
                if self.order['Market Data']['shipping']=="Buyer Can Calculate Shipping":
                    accept=0
                    res=QuestionBox("The seller has requested you calculate shipping.", " Use the Fedex shipping calculator ", " Let me estimate/offer the rate manually ")
                    location=""                    
                    try:
                        if self.order['Market Data']['Profiles']['Mail'] != []:
                            location=self.order['Market Data']['Profiles']['Mail'][0]
                            if 'weight' in self.order['Market Data']:
                                location+="\n\nPackage Weight: \n"+self.order['Market Data']['weight']
                    except:
                        traceback.print_exc()                    
                    shipping=shippingcalculator(location,res)                    
                    if shipping == "":
                        return
                    shipping=int(Decimal(shipping)*Decimal(1e8))
                    amount+=shipping
                if self.order['Market Data']['shipping']=="Buyer Pays During Escrow":
                    if "buyescrowtip" not in AdvanceArray:
                        res=QuestionBox("The seller has chosen to bill for shipping in escrow. Please realize that after they receive your mailing address, they will negotiate shipping with you. Before proceeding make sure the sellers deposit is sufficient to cover any potential payments and that you understand the process.", " Okay I understand. ", " Do not show this message again. ")
                        if res==1:
                            AdvanceArray['buyescrowtip']=1
            else:
                if "Buy" in self.order['Market Data']['Template']:
                    if self.order['Market Data']['shipping']=="Seller Estimates Shipping":
                        accept=0
                        res=QuestionBox("Please choose a shipping option.", " Use the Fedex shipping calculator ", " Let me estimate/offer the rate manually ", " Free shipping ")
                        if res != 2:
                            location=""
                            try:
                                if self.order['Market Data']['Profiles']['Mail'] != []:
                                    location=self.order['Market Data']['Profiles']['Mail'][0]
                                    if 'weight' in self.order['Market Data']:
                                        location+="\n\nPackage Weight: \n"+self.order['Market Data']['weight']
                            except:
                                traceback.print_exc()
                            shipping=shippingcalculator(location,res)
                            if shipping == "":
                                return
                            shipping=int(Decimal(shipping)*Decimal(1e8))
                            amount+=shipping
            if self.order['Market Data']['tracking']!=0:
                self.reply['rate']=self.rate            
            if counter==1:                
                accept=0
            else:
                accept=1
                if self.Dif != 1:
                    ratechange=1
                    accept=0
            if 'StartingBid' in self.order['Market Data']:
                bestbid=self.order['Market Data']['StartingBid']
                if 'BestBid' in self.order['Market Data']:
                    bestbid=self.order['Market Data']['BestBid']                    
            if "Sell" in self.order['Market Data']['Template']:
                if "I pay" in self.order["whopays"]:
                    if 'StartingBid' in self.order['Market Data']:
                        if amount<bestbid:
                            QuestionBox('The amount offered including shipping is less than the best bid in this auction. In order to proceed with a bid, you must make a better offer.', ' OK ')                            
                            return
            if "Buy" in self.order['Market Data']['Template']:
                if "I pay" not in self.order["whopays"]:
                    if 'StartingBid' in self.order['Market Data']:
                        if amount>bestbid:
                            QuestionBox('The amount offered including shipping exceeds the best bid in this reverse auction. In order to proceed with a bid, you must make a better offer.', ' OK ')
                            return
        if exchangeratenotify==1:
            QuestionBox(Gtranslate("Please confirm the exchange rate online:\n")+"USD:"+self.rate+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this."), Gtranslate("OK"),1)
        if notifymultiplier==1:
            if 'increasenotify' not in AdvanceArray:
                res=QuestionBox("Since you have requested a higher quantity and a custom deposit was not set, the deposits have also been increased to protect the deal.", " OK ", " Don't show this message again ")
                if res==1:
                    AdvanceArray['increasenotify']=1
        if "Hire" in self.order['Market Data']['Template'] or "Find" in self.order['Market Data']['Template']:
            amount=int(Decimal(self.order['amount'])*Decimal(self.Dif))
            mydeposit=int(Decimal(self.order['mydeposit'])*Decimal(self.Dif))
            theirdeposit=int(Decimal(self.order['theirdeposit'])*Decimal(self.Dif))
            if self.order['Market Data']['tracking']!=0:
                self.reply['rate']=self.rate
            self.reply['resume']=strOUT(strIN(self.Window.Box4.text()))
            if self.Window.CheckBox1.isChecked():
                self.reply['requirereport']=1
            else:
                self.reply['requirereport']=0
            if self.reply['requirereport']==1:
                if 'reportnotify' not in AdvanceArray:
                    res=QuestionBox("Please understand, for this job the employee will not be able to receive payments through escrow without submitting reports for each milestone/week/month/completion. This is good because it makes it easy for the employer to track progress and helps with automated payments.", " OK ", " Don't show this message again ")
                    if res==1:
                        AdvanceArray['reportnotify']=1
            if counter==1:
                accept=0
            else:
                accept=1
                if self.Dif != 1 or self.reply['requirereport']!=self.order['Market Data']['requirereport']:
                    ratechange=1
                    accept=0
        if accept==1 and 'pegging' in CoinSelect and CoinSelect['pegging'] and self.order['Market Data']['Template']!="Custom":
            #Because liquidity is constantly changing the peg always bids instead of direct accept
            ratechange=1
            accept=0
        if accept==1:
            window.Tabs.setCurrentIndex(5)
            window.ClearPage()
            window.ContractTo.setText("Accept Market: "+self.order['ordernumber'])
            self.Window.hide()
            window.SendMyContract()
            window.ClearPage()
            self.order={}
            self.reply={}
        if accept==0:#Counter/Bid
            global GlobalImage, GlobalID
            window.Tabs.setCurrentIndex(5)
            window.ContractTo.setText("Counter Market: "+self.order['ordernumber'])
            window.ContractAmount.setText(str(amount/Decimal(1e8)))
            window.InstantAmount.setText(str(Decimal(self.order['instantamount'])/Decimal(1e8)))
            window.YouDeposit.setText(str(mydeposit/Decimal(1e8)))
            window.TheyDeposit.setText(str(theirdeposit/Decimal(1e8)))
            window.ContractTime.setText(str(timeout))
            window.ContractFee.setText(str(Decimal(self.order['fee'])/Decimal(1e8)))
            window.DescriptionBox.setText(self.order['Details']['description'])
            if self.order['Details']['image']!="":
                window.ImageBox.setText(str("Image Attached"))
            GlobalImage=self.order['Details']['image']
            GlobalID=self.order['Details']['pastebin']
            if "I pay this" in self.order['whopays']:
                window.WhoPays.setCurrentIndex(0)
            else:
                window.WhoPays.setCurrentIndex(1)
            if "I am" in self.order['instantwhopays']:
                window.InstantWhoPays.setCurrentIndex(0)
            else:
                window.InstantWhoPays.setCurrentIndex(1)
            window.DaysMultiplier.setCurrentIndex(1)
            #change to hours
            self.Window.hide()
            if self.order['Market Data']['Template']=="Custom" or self.order['Market Data']['Template']=="Python" or "Hire" in self.order['Market Data']['Template'] or "Find" in self.order['Market Data']['Template'] or self.order['Market Data']['Template']=="Barter":
                if ratechange==0:
                    return
            if "Something" in self.order['Market Data']['Template']:
                if 'StartingBid' in self.order['Market Data'] and "Sell" in self.order['Market Data']['Template']:
                    pass
                else:
                    if counter==1 or self.readonly==0 or ratechange==0:#They may want to edit the description
                        return
            window.SendMyContract()
            window.ClearPage()
            self.order={}
            self.reply={}
    def Accept(self):
        global MyContracts, OnOrders
        if self.order['Process']=="Market Order" or "MCount" in self.order['Process']:
            window.Tabs.setCurrentIndex(5)
            window.ClearPage()
            window.ContractTo.setText("Accept Market: "+self.order['ordernumber'])
            self.Window.hide()
            window.SendMyContract()
            window.ClearPage()
            self.order={}
            self.reply={}
            return
        if self.order['Process']=="Market Offer":
            res=AcceptOffer(self.order, 1)
            if res==False:
                QuestionBox("There was an issue creating the accepted order", "OK")
                self.reply={}
                self.order={}
                return
            UpdateQuantity(self.order)
            for c in MyContracts:
                if 'oldordernumber' in self.order:
                    if c['ordernumber']==self.order['oldordernumber']:
                        break
            if 'dontclear' not in c['Market Data']:
                leng=len(MyContracts)
                i=0
                while i<leng:
                    next1=1
                    if MyContracts[i]['Process']=="Market Order":
                        if MyContracts[i]['ordernumber']==self.order['oldordernumber']:
                            l=0
                            for o in OnOrders:
                                if 'ordernumber' in o:
                                    if o['ordernumber']==MyContracts[i]['ordernumber']:
                                        OnOrders[l]['ordernumber']=self.order['ordernumber']
                                        break
                                l+=1
                            RemoveFromMarket(MyContracts[i],self.order['ordernumber'])
                            next1=0
                    if MyContracts[i]['Process']=="Market Offer" or "MCount" in MyContracts[i]['Process']:
                        if MyContracts[i]['oldordernumber']==self.order['oldordernumber'] and MyContracts[i]['ordernumber']!=self.order['ordernumber']:
                            DeleteOrder(MyContracts[i]['ordernumber'])
                            next1=0
                    if next1==0:
                        leng-=1
                        DeleteContract(i)
                    else:
                        i+=1
            i=0
            for o in OnOrders:
                if 'ordernumber' in o:
                    if o['ordernumber']==self.order['ordernumber']:
                        if 'oldtotal' in OnOrders[i]:
                            OnOrders[i]['total']=OnOrders[i]['oldtotal']
                            OnOrders[i]['mychangetotal']=OnOrders[i]['oldmychangetotal']
                i+=1
            self.reply={}
            self.order={}
            self.Window.hide()
    def ChangeOrderIndex(self, index):
        self.Window.Drop1.blockSignals(True)
        self.Window.Drop2.blockSignals(True)
        self.Window.Drop3.blockSignals(True)
        self.Window.Drop4.blockSignals(True)
        self.Window.DepositSettings10.blockSignals(True)
        self.Window.MyDepositUSD10.blockSignals(True)
        self.Window.TheirDepositUSD10.blockSignals(True)
        self.Window.USD1.blockSignals(True)
        self.Window.USD2.blockSignals(True)
        self.Window.USD3.blockSignals(True)
        self.Window.TimeLimitDays10.blockSignals(True)
        self.Window.SelectContact.blockSignals(True)
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if index==9:            
            setting=self.Window.SelectContact.itemData(self.Window.SelectContact.currentIndex()).toInt()[0]
            if setting==9999999:#"Add/Edit profiles..."
                Templates.Window.Pages.setCurrentIndex(8)
                Templates.LoadProfiles()
                Templates.dontremoveonupdate=0
                Templates.returntoconfirm=1
                response=Templates.Window.exec_()
                Templates.returntoconfirm=0
                Templates.Window.Pages.setCurrentIndex(19)
                Templates.LoadProfiles()
                ps=0
                self.Window.SelectContact.clear()
                for i in AdvanceArray[multisig]['Profiles']['Contact']:
                    self.Window.SelectContact.addItem(i['string'].replace("\n", "  "))
                    self.Window.SelectContact.setItemData(ps,QtCore.QVariant(ps))
                    ps+=1
                if ps>0:
                    self.Window.SelectContact.addItem("Add/Edit profiles...")
                    self.Window.SelectContact.setItemData(ps,QtCore.QVariant(9999999))
                    self.Window.SelectContact.setCurrentIndex(0)
        #if index==1 or index==2 or index==5:
        #    self.readonly=0
        if self.Window.Drop1.currentIndex()==0:
            if "Coins" in self.order['Market Data']['Template'] or "Something" in self.order['Market Data']['Template'] or "Hire" in self.order['Market Data']['Template'] or "Find" in self.order['Market Data']['Template']:
                self.readonly=1
                self.Window.Box1.hide()
                self.Window.USD1.hide()
        else:
            if "Coins" in self.order['Market Data']['Template'] or "Something" in self.order['Market Data']['Template']:
                self.readonly=0
                self.Window.Box1.show()
                self.Window.USD1.show()
                if "Something" in self.order['Market Data']['Template'] and 'StartingBid' in self.order['Market Data']:
                    try:
                        if 'BestBid' in self.order['Market Data']:
                            startbid=self.order['Market Data']['BestBid']
                        else:
                            startbid=self.order['Market Data']['StartingBid']                        
                        if self.Window.USD1.currentIndex()==0:
                            if self.rate!="" and self.rate!=" ":
                                if "Sell" in self.order['Market Data']['Template']:
                                    self.Window.Box1.setText(str((Decimal(startbid)/Decimal(1e8)*Decimal(1.1)*Decimal(self.rate)).quantize(Decimal('.01'))))
                                if "Buy" in self.order['Market Data']['Template']:
                                    self.Window.Box1.setText(str((Decimal(startbid)/Decimal(1e8)*Decimal(.9)*Decimal(self.rate)).quantize(Decimal('.01'))))                                    
                        else:
                            if "Sell" in self.order['Market Data']['Template']:
                                self.Window.Box1.setText(str((Decimal(startbid)/Decimal(1e8)*Decimal(1.1)).quantize(Decimal('.00000001'))))
                            if "Buy" in self.order['Market Data']['Template']:
                                self.Window.Box1.setText(str((Decimal(startbid)/Decimal(1e8)*Decimal(.9)).quantize(Decimal('.00000001'))))
                    except:
                        traceback.print_exc()
        setting=self.Window.Drop1.itemData(self.Window.Drop1.currentIndex()).toInt()[0]
        if setting==999 or setting==998:
            if "Coins" not in self.order['Market Data']['Template']:
                self.readonly=0
                self.Window.Box1.show()
                if setting==999:
                    self.Window.USD1.show()
                if setting==998:
                    self.Window.Box1.clear()
                    self.Window.USD1.hide()
        setting=self.Window.DepositSettings10.itemData(self.Window.DepositSettings10.currentIndex()).toInt()[0]
        if setting==999:
            if "Coins" not in self.order['Market Data']['Template']:
                self.readonly=0
        else:
            self.Window.MyDepositBox10.setText(self.orgmydeposit)
            self.Window.TheirDepositBox10.setText(self.orgtheirdeposit)
            self.Window.TimeLimitBox10.setText(self.orghours)
            self.Window.MyDepositUSD10.setCurrentIndex(1)
            self.Window.TheirDepositUSD10.setCurrentIndex(1)
            self.Window.TimeLimitDays10.setCurrentIndex(1)            
        if self.Window.Drop2.currentIndex()==0:
            self.Window.Box2.hide()
            self.Window.USD2.hide()
        else:
            if self.order['Market Data']['Template']!="Custom" and self.order['Market Data']['Template']!="Python" and self.order['Market Data']['Template']!="Barter" and "Coins" not in self.order['Market Data']['Template'] and "Something" not in self.order['Market Data']['Template'] and "Hire" not in self.order['Market Data']['Template'] and "Find" not in self.order['Market Data']['Template']:
                self.Window.Box2.show()
                self.Window.USD2.show()
            if "Buy Coins" in self.order['Market Data']['Template']:
                self.Window.Box2.show()
        if self.Window.Drop3.currentIndex()==0:
            self.Window.Box3.hide()
            self.Window.USD3.hide()
        else:
            if "Coins" not in self.order['Market Data']['Template'] and self.order['Market Data']['Template']!="Custom" and self.order['Market Data']['Template']!="Python" and self.order['Market Data']['Template']!="Barter" and "Something" not in self.order['Market Data']['Template'] and "Hire" not in self.order['Market Data']['Template'] and "Find" not in self.order['Market Data']['Template']:
                self.Window.Box3.show()
                self.Window.USD3.show()
        if self.Window.DepositSettings10.currentIndex()==0 and "Custom Deposit" not in self.order['Market Data']['style']:
            self.Window.MyDepositText10.hide()
            self.Window.TheirDepositText10.hide()
            self.Window.TimeLimitText10.hide()
            self.Window.MyDepositBox10.hide()
            self.Window.TheirDepositBox10.hide()
            self.Window.TimeLimitBox10.hide()
            self.Window.MyDepositUSD10.hide()
            self.Window.TheirDepositUSD10.hide()
            self.Window.TimeLimitDays10.hide()
        else:
            self.Window.MyDepositText10.show()
            self.Window.TheirDepositText10.show()
            self.Window.TimeLimitText10.show()
            self.Window.MyDepositBox10.show()
            self.Window.TheirDepositBox10.show()
            self.Window.TimeLimitBox10.show()
            self.Window.MyDepositUSD10.show()
            self.Window.TheirDepositUSD10.show()
            self.Window.TimeLimitDays10.show()
        if self.readonly==1 or "Coins" in self.order['Market Data']['Template'] or self.order['Market Data']['Template']=="Custom" or self.order['Market Data']['Template']=="Python" or self.order['Market Data']['Template']=="Barter":#Read only
            self.Window.MyDepositUSD10.setCurrentIndex(1)
            self.Window.TheirDepositUSD10.setCurrentIndex(1)
            self.Window.TimeLimitDays10.setCurrentIndex(1)
            self.Window.MyDepositBox10.setReadOnly(True)
            self.Window.TheirDepositBox10.setReadOnly(True)
            self.Window.TimeLimitBox10.setReadOnly(True)
        else:
            self.Window.MyDepositBox10.setReadOnly(False)
            self.Window.TheirDepositBox10.setReadOnly(False)
            self.Window.TimeLimitBox10.setReadOnly(False)
            setting=self.Window.DepositSettings10.itemData(self.Window.DepositSettings10.currentIndex()).toInt()[0]
            if "Something" in self.order['Market Data']['Template']:
                if setting != 999:#They must request to edit the deposits
                    self.Window.MyDepositBox10.setReadOnly(True)
                    self.Window.TheirDepositBox10.setReadOnly(True)
                    self.Window.TimeLimitBox10.setReadOnly(True)                
        if self.order['Market Data']['Template']=="Custom" or self.order['Market Data']['Template']=="Python" or self.order['Market Data']['Template']=="Barter" or "Something" in self.order['Market Data']['Template'] or "Hire" in self.order['Market Data']['Template'] or "Find" in self.order['Market Data']['Template']:
            self.Window.Button1.show()
            self.Window.Button2.show()
            self.Window.Drop2.hide()
        if "Hire" in self.order['Market Data']['Template'] or "Find" in self.order['Market Data']['Template']:
            self.Window.Button1.hide()
            self.Window.Button2.hide()
            self.Window.Drop3.show()
            self.Window.Drop3.clear()
            jobtype=self.order['Market Data']['Job Length']
            if "One" in jobtype and "Part" in jobtype and "Full" in jobtype:
                jobtype="One/Part/Full Time Jobs"
            self.Window.Drop3.addItem(jobtype)            
            self.Window.Drop4.show()
            self.Window.Drop4.clear()
            self.Window.Drop4.addItem(self.order['Market Data']['Pay Frequency'])
            self.Window.Text1.hide()
            self.Window.Box4.hide()
            self.Window.Link1.hide()
            self.Window.Link2.hide()
            self.Window.CheckBox1.show()
            if 'Flat' in self.order['Market Data']['Pay Frequency']:
                self.Window.CheckBox1.hide()
            if self.order['Market Data']['allowcounters']==0 or self.order['Market Data']['tracking']==2:
                if self.order['Market Data']['requirereport']==0:
                    self.Window.CheckBox1.setCheckState(0)            
                if self.order['Market Data']['requirereport']==1:
                    self.Window.CheckBox1.setCheckState(2)
            if self.mode!=1:
                if self.order['Market Data']['resume']!="0":
                    if self.order['Market Data']['resume']!="1":
                        self.Window.Box4.setText(self.order['Market Data']['resume'])
                    self.Window.Text1.show()
                    self.Window.Box4.show()
                    self.Window.Link1.show()
                    self.Window.Link2.show()

        else:
            self.Window.Drop4.hide()
            self.Window.Text1.hide()
            self.Window.Box4.hide()
            self.Window.Link1.hide()
            self.Window.Link2.hide()
            self.Window.CheckBox1.hide()

        self.Window.Drop1.blockSignals(False)
        self.Window.Drop2.blockSignals(False)
        self.Window.Drop3.blockSignals(False)
        self.Window.Drop4.blockSignals(False)
        self.Window.DepositSettings10.blockSignals(False)
        self.Window.MyDepositUSD10.blockSignals(False)
        self.Window.TheirDepositUSD10.blockSignals(False)
        self.Window.TimeLimitDays10.blockSignals(False)
        self.Window.USD1.blockSignals(False)
        self.Window.USD2.blockSignals(False)
        self.Window.USD3.blockSignals(False)
        self.Window.SelectContact.blockSignals(False)
    def showorder(self, order, mode=0):
        global AdvanceArray, timestamp, globfont, MyContracts
        data=""#mode 0 is when you first see the offer, 1 is frozen for sending, 2 is where you can accept but its final and 3 is sent for counters(the offeree), mode 4 is escrow
        window.ClearPage()
        orgmode=mode
        if orgmode==4:
            mode=3
        if order['Process']=="MCount0" and mode != 3 or order['Process']=="Market Offer" and mode != 3:#You were the original offeree, is counter-offer allowed?
            if "Coins" in order['Market Data']['Template']:
                data+="Received a bid!<br />"
                if order['Market Data']['reply']['match']==1:
                    data+="This bid matches your original offer.<br />"
                else:
                    data+="Either we were not able to find their exchange rate based on the time stamp or the bid exceeds the original offer. The bid may also offer a better rate. Please carefully review this bid.<br />"
                data+="<br />"
                mode=2#Final offer
            if "Custom" in order['Market Data']['Template'] or "Python" in order['Market Data']['Template'] or "Barter" in order['Market Data']['Template'] or "Something" in order['Market Data']['Template'] or "Hire" in order['Market Data']['Template'] or "Find" in order['Market Data']['Template']:
                if order['Process']=="MCount0":
                    if order['Market Data']['tracking']!=0:#For now to avoid too many fluctuation battles just consider these final
                        data+="Received a bid!<br />"
                        if order['Market Data']['reply']['match']==1:
                            data+="This bid matches your original offer.<br />"
                        else:
                            data+="Please carefully review this bid. Make sure the price tracking, details and conditions matches your original offer.<br />"
                        data+="<br />"
                        mode=2
                    if 'higherquantity' in order['Market Data']:
                        data+="Higher quantity requested! Higher volume deals may have higher deposits or custom deposits to cover shipping risk. Please also make sure the price matches the number of items requested.<br />"
                        data+="Quantity requested: " + str(order['Market Data']['higherquantity']) + "<br /><br />"
                    if 'shipping' in order['Market Data']:
                        if order['Market Data']['shipping']=="Buyer Can Calculate Shipping":
                            if "I pay this" not in order['whopays']:
                                data+="Since you have asked the buyer to calculate shipping, you will want to verify the amount based on your original offer and your own shipping calculations based on the address given to you in this bid.<br /><br />"
                if order['Process']=="Market Offer":                    
                    mode=2
        if orgmode==4:
            mode=2
        if 'reply' in order['Market Data'] and mode != 3:
            if 'message' in order['Market Data']['reply']:
                if order['Market Data']['reply']['message']!="":
                    data+="Their Comments:<br />"
                    data+=order['Market Data']['reply']['message']+"<br /><br />"
        if orgmode==4:
            mode=3
        self.mode=mode
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        self.Window.Accept.setText("Accept")
        self.blockAllSignals(0)
        self.Window.SupplyAdditional10.setCheckState(2)
        self.readonly=1
        self.order=json_deep_copy(order,1)
        self.reply={}        
        self.Window.Pages.setCurrentIndex(19)
        if multisig not in AdvanceArray:
            AdvanceArray[multisig]={}
        Templates.LoadProfiles()
        ps=0
        self.Window.SelectContact.clear()
        for i in AdvanceArray[multisig]['Profiles']['Contact']:
            self.Window.SelectContact.addItem(i['string'].replace("\n", "  "))
            self.Window.SelectContact.setItemData(ps,QtCore.QVariant(ps))
            ps+=1
        if ps>0 and mode==0:
            self.Window.SelectContact.addItem("Add/Edit profiles...")
            self.Window.SelectContact.setItemData(ps,QtCore.QVariant(9999999))
        if order['Market Data']['allowcounters']==1 and order['Market Data']['Template']!="Sell Coins" and order['Market Data']['Template']!="Buy Coins":
            self.Window.Counter.show()
        else:            
            self.Window.Counter.hide()
        self.Window.Delete.hide()
        if 'Private' in order['Market Data'] and order['Market Data']['Private']==2:
            self.Window.Delete.show()
        self.Window.SelectContact.show()
        self.Window.SupplyAdditional10.show()
        self.Window.Text2.show()
        self.Window.TextBox1.show()

        self.Window.Drop1.clear()
        self.Window.Drop2.clear()
        self.Window.Drop3.clear()
        self.Window.Drop4.clear()
        self.Window.Display1.setHtml("")
        self.Window.Display1.show()
        self.Window.Display2.setHtml("")
        self.Window.Display2.show()
        self.Window.TextBox1.clear()
        self.Window.Button1.hide()
        self.Window.Button2.hide()
        self.Button2Text="Show User Profile"
        self.Window.Button2.setText(Gtranslate(self.Button2Text))
        self.Window.USD1.hide()
        self.Window.USD2.hide()
        self.Window.USD3.hide()
        self.Window.Box1.hide()
        self.Window.Box2.hide()
        self.Window.Box3.hide()
        self.Window.Link1.hide()
        self.Window.Link2.hide()
        self.Window.Attach.hide()
        self.Window.Box4.hide()
        self.Window.Box4.setText("")
        self.Window.Text1.hide()
        self.Window.Drop3.hide()
        self.Window.Drop4.hide()
        self.Window.DepositSettings10.clear()
        self.Window.MyDepositText10.hide()
        self.Window.TheirDepositText10.hide()
        self.Window.TimeLimitText10.hide()
        self.Window.MyDepositBox10.hide()
        self.Window.TheirDepositBox10.hide()
        self.Window.TimeLimitBox10.hide()
        self.Window.MyDepositUSD10.hide()
        self.Window.TheirDepositUSD10.hide()
        self.Window.TimeLimitDays10.hide()
        self.Window.USD1.setCurrentIndex(0)
        self.Window.MyDepositUSD10.setCurrentIndex(1)
        self.Window.TheirDepositUSD10.setCurrentIndex(1)
        self.Window.TimeLimitDays10.setCurrentIndex(1)
        self.Window.CheckBox1.hide()
        self.Window.SupplyAdditional10.setCheckState(2)
        self.Window.Drop2.show()
        self.ChangeOrderIndex(1000)
        f=0
        usd,btc=GetMarketValue(order['Market Data']['Payment Method'],CoinMarketCap, 0)
        self.rate=usd
        self.reply['timestamp']=UniversalTimeStamp
        self.reply['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
        t=ConvertDate(order['Market Data']['date'],1)
        t=t.strftime('%m/%d/%Y')
        data+="Contract Halo version " + str(order['version'])+"<br />"
        data+="Template: " + str(order['Market Data']['Template']) + "<br />"
        if "Coins" in order['Market Data']['Template'] and order['Process']=="Market Order":
            if 'quantity' in order['Market Data']:
                data+="Coins Remaining: " + str(Satoshis(order['Market Data']['quantity'])) + "<br />"
        else:
            if 'quantity' in order['Market Data']:
                data+="Quantity: " + str(order['Market Data']['quantity']) + "<br />"
        if order['Process']=="Market Order" and orgmode==1:
            data+="From: " + str(order['MyBMAddress']) + "<br />"
        else:
            data+="From: " + str(order['TheirBMAddress']) + "<br />"
        data+="Preferred contact method: "
        if "@" in order['Market Data']['Preferred']:
            data+="Email"
            if "BM-" not in order['Market Data']['Preferred']:
                data+="<br />"
            else:
                data+=", "
        if "BM-" in order['Market Data']['Preferred']:
            data+="Bitmessage" + "<br />"
        if "@" not in order['Market Data']['Preferred'] and "BM-" not in order['Market Data']['Preferred']:
            data+="Coin address  (Spam filter enabled)" + "<br />"

        conv=""
        conv2=""
        conv3=""
        conv4=""
        if 'StartingBid' in self.order['Market Data']:
            bestbid=self.order['Market Data']['StartingBid']
            if 'BestBid' in self.order['Market Data']:
                bestbid=self.order['Market Data']['BestBid']
        Dif=Decimal(1)
        nodif=0
        if mode>1:#Check the agreed rate if applicable
            if order['Market Data']['Template']=="Sell Coins" or order['Market Data']['Template']=="Buy Coins":
                if 'rate' in order['Market Data']['reply']:
                    usd=str(order['Market Data']['reply']['rate'])
                    self.rate=usd
                    nodif=1
                else:
                    usd=str(order['Market Data']['rate'])
                    self.rate=usd
            else:
                if 'rate' in order['Market Data']['reply']:
                    usd=str(order['Market Data']['reply']['rate'])
                    self.rate=usd
                    nodif=1
                else:
                    if 'rate' in order['Market Data']:
                        usd=str(order['Market Data']['rate'])
                        self.rate=usd                
        if usd!="" and usd!=" ":
            if order['Market Data']['Template']=="Sell Coins" or order['Market Data']['Template']=="Buy Coins":
                if order['Market Data']['tracking']==0:
                    rt=str(order['Market Data']['rate'])
                    data+="Price Per Coin: $" + rt + "<br />"
                    st=str(int(Decimal(order['amount'])/Decimal(1e8)*Decimal(rt)*Decimal(100)))
                    st=str(Decimal(st)/Decimal(100))
                    conv=", $"+st
                    st2=str(int(Decimal(order['mydeposit'])/Decimal(1e8)*Decimal(rt)*Decimal(100)))
                    st2=str(Decimal(st2)/Decimal(100))
                    conv2=", $"+st2
                    st3=str(int(Decimal(order['theirdeposit'])/Decimal(1e8)*Decimal(rt)*Decimal(100)))
                    st3=str(Decimal(st3)/Decimal(100))
                    conv3=", $"+st3
                else:
                    if nodif==0:
                        Dif=(Decimal(usd)/Decimal(order['Market Data']['rate'])).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)
                    if Dif>1:
                        if Dif>Decimal(order['Market Data']['maxincrease']) and order['Market Data']['maxincrease']!="1.0000000011":
                            Dif=Decimal(order['Market Data']['maxincrease'])
                    else:
                        if Dif<Decimal(order['Market Data']['maxdecrease']):
                            Dif=Decimal(order['Market Data']['maxdecrease'])
                    if order['Market Data']['maxincrease'] == "1.000000001":#They wanted a specific price with advanced options
                        Dif=Decimal(1)
                        self.rate=order['Market Data']['rate']
                    data+="Price Per Coin: $" + str((Decimal(order['Market Data']['rate'])*Decimal(Dif)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)) + "<br />"
                    if order['Market Data']['maxincrease'] != "1.000000001":
                        data+="Price Tracking Is Enabled: Price may fluctuate depending on market" + "<br />"
                    st=str(int(Decimal(order['amount'])/Decimal(1e8)*Decimal(order['Market Data']['rate'])*Decimal(Dif)*Decimal(100)))
                    st2=str(int(Decimal(order['mydeposit'])/Decimal(1e8)*Decimal(order['Market Data']['rate'])*Decimal(Dif)*Decimal(100)))
                    st3=str(int(Decimal(order['theirdeposit'])/Decimal(1e8)*Decimal(order['Market Data']['rate'])*Decimal(Dif)*Decimal(100)))
                    st=str(Decimal(st)/Decimal(100))
                    st2=str(Decimal(st2)/Decimal(100))
                    st3=str(Decimal(st3)/Decimal(100))
                    conv=", $"+st
                    conv2=", $"+st2
                    conv3=", $"+st3
            if order['Market Data']['Template']=="Custom" or order['Market Data']['Template']=="Python" or order['Market Data']['Template']=="Barter" or "Something" in order['Market Data']['Template'] or "Hire" in order['Market Data']['Template'] or "Find" in order['Market Data']['Template']:
                if order['Market Data']['tracking']!=0:
                    data+="Price Tracking Is Enabled: Amount of coins may fluctuate depending on market" + "<br />"
                    if nodif==0:
                        Dif=(Decimal(order['Market Data']['rate'])/Decimal(self.rate)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP)
                st=str(int(Decimal(order['amount'])/Decimal(1e8)*Decimal(self.rate)*Decimal(Dif)*Decimal(100)))
                if 'Barter' in order['Market Data']['Template']:
                    st=str(int(Decimal(order['amount'])/Decimal(1e8)*Decimal(self.rate)*Decimal(1)*Decimal(100)))
                st2=str(int(Decimal(order['mydeposit'])/Decimal(1e8)*Decimal(self.rate)*Decimal(Dif)*Decimal(100)))
                st3=str(int(Decimal(order['theirdeposit'])/Decimal(1e8)*Decimal(self.rate)*Decimal(Dif)*Decimal(100)))
                st=str(Decimal(st)/Decimal(100))
                st2=str(Decimal(st2)/Decimal(100))
                st3=str(Decimal(st3)/Decimal(100))
                conv=", $"+st
                conv2=", $"+st2
                conv3=", $"+st3
                BestDif=Dif
                if mode == 0 and 'BestBid' in self.order['Market Data']:
                    BestDif=1
                if 'StartingBid' in self.order['Market Data']:
                    st4=str(int(Decimal(bestbid)/Decimal(1e8)*Decimal(self.rate)*Decimal(BestDif)*Decimal(100)))
                    st4=str(Decimal(st4)/Decimal(100))
                    conv4=", $"+st4
        else:
            if 'rate' in order['Market Data']:
                st=str(int(Decimal(order['amount'])/Decimal(1e8)*Decimal(order['Market Data']['rate'])*Decimal(Dif)*Decimal(100)))
                st=str(Decimal(st)/Decimal(100))
            conv=""
            conv2=""
            conv3=""
            conv4=""
            if order['Market Data']['Template']=="Sell Coins" or order['Market Data']['Template']=="Buy Coins":
                if order['Market Data']['tracking']==0:
                    data+="Price Per Coin: " + str(order['Market Data']['rate']) + "<br />"
                else:
                    data+="Price Per Coin: " + str(order['Market Data']['rate']) + "<br />"
                    data+="Price Tracking Is Enabled: Market Price Not Loaded Yet..." + "<br />"
            else:
                if order['Market Data']['tracking']!=0:
                    data+="Price Tracking Is Enabled: Market Price Not Loaded Yet..." + "<br />"
                    data+="Please verify the exchange rate or wait for the rate to load." + "<br />"
        amtstring="Amount: "
        if "Something" in self.order['Market Data']['Template']:
            if 'StartingBid' in self.order['Market Data']:
                if "Sell" in self.order['Market Data']['Template']:
                    data+="<br />AUCTION!<br />"
                else:
                    data+="<br />REVERSE AUCTION!<br />"
                data+="Duration: " + str(self.order['Market Data']['duration']) + " hours<br />"
                try:
                    timeremaining = (Decimal(self.order['timestamp']) + Decimal(self.order['Market Data']['duration'])*60*60) - Decimal(timestamp)
                    if timeremaining>Decimal(0):
                        timeremaining = Decimal(int(Decimal((timeremaining/60)/60)*Decimal(100)))/Decimal(100)
                    else:
                        timeremaining=Decimal(0)
                    data+="Time Left: " + str(timeremaining) + " hours<br />"
                except:
                    traceback.print_exc()
                if 'BestBid' in self.order['Market Data']:
                    if "Sell" in self.order['Market Data']['Template']:
                        data+="Highest Bid: "
                    else:
                        data+="Lowest Bid: "
                else:
                    data+="Starting Bid: "
                data+= str(dropzeros((Decimal(bestbid)/Decimal(1e8)).quantize(Decimal('.00000001')),1))+conv4+", "+order['Market Data']['Payment Method'] + "<br />"
                if mode==0:
                    amtstring="Buyout Price: "
        if "Hire" in order['Market Data']['Template'] or "Find" in order['Market Data']['Template']:
            amtstring+=order['Market Data']['Pay Frequency']+" - "
        if "Coins" in order['Market Data']['Template']:
            data+="<br />Amount: " + str(dropzeros((Decimal(order['amount'])/Decimal(1e8)).quantize(Decimal('.00000001')),1))+conv+", "+order['Market Data']['Payment Method'] + "<br />"
        else:
            if 'Barter' in order['Market Data']['Template']:
                data+="<br />" + amtstring + str(dropzeros(((Decimal(order['amount'])/Decimal(1e8))).quantize(Decimal('.00000001')),1))+conv+", "+order['Market Data']['Payment Method'] + "<br />"
            else:
                data+="<br />" + amtstring + str(dropzeros(((Decimal(order['amount'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001')),1))+conv+", "+order['Market Data']['Payment Method'] + "<br />"
        if 'StartingBid' in self.order['Market Data'] and mode==0:
            self.Window.Drop1.addItem("Buyout Price: " + str(dropzeros(((Decimal(order['amount'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001')),1))+conv+", "+order['Market Data']['Payment Method'])
            self.Window.Drop1.setItemData(0,QtCore.QVariant(0))
        else:
            if "Coins" in order['Market Data']['Template']:
                self.Window.Drop1.addItem("Amount: " + str(dropzeros((Decimal(order['amount'])/Decimal(1e8)).quantize(Decimal('.00000001')),1))+conv+", "+order['Market Data']['Payment Method'])
                self.Window.Drop1.setItemData(0,QtCore.QVariant(0))
            else:
                if 'Barter' in order['Market Data']['Template']:
                    self.Window.Drop1.addItem("Amount: " + str(dropzeros(((Decimal(order['amount'])/Decimal(1e8))).quantize(Decimal('.00000001')),1))+conv+", "+order['Market Data']['Payment Method'])
                else:
                    self.Window.Drop1.addItem("Amount: " + str(dropzeros(((Decimal(order['amount'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001')),1))+conv+", "+order['Market Data']['Payment Method'])
                self.Window.Drop1.setItemData(0,QtCore.QVariant(0))                
        skip=0
        if "Coins" in order['Market Data']['Template'] and 'minorder' not in order['Market Data']:#Countering in the UI
            skip=1
        if mode==0 and skip==0:#Perhaps certain counters will allow this(wanting a different quantity of an accepting order)
            if self.order['Market Data']['Template']!="Custom" and self.order['Market Data']['Template']!="Python" and self.order['Market Data']['Template']!="Barter":
                if "Coins" in order['Market Data']['Template']:
                    self.Window.Drop1.addItem("Request a different amount...")
                    self.Window.Drop1.setItemData(1,QtCore.QVariant(999))
                if "Something" in order['Market Data']['Template']:
                    if 'StartingBid' not in self.order['Market Data']:
                        if order['Market Data']['tracking']!=2 and order['Market Data']['allowcounters']==1:#Counters are allowed
                            kr=0
                            if 'keepratio' not in order['Market Data']:
                                self.Window.Drop1.addItem("Request a different amount...")
                                self.Window.Drop1.setItemData(1,QtCore.QVariant(999))
                                kr=1
                            if 'quantity' in order['Market Data'] and order['Market Data']['quantity']>1:
                                self.Window.Drop1.addItem("Order higher quantity...")
                                self.Window.Drop1.setItemData(1+kr,QtCore.QVariant(998))
                    else:
                        self.Window.Drop1.addItem("Bid on this auction...")
                        self.Window.Drop1.setItemData(1,QtCore.QVariant(999))
        data+=str(order['whopays'])+"<br /><br />"
        if "Coins" in self.order['Market Data']['Template']:
            try:
                data+="Total in USD: $" + str((Decimal(st)*Decimal(self.order['Market Data']['service'])).quantize(Decimal('.01')))+"<br />"
            except:
                pass
        else:
            if 'shipping' in self.order['Market Data']:
                try:
                    test=Decimal(self.order['Market Data']['shipping'])
                    data+="Shipping: "+str(self.order['Market Data']['shipping'])+" Coins(included in amount)<br />"
                except:
                    data+="Shipping: "+self.order['Market Data']['shipping']+"<br />"
            if 'weight' in self.order['Market Data']:
                data+="Weight: "+self.order['Market Data']['weight']+"<br />"                    
            if 'countries' in self.order['Market Data']:
                data+="Will Ship To: " + self.order['Market Data']['countries']+"<br />"
        data+="Deposits: " + str(order['Market Data']['style']) + "<br />"
        if str(order['Market Data']['style'])=="Guarantor":
            if order['theirdeposit']==0:
                data+="I'm the guarantor!<br />"
            if order['mydeposit']==0:
                data+="They are the guarantor!<br />"
        self.Window.DepositSettings10.addItem(str(order['Market Data']['style']))
        self.Window.DepositSettings10.setItemData(0,QtCore.QVariant(0))
        data+="Date: " + str(t) + "<br />"
        if 'minorder' in order['Market Data']:
            if "Coins" in order['Market Data']['Template']:
                min1=str(Decimal(order['Market Data']['minorder']))
                data+="Minimum Order: " + str((Decimal(order['amount'])/Decimal(1e8)*Decimal(min1)).quantize(Decimal('.00000001'))) + "<br />"
        if self.rate!="" and self.rate!=" ":
            if "Coins" in order['Market Data']['Template']:
                self.Window.Box1.setText(str((Decimal(order['amount'])/Decimal(1e8)*Dif*Decimal(order['Market Data']['rate'])).quantize(Decimal('.01'))))
            else:
                self.Window.Box1.setText(str((Decimal(order['amount'])/Decimal(1e8)*Dif*Decimal(self.rate)).quantize(Decimal('.01'))))
        else:
            self.Window.Box1.setText(str(Decimal(order['amount'])/Decimal(1e8)))
            self.Window.USD1.setCurrentIndex(1)
        mct=0
        if "MCount" in order['Process']:
            if order['lock']=="1":
                mct=1
        if order['Process']=="Market Order" or mct==1 or order['Process']=="Market Offer":
            self.Window.Accept.show()
        else:
            self.Window.Accept.hide()
        #Have a way to divide by dif in all of these for buyers tracking price
        if "Coins" in order['Market Data']['Template']:
            data+="My Deposit: "+str(dropzeros((Decimal(order['mydeposit'])/Decimal(1e8)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))+conv2+"<br />"
            data+="Their Deposit: "+str(dropzeros((Decimal(order['theirdeposit'])/Decimal(1e8)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))+conv3+"<br />"
            self.Window.MyDepositBox10.setText(str(dropzeros((Decimal(order['mydeposit'])/Decimal(1e8)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))
            self.Window.TheirDepositBox10.setText(str(dropzeros((Decimal(order['theirdeposit'])/Decimal(1e8)).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))            
        else:
            data+="My Deposit: "+str(dropzeros(((Decimal(order['mydeposit'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))+conv2+"<br />"
            data+="Their Deposit: "+str(dropzeros(((Decimal(order['theirdeposit'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1))+conv3+"<br />"
            self.Window.MyDepositBox10.setText(str(dropzeros(((Decimal(order['mydeposit'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))
            self.Window.TheirDepositBox10.setText(str(dropzeros(((Decimal(order['theirdeposit'])/Decimal(1e8))*Dif).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))
        if order['instantamount'] != 0:
            f+=.5
            data+="Instant refund: ("+str(order['instantwhopays'])+")<br />"
            data+="Amount: " + str(Decimal(order['instantamount'])/Decimal(1e8))+"<br />"
        f+=1#Temporary account
        f+=1#Split escrow fund/release
        data+="<br />"
        data+="Fee: "+str(Decimal(order['fee']*f)/Decimal(1e8))+"<br />"
        data+="Time limit: "+str(order['timeout'])+" Hours -- "+str(round((order['timeout']/24),2))+" Days<br />"
        self.Window.TimeLimitBox10.setText(str(order['timeout']))
        self.orgmydeposit=str(self.Window.MyDepositBox10.text())
        self.orgtheirdeposit=str(self.Window.TheirDepositBox10.text())
        self.orghours=str(order['timeout'])
        data+="Order number: "+str(order['ordernumber'])
        data+="<br /><br />"
        if "Hire" in order['Market Data']['Template'] or "Find" in order['Market Data']['Template']:
            data+="Job Title: "+order['Market Data']['title']+"<br />"
        if 'notes' in order['Market Data']:
            if 'description' in order['Market Data']:
                data+="Description: <br />"
                data+=order['Details']['description'].replace("\n","<br />")+"<br />"                
            if order['Market Data']['notes']!="":
                data+="Notes: <br />"
                data+=order['Market Data']['notes'].replace("\n","<br />")+"<br />"
        else:
            data+="Description: <br />"
            data+=order['Details']['description'].replace("\n","<br />")+"<br />"
        if "Something" in order['Market Data']['Template']:
            if order['Market Data']['Profiles']['Mail']!=[] and mode!=0:
                data+="<br />"
                data+="Shipping Information: <br />"
                data+=order['Market Data']['Profiles']['Mail'][0].replace("\n","<br />")
            if "I pay" in order["whopays"] and "mymailing" in order['Market Data']:
                try:
                    data+="<br />"
                    data+="My Shipping Information: <br />"
                    data+=order['Market Data']['mymailing'].replace("\n","<br />")
                except:
                    traceback.print_exc()
        if "Hire" in order['Market Data']['Template'] or "Find" in order['Market Data']['Template']:
            data+="<br />"
            data+="Job Length: "+order['Market Data']['Job Length']+"<br />"
            if order['Market Data']['requirereport']==1:
                data+="Progress reports required for payment"+"<br />"
            if self.order['Market Data']['requirereport']==0:
                self.Window.CheckBox1.setCheckState(0)            
            if self.order['Market Data']['requirereport']==1:
                self.Window.CheckBox1.setCheckState(2)
            if order['Market Data']['interview']==1:
                data+="Interview requested"+"<br />"
            if order['Market Data']['resume']=="1":
                data+="Resume requested"+"<br />"
            else:
                if order['Market Data']['resume']!="0":
                    data+="Resume: "+order['Market Data']['resume']+"<br />"
                    self.Window.LinkResumeBox.setText(order['Market Data']['resume'])
            data+="<br />"
        if order['Market Data']['Profiles']['Contact']!=[]:
            data+="<br />"
            data+="Contact Information: <br />"
            data+=order['Market Data']['Profiles']['Contact'][0].replace("\n","<br />")
        self.Window.Display1.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'"+globfont+"\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+data+"</span></p></body></html>")
        self.Dif=Dif
        #if Dif==1:
        #    if 'rate' in order['Market Data']:
        #        self.rate=order['Market Data']['rate']
        if order['Market Data']['Template']=="Sell Coins" or order['Market Data']['Template']=="Buy Coins":
            #This will have to change for Buy Coins
            self.Window.Drop2.addItem("Service Charge: %" + str(dropzeros((Decimal(order['Market Data']['service'])-1)*100,1)))
            if mode==0:
                self.Window.Drop3.addItem("Payment: Please Select...")
                if order['Market Data']['Template']=="Buy Coins":
                    self.Window.Drop2.addItem("Custom service charge...")
            if order['Market Data']['Profiles']['Bank']!=[]:
                self.Window.Drop3.addItem("Payment: Bank Wire")
            if order['Market Data']['Profiles']['WU']!=[]:
                self.Window.Drop3.addItem("Payment: Western Union")
            if order['Market Data']['Profiles']['MG']!=[]:
                self.Window.Drop3.addItem("Payment: MoneyGram")
            if order['Market Data']['Profiles']['Card']!=[]:
                self.Window.Drop3.addItem("Payment: Prepaid Card")
            if order['Market Data']['Profiles']['Cash']!=[]:
                self.Window.Drop3.addItem("Payment: Cash In The Mail")
            if order['Market Data']['Profiles']['Other']!=[]:
                self.Window.Drop3.addItem("Payment: Other")
            if mode>1:
                self.Window.Drop3.clear()
                if order['Market Data']['reply']['selected']=="Bank":
                    self.Window.Drop3.addItem("Payment: Bank Wire")
                if order['Market Data']['reply']['selected']=="WU":
                    self.Window.Drop3.addItem("Payment: Western Union")
                if order['Market Data']['reply']['selected']=="MG":
                    self.Window.Drop3.addItem("Payment: MoneyGram")
                if order['Market Data']['reply']['selected']=="Card":
                    self.Window.Drop3.addItem("Payment: Prepaid Card")
                if order['Market Data']['reply']['selected']=="Cash":
                    self.Window.Drop3.addItem("Payment: Cash In The Mail")
                if order['Market Data']['reply']['selected']=="Other":
                    self.Window.Drop3.addItem("Payment: Other")
            self.Window.Drop3.show()
        if "Something" in order['Market Data']['Template']:
            if mode==0:
                if 'StartingBid' not in self.order['Market Data']:
                    if order['Market Data']['tracking']!=2 and order['Market Data']['allowcounters']==1:
                        if 'keepratio' not in order['Market Data']:#Counters are allowed
                            self.Window.DepositSettings10.addItem("Request different deposits...")
                            self.Window.DepositSettings10.setItemData(1,QtCore.QVariant(999))
        data2=""
        try:
            if mode==1:
                pubs=get_ordered_pubkeys(PrivKeyFilename1)
                public=pubs[0]
            else:
                public=order['Market Data']['orgpublic']
            data2+="User Profile:<br />"+public[:10]+"<br /><br />"
            if Markets['Reputation'][public]['Reputation']['Reviews']==[] and Markets['Reputation'][public]['Reputation']['Rating'] == 0:
                data2+="New User!<br />"
            data2+="Rating: "+ str(Markets['Reputation'][public]['Reputation']['Rating'])+"<br />"
            if 'Ratio' in Markets['Reputation'][public]['Reputation']:
                x=Markets['Reputation'][public]['Reputation']['Ratio'][0]
                y=Markets['Reputation'][public]['Reputation']['Ratio'][1]
                data2+="Contracts Completed: "+str(x)+"<br />"
                if x<y:
                    data2+="Contracts Lost: "+str(y-x)+"<br />"
                data2+="Success Rate: "+str(Decimal(int((Decimal(x)/Decimal(y))*Decimal(1000)))/Decimal(10))+"%<br />"
            data2+="<br />Reviews:<br />"
            r=1
            for Review in Markets['Reputation'][public]['Reputation']['Reviews']:
                data2+=str(r)+")<br />" +Review+"<br />"
                r+=1
        except:
            print "EXCEPTION LOADING PROFILE"
        self.data3=data
        self.data4=data2
        if "Coins" in order['Market Data']['Template']:
            data3=data
            data4=data2
        else:
            data3=data2
            data4=data
            try:
                output = StringIO.StringIO()
                image_string = StringIO.StringIO(base64.b64decode(self.order['Details']['image']))
                image = Image.open(image_string)
                image.save(output, 'PNG')#Used to be JPEG
                self.b64img= base64.b64encode(output.getvalue())
                tup=image.size
                w=Decimal(tup[0])
                h=Decimal(tup[1])
                if w > 310:
                    ratio=Decimal(310)/Decimal(w)
                    image=image.resize((int(ratio*w),int(ratio*h)), Image.ANTIALIAS)
                    w=310
                    h=int(ratio*h)
                if h > 210:
                    ratio=Decimal(210)/Decimal(h)
                    image=image.resize((int(ratio*w),int(ratio*h)), Image.ANTIALIAS)
                    h=210
                tup=image.size
                output = StringIO.StringIO()
                image.save(output, 'PNG')#Used to be JPEG
                b64img= base64.b64encode(output.getvalue())
                data3="<img src=\"data:image/png;base64,"+b64img+"\"/>"
                image_string.close()
                output.close()
                output=""
                image_string=""
            except:
                image_string.close()
                output.close()
                output=""
                image_string=""
                #traceback.print_exc()
        try:
            self.Window.Display1.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
            "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
            "p, li { white-space: pre-wrap; }\n"
            "</style></head><body style=\" font-family:\'"+globfont+"\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
            "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+data3+"</span></p></body></html>")
        except:
            self.Window.Display1.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
            "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
            "p, li { white-space: pre-wrap; }\n"
            "</style></head><body style=\" font-family:\'"+globfont+"\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
            "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+""+"</span></p></body></html>")
            traceback.print_exc()
        self.Window.Display2.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'"+globfont+"\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+data4+"</span></p></body></html>")
        if "Python" in order['Market Data']['Template']:
            global ApprovedContracts
            if 'pythonnotify' not in AdvanceArray:
                res=QuestionBox('Welcome to Python contracts. Please understand, for your own safety it is recommended that you audit these contracts yourself. Failure to do so can put your computer at risk to hackers. This is true even for contracts that get audited by developers and officially approved! This code is open source and therefore it is up to the users to review everything in advance.', ' I understand ', ' Do not show this message again. ')
                if res==1:
                    AdvanceArray['pythonnotify']=1
            if mode!=1 and mode !=3:
                thehash=txhash(order['Market Data']['code1']+order['Market Data']['code2']+order['Market Data']['code3'])
                if thehash not in ApprovedContracts and mode!=2:
                    res=QuestionBox(Gtranslate("WARNING! This contract is not in the list of audited custom Python contract templates. Therefore if you choose to proceed without auditing the code yourself you run the risk of the counter-party completely hijacking your computer. Therefore do this with EXTREME CAUTION as we are not responsible if you or your counter-party are experimenting with customized contracts. If you are familiar with the contract hash make sure it matches exactly with your records.")+'\n\nContract hash: \n'+thehash, Gtranslate(" OK "), Gtranslate(" Let me audit the code first "), Gtranslate(" Save the code "), 1)
                else:
                    res=QuestionBox('Contract hash: \n'+thehash, Gtranslate(" Proceed to contract "), Gtranslate(" Let me audit the code first "), Gtranslate(" Save the code "), 1)
                if res==1:
                    ewindow=QtGui.QDialog()
                    ewindow.resize(700, 700)
                    Display1 = QtGui.QTextBrowser((ewindow))
                    Display1.setGeometry(QtCore.QRect(10, 10, 670, 220))
                    Display2 = QtGui.QTextBrowser((ewindow))
                    Display2.setGeometry(QtCore.QRect(10, 240, 670, 220))
                    Display3 = QtGui.QTextBrowser((ewindow))
                    Display3.setGeometry(QtCore.QRect(10, 470, 670, 220))
                    try:
                        Display1.setText("Code For Offer Forms:<br /><br />"+order['Market Data']['code1'].replace('\n','<br/>').replace(' ', '&nbsp;'))
                        Display2.setText("Code Run During Escrow:<br /><br />"+order['Market Data']['code2'].replace('\n','<br/>').replace(' ', '&nbsp;'))
                        Display3.setText("Code For Escrow Window:<br /><br />"+order['Market Data']['code3'].replace('\n','<br/>').replace(' ', '&nbsp;'))
                    except:
                        traceback.print_exc()
                        QuestionBox('Exception loading text.', ' OK ')
                        return
                    ewindow.setWindowTitle("Python Contract")
                    ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
                    ewindow.exec_()
                if res==2:
                    dir1 = strOUT(strIN(QtGui.QFileDialog.getExistingDirectory(self,Gtranslate("Open a folder to save the source code"),MacDir()+"",QtGui.QFileDialog.ShowDirsOnly)))
                    if dir1=="":
                        return
                    try:
                        with open(os.path.join(dir1,'file1.py'),'w') as f:
                            f.write(order['Market Data']['code1'])
                            f.flush()
                            os.fsync(f)
                            f.close()
                        with open(os.path.join(dir1,'file2.py'),'w') as f:
                            f.write(order['Market Data']['code2'])
                            f.flush()
                            os.fsync(f)
                            f.close()
                        with open(os.path.join(dir1,'file3.py'),'w') as f:
                            f.write(order['Market Data']['code3'])
                            f.flush()
                            os.fsync(f)
                            f.close()
                    except:
                        traceback.print_exc()
                        QuestionBox('Error saving files to disk.', ' OK ')
                if res!=0:
                    return
                if thehash not in ApprovedContracts and mode!=2:
                    text, ok = QtGui.QInputDialog.getText(window, CoinSelect['HaloName'], Gtranslate('Please type "yes" in the box if you understand the risks of unknown custom Python contracts:'))
                    if str(text).lower()!='yes':
                        QuestionBox('You must type "yes" in the box if you wish to continue and see this contract.', ' OK ')
                        self.Window.hide()
                        return
                    QuestionBox('You will now be asked to sign the code so that it can be officially recognized by the software.', ' OK ')                    
                    if not SignCode([order['Market Data']['code1'],order['Market Data']['code2'],order['Market Data']['code3']]):
                        return False
                    ApprovedContracts[thehash]={}
                try:
                    showform=1
                    exec(validateCode(order['Market Data']['code1']))
                except:
                    QuestionBox("Code execution failed", " OK ")
                    traceback.print_exc()
                    return
        if "Barter" in order['Market Data']['Template']:
            if mode==0:
                if 'barterinfo' not in AdvanceArray:
                    res=QuestionBox('Welcome to a barter contract. Here you can choose items your counterparty is willing to trade by adding it to your demand list. In exchange, you can offer items from the supply list. The software can calculate the precise amounts needed for a fair trade regardless of what is being traded. This could be commodities, crops, services, minerals and even currencies. The quantity tells you how much they have in total supply and how much they might want in demand. You can limit shipping sizes to lower deposits and break the deal into multiple shipments as well. When finished, you can see the contract details in another window. There you can see the users profile, contract details and the adjusted calculation of the deposits based on your decision. You may also choose to customize the deposits in some contracts.',' OK ', ' Do not show this message again. ')
                    if res==1:
                        AdvanceArray['barterinfo']=1
                self.Window.DepositSettings8.clear()
                self.Window.DepositSettings8.addItem(str(self.order['Market Data']['style']))
                self.Window.MyDepositBox8.setText(str(self.orgmydeposit))
                self.Window.TheirDepositBox8.setText(str(self.orgtheirdeposit))
                self.Window.TimeLimitBox8.setText(str(self.orghours))
                self.Window.MyDepositUSD8.setCurrentIndex(self.Window.MyDepositUSD10.currentIndex())
                self.Window.TheirDepositUSD8.setCurrentIndex(self.Window.TheirDepositUSD10.currentIndex())
                self.Window.TimeLimitDays8.setCurrentIndex(self.Window.TimeLimitDays10.currentIndex())
                self.Window.MyDepositBox8.setReadOnly(True)
                self.Window.TheirDepositBox8.setReadOnly(True)
                self.Window.TimeLimitBox8.setReadOnly(True)
                self.Window.MyDepositBox8.show()
                self.Window.MyDepositText8.show()
                self.Window.TheirDepositBox8.show()
                self.Window.TheirDepositText8.show()
                self.Window.TimeLimitBox8.show()
                self.Window.TimeLimitText8.show()
                self.Window.MyDepositUSD8.show()
                self.Window.TheirDepositUSD8.show()
                self.Window.TimeLimitDays8.show()
                if self.barterwindow==1:
                    self.barteritems2={'supply':{},'demand':{}}
                    self.barteritems=self.order['Market Data']['barteritems']
                    self.PopulateBarter(1)
                    Templates.Window.Pages.setCurrentIndex(16)
                    self.Window.show()
                    return
                else:
                    try:
                        self.order['Market Data']['barteritems']=json_deep_copy(self.barteritems2,1)
                        totalmerch=0
                        totaldemand=0
                        highest=0
                        besttitle=''
                        for item in self.barteritems2['supply']:
                            myitem=self.barteritems2['supply'][item]
                            av=int(self.barteritems2['supply'][item]['amount'])
                            highvalue=av
                            highvalue=self.TestHighValue(highvalue, myitem)
                            if highvalue==False:
                                print "High value check failed!"
                                self.barterwindow=1
                                return
                            if highvalue>highest:
                                highest=highvalue
                                besttitle=item
                            totalmerch+=av
                        for item in self.barteritems2['demand']:
                            myitem=self.barteritems2['demand'][item]
                            av=int(self.barteritems2['demand'][item]['amount'])
                            highvalue=av
                            highvalue=self.TestHighValue(highvalue, myitem)
                            if highvalue==False:
                                print "High value check failed!"
                                self.barterwindow=1
                                return
                            if highvalue>highest:
                                highest=highvalue
                                besttitle=item
                            totaldemand+=av
                        print str(highest), besttitle
                        self.order['mydeposit']=str(int(Decimal(highest*2)))
                        self.order['theirdeposit']=str(int(Decimal(highest*2)))
                        self.orgmydeposit=self.order['mydeposit']
                        self.orgtheirdeposit=self.order['theirdeposit']
                        if self.evenbarter==0:
                            res=QuestionBox('The total values for the supply list and demand list are not even. The amounts should be within 5 percent of each other. Your counter-party might consider this an unfair trade. Do you still wish to continue?', ' Yes ', ' No ')
                            if res==1:
                                self.Window.hide()
                                self.barterwindow=1
                                return
                        if 'notifybarterdeposit' not in AdvanceArray:
                            res=QuestionBox('The deposits have been modified based on your decisions for this order. Once you click counter-offer you will be able to adjust the deposits if you wish. However we highly recommend taking the suggestions of the software for your protection. It is also highly recommended that you supply additional contact information for this template. If there is shipping involved, you should include a profile with shipping information as well.', ' OK ', ' Do not show this again. ')
                            if res==1:
                                AdvanceArray['notifybarterdeposit']=1
                        self.Window.DepositSettings10.clear()
                        self.Window.DepositSettings10.addItem(str(self.order['Market Data']['style']))
                        self.Window.MyDepositBox10.setText(str(dropzeros(((Decimal(self.order['mydeposit'])/Decimal(1e8))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))
                        self.Window.TheirDepositBox10.setText(str(dropzeros(((Decimal(self.order['theirdeposit'])/Decimal(1e8))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))
                        self.Window.TimeLimitBox10.setText(str(self.orghours))
                        self.Window.MyDepositUSD10.setCurrentIndex(1)
                        self.Window.TheirDepositUSD10.setCurrentIndex(1)
                        self.Window.TimeLimitDays10.setCurrentIndex(1)
                        self.Window.MyDepositBox10.setReadOnly(True)
                        self.Window.TheirDepositBox10.setReadOnly(True)
                        self.Window.TimeLimitBox10.setReadOnly(True)
                        self.Window.MyDepositBox10.show()
                        self.Window.MyDepositText10.show()
                        self.Window.TheirDepositBox10.show()
                        self.Window.TheirDepositText10.show()
                        self.Window.TimeLimitBox10.show()
                        self.Window.TimeLimitText10.show()
                        self.Window.MyDepositUSD10.show()
                        self.Window.TheirDepositUSD10.show()
                        self.Window.TimeLimitDays10.show()
                    except:
                        traceback.print_exc()
                        self.barterwindow=1
                self.barterwindow=1
                Templates.Window.Pages.setCurrentIndex(19)
            else:
                if mode==2:
                    if 'barteroffernotify' not in AdvanceArray:
                        res=QuestionBox('When getting offers in a barter contract, remember to carefully check all the items before accepting. The deposits should be enough to cover shipments and to disincentivize breaking the contract. Users can usually take turns making shipments or trading goods and services especially when multiple shipments are involved.', ' OK ', ' Do not show this message again. ')
                        if res==1:
                            AdvanceArray['barteroffernotify']=1
                Templates.Window.Pages.setCurrentIndex(14)
                self.barteritems2={'supply':{},'demand':{}}
                self.barteritems=self.order['Market Data']['barteritems']
                self.PopulateBarter(2)
                res=Templates.Window.exec_()

                self.Window.DepositSettings10.clear()
                self.Window.DepositSettings10.addItem(str(self.order['Market Data']['style']))
                self.Window.MyDepositBox10.setText(str(dropzeros(((Decimal(self.order['mydeposit'])/Decimal(1e8))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))
                self.Window.TheirDepositBox10.setText(str(dropzeros(((Decimal(self.order['theirdeposit'])/Decimal(1e8))).quantize(Decimal('.00000001'), rounding=ROUND_HALF_UP),1)))
                self.Window.TimeLimitBox10.setText(str(self.orghours))
                self.Window.MyDepositUSD10.setCurrentIndex(1)
                self.Window.TheirDepositUSD10.setCurrentIndex(1)
                self.Window.TimeLimitDays10.setCurrentIndex(1)
                self.Window.MyDepositBox10.setReadOnly(True)
                self.Window.TheirDepositBox10.setReadOnly(True)
                self.Window.TimeLimitBox10.setReadOnly(True)
                self.Window.MyDepositBox10.show()
                self.Window.MyDepositText10.show()
                self.Window.TheirDepositBox10.show()
                self.Window.TheirDepositText10.show()
                self.Window.TimeLimitBox10.show()
                self.Window.TimeLimitText10.show()
                self.Window.MyDepositUSD10.show()
                self.Window.TheirDepositUSD10.show()
                self.Window.TimeLimitDays10.show()

                self.Window.show()
                Templates.Window.Pages.setCurrentIndex(19)
        self.Window.show()
        if mode>0:#Might have to change depending on if counters are allowed. AGAIN Mode 1 and 3 are sent options Mode 2 is final offers Mode 4 is escrow
            self.blockAllSignals(1)
            self.Window.Accept.show()
            self.Window.Delete.show()
            if mode==1 or mode==3:#These are sent options and 2 is final offer
                self.Window.Accept.setText("Send Request Again")
                self.Window.Text2.hide()
                self.Window.TextBox1.hide()
            self.Window.Counter.hide()
            if orgmode==4:#Escrow
                self.mode=4
                if "Coins" in order['Market Data']['Template']:
                    self.Window.Accept.setText("Show Funding Details")
                if "Custom" in order['Market Data']['Template'] or "Something" in order['Market Data']['Template'] or "Python" in order['Market Data']['Template'] or "Hire" in order['Market Data']['Template'] or "Find" in order['Market Data']['Template'] or "Barter" in order['Market Data']['Template']:
                    self.Window.Accept.hide()
                self.Window.Counter.hide()
                self.Window.Delete.hide()
            self.Window.SelectContact.hide()
            self.Window.SupplyAdditional10.hide()
        if mode==0:#This seems to be all cases where its open for accepting except final offers!! May want to reactivate this later
            if self.order['Market Data']['Template']=="Barter":
                self.Window.Counter.show()
                self.Window.Accept.hide()
            if self.order['Market Data']['Template']=="Custom" or self.order['Market Data']['Template']=="Python":
                if self.order['Market Data']['allowcounters']==1:
                    if self.order['Market Data']['tracking']!=2:
                        self.Window.Counter.show()
                    else:
                        self.Window.Counter.hide()
            if "Something" in self.order['Market Data']['Template']:
                self.Window.Counter.hide()                
                if 'StartingBid' not in self.order['Market Data']:
                    if order['Market Data']['tracking']!=2 and order['Market Data']['allowcounters']==1:#Counters are allowed
                        self.Window.Counter.show()
            if "Hire" in order['Market Data']['Template'] or "Find" in order['Market Data']['Template']:
                self.Window.Counter.hide()
                if order['Market Data']['allowcounters']==1 and order['Market Data']['tracking']!=2:
                    self.Window.Counter.show()

    def blockAllSignals(self, mode=0):
        if mode==0:
            self.Window.Button1.blockSignals(False)
            self.Window.Button2.blockSignals(False)
            self.Window.Attach.blockSignals(False)
            self.Window.Link2.blockSignals(False)
            self.Window.Drop1.blockSignals(False)
            self.Window.Drop2.blockSignals(False)
            self.Window.Drop3.blockSignals(False)
            self.Window.Drop4.blockSignals(False)
            self.Window.DepositSettings10.blockSignals(False)
            self.Window.MyDepositUSD10.blockSignals(False)
            self.Window.TheirDepositUSD10.blockSignals(False)
            self.Window.USD1.blockSignals(False)
            self.Window.USD2.blockSignals(False)
            self.Window.USD3.blockSignals(False)
            self.Window.TimeLimitDays10.blockSignals(False)
            self.Window.SelectContact.blockSignals(False)
        if mode==1:
            #self.Window.Button1.blockSignals(True)
            #self.Window.Button2.blockSignals(True)
            self.Window.Attach.blockSignals(True)
            self.Window.Link2.blockSignals(True)
            self.Window.Drop1.blockSignals(True)
            self.Window.Drop2.blockSignals(True)
            self.Window.Drop3.blockSignals(True)
            self.Window.Drop4.blockSignals(True)
            self.Window.DepositSettings10.blockSignals(True)
            self.Window.MyDepositUSD10.blockSignals(True)
            self.Window.TheirDepositUSD10.blockSignals(True)
            self.Window.USD1.blockSignals(True)
            self.Window.USD2.blockSignals(True)
            self.Window.USD3.blockSignals(True)
            self.Window.TimeLimitDays10.blockSignals(True)
            self.Window.SelectContact.blockSignals(True)




#protectOBF2

class InputState:
    LOWER = 0
    CAPITAL = 1

class KeyButton(QtGui.QPushButton):
    def __init__(self, key):
        super(KeyButton, self).__init__()       
        self._key = key
        self._activeSize = QtCore.QSize(50,50)
        self.connect(self, QtCore.SIGNAL("clicked()"), self.emitKey)
        self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed))

        self.ticker = 0
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.tick)

    def emitKey(self):
        self.emit(QtCore.SIGNAL("sigKeyButtonClicked"), self._key)

    def tick(self):
        self.ticker+=1.5
        if self.ticker>100:
            self.ticker=100
        AntiLogger.progress.setValue(self.ticker)
        if self.ticker==100:
            AntiLogger.addInputByKey(self._key)
            self.ticker=0

    def enterEvent(self, event):
        self.timer.start(15)
        self.setFixedSize(self._activeSize)

    def leaveEvent(self, event):
        self.ticker=0
        AntiLogger.progress.setValue(0)
        self.timer.stop()
        self.setFixedSize(self.sizeHint())

    def sizeHint(self):
        return QtCore.QSize(40, 40)

class VirtualKeyboard(QtGui.QDialog):
    def __init__(self):
        super(VirtualKeyboard, self).__init__()
        
        self.setWindowTitle("Enter your password:")
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        #self.setWindowTitle(Gtranslate("Enter your password:"))
        self.globalLayout = QtGui.QVBoxLayout(self)
        self.keysLayout = QtGui.QGridLayout()
        self.buttonLayout = QtGui.QHBoxLayout()
        self.progress = QtGui.QProgressBar()
        self.keyListByLines = [
                    ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                    ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z'],
                    ['x', 'c', 'v', 'b', 'n', 'm', '`', '~', '!', '1'],
                    ['@', '2', '#', '3', '$', '4', '%', '5', '^', '6'],
                    ['&&', '7', '*', '8', '(', '9', ')', '0', '_', '-'],
                    ['+', '=', '{', '[', '}', ']', '\\', '|', ';', ':'],
                    ['"', "'", '<', ',', '>', '.', '?', '/', ' ', ' '],
                ]
        self.inputString = ""
        self.state = InputState.LOWER

        self.stateButton = QtGui.QPushButton()
        self.stateButton.setText('Shift')
        self.backButton = QtGui.QPushButton()
        self.backButton.setText('Back')
        self.okButton = QtGui.QPushButton()
        self.okButton.setText('OK')
        self.cancelButton = QtGui.QPushButton()
        self.cancelButton.setText("Cancel")

        self.inputLine = QtGui.QLineEdit()
        self.inputLine.setText("")

        for lineIndex, line in enumerate(self.keyListByLines):
            for keyIndex, key in enumerate(line):
                buttonName = "keyButton" + key.capitalize()                
                self.__setattr__(buttonName, KeyButton(key))
                self.keysLayout.addWidget(self.getButtonByKey(key), self.keyListByLines.index(line), line.index(key))
                self.getButtonByKey(key).setText(key)
                self.connect(self.getButtonByKey(key), QtCore.SIGNAL("sigKeyButtonClicked"), self.addInputByKey)
                self.keysLayout.setColumnMinimumWidth(keyIndex, 50)
            self.keysLayout.setRowMinimumHeight(lineIndex, 50)

        ApplyCSS(self)

        self.connect(self.stateButton, QtCore.SIGNAL("clicked()"), self.switchState)
        self.connect(self.backButton, QtCore.SIGNAL("clicked()"), self.backspace)
        self.connect(self.okButton, QtCore.SIGNAL("clicked()"), self.emitInputString)
        self.connect(self.cancelButton, QtCore.SIGNAL("clicked()"), self.emitCancel)
        self.inputLine.textChanged.connect(self.changed)


        self.buttonLayout.addWidget(self.cancelButton)
        self.buttonLayout.addWidget(self.backButton)
        self.buttonLayout.addWidget(self.stateButton)
        self.buttonLayout.addWidget(self.okButton)

        self.globalLayout.addWidget(self.inputLine)
        self.globalLayout.addWidget(self.progress)
        self.globalLayout.addLayout(self.keysLayout)

        self.globalLayout.addLayout(self.buttonLayout)
        self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Fixed, QtGui.QSizePolicy.Fixed))
    def reset(self):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.inputLine.setText("")
        self.inputString=""
    def changed(self):
        self.inputLine.blockSignals(True)
        if len(self.inputLine.text())<len(self.inputString):
            self.inputString = self.inputString[:-1]
            self.inputLine.blockSignals(False)
            return   
        key=str(self.inputLine.text().replace("*",""))
        if key=="":
            key="*"
        self.inputString+=key
        #self.addInputByKey(key, block=0)
        self.inputLine.setText(self.inputLine.text().replace(key,"*"))
        self.inputLine.blockSignals(False)

    def getButtonByKey(self, key):
        return getattr(self, "keyButton" + key.capitalize())

    def getLineForButtonByKey(self, key):       
        return [key in keyList for keyList in self.keyListByLines].index(True)

    def switchState(self):
        lowers=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
        self.state = not self.state
        for key in lowers:
            self.getButtonByKey(key).setText((key.lower(), key.capitalize())[self.state])

    def addInputByKey(self, key, block=1):
        if block==1:
            self.inputLine.blockSignals(True)
        if key=="&&": key="&"
        self.inputString += (key.lower(), key.capitalize())[self.state]
        self.inputLine.setText(str(self.inputLine.text())+"*")
        #self.state = InputState.LOWER
        if block==1:
            self.inputLine.blockSignals(False)

    def backspace(self):
        self.inputLine.blockSignals(True)
        self.inputLine.backspace()
        self.inputLine.blockSignals(False)
        self.inputString = self.inputString[:-1]

    def emitInputString(self):
        pass
        #print str(self.inputString)
        self.accept() 
        #self.emit(QtCore.SIGNAL("sigInputString"), self.inputString)

    def emitCancel(self):
        self.inputString=""
        self.accept()
        #self.emit(QtCore.SIGNAL("sigInputString"), "")

    def sizeHint(self):
        return QtCore.QSize(480,272)

def shippingcalculator(clientinfo="", manualoffer=0):
    global bestcalcrate
    global AdvanceArray
    global CoinMarketCap
    try:
        if window.EnableShippingCalc:
            pass
    except:
        res=QuestionBox("Shipping calculator is not enabled.","OK")
        return
    if 'shippingtip' not in AdvanceArray and manualoffer==0:
        res=QuestionBox("The program will now launch a shipping calculator to help you estimate the cost of shipping. Please understand there are many companies and options for shipping. When a seller or buyer calculates the shipping they might find better rates.", " Okay, I understand ", " Do not show this message again. ")
        if res==1:
            AdvanceArray['shippingtip']=1
    if clientinfo != "":
        res=QuestionBox(Gtranslate("Here is your counter-parties shipping information so you know both the origin and destination of your shipment. You will need this to get a proper estimate when calculating shipping.\n\n") + clientinfo, " Okay, Thanks ", " Copy to Clipboard ",1)
        if res==1:
            clipboard = app.clipboard()
            clipboard.setText(str(clientinfo))              
    bestcalcrate=[]
    js_eval = CalcJavaScriptEvaluator(calcpage)
    action_box = CalcActionInputBox(calcpage)

    url_input = CalcUrlInput(calcbrowser)
    requests_table = CalcRequestsTable()
    manager = CalcManager(requests_table)
    calcpage.setNetworkAccessManager(manager)    
    calcbrowser.setPage(calcpage)
    url=QtCore.QUrl("https://www.fedex.com/ratefinder/home")
    calcbrowser.load(url)
    
    grid = QtGui.QGridLayout()
    #grid.addWidget(url_input, 1, 0)
    #grid.addWidget(action_box, 2, 0)
    grid.addWidget(calcbrowser, 3, 0)
    #grid.addWidget(requests_table, 4, 0)
    #grid.addWidget(js_eval, 5, 0)
    calcmain_frame.resize(800,800)
    try:
        calcbrowser.resize(800,800)       
        calcmain_frame.setLayout(grid)
    except:
        pass   
    res=1
    rate=""
    usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)
    if usd=="":
        if manualoffer==0:
            res2=QuestionBox("Exchange rate not loaded yet. Therefore you can not use the calculator yet until it loads. However, you can choose to estimate shipping manually in coins.", " I will wait for the rate to load ", " Let me estimate shipping manually in coins ")
            if res2==0:
                return rate
            else:
                manualoffer=1
        else:
            res2=QuestionBox("Exchange rate not loaded yet. Therefore you will have to calculate the shipping manually in coins instead of dollars.", " OK ", " Cancel ")
            if res2==1:
                return rate
    if manualoffer==0:
        calcmain_frame.exec_()
        if bestcalcrate!=[]:
            res = QuestionBox(Gtranslate("The Fedex shipping calculator has estimated the following rate in dollars.")+"\n\n"+str(bestcalcrate[0])+": "+str(bestcalcrate[1])," Use this rate ", " Let me offer a different rate ",1)
            if res==0:
                rate=Decimal(bestcalcrate[1])
        else:
            res2=QuestionBox("The Fedex shipping calculator has not found a rate. You will have to estimate your shipping manually.", " OK ", " Cancel ")
            if res2==1:
                return ""
    if res==1:
        if usd=="":
            text, ok = QtGui.QInputDialog.getText(window, CoinSelect['HaloName'], Gtranslate('Please enter what you have estimated shipping to be in coins:'))
        else:
            text, ok = QtGui.QInputDialog.getText(window, CoinSelect['HaloName'], Gtranslate('Please enter what you have estimated shipping to be in dollars:'))
        try:
            if str(text)=="":
                return ""
            rate=Decimal(str(text))
            if rate<Decimal(0):
                float("a")
        except:
            QuestionBox("Not a valid amount!", " OK ")
            rate=""
    if rate!="":
        if rate>Decimal(0):
            if usd!="":
                rate=(Decimal(rate)/Decimal(usd)).quantize(Decimal('.00000001'))
                QuestionBox(Gtranslate("Please confirm the converted shipping rate from dollars to coins and please confirm the exchange rate online:\n")+"USD:"+usd+"->"+CoinSelect['name']+"\nBTC:"+btc+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this."+"\n\n\nTotal amount to be paid for shipping(in coins): \n"+str(rate)), Gtranslate("OK"),1)
    return rate
def findrates(text):
    text=text.split('eval(')[1]
    text=text.split('});')[0] + "}"
    text=ast.literal_eval(text)
    mylist=[]
    mylist2=[]
    def myprint(d):
        for k, v in d.iteritems():
            if isinstance(v, dict):
                myprint(v)
            else:
                if k=='revenue':
                    mylist.append(v)                    
                if k=='productName':                    
                    mylist2.append(v)
    myprint(text)
    return mylist, mylist2
class CalcUrlInput(QtGui.QLineEdit):
    def __init__(self, calcbrowser):
        super(CalcUrlInput, self).__init__()
        self.calcbrowser = calcbrowser
        self.returnPressed.connect(self._return_pressed)

    def _return_pressed(self):
        url = QtCore.QUrl(self.text())
        calcbrowser.load(url)
class CalcJavaScriptEvaluator(QtGui.QLineEdit):
    def __init__(self, calcpage):
        super(CalcJavaScriptEvaluator, self).__init__()
        self.calcpage = calcpage
        self.returnPressed.connect(self._return_pressed)

    def _return_pressed(self):
        frame = self.calcpage.currentFrame()
        result = frame.evaluateJavaScript(self.text())
class CalcActionInputBox(QtGui.QLineEdit):
    def __init__(self, calcpage):
        super(CalcActionInputBox, self).__init__()
        self.calcpage = calcpage
        self.returnPressed.connect(self._return_pressed)

    def _return_pressed(self):       
        frame = self.calcpage.currentFrame()
        action_string = str(self.text()).lower()
        if action_string == "b":
            self.calcpage.triggerAction(QWebPage.Back)
        elif action_string == "f":
            self.calcpage.triggerAction(QWebPage.Forward)
        elif action_string == "s":
            self.calcpage.triggerAction(QWebPage.Stop)
        elif action_string == "r":
            self.calcpage.triggerAction(QWebPage.Reload)
class CalcRequestsTable(QtGui.QTableWidget):
    header = ["url", "status", "content-type"]

    def __init__(self):
        super(CalcRequestsTable, self).__init__()
        self.setColumnCount(3)
        self.setHorizontalHeaderLabels(self.header)
        header = self.horizontalHeader()
        header.setStretchLastSection(True)
        header.setResizeMode(QtGui.QHeaderView.ResizeToContents)

    def update(self, data):
        last_row = self.rowCount()
        next_row = last_row + 1
        self.setRowCount(next_row)
        for col, dat in enumerate(data, 0):
            if not dat:
                continue
            self.setItem(last_row, col, QtGui.QTableWidgetItem(dat))
class CalcManager(QNetworkAccessManager):
    def __init__(self, table):
        QNetworkAccessManager.__init__(self)
        self.finished.connect(self._finished)
        self.table = table

    def _finished(self, reply):
        global bestcalcrate
        headers = reply.rawHeaderPairs()
        headers = {str(k):str(v) for k,v in headers}
        #print str(headers)
        frame = calcpage.mainFrame()
        if "Amounts are shown in USD" in unicode(frame.toHtml()).encode('utf-8'):
            try:
                rates, prods=findrates(unicode(frame.toHtml()).encode('utf-8'))
                bestval=0
                bestprod=""
                pos=0
                for r in rates:
                    if bestval==0 or r<bestval:
                        bestval=r
                        bestprod=prods[pos]
                    pos+=1
                bestcalcrate=[bestprod,bestval]
            except:
                traceback.print_exc()
            calcmain_frame.accept()          
        content_type = headers.get("Content-Type")
        url = reply.url().toString()
        status = reply.attribute(QNetworkRequest.HttpStatusCodeAttribute)
        status, ok = status.toInt()
        self.table.update([url, str(status), content_type])

#For cross platform font sizes
def compareFont(Label1, Label2):
    try:
        f=Label1.font()
        f2=Label2.font()
        s=f.pixelSize()
        s2=f2.pixelSize()
        if s==-1:
            s=f.pointSize()
            s2=f2.pointSize()
        if s > s2:
            Label1.setFont(Label2.font())
        else:
            Label2.setFont(Label1.font())
    except:
        traceback.print_exc()
    return True
class myQLabel(QtGui.QLabel):
    def __init__(self, *args, **kargs):
        super(myQLabel, self).__init__(*args, **kargs)

        self.setSizePolicy(QtGui.QSizePolicy(QtGui.QSizePolicy.Ignored,
                                             QtGui.QSizePolicy.Ignored))

        self.setMinSize(6)

    def setMinSize(self, minfs):

        f = self.font()
        f.setPixelSize(minfs)
        f.setFamily(_fromUtf8("Arial"))
        br = QtGui.QFontMetrics(f).boundingRect(self.text())

        self.setMinimumSize(br.width(), br.height())

    def resizeEvent(self, event):
        super(myQLabel, self).resizeEvent(event)

        if not self.text():
            return

        #--- fetch current parameters ----

        f = self.font()
        cr = self.contentsRect()

        #--- find the font size that fits the contentsRect ---

        fs = 1
        while True:

            f.setPixelSize(fs)
            br =  QtGui.QFontMetrics(f).boundingRect(self.text())

            if br.height() <= cr.height() and br.width() <= cr.width():
                fs += 1
            else:
                f.setPixelSize(max(fs - 1, 1)) # backtrack
                break

        #--- update font size ---

        self.setFont(f)

#More UI windows
class Settings(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(683, 681)
        
        self.stopcount=0
        self.connectioncount=""
        self.SettingsTabs = QtGui.QTabWidget(Form)
        self.SettingsTabs.setGeometry(QtCore.QRect(10, 10, 671, 661))
        self.SettingsTabs.setObjectName(_fromUtf8("SettingsTabs"))
        self.tab = QtGui.QWidget()
        self.tab.setObjectName(_fromUtf8("tab"))
        self.ProxyEdit = QtGui.QTextEdit(self.tab)
        self.ProxyEdit.setGeometry(QtCore.QRect(10, 40, 591, 41))
        self.ProxyEdit.setObjectName(_fromUtf8("ProxyEdit"))
        self.ProxyLabel = QtGui.QLabel(self.tab)
        self.ProxyLabel.setGeometry(QtCore.QRect(10, 10, 551, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(19)
        self.ProxyLabel.setFont(font)
        self.ProxyLabel.setObjectName(_fromUtf8("ProxyLabel"))
        self.RunSetupWizard = QtGui.QPushButton(self.tab)
        self.RunSetupWizard.setGeometry(QtCore.QRect(10, 90, 191, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.RunSetupWizard.setFont(font)
        self.RunSetupWizard.setObjectName(_fromUtf8("RunSetupWizard"))
        self.ShowReputation = QtGui.QPushButton(self.tab)
        self.ShowReputation.setGeometry(QtCore.QRect(210, 90, 191, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.ShowReputation.setFont(font)
        self.ShowReputation.setObjectName(_fromUtf8("ShowReputation"))
        self.EditProfiles = QtGui.QPushButton(self.tab)
        self.EditProfiles.setGeometry(QtCore.QRect(410, 90, 191, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.EditProfiles.setFont(font)
        self.EditProfiles.setObjectName(_fromUtf8("EditProfiles"))

        self.Info = QtGui.QPushButton(self.tab)
        self.Info.setGeometry(QtCore.QRect(610, 40, 41, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(21)
        self.Info.setFont(font)
        self.Info.setObjectName(_fromUtf8("Info"))
        self.Info.setText("?")

        self.ActivateAntiKeylogger = QtGui.QCheckBox(self.tab)
        self.ActivateAntiKeylogger.setGeometry(QtCore.QRect(10, 150, 591, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.ActivateAntiKeylogger.setFont(font)
        self.ActivateAntiKeylogger.setObjectName(_fromUtf8("ActivateAntiKeylogger"))
        self.DontSavePasswords = QtGui.QCheckBox(self.tab)
        self.DontSavePasswords.setGeometry(QtCore.QRect(10, 190, 591, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.DontSavePasswords.setFont(font)
        self.DontSavePasswords.setObjectName(_fromUtf8("DontSavePasswords"))
        self.FilterCurrencies = QtGui.QCheckBox(self.tab)
        self.FilterCurrencies.setGeometry(QtCore.QRect(10, 270, 591, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.FilterCurrencies.setFont(font)
        self.FilterCurrencies.setObjectName(_fromUtf8("FilterCurrencies"))
        self.ClearKeysOnExit = QtGui.QCheckBox(self.tab)
        self.ClearKeysOnExit.setGeometry(QtCore.QRect(10, 230, 591, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.ClearKeysOnExit.setFont(font)
        self.ClearKeysOnExit.setObjectName(_fromUtf8("ClearKeysOnExit"))
        self.DebugOnExit = QtGui.QCheckBox(self.tab)
        self.DebugOnExit.setGeometry(QtCore.QRect(10, 310, 591, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.DebugOnExit.setFont(font)
        self.DebugOnExit.setObjectName(_fromUtf8("DebugOnExit"))
        self.NetworkConnections = QtGui.QLabel(self.tab)
        self.NetworkConnections.setGeometry(QtCore.QRect(10, 590, 551, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(19)
        self.NetworkConnections.setFont(font)
        self.NetworkConnections.setObjectName(_fromUtf8("NetworkConnections"))

        self.SettingsTabs.addTab(self.tab, _fromUtf8(""))


        self.tab_2 = QtGui.QWidget()
        self.tab_2.setObjectName(_fromUtf8("tab_2"))
        self.ColdStakingLabel = QtGui.QLabel(self.tab_2)
        self.ColdStakingLabel.setGeometry(QtCore.QRect(10, 10, 641, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(13)
        self.ColdStakingLabel.setFont(font)
        self.ColdStakingLabel.setObjectName(_fromUtf8("ColdStakingLabel"))
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            self.RewardsLabel = QtGui.QLabel(self.tab_2)
            self.RewardsLabel.setGeometry(QtCore.QRect(410, 250, 641, 300))
            font = QtGui.QFont()
            font.setFamily(_fromUtf8("Courier"))
            font.setPixelSize(13)
            self.RewardsLabel.setFont(font)
            self.RewardsLabel.setObjectName(_fromUtf8("RewardsLabel"))
        self.EnableStaking = QtGui.QCheckBox(self.tab_2)
        self.EnableStaking.setGeometry(QtCore.QRect(10, 100, 641, 31))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.EnableStaking.setFont(font)
        self.EnableStaking.setObjectName(_fromUtf8("EnableStaking"))
        self.ColdStakingIP = QtGui.QTextEdit(self.tab_2)
        self.ColdStakingIP.setGeometry(QtCore.QRect(10, 40, 591, 41))
        self.ColdStakingIP.setObjectName(_fromUtf8("ColdStakingIP"))
        self.AddRemoveVotes = QtGui.QPushButton(self.tab_2)
        self.AddRemoveVotes.setGeometry(QtCore.QRect(10, 150, 191, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.AddRemoveVotes.setFont(font)
        self.AddRemoveVotes.setObjectName(_fromUtf8("AddRemoveVotes"))
        self.CountVotes = QtGui.QPushButton(self.tab_2)
        self.CountVotes.setGeometry(QtCore.QRect(210, 150, 191, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.CountVotes.setFont(font)
        self.CountVotes.setObjectName(_fromUtf8("CountVotes"))
        self.AddAccounts = QtGui.QPushButton(self.tab_2)
        self.AddAccounts.setGeometry(QtCore.QRect(410, 150, 241, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.AddAccounts.setFont(font)
        self.AddAccounts.setObjectName(_fromUtf8("AddAccounts"))

        self.DonateStake = QtGui.QPushButton(self.tab_2)
        self.DonateStake.setGeometry(QtCore.QRect(410, 570, 241, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        self.DonateStake.setFont(font)
        self.DonateStake.setObjectName(_fromUtf8("DonateStake"))

        self.listWidget = QtGui.QListWidget(self.tab_2)
        self.listWidget.setGeometry(QtCore.QRect(10, 210, 391, 401))
        self.listWidget.setObjectName(_fromUtf8("listWidget"))
        self.PeggingVote = QtGui.QComboBox(self.tab_2)
        self.PeggingVote.setGeometry(QtCore.QRect(410, 210, 241, 41))
        self.PeggingVote.setObjectName(_fromUtf8("PeggingVote"))
        self.PeggingVote.addItem(_fromUtf8(""))
        self.PeggingVote.addItem(_fromUtf8(""))
        self.PeggingVote.addItem(_fromUtf8(""))
        self.PeggingVote.addItem(_fromUtf8(""))
        self.PeggingVote.addItem(_fromUtf8(""))
        self.SettingsTabs.addTab(self.tab_2, _fromUtf8(""))

        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            self.tab_3 = QtGui.QWidget()
            self.tab_3.setObjectName(_fromUtf8("tab_3"))
            font = QtGui.QFont()
            font.setFamily(_fromUtf8("Courier"))
            font.setPixelSize(13)
            self.EnableBridge = QtGui.QCheckBox(self.tab_3)
            self.EnableBridge.setGeometry(QtCore.QRect(10, 10, 641, 31))
            self.EnableBridge.setFont(font)
            self.EnableBridge.setObjectName(_fromUtf8("EnableBridge"))
            self.BridgeInfo = QtGui.QTextEdit(self.tab_3)
            self.BridgeInfo.setAlignment(QtCore.Qt.AlignLeft)
            self.BridgeInfo.setGeometry(QtCore.QRect(10, 50, 641, 500))
            self.BridgeInfo.setMaximumSize(QtCore.QSize(641, 16777215))
            self.BridgeInfo.setReadOnly(True)
            self.BridgeInfo.setFont(font)
            self.BridgeInfo.setObjectName(_fromUtf8("BridgeInfo"))
            self.SettingsTabs.addTab(self.tab_3, _fromUtf8(""))
            self.EnableBridge.toggled.connect(self.BridgeThis)
        ApplyCSS(self,1,1)

        self.retranslateUi(Form)
        self.SettingsTabs.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(Form)

        self.RunSetupWizard.clicked.connect(self.RunWizard)
        self.ShowReputation.clicked.connect(self.ShowRep)
        self.EditProfiles.clicked.connect(self.MyProfiles)
        self.Info.clicked.connect(self.ProxyInfo)
        self.EnableStaking.clicked.connect(self.StakeNotify)

        self.AddAccounts.clicked.connect(self.AddAccount)
        self.AddRemoveVotes.clicked.connect(lambda: self.AddVote())
        self.CountVotes.clicked.connect(self.CountMyVotes)
        self.DonateStake.clicked.connect(self.DonateMyStake)

        self.PeggingVote.connect(self.PeggingVote,QtCore.SIGNAL("currentIndexChanged(int)"),self.PegVote)
        self.SettingsTabs.connect(self.SettingsTabs,QtCore.SIGNAL("currentChanged(int)"),self.changetab)
        
        QtCore.QObject.connect(self.listWidget, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.ClearVote)
    def retranslateUi(self, Form):
        self.ProxyLabel.setText(Gtranslate("Proxy/Tor:"))
        self.RunSetupWizard.setText(Gtranslate("Run Setup Wizard"))
        self.ShowReputation.setText(Gtranslate("Show my Reputation"))
        self.EditProfiles.setText(Gtranslate("Edit Profiles"))
        self.ActivateAntiKeylogger.setText(Gtranslate("Activate Anti-Keylogger Virtual Keypad"))
        self.DontSavePasswords.setText(Gtranslate("Do not Save Email Passwords, Login Manually"))
        self.FilterCurrencies.setText(Gtranslate("Filter out other currencies from the markets"))
        self.ClearKeysOnExit.setText(Gtranslate("Clear Keys Location From Config On Exit"))
        self.DebugOnExit.setText(Gtranslate("Create Debug File on Exit"))
        self.NetworkConnections.setText(Gtranslate("Network Connections: "))
        self.SettingsTabs.setTabText(self.SettingsTabs.indexOf(self.tab), Gtranslate("General Settings"))
        self.ColdStakingLabel.setText(Gtranslate("Cold Staking IP Address (Stake using 2 Step Send):"))
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            self.RewardsLabel.setText(Gtranslate("Rewards:\n\nMajority Liquid-\n5\n\nMajority Reserve-\n10\n\nFrozen Reserve/Liquid-\n20\n\nVoluntarily Frozen Liquid-\n40"))
        self.EnableStaking.setText(Gtranslate("Enable Staking (when account is unlocked)"))
        self.AddRemoveVotes.setText(Gtranslate("Add Vote"))
        self.CountVotes.setText(Gtranslate("Count Votes"))
        self.AddAccounts.setText(Gtranslate("Stake Multiple Accounts"))
        self.DonateStake.setText(Gtranslate("Donate Stake Profits"))
        self.PeggingVote.setItemText(0, Gtranslate("Automate Pegging Vote"))
        self.PeggingVote.setItemText(1, Gtranslate("Vote To Deflate/Freeze Supply"))
        self.PeggingVote.setItemText(2, Gtranslate("Vote To Inflate/Unfreeze Supply"))
        self.PeggingVote.setItemText(3, Gtranslate("Vote To Maintain Supply"))
        self.PeggingVote.setItemText(4, Gtranslate("Do Not Vote On Supply"))
        self.SettingsTabs.setTabText(self.SettingsTabs.indexOf(self.tab_2), Gtranslate("Mining/Staking and Voting"))
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            self.BridgeInfo.setText(Gtranslate("Information will display once administration is enabled"))
            self.EnableBridge.setText(Gtranslate("Enable Automatic Bridge Administration"))
            self.SettingsTabs.setTabText(self.SettingsTabs.indexOf(self.tab_3), Gtranslate("Bridge Administration"))
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def Load(self):
        global AdvanceArray, isdownloading, connectioncount, BridgeAdmin
        self.PopulateVotes()
        if 'pegging' in CoinSelect:
            self.PeggingVote.show()
            self.PegVote('1')
        else:
            self.PeggingVote.hide()
        try:
            self.connectioncount=connectioncount
            if self.connectioncount=="":
                self.connectioncount="Loading..."
            self.NetworkConnections.setText(Gtranslate("Network Connections: ")+self.connectioncount)
        except:
            pass
        if 'MySettings' not in AdvanceArray:
            AdvanceArray['MySettings']={'Proxy':'', 'AntiLogger':False, 'ManualLogin':False, 'ClearLocation':False, 'FilterOther':False, 'CreateDebug':False, 'Staking':True, 'ColdStake':'', 'PeggingVote':0, 'Voting':[]}
        if 'EnableBridge' not in AdvanceArray['MySettings']:
            AdvanceArray['MySettings']['EnableBridge'] = False
        if 'pegging' in CoinSelect:
            if AdvanceArray['MySettings']['EnableBridge']:
                self.EnableBridge.setCheckState(2)
                BridgeAdmin = True
            else:
                self.EnableBridge.setCheckState(0)
                BridgeAdmin = False
        if AdvanceArray['MySettings']['CreateDebug']:
            UpdateCfg('#Debug#',"1")
            self.DebugOnExit.setCheckState(2)
        else:
            UpdateCfg('#Debug#',"0")
            self.DebugOnExit.setCheckState(0)
        self.ColdStakingIP.setText(AdvanceArray['MySettings']['ColdStake'])
        if AdvanceArray['MySettings']['Proxy']!='':
            try:
                AdvanceArray['MySettings']['Proxy']=AdvanceArray['MySettings']['Proxy'].replace("http://","")
                AdvanceArray['MySettings']['Proxy']=AdvanceArray['MySettings']['Proxy'].replace("https://","")
                url, port = AdvanceArray['MySettings']['Proxy'].split(":",1)
                socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, url, int(port))
                socket.socket = socks.socksocket
                socket.create_connection = create_connection
                try:
                    x = rget('https://ip.42.pl/raw')
                except:
                    x = rget('https://duckduckgo.com')
                    print "Proxy failed"
                self.ProxyEdit.setText(AdvanceArray['MySettings']['Proxy'])
            except:
                AdvanceArray['MySettings']['Proxy']=''
                self.ProxyEdit.setText("")
                socket.socket = socket_original
                socket.create_connection = connection_original
        else:
            socket.socket = socket_original
            socket.create_connection = connection_original
        if AdvanceArray['MySettings']['AntiLogger']:
            self.ActivateAntiKeylogger.setCheckState(2)
        else:
            self.ActivateAntiKeylogger.setCheckState(0)
        if AdvanceArray['MySettings']['ManualLogin']:
            self.DontSavePasswords.setCheckState(2)
        else:
            self.DontSavePasswords.setCheckState(0)
        if AdvanceArray['MySettings']['ClearLocation']:
            self.ClearKeysOnExit.setCheckState(2)
        else:
            self.ClearKeysOnExit.setCheckState(0)
        if AdvanceArray['MySettings']['FilterOther']:
            self.FilterCurrencies.setCheckState(2)
        else:
            self.FilterCurrencies.setCheckState(0)
        if AdvanceArray['MySettings']['Staking']:
            self.EnableStaking.setCheckState(2)
        else:
            self.EnableStaking.setCheckState(0)
    def BridgeThis(self):
        global BridgeAdmin, MySettingsInfo
        if self.EnableBridge.isChecked():
            BridgeAdmin = True
            AdvanceArray['MySettings']['EnableBridge'] = True
            self.BridgeInfo.setText(Gtranslate("Loading bridge information..."))
            MySettingsInfo = "Loading bridge information..."
        else:
            BridgeAdmin = False
            AdvanceArray['MySettings']['EnableBridge'] = False
            self.BridgeInfo.setText(Gtranslate("Information will be displayed once administration is enabled. You will need altcoins to manage each bridge to vote on supply and merkles. The costs are typically low because efficient networks are used. It is important for all users who manage bridges to coordinate in order to synchronize AMMs. This would require replacing the line in bridge.htm that specifies the pairs everyone wishes to actively maintain. This helps the users so their transactions are not denied on exchanges such as Uniswap due to the contract being out of sync. For security users still must manage this manually."))
    def changetab(self):
        pass
    def closeEvent(self, event):
        global AdvanceArray, HaloRPC
        try:
            if self.DebugOnExit.isChecked():
                AdvanceArray['MySettings']['CreateDebug']=True
                UpdateCfg('#Debug#',"1")
            else:
                AdvanceArray['MySettings']['CreateDebug']=False
                UpdateCfg('#Debug#',"0")
            txt=self.ProxyEdit.toPlainText()
            txt=str(txt)
            if txt==" ":
                txt=""
            if txt=="":
                AdvanceArray['MySettings']['Proxy']=''
                socket.socket = socket_original
                socket.create_connection = connection_original
            else:
                try:
                    AdvanceArray['MySettings']['Proxy']=txt
                    AdvanceArray['MySettings']['Proxy']=AdvanceArray['MySettings']['Proxy'].replace("http://","")
                    AdvanceArray['MySettings']['Proxy']=AdvanceArray['MySettings']['Proxy'].replace("https://","")
                    url, port = AdvanceArray['MySettings']['Proxy'].split(":",1)
                    socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, url, int(port))
                    socket.socket = socks.socksocket
                    socket.create_connection = create_connection
                    try:
                        x = rget('https://ip.42.pl/raw')
                    except:
                        x = rget('https://duckduckgo.com')
                        print "Proxy failed"
                except:
                    socket.socket = socket_original
                    socket.create_connection = connection_original
                    AdvanceArray['MySettings']['Proxy']=''
                    self.ProxyEdit.setText("")
                    QuestionBox("The proxy was not able to connect.", "OK")
            if self.ActivateAntiKeylogger.isChecked():
                AdvanceArray['MySettings']['AntiLogger']=True
            else:
                AdvanceArray['MySettings']['AntiLogger']=False
            if self.DontSavePasswords.isChecked():
                AdvanceArray['MySettings']['ManualLogin']=True
            else:
                if AdvanceArray['MySettings']['ManualLogin']:
                    QuestionBox("Because you are no longer requesting to manually login, you will need to add your Email address again.", "OK")
                    AdvanceArray['MySettings']['ManualLogin']=False
                    window.NewEmail()
                AdvanceArray['MySettings']['ManualLogin']=False
            if self.ClearKeysOnExit.isChecked():
                AdvanceArray['MySettings']['ClearLocation']=True
            else:
                AdvanceArray['MySettings']['ClearLocation']=False
            if self.FilterCurrencies.isChecked():
                AdvanceArray['MySettings']['FilterOther']=True
            else:
                AdvanceArray['MySettings']['FilterOther']=False
            if self.EnableStaking.isChecked():
                AdvanceArray['MySettings']['Staking']=True
            else:
                AdvanceArray['MySettings']['Staking']=False
            txt=self.ColdStakingIP.toPlainText()
            txt=str(txt)
            if txt==" ":
                txt=""
            if txt=="":
                AdvanceArray['MySettings']['ColdStake']=''
            else:
                AdvanceArray['MySettings']['ColdStake']=txt
            if AdvanceArray['MySettings']['ColdStake']!='':
                try:
                    res=False
                    HaloRPC = xmlrpclib.ServerProxy('http://' + AdvanceArray['MySettings']['ColdStake'] + ':55779')
                    res = HaloRPC.ShowHalo("",'yes')
                    if res=="AlreadyStaking":
                        QuestionBox('Your cold stake IP address is already cold staking. When cold staking only one of the computers have to enter the IP address.',' OK ')
                    if res!=True:
                        float('a')
                except:
                    traceback.print_exc()
                    AdvanceArray['MySettings']['ColdStake']=''
                    QuestionBox(Gtranslate('Your cold stake IP address did not respond. If you are trying to communicate over the local network, please use the local IP address of the computer you are communicating with and make sure there is no firewall restrictions. If you are trying to communicate to another computer over the internet, that is a more demanding challenge. You might have to open port 55779 and also investigate any firewall or ISP issues. Some ISPs do not allow port forwarding. We do not diagnose networking, port forwarding or router problems. So please make sure the IP address entered is correct. Make sure the other computer is running ') + CoinSelect['HaloName'] + Gtranslate(' at the same time you add the IP address.'), ' OK ')
                    return                
        except:
            traceback.print_exc()
        event.accept()
    def RunWizard(self):
        SetupWizard.myindex=0
        SetupWizard.retranslateUi(SetupWizard)
        SetupWizard.show()
    def ShowRep(self):
        global Markets
        ewindow=QtGui.QDialog()
        ewindow.resize(500, 500)
        Display = QtWebKit.QWebView(ewindow)
        Display.setGeometry(QtCore.QRect(10, 10, 480, 480))
        try:
            pubs=get_ordered_pubkeys(PrivKeyFilename1)
            public=pubs[0]
            data=""
            data+="User Profile:<br />"+public[:10]+"<br /><br />"
            if Markets['Reputation'][public]['Reputation']['Reviews']==[] and Markets['Reputation'][public]['Reputation']['Rating'] == 0:
                data+="New User!<br />"
            data+="Rating: "+ str(Markets['Reputation'][public]['Reputation']['Rating'])+"<br />"
            if 'Ratio' in Markets['Reputation'][public]['Reputation']:
                x=Markets['Reputation'][public]['Reputation']['Ratio'][0]
                y=Markets['Reputation'][public]['Reputation']['Ratio'][1]
                data+="Contracts Completed: "+str(x)+"<br />"
                if x<y:
                    data+="Contracts Lost: "+str(y-x)+"<br />"
                data+="Success Rate: "+str(Decimal(int((Decimal(x)/Decimal(y))*Decimal(1000)))/Decimal(10))+"%<br />"
            data+="<br />Reviews:<br />"
            r=1
            for Review in Markets['Reputation'][public]['Reputation']['Reviews']:
                data+=str(r)+")<br />" +Review+"<br />"
                r+=1
        except:
            data=""
            print "EXCEPTION LOADING PROFILE"
        Display.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+data+"</span></p></body></html>")

        ewindow.setWindowTitle("Reputation")
        ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        ewindow.exec_()        
    def MyProfiles(self):
        ewindow=QtGui.QDialog()
        ewindow.resize(305, 610)

        ContactSelectConfirm = QtGui.QComboBox(ewindow)
        ContactSelectConfirm.setGeometry(QtCore.QRect(20, 50, 211, 40))
        ContactSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        ContactSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        ContactSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        ContactSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        ContactSelectConfirm.setObjectName(_fromUtf8("ContactSelectConfirm"))
        MailingSelectConfirm = QtGui.QComboBox(ewindow)
        MailingSelectConfirm.setGeometry(QtCore.QRect(20, 120, 211, 40))
        MailingSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        MailingSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        MailingSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        MailingSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        MailingSelectConfirm.setObjectName(_fromUtf8("MailingSelectConfirm"))
        BankSelectConfirm = QtGui.QComboBox(ewindow)
        BankSelectConfirm.setGeometry(QtCore.QRect(20, 190, 211, 40))
        BankSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        BankSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        BankSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        BankSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        BankSelectConfirm.setObjectName(_fromUtf8("BankSelectConfirm"))
        WUSelectConfirm = QtGui.QComboBox(ewindow)
        WUSelectConfirm.setGeometry(QtCore.QRect(20, 260, 211, 40))
        WUSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        WUSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        WUSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        WUSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        WUSelectConfirm.setObjectName(_fromUtf8("WUSelectConfirm"))
        MGSelectConfirm = QtGui.QComboBox(ewindow)
        MGSelectConfirm.setGeometry(QtCore.QRect(20, 330, 211, 40))
        MGSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        MGSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        MGSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        MGSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        MGSelectConfirm.setObjectName(_fromUtf8("MGSelectConfirm"))
        DebitSelectConfirm = QtGui.QComboBox(ewindow)
        DebitSelectConfirm.setGeometry(QtCore.QRect(20, 400, 211, 40))
        DebitSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        DebitSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        DebitSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        DebitSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        DebitSelectConfirm.setObjectName(_fromUtf8("DebitSelectConfirm"))
        OtherSelectConfirm = QtGui.QComboBox(ewindow)
        OtherSelectConfirm.setGeometry(QtCore.QRect(20, 470, 211, 40))
        OtherSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        OtherSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        OtherSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        OtherSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        OtherSelectConfirm.setObjectName(_fromUtf8("OtherSelectConfirm"))
        CashSelectConfirm = QtGui.QComboBox(ewindow)
        CashSelectConfirm.setGeometry(QtCore.QRect(20, 540, 211, 40))
        CashSelectConfirm.setMinimumSize(QtCore.QSize(0, 40))
        CashSelectConfirm.setMaximumSize(QtCore.QSize(16777215, 40))
        CashSelectConfirm.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        CashSelectConfirm.setStyleSheet(_fromUtf8("font: 16px \"Arial\";\n"
        "color: #24282C;\n"
        "background-color:rgba(251, 251, 251, 80%);\n"
        "border-radius: 8px;\n"
        "     border-style: inset;\n"
        "border-width: 2px;\n"
        "border-color: lightgrey;"))
        CashSelectConfirm.setObjectName(_fromUtf8("CashSelectConfirm"))

        ContactConfirm = QtGui.QLabel(ewindow)
        ContactConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        ContactConfirm.setGeometry(QtCore.QRect(20, 20, 201, 29))
        ContactConfirm.setObjectName(_fromUtf8("ContactConfirm"))
        MailingConfirm = QtGui.QLabel(ewindow)
        MailingConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        MailingConfirm.setGeometry(QtCore.QRect(20, 90, 201, 29))
        MailingConfirm.setObjectName(_fromUtf8("MailingConfirm"))
        BankConfirm = QtGui.QLabel(ewindow)
        BankConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        BankConfirm.setGeometry(QtCore.QRect(20, 160, 201, 29))
        BankConfirm.setObjectName(_fromUtf8("BankConfirm"))
        WUConfirm = QtGui.QLabel(ewindow)
        WUConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        WUConfirm.setGeometry(QtCore.QRect(20, 230, 201, 29))
        WUConfirm.setObjectName(_fromUtf8("WUConfirm"))
        MGConfirm = QtGui.QLabel(ewindow)
        MGConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        MGConfirm.setGeometry(QtCore.QRect(20, 300, 201, 29))
        MGConfirm.setObjectName(_fromUtf8("MGConfirm"))
        DebitConfirm = QtGui.QLabel(ewindow)
        DebitConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        DebitConfirm.setGeometry(QtCore.QRect(20, 370, 201, 29))
        DebitConfirm.setObjectName(_fromUtf8("DebitConfirm"))
        OtherConfirm = QtGui.QLabel(ewindow)
        OtherConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        OtherConfirm.setGeometry(QtCore.QRect(20, 440, 201, 29))
        OtherConfirm.setObjectName(_fromUtf8("OtherConfirm"))
        CashConfirm = QtGui.QLabel(ewindow)
        CashConfirm.setStyleSheet(_fromUtf8("font: 14px \"Courier\";\ncolor: #24282C;"))
        CashConfirm.setGeometry(QtCore.QRect(20, 510, 201, 29))
        CashConfirm.setObjectName(_fromUtf8("CashConfirm"))
        
        ContactEdit = QtGui.QPushButton(ewindow)
        ContactEdit.setGeometry(QtCore.QRect(230, 50, 51, 41))
        ContactEdit.setObjectName(_fromUtf8("ContactEdit"))
        AddressEdit = QtGui.QPushButton(ewindow)
        AddressEdit.setGeometry(QtCore.QRect(230, 120, 51, 41))
        AddressEdit.setObjectName(_fromUtf8("AddressEdit"))
        BankEdit = QtGui.QPushButton(ewindow)
        BankEdit.setGeometry(QtCore.QRect(230, 190, 51, 41))
        BankEdit.setObjectName(_fromUtf8("BankEdit"))
        WUEdit = QtGui.QPushButton(ewindow)
        WUEdit.setGeometry(QtCore.QRect(230, 260, 51, 41))
        WUEdit.setObjectName(_fromUtf8("WUEdit"))
        DebitEdit = QtGui.QPushButton(ewindow)
        DebitEdit.setGeometry(QtCore.QRect(230, 400, 51, 41))
        DebitEdit.setObjectName(_fromUtf8("DebitEdit"))
        MGEdit = QtGui.QPushButton(ewindow)
        MGEdit.setGeometry(QtCore.QRect(230, 330, 51, 41))
        MGEdit.setObjectName(_fromUtf8("MGEdit"))
        OtherEdit = QtGui.QPushButton(ewindow)
        OtherEdit.setGeometry(QtCore.QRect(230, 470, 51, 41))
        OtherEdit.setObjectName(_fromUtf8("OtherEdit"))
        CashEdit = QtGui.QPushButton(ewindow)
        CashEdit.setGeometry(QtCore.QRect(230, 540, 51, 41))
        CashEdit.setObjectName(_fromUtf8("CashEdit"))        
        
        ContactConfirm.setText(Gtranslate("Additional Contact Info:"))
        MailingConfirm.setText(Gtranslate("Mailing Address:"))
        BankConfirm.setText(Gtranslate("Bank Wire/Direct Deposit:"))
        WUConfirm.setText(Gtranslate("Western Union:"))
        MGConfirm.setText(Gtranslate("MoneyGram:"))
        DebitConfirm.setText(Gtranslate("Prepaid Debit Cards:"))
        OtherConfirm.setText(Gtranslate("Other Funding Options:"))
        CashConfirm.setText(Gtranslate("Cash in The Mail:"))
        
        ContactEdit.setText(Gtranslate("Edit"))
        AddressEdit.setText(Gtranslate("Edit"))
        BankEdit.setText(Gtranslate("Edit"))
        WUEdit.setText(Gtranslate("Edit"))
        MGEdit.setText(Gtranslate("Edit"))
        OtherEdit.setText(Gtranslate("Edit"))
        CashEdit.setText(Gtranslate("Edit"))
        DebitEdit.setText(Gtranslate("Edit"))

        def LoadProfiles():
            global AdvanceArray
            ContactSelectConfirm.clear()
            MailingSelectConfirm.clear()
            CashSelectConfirm.clear()
            OtherSelectConfirm.clear()
            DebitSelectConfirm.clear()
            MGSelectConfirm.clear()
            WUSelectConfirm.clear()
            BankSelectConfirm.clear()
            multisig,mscript=create_multisig_address(PrivKeyFilename1)
            for i in AdvanceArray[multisig]['Profiles']['Contact']:            
                ContactSelectConfirm.addItem(i['string'].replace("\n", "  "))                
            for i in AdvanceArray[multisig]['Profiles']['Mail']:            
                MailingSelectConfirm.addItem(i['string'].replace("\n", "  "))
            for i in AdvanceArray[multisig]['Profiles']['Cash']:            
                CashSelectConfirm.addItem(i['string'].replace("\n", "  "))                
            for i in AdvanceArray[multisig]['Profiles']['Other']:            
                OtherSelectConfirm.addItem(i['string'].replace("\n", "  "))
            for i in AdvanceArray[multisig]['Profiles']['Card']:            
                DebitSelectConfirm.addItem(i['string'].replace("\n", "  "))
            for i in AdvanceArray[multisig]['Profiles']['MG']:            
                MGSelectConfirm.addItem(i['string'].replace("\n", "  "))
            for i in AdvanceArray[multisig]['Profiles']['WU']:            
                WUSelectConfirm.addItem(i['string'].replace("\n", "  "))                                        
            for i in AdvanceArray[multisig]['Profiles']['Bank']:            
                BankSelectConfirm.addItem(i['string'].replace("\n", "  "))                
        def Edit(index=0):
            Templates.Window.Pages.setCurrentIndex(index)
            Templates.LoadProfiles()
            Templates.dontremoveonupdate=0
            Templates.returntoconfirm=1
            response=Templates.Window.exec_()
            Templates.returntoconfirm=0
            Templates.Window.hide()
            Templates.LoadProfiles()
            LoadProfiles()

        LoadProfiles()
        BankEdit.clicked.connect(lambda: Edit(1))
        WUEdit.clicked.connect(lambda: Edit(2))
        MGEdit.clicked.connect(lambda: Edit(3))
        DebitEdit.clicked.connect(lambda: Edit(4))
        OtherEdit.clicked.connect(lambda: Edit(5))
        CashEdit.clicked.connect(lambda: Edit(6))
        AddressEdit.clicked.connect(lambda: Edit(7))
        ContactEdit.clicked.connect(lambda: Edit(8))
        
        ewindow.setWindowTitle("Edit Profiles")
        ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        ewindow.exec_()   
    def ProxyInfo(self, event):
        QuestionBox("Enter the proxy in this format:\nIP:port\n\nFor example TOR would look like this...\n127.0.0.1:9150", "OK")
    def AddAccount(self, event):
        global AdvanceArray
        ewindow=QtGui.QDialog()
        ewindow.resize(300, 500)
        AccountList = QtGui.QListWidget(ewindow)
        AccountList.setGeometry(QtCore.QRect(10, 10, 280, 435))
        AccountList.setObjectName(_fromUtf8("AccountList"))
        AddStake = QtGui.QPushButton(ewindow)
        AddStake.setGeometry(QtCore.QRect(55, 450, 191, 41))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)
        AddStake.setFont(font)
        AddStake.setObjectName(_fromUtf8("AddStake"))
        AddStake.setText(Gtranslate("Add Account"))
        QuestionBox("This will allow you to stake accross multiple accounts. It saves your passwords and key locations in memory to unlock the accounts. You can clear accounts from the list by clicking on them. To Cold stake across multiple accounts, load only one key on this computer and load the other key on the second computer.", "OK")
        if 'multinotify' not in AdvanceArray:
            res=QuestionBox("Please note: You should load each account you wish to stake at least once from the file menu so the wallet can be made aware of the account and watch for incoming inputs.", " OK ", " Do not show this message again. ")
            if res==1:
                AdvanceArray['multinotify']=1
        if 'StakingAccounts' not in AdvanceArray:
            AdvanceArray['StakingAccounts']={}
        def PopulateList():
            AccountList.clear()
            for key, value in AdvanceArray['StakingAccounts'].iteritems():
                text=str(key)
                if AdvanceArray['StakingAccounts'][key]['key2']=='':
                    text='Cold Stake: ' + text
                AccountList.addItem(str(text))
        def ClearItem(item):
            global AdvanceArray
            t=str(item.text())
            t=t.replace('Cold Stake: ', '')
            res=QuestionBox("Do you wish to remove this account from the list?"," Yes ", " No ")
            if res==0:
                AdvanceArray['StakingAccounts'].pop(t, None)
            PopulateList()
        def StakeTHIS():
            global AdvanceArray, isdownloading, BLK, rescanning, WatchlistQueue
            QuestionBox("Please open the first private key."," OK ")
            path = QtGui.QFileDialog.getOpenFileName(ewindow,Gtranslate("Please open the private key."),MacDir()+"","Private Key (*.private)")
            path = strOUT(strIN(path))
            if path == '':
                return
            dir1=os.path.dirname(path)
            key=os.path.basename(path)
            key=str(key)
            dir1=str(dir1)
            text,check=DecryptPrivateKey(key,dir1,"5", "", "1")
            if text=="Failed":
                QuestionBox("Incorrect Password!", " OK ")
                return
            if check=="2":#No password
                text=""
            else:
                text=str(text)
            msg,multiscript=create_multisig_address(key, dir1)
            AdvanceArray['StakingAccounts'][msg]={}
            AdvanceArray['StakingAccounts'][msg]['key1']=key
            AdvanceArray['StakingAccounts'][msg]['dir1']=dir1
            AdvanceArray['StakingAccounts'][msg]['pw1']=password.EncryptWithAES("Halo Master", text)            
            AdvanceArray['StakingAccounts'][msg]['key2']=''
            AdvanceArray['StakingAccounts'][msg]['dir2']=''
            AdvanceArray['StakingAccounts'][msg]['pw2']=''
            QuestionBox("Please open the second private key. You can also cancel to only load one key and cold stake this account."," OK ")
            path = QtGui.QFileDialog.getOpenFileName(ewindow,Gtranslate("Please open the private key."),MacDir()+"","Private Key (*.private)")
            path = strOUT(strIN(path))
            if path == '':
                PopulateList()
                return
            dir1=os.path.dirname(path)
            key=os.path.basename(path)
            key=str(key)
            dir1=str(dir1)
            text,check=DecryptPrivateKey(key,dir1,"5", "", "1")
            if text=="Failed":
                QuestionBox("Incorrect Password!", " OK ")
                return
            if check=="2":#No password
                text=""
            else:
                text=str(text)
            AdvanceArray['StakingAccounts'][msg]['key2']=key
            AdvanceArray['StakingAccounts'][msg]['dir2']=dir1
            AdvanceArray['StakingAccounts'][msg]['pw2']=password.EncryptWithAES("Halo Master", text)
            PopulateList()
            try:
                WatchlistQueue.append("0"+msg)
                SaveOtherdata()
                self.imported=1
            except:
                print "Was not able to import address: " + str(msg)

        PopulateList()
        AddStake.clicked.connect(lambda: StakeTHIS())
        QtCore.QObject.connect(AccountList, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), ClearItem)

        ewindow.setWindowTitle("Stake Multiple Accounts")
        ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.imported=0
        ewindow.exec_()
        if self.imported==1:
            res=QuestionBox("Since you have imported some new accounts to stake with, we recommend a rescan of the blockchain. This can take several minutes to complete. Would you like to do rescan now?", " Yes ", " No ")
            if res==0:
                rescanning=1
    def PegVote(self, update=''):
        global voteforever
        found=0   
        if self.PeggingVote.currentIndex()==0:
            #It is possible to offer multiple algorithms here. For now we track the peak price
            i=0
            for vote in AdvanceArray['MySettings']['Voting']:
                if vote['vote']=='pegautomatic':
                    if update=='1':
                        AdvanceArray['MySettings']['Voting'].pop(i)
                    else:
                        found=1
                if vote['vote']=='peginflate' or vote['vote']=='pegdeflate' or vote['vote']=='pegnochange':
                    AdvanceArray['MySettings']['Voting'].pop(i)
                i+=1
            if found==0:
                self.AddVote('pegautomatic', str(200*voteforever))
        if self.PeggingVote.currentIndex()==1:
            i=0
            for vote in AdvanceArray['MySettings']['Voting']:
                if vote['vote']=='pegdeflate':
                    if update=='1':
                        AdvanceArray['MySettings']['Voting'].pop(i)
                    else:
                        found=1
                if vote['vote']=='peginflate' or vote['vote']=='pegautomatic' or vote['vote']=='pegnochange':
                    AdvanceArray['MySettings']['Voting'].pop(i)
                i+=1
            if found==0:
                self.AddVote('pegdeflate', str(100*voteforever))
        if self.PeggingVote.currentIndex()==2:
            i=0
            for vote in AdvanceArray['MySettings']['Voting']:
                if vote['vote']=='peginflate':
                    if update=='1':
                        AdvanceArray['MySettings']['Voting'].pop(i)
                    else:
                        found=1
                if vote['vote']=='pegautomatic' or vote['vote']=='pegdeflate' or vote['vote']=='pegnochange':
                    AdvanceArray['MySettings']['Voting'].pop(i)
                i+=1
            if found==0:
                self.AddVote('peginflate', str(100*voteforever))
        if self.PeggingVote.currentIndex()==3:
            i=0
            for vote in AdvanceArray['MySettings']['Voting']:
                if vote['vote']=='pegnochange':
                    if update=='1':
                        AdvanceArray['MySettings']['Voting'].pop(i)
                    else:
                        found=1
                if vote['vote']=='peginflate' or vote['vote']=='pegdeflate' or vote['vote']=='pegautomatic':
                    AdvanceArray['MySettings']['Voting'].pop(i)
                i+=1
            if found==0:
                self.AddVote('pegnochange', str(100*voteforever))
        if self.PeggingVote.currentIndex()==4:
            return
        self.PopulateVotes()
    def AddVote(self, text='', text2=''):
        global AdvanceArray
        burn=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            burn=1
            if text=='pegautomatic' or text=='peginflate' or text=='pegdeflate' or text=='pegnochange':
                burn=0
            if len(AdvanceArray['MySettings']['Voting'])>3:
                if text=='pegautomatic' or text=='peginflate' or text=='pegdeflate' or text=='pegnochange':
                    pass
                else:
                    if text=='':
                        QuestionBox('The maximum number of 5 addresses has been reached.', "OK")
                    return
        if len(AdvanceArray['MySettings']['Voting'])>20:
            QuestionBox('The maximum number of 20 addresses has been reached.', "OK")
            return
        if text=='':
            text, ok = QtGui.QInputDialog.getText(self, CoinSelect['HaloName'], Gtranslate('Enter the name of your vote (248 characters maximum):'))
            text=str(text)
            if len(text)>248:
                QuestionBox('The name of your vote cannot be more than 248 characters in length.', "OK")
                return
            if text=='':            
                return
            if text=='pegautomatic' or text=='peginflate' or text=='pegdeflate' or text=='pegnochange':
                QuestionBox('The name of your vote is reserved for the peg.', ' OK ')
                return
        if text2=='':
            text2, ok = QtGui.QInputDialog.getText(self, CoinSelect['HaloName'], Gtranslate('Enter the amount of times you wish to cast this vote:'))
            if text2=='':
                return
            try:
                text2=int(text2)
                if text2==0:
                    float('a')
            except:
                QuestionBox("You did not enter a valid quantity for the amount of votes to cast. Please try again.", "OK")
                return
        else:
            text2=int(text2)
        out=MakeCipherOutputs(text, burn)
        out=str(out[0])        
        AdvanceArray['MySettings']['Voting'].append({'vote':text,'quantity':text2, 'address': out})
        self.PopulateVotes()
    def PopulateVotes(self):
        global AdvanceArray
        self.listWidget.clear()
        for value in AdvanceArray['MySettings']['Voting']:
            if value['vote']=="**DONATETOTHISADDRESS**":
                text="Donate Stake To: " + str(value['address'])
            else:
                text=value['vote']+": Votes Remaining - "+ str(value['quantity'])
            self.listWidget.addItem(str(text))
    def ClearVote(self, item):
        global AdvanceArray
        t=str(item.text())
        t=t.split(':')[0]
        if t=="Donate Stake To":
            x=0
        else:
            for x in range(len(AdvanceArray['MySettings']['Voting'])):
                if t == AdvanceArray['MySettings']['Voting'][x]['vote']:
                    break
        res=QuestionBox("Do you wish to remove this item from the list?"," Yes ", " No ")
        if res==0:
            AdvanceArray['MySettings']['Voting'].pop(x)
        self.PopulateVotes()
    def CountMyVotes(self):
        global AdvanceArray
        ewindow=QtGui.QDialog()
        ewindow.resize(300, 500)

        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Courier"))
        font.setPixelSize(12)

        AddyLabel = QtGui.QLabel(ewindow)
        AddyLabel.setGeometry(QtCore.QRect(10, 10, 281, 31))
        AddyLabel.setFont(font)
        AddyLabel.setObjectName(_fromUtf8("Voting address to count: "))
        AddyLabel.setText(Gtranslate("Voting address to count: "))

        VoteBox = QtGui.QTextEdit(ewindow)
        VoteBox.setGeometry(QtCore.QRect(10, 60, 281, 31))
        VoteBox.setFont(font)
        VoteBox.setObjectName(_fromUtf8("Vote Box"))

        StartLabel = QtGui.QLabel(ewindow)
        StartLabel.setGeometry(QtCore.QRect(10, 100, 281, 31))
        StartLabel.setFont(font)
        StartLabel.setObjectName(_fromUtf8("Starting Counting At Block Number: "))
        StartLabel.setText(Gtranslate("Starting Counting At Block Number: "))

        StartBlock = QtGui.QTextEdit(ewindow)
        StartBlock.setGeometry(QtCore.QRect(10, 140, 281, 31))
        StartBlock.setFont(font)
        StartBlock.setObjectName(_fromUtf8("Start Block"))

        FinishLabel = QtGui.QLabel(ewindow)
        FinishLabel.setGeometry(QtCore.QRect(10, 180, 281, 31))
        FinishLabel.setFont(font)
        FinishLabel.setObjectName(_fromUtf8("Finish Counting At Block Number: "))
        FinishLabel.setText(Gtranslate("Finish Counting At Block Number: "))

        FinishBlock = QtGui.QTextEdit(ewindow)
        FinishBlock.setGeometry(QtCore.QRect(10, 220, 281, 31))
        FinishBlock.setFont(font)
        FinishBlock.setObjectName(_fromUtf8("Finish Block"))

        CountTHIS = QtGui.QPushButton(ewindow)
        CountTHIS.setGeometry(QtCore.QRect(10, 270, 131, 31))
        CountTHIS.setFont(font)
        CountTHIS.setObjectName(_fromUtf8("Count Votes"))
        CountTHIS.setText(Gtranslate("Count Votes"))

        self.CountProgress = QtGui.QProgressBar(ewindow)
        self.CountProgress.setGeometry(QtCore.QRect(10, 320, 281, 31))
        self.CountProgress.hide()

        MyResults = QtGui.QTextBrowser(ewindow)
        MyResults.setGeometry(QtCore.QRect(10, 360, 281, 31))

        def CountMe():
            self.stopcount=0
            addy=str(VoteBox.toPlainText())
            try:
                start=int(StartBlock.toPlainText())
                finish=int(FinishBlock.toPlainText())
                if start > finish:
                    float('a')
                if start==0 or finish==0:
                    float('a')
            except:
                QuestionBox("Not a valid amount for the start and finish blocks.", "OK")
                return
            res=CountVotes(addy,start,finish)
            if res==False or res=="The blockchain is busy, please try again later.":
                QuestionBox("Vote counting failed! Please try again.", "OK")
            MyResults.setText(str(res))
        CountTHIS.clicked.connect(lambda: CountMe())

        ewindow.setWindowTitle("Count Votes")
        ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        ewindow.exec_()
        self.stopcount=1
    def StakeNotify(self):
        global AdvanceArray
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if 'stakenotify' not in AdvanceArray:
            if len(Spendable)==1:
                mbox = QuestionBox("You only have one input. We recommend breaking for change, dividing your balance into smaller pieces before staking. This frees up more inputs and keeps your account more liquid because a stake can take up to 120 blocks to confirm. For more information on how coins work like cash, please read the documentation. Would you like to break for change now?", " Yes, I will enable staking after making change ", " No, please enable staking anyways ")
                AdvanceArray['stakenotify']=1
                if mbox != 1:
                    window.Tabs.setCurrentIndex(1)
                    window.BitPayTo.setText(str(multisig))
                    window.BitAmount.setText(str("0.0001"))
                    QuestionBox("Please review the information to confirm the address is your own. To break for change, you simply make a payment to yourself. When ready, simply click 'Send'.", "OK")
                    self.EnableStaking.setCheckState(0)
        if 'pegging' in CoinSelect:
            if 'votenotify' not in AdvanceArray:
                res = QuestionBox("This coin allows users to control the price stability by voting on the supply when you stake. By default the vote is automated however you may choose how you wish to vote for the health of the economy. This revolutionary feature gives you more control over the coin in a fair way. To keep voting constant, you must occasionally come back to this page for the vote count to refresh. This ensures that users are actively using the software.", " OK ", " Do not show this message again. ")
                if res==1:
                    AdvanceArray['votenotify']=1
            if 'algorithmnotify' not in AdvanceArray:
                res=QuestionBox("The current algorithm will try to maintain the peak price and volume with a slow yearly increase in price based on exchange rates. It is possible this algorithm will continue to improve with feedback. Using our API you might also wish to design your own algorithm.", " OK ", " Do not show this again. ")
                if res==1:
                    AdvanceArray['algorithmnotify']=1
            self.PegVote()
    def DonateMyStake(self):
        text, ok = QtGui.QInputDialog.getText(self, CoinSelect['HaloName'], Gtranslate('Enter the address you wish to donate to:'))
        text=str(text)
        test=1
        try:
            test=address_to_script(text)
        except:
            test=0
        if "BM-" in text or ":" in text or " " in text or test==0:
            res=QuestionBox("The address entered was invalid."," OK ")
            return
        try:
            if AdvanceArray['MySettings']['Voting'][0]['vote']=="**DONATETOTHISADDRESS**":
                AdvanceArray['MySettings']['Voting'][0]={'vote':"**DONATETOTHISADDRESS**",'quantity':1000000, 'address': text}
            else:
                AdvanceArray['MySettings']['Voting'].insert(0,{'vote':"**DONATETOTHISADDRESS**",'quantity':1000000, 'address': text})
        except:
            AdvanceArray['MySettings']['Voting'].insert(0,{'vote':"**DONATETOTHISADDRESS**",'quantity':1000000, 'address': text})        
        self.PopulateVotes()
class CustomTemplate(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(312, 248)
        
        self.verticalLayout_2 = QtGui.QVBoxLayout(Form)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.verticalLayout = QtGui.QVBoxLayout()
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))

        self.SendTo = QtGui.QLabel(Form)
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.SendTo.setFont(font)
        self.SendTo.setObjectName(_fromUtf8("SendTo"))
        self.verticalLayout.addWidget(self.SendTo)

        self.MarketSelect = QtGui.QComboBox(Form)
        self.MarketSelect.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.MarketSelect.setFont(font)
        self.MarketSelect.setObjectName(_fromUtf8("MarketSelect"))
        self.MarketSelect.addItem(_fromUtf8(""))
        self.verticalLayout.addWidget(self.MarketSelect)

        self.MarketSelectBox = QtGui.QLineEdit(Form)
        self.MarketSelectBox.setMaximumSize(QtCore.QSize(300, 16777215))
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.MarketSelectBox.setFont(font)
        self.MarketSelectBox.setObjectName(_fromUtf8("MarketSelectBox"))
        self.verticalLayout.addWidget(self.MarketSelectBox)
        self.MarketSelectBox.hide()

        self.AutoAccept = QtGui.QCheckBox(Form)
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.AutoAccept.setFont(font)
        self.AutoAccept.setCheckState(2)
        self.AutoAccept.setObjectName(_fromUtf8("AutoAccept"))
        self.verticalLayout.addWidget(self.AutoAccept)
        self.AllowCounter = QtGui.QCheckBox(Form)
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.AllowCounter.setFont(font)
        self.AllowCounter.setObjectName(_fromUtf8("AllowCounter"))
        self.verticalLayout.addWidget(self.AllowCounter)

        self.SupplyAdditional = QtGui.QCheckBox(Form)
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.SupplyAdditional.setFont(font)
        self.SupplyAdditional.setObjectName(_fromUtf8("SupplyAdditional"))
        self.verticalLayout.addWidget(self.SupplyAdditional)
        self.SupplyAdditional.setCheckState(2)

        self.AllowChat = QtGui.QCheckBox(Form)
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.AllowChat.setFont(font)
        self.AllowChat.setObjectName(_fromUtf8("AllowChat"))
        self.verticalLayout.addWidget(self.AllowChat)
        self.AllowChat.setCheckState(2)

        self.TrackPrice = QtGui.QCheckBox(Form)
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.TrackPrice.setFont(font)
        self.TrackPrice.setObjectName(_fromUtf8("TrackPrice"))
        self.verticalLayout.addWidget(self.TrackPrice)
        self.TrackPrice.setCheckState(2)        

        self.AcceptMe = QtGui.QPushButton(Form)
        self.AcceptMe.setMaximumSize(QtCore.QSize(100, 16777215))
        font = QtGui.QFont()
        font.setPixelSize(15)
        self.AcceptMe.setFont(font)
        self.AcceptMe.setObjectName(_fromUtf8("pushButton"))
        self.verticalLayout.addWidget(self.AcceptMe)
        self.verticalLayout_2.addLayout(self.verticalLayout)

        ApplyCSS(self)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        self.AcceptMe.clicked.connect(self.Accept)

        self.MarketSelect.connect(self.MarketSelect,QtCore.SIGNAL("currentIndexChanged(int)"),self.MarketChange)
    def retranslateUi(self, Form):
        self.SendTo.setText(_translate("","Send Contract To:"))
        self.MarketSelect.setItemText(0, "Private Email/BitMessage/Coin Address...")
        self.AutoAccept.setText(_translate("","Automatically Accept First Valid Offer"))
        self.AllowCounter.setText(_translate("","Allow Counter-Offers/Bids"))
        self.SupplyAdditional.setText(_translate("","Supply Additional Contact Information"))
        self.AllowChat.setText(_translate("","Allow Chat In Escrow"))
        self.TrackPrice.setText(_translate("","Allow Price Tracking"))
        self.AcceptMe.setText(_translate("","Accept"))
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def MarketChange(self):
        text=str(self.MarketSelect.currentText())
        if text == "Private Email/BitMessage/Coin Address...":
            self.MarketSelectBox.show()
        else:
            self.MarketSelectBox.hide()
    def UpdateMarketList(self):
        global Markets
        self.MarketSelect.blockSignals(True)
        try:
            list1=[]
            for name, mark in Markets['MyMarkets'].iteritems():
                list1.append(name)
            list1.sort()
            list1.append("Private Email/BitMessage/Coin Address...")
            self.MarketSelect.clear()
            self.MarketSelect.addItems(list1)
            index = self.MarketSelect.findText(Markets['Current'], QtCore.Qt.MatchFixedString)
            if index >= 0:
                 self.MarketSelect.setCurrentIndex(index)
        except:
            traceback.print_exc()
            pass
        self.MarketSelect.blockSignals(False)
    def Accept(self):
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        Templates.Data={}
        Templates.reply={}
        window.ClearPage()
        global AdvanceArray, GlobalID, GlobalImage
        GlobalImage=""
        GlobalID=""
        if multisig not in AdvanceArray:
            AdvanceArray[multisig]={}
        if self.SupplyAdditional.isChecked():
            Templates.Window.Pages.setCurrentIndex(8)
            Templates.LoadProfiles()
            Templates.dontremoveonupdate=0
            Templates.returntoconfirm=1
            response=Templates.Window.exec_()
            if response==0:
                QuestionBox("You requested to supply additional information. In order to continue you must set up a profile.", "OK")
                return
            Templates.returntoconfirm=0
            Templates.Window.hide()
        Templates.Data['Template']="Custom"
        Templates.Data['tracking']=0
        Templates.Data['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
        if self.SupplyAdditional.isChecked():
            Templates.Data['Profiles']['Contact'].append(AdvanceArray[multisig]['Profiles']['Contact'][0]['string'])
        Templates.Data['autoaccept']=0
        Templates.Data['allowcounters']=0
        Templates.Data['allowchat']=0
        Templates.Data['Private']=0
        if self.AllowChat.isChecked():
            Templates.Data['allowchat']=1
        if self.AllowCounter.isChecked():
            Templates.Data['allowcounters']=1
        if self.TrackPrice.isChecked():
            usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap, 0)        
            if CoinMarketCap==" ":
                usd,btc=GetMarketValue(CoinSelect['name'])
            if usd=="":
                res=QuestionBox("Exchange rate not loaded yet. To price track, you must be able to compare your rate to the rate accepted to verify valid offers. You may try again later or you may also enter the fiat rate manually.", "Try Again Later", "Enter Rate Manually")
                if res==0:
                    Templates.Data={}
                    Templates.reply={}                     
                    return False
                if res==1:
                    text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the exchange rate for ') + CoinSelect['name'] + Gtranslate(' in dollars. You can find this rate online. Please be as precise as possible.'))
                    try:
                        a=float(Decimal(str(text)))
                    except:
                        QuestionBox("The rate you entered was invalid.", "OK")
                        Templates.Data={}
                        Templates.reply={}                         
                        return False
                    usd=Decimal(str(text))
                    if usd<=0:
                        QuestionBox("The rate you entered was invalid.", "OK")
                        Templates.Data={}
                        Templates.reply={} 
                        return False                            
                    usd=str(usd)
                    btc=" Not Found "
            else:
                QuestionBox(Gtranslate("Please confirm the exchange rate online:")+"\n"+"USD:"+usd+"->"+CoinSelect['name']+"\nBTC:"+btc+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this. Otherwise, you may simply send the coins without denominating in dollars. If you are price tracking and do not agree with the rate posted, you might want to try again later."), Gtranslate("OK"),1)                 
            Templates.Data['rate']=usd      
            Templates.Data['allowcounters']=1
            if self.AllowCounter.isChecked():
                Templates.Data['tracking']=1#No autoaccept is allowed here because they will also want to counter on terms and deposits, users should verify everything
            else:
                Templates.Data['tracking']=2#This will symbolize that counters are only allowed on the rate but will maintain the same ratios, it also activates autoaccept
            Templates.Data['maxincrease']="1.0000000011"
            Templates.Data['maxdecrease']="0.000000001"
            Templates.Data['maxorder']="1"
            Templates.Data['minorder']="1"                
        if self.AutoAccept.isChecked() and Templates.Data['tracking']!=0:
            res=QuestionBox("We recommend against autoaccept in price tracked custom orders so you may review bids. However, the software will compare offers to it's own tracking history and only accept orders that match. Would you like to continue anyways?", "Yes", "No")
            if res==1:
                Templates.Data={}
                Templates.reply={}                
                return False              
        if self.AutoAccept.isChecked():
            Templates.Data['autoaccept']=1
        text=str(self.MarketSelect.currentText())
        if text == "Private Email/BitMessage/Coin Address...":
            text2=str(self.MarketSelectBox.text())
            Templates.Data['Private']=1
            window.ContractTo.setText("Market Order: "+text2)
        else:
            text=Markets['MyMarkets'][text]
            window.ContractTo.setText("Market Order: "+text)

        self.MarketSelectBox.clear()
        self.MarketSelectBox.hide()
        self.hide()
        return True
class PayToEmail(QtGui.QDialog):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(492, 226)
        
        self.checkBox = QtGui.QCheckBox(Form)
        self.checkBox.setGeometry(QtCore.QRect(130, 190, 181, 31))
        self.checkBox.setObjectName(_fromUtf8("checkBox"))
        self.pushButton = QtGui.QPushButton(Form)
        self.pushButton.setGeometry(QtCore.QRect(20, 190, 75, 23))
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.textEdit = QtGui.QTextEdit(Form)
        self.textEdit.setGeometry(QtCore.QRect(20, 60, 261, 111))
        self.textEdit.setObjectName(_fromUtf8("textEdit"))
        self.comboBox = QtGui.QComboBox(Form)
        self.comboBox.setGeometry(QtCore.QRect(20, 10, 261, 31))
        self.comboBox.setObjectName(_fromUtf8("comboBox"))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox_2 = QtGui.QComboBox(Form)
        self.comboBox_2.setGeometry(QtCore.QRect(300, 10, 171, 31))
        self.comboBox_2.setObjectName(_fromUtf8("comboBox_2"))
        self.comboBox_2.addItem(_fromUtf8(""))
        self.comboBox_2.addItem(_fromUtf8(""))
        self.webview = QtWebKit.QWebView(Form)
        self.webview.setGeometry(QtCore.QRect(300, 60, 171, 111))
        self.webview.setObjectName(_fromUtf8("webview"))
        ApplyCSS(self)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        self.pushButton.clicked.connect(self.Accept)
        self.comboBox.connect(self.comboBox,QtCore.SIGNAL("currentIndexChanged(int)"),self.ChangeIndex)
        self.comboBox_2.connect(self.comboBox_2,QtCore.SIGNAL("currentIndexChanged(int)"),self.ChangeIndex2)

    def retranslateUi(self, Form):
        self.checkBox.setText(_translate("Form", "Password Protect Payment", None))
        self.pushButton.setText(_translate("Form", "Accept", None))
        self.comboBox.setItemText(0, _translate("Form", "Send with default message", None))
        self.comboBox.setItemText(1, _translate("Form", "Attach personal message...", None))
        self.comboBox_2.setItemText(0, _translate("Form", "Send with default image", None))
        self.comboBox_2.setItemText(1, _translate("Form", "Change default image...", None))
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])

    def __init__(self):
        QtGui.QDialog.__init__(self)
        self.setupUi(self)
    def ChangeIndex(self):
        if self.comboBox.currentIndex()==0:
            self.textEdit.setText("")
            self.textEdit.hide()
        else:
            self.textEdit.show()
    def ChangeIndex2(self):
        self.comboBox_2.blockSignals(True)
        try:
            if self.comboBox_2.currentIndex()==1:
                path = strOUT(strIN(QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Please choose the image you want to use as your default."),MacDir()+"","Image File (*.jpg *.jpeg *.png *.bmp)")))
                size = os.stat(path).st_size
                if size>45000:
                    try:
                        output = StringIO.StringIO()
                        output=ResizeImage(str(path), 45000,1)
                        path=path+"backup"+".jpg"
                        output.close()
                        output=""
                    except:
                        output.close()
                        output=""
                        traceback.print_exc()
                        QuestionBox("Load image failed, please try again or try another image", "OK")
                        self.comboBox_2.setCurrentIndex(0)
                        self.comboBox_2.blockSignals(False)
                        return
                try:
                    im=Image.open(path)
                    testcontent="1234567890!@#$%^&*()-=_+~`qwertyuiopasdfghjkl;[]:/.,mnbvcxz"*300
                    rawout=StringIO.StringIO()
                    im2=stepic.encode(im, testcontent)
                    im2.save(rawout,"BMP")#It must be losses PNG or BMP. BMP works well with the pyzmail library
                    b64= base64.b64encode(rawout.getvalue())
                    rawout.close()
                    rawout=""
                except:
                    rawout.close()
                    rawout=""
                    QuestionBox("The image selected is not high enough quality and size to encode messages within it.", "OK")
                    self.comboBox_2.setCurrentIndex(0)
                    self.comboBox_2.blockSignals(False)
                    return
                AdvanceArray['p2mpath']=path
        except:
            pass
        self.comboBox_2.setCurrentIndex(0)
        self.comboBox_2.blockSignals(False)
        self.initwindow(1)
        self.raise_()
    def initwindow(self, refresh=0):
        global AdvanceArray
        if refresh==0:
            self.comboBox.setCurrentIndex(0)
            self.comboBox_2.setCurrentIndex(0)
            self.checkBox.setCheckState(0)
            self.textEdit.setText("")
            self.textEdit.hide()
        self.b64img=""
        b64img=""
        defaultpath = application_path+'/images/Doge.jpg'
        if 'p2mpath' not in AdvanceArray:
            AdvanceArray['p2mpath']=defaultpath
        try:
            output = StringIO.StringIO()
            image = Image.open(AdvanceArray['p2mpath'])
            image.save(output, 'JPEG')
            self.b64img= base64.b64encode(output.getvalue())
            tup=image.size
            w=Decimal(tup[0])
            h=Decimal(tup[1])
            if w > 150:
                ratio=Decimal(150)/Decimal(w)
                image=image.resize((int(ratio*w),int(ratio*h)), Image.ANTIALIAS)
                w=150
                h=int(ratio*h)
            if h > 100:
                ratio=Decimal(100)/Decimal(h)
                image=image.resize((int(ratio*w),int(ratio*h)), Image.ANTIALIAS)
                h=100
            tup=image.size
            output = StringIO.StringIO()
            image.save(output, 'PNG')#Used to be JPEG
            b64img= base64.b64encode(output.getvalue())
            output.close()
            output=""
        except:
            output.close()
            output=""
            AdvanceArray['p2mpath']=defaultpath
            QuestionBox("Loading Image failed", "OK")
            self.b64img="/9j/4RgYRXhpZgAATU0AKgAAAAgABwESAAMAAAABAAEAAAEaAAUAAAABAAAAYgEbAAUAAAABAAAAagEoAAMAAAABAAIAAAExAAIAAAAcAAAAcgEyAAIAAAAUAAAAjodpAAQAAAABAAAApAAAANAACvzaAAAnEAAK/NoAACcQQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzADIwMTU6MDc6MDYgMTg6MjQ6MTgAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAABo6ADAAQAAAABAAABBgAAAAAAAAAGAQMAAwAAAAEABgAAARoABQAAAAEAAAEeARsABQAAAAEAAAEmASgAAwAAAAEAAgAAAgEABAAAAAEAAAEuAgIABAAAAAEAABbiAAAAAAAAAEgAAAABAAAASAAAAAH/2P/tAAxBZG9iZV9DTQAB/+4ADkFkb2JlAGSAAAAAAf/bAIQADAgICAkIDAkJDBELCgsRFQ8MDA8VGBMTFRMTGBEMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAENCwsNDg0QDg4QFA4ODhQUDg4ODhQRDAwMDAwREQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgAZACgAwEiAAIRAQMRAf/dAAQACv/EAT8AAAEFAQEBAQEBAAAAAAAAAAMAAQIEBQYHCAkKCwEAAQUBAQEBAQEAAAAAAAAAAQACAwQFBgcICQoLEAABBAEDAgQCBQcGCAUDDDMBAAIRAwQhEjEFQVFhEyJxgTIGFJGhsUIjJBVSwWIzNHKC0UMHJZJT8OHxY3M1FqKygyZEk1RkRcKjdDYX0lXiZfKzhMPTdePzRieUpIW0lcTU5PSltcXV5fVWZnaGlqa2xtbm9jdHV2d3h5ent8fX5/cRAAICAQIEBAMEBQYHBwYFNQEAAhEDITESBEFRYXEiEwUygZEUobFCI8FS0fAzJGLhcoKSQ1MVY3M08SUGFqKygwcmNcLSRJNUoxdkRVU2dGXi8rOEw9N14/NGlKSFtJXE1OT0pbXF1eX1VmZ2hpamtsbW5vYnN0dXZ3eHl6e3x//aAAwDAQACEQMRAD8A4v8APgGBMEmSB9yiXnvr/rCnLJdIndO3aYgz+dI/6Khtn/XurURa6RpYvMEH8FAvPxI7FGbjvgkDka+CG9hZqQJ8SFKIkBjsWw3mI0gfAJB5JG5x28RzA7DVQsdJE9gGg+QUJ/3IErqSF+ukkQNxI8lBzjHyk8/BIv0gGGu5000UYkccd/imkppb4pX1FjmtJa4lod7CH6Eb/wAzd+a73s/M/PUthJ9snUc86n/vyGWyYhKyqmB11B8/JPqGmCCDEjufzv8AoqZYfh4Two7Rr4+P9yHmql2xtMx2jmf7P9X+spNAiT28FLcbb2ueGiXMBDWhogFrfoMDW/RWz9Y8INtdk0j2j+cjw/e/sppnGM4xP6d0miQT2cqnEyL7zj1RuAO9wd7Wj6O572bv/Ui0H9DbuA+07bNCGtqED/wTcqPTskYmRNhiuwbXnw1lrv7K0+r9POawZeOJvrbDmN5cwfRNf/CN/wCmo8spjII8XBEjSVcX2qFVe7Tt6HlgfoSy4+AO0x/Ut2/+fVnWNsqearWmt45a8Q78VYx+qZuO6BZ6jByy3UfDd/OM/wA5bdN+N1HFnKx3OYOKnDUfy6r/AG7Gfyv/AANEzyY9cgEo/vR3+xGh2ecmTqYM89km6ubHYiVczOnOqr+1Y8vxho8O1fWQf8Lt2+pW7/Ts/wCuemqjS7e1ruzg3y57lqkEhIXE2nbQv//Q4nFx87Nyjj4TaX2y0NZbdXS5znmGNqGTZT6rv+LUbjl4jRZc2k1ueaxbXay1pe1tdz2iyiyxnsrvq3f9t/ziXTb6sP6wYmVkEtpx7mWWkDcQxpl7to9zlb6F1pvT8bBxnXvqqGcbeoVsaS1+Oa8enZaB/P1u25LH4356klPLCZoWB4f3v0vV+7+6vkL0LZ6Z1vGqqtbkY9T3FpDDLxDh9L6LwsrJ6kHWSGVlszALoj5O/OW1R13p4w8Kt1rW00tw2nELL3uY+iyizMyWM9T9mV+p6GTb9pobZl3/AGuzGso/TXXKdX1hxhVYb8oPsssvty/XZkP+0MexleLj+ljWU493oMqfjejnPooxq7PUxv8ACVp55rKYn0S/l/gLOAaah5V2S6dWtB+agcg8QNdY1W59V+p4/TW2vsyn41pux3bB6oa+qs2Ou1wduRbe3d+hxrcjFwbPp3++ur07mN9YMem6mmm5zMSrHyW06WMqpybcjLsoy/SxfTu/oN1eP6+N+sY9d/6P+a9JRyzZOKQEDLh699P7q4DxeX9cxMNjx1SGRwSBH9y27Op4o+stHUrHNsqr9MWX11vM2Mr9L7Z6Wa992S+m/ZdvyPSszfR9S2qn1VZp6s4NNTuuPbnF1Dn9VFdx3V1uyHWYe/0/t2Tt9ei5v2umqm99f2az9Dh4iEsuQV6TsD1/71NPPOudW2t52RYNzdrgSAHOr92xznVP3N+hY31Nnp2/zViYZDp4Bnn5ro8rrtLcfIPR3WYF1jNmOypvpurac7NzxSy2r+a2YuRj/wA0/wD4BGy+q9PvxOpYzLy3HvuyrMbHrrsqcTbb6uKH1jf07Ixv5p9lmQ3E6jien6eNZZ6GMiMmXS4HU1/b8qaLgGr/AGBN6IgyQCIgGZM+H9VX7adpII7oBrLnBoEytAwCpRIYdPxzbn49Y72Nn4D38f2V1z8R1o3WDYCILHayOELonSqsNouc3dkOHusdy1p/Nb+41aGXDWbhqsnm5ic/T8sP+kyY/SPEvKZn1efU4ux3yzkNPb4O/dT9Pbn4s1OrL2fmCY2a6/SHuZ/wa6BlbnCfpHun2AEiEvvUzCpgS8Sg443oaaI6JgZ7vtORtZY3swyHu/dyG6f+TU8qq/EbDmgt4c9mrf8Ao/Rb/WR34FrrW3Y4duadWiY1/Pb/AClSxepZd+YZZtpYY3O9h/tf1v3VBxZZdeKMR8p04V3DEbdWvXksrv8ARn3Wy9s8aAB9bh/VKyOo4TcTKApBFN8WVidG6++r+x+Yt7qPVsQ3smre8e5rwxrpk7fa/wDsrIy77Mu5ljmhrW6MYOQJ/P8A5Tld5WE7EuExjKPqv/m8LHMAk93/0eZdj4dLeq2ZlDrq6qcd7Wsc2t+43sbpe+u/0WuZv37K/epZnRMPGpyy9t99XT35m2tuyt7xXdhYrHWXNosf+jbl+tkfzv0P0H2dltqE5uR1XKvrprL7CKKmtY5oa51lrcaptvqvZ7XWWN2/T/S/znp1/pEx6X1bHb9ubc0Gttl9dtOS11hDfZmWY/pW+q91Efrfp/mf6apSZhH3JVkA9Xyk+GkWeQBJLqDpOCzrtD3YWQ/1so0Mxw1gbUKcXFvLcvG9BzLbLftDrMn+j7GUXW/8VTo+rOBa3Cqdbf61zcCy17A98tzXUVuZt+yNxcb0/tD/AEL3Z1/q3Ytlb6v0/p4wK+ldUrea6rwTe413uqymlodUw5JZnW12+m30KGWXb7X2VV+jd799STuldQbVXUchleLX6d9Lzktbjh1xsbjvoLrBUzItfTkfuW1+ldZd6P6RRcJA0zDYdf8Anf8AcLTHyc/qWJhMwaM3CrtrrvdfU6u94scDjmr9K22tlH863J99Wz9G9n0/0i2Mzo/ThlZFNgyHZN1vUhVa11bK2DBa66rdjV0Na/1tmy9lf2euv+cqWNkY1uOLK7mkOpLw6pxPteDtta5n5r9zNlq3Mj6shuRdWLs9v2eyphyb6dtNn2i2nEt+y3+r/PWfafWaz/tXRVb6idP0cIMyPmrr/d/7hVU1/qxjYWQyt1+OLHnqONWbCGuip9OU+yj0rGOZ7/S/Pf8Azvpf6FTwukYF+NVdSzIZRl00OfV7L7Z+2jAt9B/oMc9762+rU2ttX6b9B+lp/RINXTMuii22t+2s7n7G2AWPppsdV9rdisd6no13M9rvzP53+aZ6y0aei3kNZurcwF7CK7WvYw1N+0Xix9bnM/Rsb637m/8Amt9idICzL3Ksjr+58yQGh1DplNDqXYrf1e+svrfvNgJa99Vmx9lOFkN27Njq8nGrf6n79SpW0+nIjWQuhtwcq+wvNjbrHubVW99webXlu+unGe97vtDvTe32Nd/hGV/z1nprIuaLNWt3boDfHnlSY5WALuvqkFPlMJc7cI1P3q70Dpjcix2RYIa07WFa2d9Xc1tdjhXue1xGg8DH+u5X8bEqxelusvsbQ1kNl+msf9W5WuamBjPCbvTRnyCFWDuXmsrL6h+2G42M+x9ZcA6kbfTDfznWN2+o3Ztf+l9X6a1LqfVMkx5eARhm9Pe4MqsBc/Qfml/zP/Uqdg9v8FkZLNenhAYgAOt203ZdGOxjNX2PMMqrG6x5/kM/6p/0K0DFzMTPe40ksuqMW02Ase0+D2H/AKtiFkdHc+199dhrfbU/HsaQSCx/0tj/AKVatdE+reFhubaXG63afcdGhp/NYlUDDf1dluolto6dTXOqLSBtcI+H8pUc/DYwk1GZHu7Se/tK27amVtHnoBys/KqBeQDP8FGYFfCQeO6hUX1tyTIsZ7HDQe0fR+j9HaqlY9wIPcag+Oi2ur0EUWbRxrA8R7li1gkBwGgIB17k/wDmK1OVlxYh4GkSj6tH/9LicTrD+l5j7msbZLqXw4mJotbmVt9p+i99Xp2fyEndSycIDAvpbXdi05OG9r5Dwby/1S9s/wA5S6z2qWBdUwZzRdTi5r21tovyBLAyX/a6R7LfTsuZs9/pfzNV2L/2p9K7Us6p0i3JyrhkUfYbMjMszqHVH1MltjnnAdihzC/+bdVXiM9Sn9m5FdmRZ6X85Yck6nL0Xrrv/L+qyncoHfW37Tc2rJY2nHe+xz977bmMFtN2K/Fpx2vq+y9P237GMxW/aMT+c/W/RrqT2fWbHw7BjYLd2I2mhlno234xdZS7It3su3fanUP+23VXesyv7R/PV14f6H0qf1f6liYNVYudU2x+fj/afUrFh+ybbG5rfdXZ+rv9v2ipv86jNzsCrpYbXfR9nrxi1mGKyb/twfuZlh7q/L1/tXrf0H/J/wD3XUZEbrgPDoKs8Pmi/FpZV1lllwvq+z5Bfb9pkvne553Ney9z3Vuo/mvp73/4b9Kr2TlZNvU29TyGiq02VZlNL3ONZBLLKRTJPttaz2/8GpW5+I/609RzftFTxkOyLMHMLSamWWjfh3WMNfsdWx3pb3U/q2V+m/wPqLRxuqdNbY8uyKHZAZhtff8AzVT66qnV5lDd2HlepV9o/pNFVVP27/Beqpfc0HoMvT4/p8PFFcC139VzK8KujIaWVvrLaSbbBWaXWWPl2FvGPc71PXxfVs+nV/OY/q/pVov66+wttur21mx91ZNtvtcR6Tm4tks+yU0OP6D7P/Mf4T1lUwepdMFLGV210ZAprrrc9xrbXWMnPuuxfXuxs/8AwV+DY5np/rGOz0fW9T9XvLX1bpxDGsurYyr7azCrBNQpfbfXdRYyy7HudTVbherRi32VWehd/OfZP6QwERsj2jpI63IfPHdKezr1osc8NJBcLGNbdbXLwxlG7IsodW/L9X0a7LvU2WWW/wCFr9Sxc+62yl3qbS9jSJPgZ+l7fovRuqZeM/ItsosqsYCxm2ouG53pt9e9m6nHa+t9+/fZ6dP6b+ao9F6z3ZNgEESJBjv/AJ6mxQjEWBw2BYTWj6dR9ZsWuo02N9Wq8nY10729vdO/c1yxfrXk139Pppjc2u31AJg8bZ2jc1/7m1c56tgyRbuGplrWzMnQBrv+ktvKxci/CrfXrkN1LSJhvcw76TlNzPDEggVZ1XZOGiB3eco6Xk3Wg47pa6JadI+H8pejY9FXoMFrC5wYAS4gcCJ5XE0ZuTj2scWCzZoS0Fhj4fQctxn1nwy0BjbbHO0dW2rWf3Xu+iqmTUbMMT3NOq3GaJn6PhyjBjDqBEdhpoqeF1A5LC41uqBPtDon4+yVYaHWGXfRHHmo6A6MtXqlddHPAlZ+RYNxjUeKt+mTq4geQQMmg7Zg6jQeR4TZXS6MHGzC59bzxOnyXOMpDLdh53DU8c/+RXWWUnbB0gHsuezag3J07kflVnkJaSiWTgf/0/M73H1XTyhyrrME5GPm5LLALMIMsdSQZdU5/wBntta//gbrcb9H+5d/wKM/6vZ7n1V44F1rqKbbWS2sMfkh1uHiMfc9n2jKyMX07q6af09n6WtlX6CxOlkjZs9V53cuVNjiDOh8jB/KrP7H6kML7d6B+zlrnh25u7Yx/oWWind6/pV3forLfT9Nlinh9GzcjOOCQ2m/0HZIFzg0bG0HPr9zjt/S0bdv9f8AS/4RATiLNjT9iGsDJEzHiNeFZrNfpguLgRoTOh1nhWMn6vdSobTZVW7IryG4xqNcF2/LqbfTU6hrn3s3vc+imx7PTyX1Weko/sTrBeKW1NINZtdYy2o0+mx4pfY7LZa7F2VXOa23dd+i/wAInDLDfiH2rrLXNo3ENJj83xUWvLnc6d9Vbf0LqFVJdZU4W02ZLMqkiDU3FZjW23XWOd6ex/2z06/337PS9V99SLV0DOOQyvJZ9la+u9+87X7X49D812Ncyqxz8fIcxjW+jkendV6n80nDNGvmH+8oyLVY9p7wO8eKiSZG0yJ+AVcP0BPBTtsM6aKS1vEXrHW2ECzHa2uwl0QwAkj/AEbvds3roenFzqB6ggn/AFgrj/2q9u1tcbifc793u1rGrqOlvP2VthMvcNQUedkOH6phZOrYfjYzCdoMkzA4E88qv6NDeG6A6DgfgjvcHE9nDshyA6NNex7rO4mRmx7hAA2jtCtNyHRDjPaR2hZ77/cI+iO3inF7niR24KIkE2Q3H3sHH4qtdkOkyYHJ/wByhvjXUxrPGqEXv9VuwjeDIHJn4oTlbJGbIZTrDrq0eOv/AJksnPtxzdqSw9vD/O/lLYrp09/BMuI5+S5rrzduWwCAC7QlWOSJE9eoSc1bP//U87wM44PUPXdWMimLKsincWC2mwOqyK/Ub/N763/o7dv6Kz07Vo4f1osZZluzqH3fasluYfRe2pzbGixvpsddTlbafTt2M2MZbT6dfo2LELiHO7an8qnRs9VpsDjWCDZsPu2z7trj7WuSljjLcLxfd18DrFeR1TBuzyKqMaq6rNL3WON9V9uVkZlNe1r7W5GRRn249O6z+d/TfaK1XZn31dWs6p1Ch9gzG3mytp9IuZlV3Yrzj2OZaxnpttd6P6Oyv9GqLnV+oTVOyTsDjJjtMfnIotD2ieRpH/UlSQwwN+I4f4oOjfx+utrvNluC3Irc3BY+h7pa5uC2mpzHzW7czL+z/Q/wf/DKfUPrGzKw34deK9jX0Pxw972kjfkY2fv9KijHoY1v2T0vSqrYz9J/n5YJMtnk8yptvG9pY0H2uZDgDMhzd7f6rTu/rojlsZIPaq+iOI7Opf8AWh2Ti3YVmITh5Dnvuq38uNOLjYlrHen7LMK3C+0M/wBLXfdi/QUcv6w15DKnfZbG2sFjTe61r7Q2yp+N9mpvfj/aHYbfV3bM5+bf6X6vRk0fpci3LbBdzHlylPnA4B+CP3XGKPmjiJQDSJCRmNAR5IwnbrrPCcuI4+CfX8qVSfG2uyavUJawvAc4DcQD/J9u5d30tkYzSdBHHZcLhsdbfWGjWRqu8xGmuhrTzCi5mWgXxZZIbwf9qqOrExqfMK3cSRAAGkE+aBt4A0jlUTqWQbKrobBmTHAI7okfuwAO3ikJg7dI+5SDZIIA04MwPwTwhYAF0GQ7948H4IjWBrfj2TEBwhwJPMbo1RWbYj87xhEBFsNoI0iPguY69X+sNJ4BH5V1NlgGmkjiFzPXLm+o2WgzoA7xIPvG39z8xS4JfrAEkaEv/9XzH27j4yZ+9WsSN/6KZ7xz/JWckpMe64t3N2+sfo7o92397vvhDbMees+MqsknfpHzQ2xwFOv1vSu9Odm1vrxHG79Hu/O/nP3VRSUgWttnHnKJX8p158VQSTo7hToHbAj6Xf4oWuqqJISSHp/q39m9f9L9PzXaD04H7q8kSVTmN18X1N+7X8FEeX0vwXlySqjdkL6mNvl80neltO7yjmZ+X521eWJJ619Uq3dvo/mzyimduq8mSR6K6vp+Rv2afS7rmOservZuiN4/2Ll0keW/nei+Xyv/2f/tHyRQaG90b3Nob3AgMy4wADhCSU0EJQAAAAAAEAAAAAAAAAAAAAAAAAAAAAA4QklNBDoAAAAAAL0AAAAQAAAAAQAAAAAAC3ByaW50T3V0cHV0AAAABAAAAABQc3RTYm9vbAEAAAAASW50ZWVudW0AAAAASW50ZQAAAABDbHJtAAAAD3ByaW50U2l4dGVlbkJpdGJvb2wAAAAAC3ByaW50ZXJOYW1lVEVYVAAAACQASABQACAATABhAHMAZQByAEoAZQB0ACAAMQAwADAAIABjAG8AbABvAHIAIABNAEYAUAAgAE0AMQA3ADUAIABQAEMATAA2AAAAOEJJTQQ7AAAAAAGyAAAAEAAAAAEAAAAAABJwcmludE91dHB1dE9wdGlvbnMAAAASAAAAAENwdG5ib29sAAAAAABDbGJyYm9vbAAAAAAAUmdzTWJvb2wAAAAAAENybkNib29sAAAAAABDbnRDYm9vbAAAAAAATGJsc2Jvb2wAAAAAAE5ndHZib29sAAAAAABFbWxEYm9vbAAAAAAASW50cmJvb2wAAAAAAEJja2dPYmpjAAAAAQAAAAAAAFJHQkMAAAADAAAAAFJkICBkb3ViQG/gAAAAAAAAAAAAR3JuIGRvdWJAb+AAAAAAAAAAAABCbCAgZG91YkBv4AAAAAAAAAAAAEJyZFRVbnRGI1JsdAAAAAAAAAAAAAAAAEJsZCBVbnRGI1JsdAAAAAAAAAAAAAAAAFJzbHRVbnRGI1B4bEBSAJOAAAAAAAAACnZlY3RvckRhdGFib29sAQAAAABQZ1BzZW51bQAAAABQZ1BzAAAAAFBnUEMAAAAATGVmdFVudEYjUmx0AAAAAAAAAAAAAAAAVG9wIFVudEYjUmx0AAAAAAAAAAAAAAAAU2NsIFVudEYjUHJjQFkAAAAAAAA4QklNA+0AAAAAABAASAJOAAEAAQBIAk4AAQABOEJJTQQmAAAAAAAOAAAAAAAAAAAAAD+AAAA4QklNBA0AAAAAAAQAAAAeOEJJTQQZAAAAAAAEAAAAHjhCSU0D8wAAAAAACQAAAAAAAAAAAQA4QklNJxAAAAAAAAoAAQAAAAAAAAACOEJJTQP1AAAAAABIAC9mZgABAGxmZgAGAAAAAAABAC9mZgABAKGZmgAGAAAAAAABADIAAAABAFoAAAAGAAAAAAABADUAAAABAC0AAAAGAAAAAAABOEJJTQP4AAAAAABwAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAADhCSU0ECAAAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4AAAAAAAQAAAAAOEJJTQQaAAAAAAM9AAAABgAAAAAAAAAAAAABBgAAAaMAAAAEAEQAbwBnAGUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAaMAAAEGAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAABudWxsAAAAAgAAAAZib3VuZHNPYmpjAAAAAQAAAAAAAFJjdDEAAAAEAAAAAFRvcCBsb25nAAAAAAAAAABMZWZ0bG9uZwAAAAAAAAAAQnRvbWxvbmcAAAEGAAAAAFJnaHRsb25nAAABowAAAAZzbGljZXNWbExzAAAAAU9iamMAAAABAAAAAAAFc2xpY2UAAAASAAAAB3NsaWNlSURsb25nAAAAAAAAAAdncm91cElEbG9uZwAAAAAAAAAGb3JpZ2luZW51bQAAAAxFU2xpY2VPcmlnaW4AAAANYXV0b0dlbmVyYXRlZAAAAABUeXBlZW51bQAAAApFU2xpY2VUeXBlAAAAAEltZyAAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAAAABUb3AgbG9uZwAAAAAAAAAATGVmdGxvbmcAAAAAAAAAAEJ0b21sb25nAAABBgAAAABSZ2h0bG9uZwAAAaMAAAADdXJsVEVYVAAAAAEAAAAAAABudWxsVEVYVAAAAAEAAAAAAABNc2dlVEVYVAAAAAEAAAAAAAZhbHRUYWdURVhUAAAAAQAAAAAADmNlbGxUZXh0SXNIVE1MYm9vbAEAAAAIY2VsbFRleHRURVhUAAAAAQAAAAAACWhvcnpBbGlnbmVudW0AAAAPRVNsaWNlSG9yekFsaWduAAAAB2RlZmF1bHQAAAAJdmVydEFsaWduZW51bQAAAA9FU2xpY2VWZXJ0QWxpZ24AAAAHZGVmYXVsdAAAAAtiZ0NvbG9yVHlwZWVudW0AAAARRVNsaWNlQkdDb2xvclR5cGUAAAAATm9uZQAAAAl0b3BPdXRzZXRsb25nAAAAAAAAAApsZWZ0T3V0c2V0bG9uZwAAAAAAAAAMYm90dG9tT3V0c2V0bG9uZwAAAAAAAAALcmlnaHRPdXRzZXRsb25nAAAAAAA4QklNBCgAAAAAAAwAAAACP/AAAAAAAAA4QklNBBQAAAAAAAQAAAABOEJJTQQMAAAAABb+AAAAAQAAAKAAAABkAAAB4AAAu4AAABbiABgAAf/Y/+0ADEFkb2JlX0NNAAH/7gAOQWRvYmUAZIAAAAAB/9sAhAAMCAgICQgMCQkMEQsKCxEVDwwMDxUYExMVExMYEQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQ0LCw0ODRAODhAUDg4OFBQODg4OFBEMDAwMDBERDAwMDAwMEQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABkAKADASIAAhEBAxEB/90ABAAK/8QBPwAAAQUBAQEBAQEAAAAAAAAAAwABAgQFBgcICQoLAQABBQEBAQEBAQAAAAAAAAABAAIDBAUGBwgJCgsQAAEEAQMCBAIFBwYIBQMMMwEAAhEDBCESMQVBUWETInGBMgYUkaGxQiMkFVLBYjM0coLRQwclklPw4fFjczUWorKDJkSTVGRFwqN0NhfSVeJl8rOEw9N14/NGJ5SkhbSVxNTk9KW1xdXl9VZmdoaWprbG1ub2N0dXZ3eHl6e3x9fn9xEAAgIBAgQEAwQFBgcHBgU1AQACEQMhMRIEQVFhcSITBTKBkRShsUIjwVLR8DMkYuFygpJDUxVjczTxJQYWorKDByY1wtJEk1SjF2RFVTZ0ZeLys4TD03Xj80aUpIW0lcTU5PSltcXV5fVWZnaGlqa2xtbm9ic3R1dnd4eXp7fH/9oADAMBAAIRAxEAPwDi/wA+AYEwSZIH3KJee+v+sKcsl0id07dpiDP50j/oqG2f9e6tRFrpGli8wQfwUC8/EjsUZuO+CQORr4Ib2FmpAnxIUoiQGOxbDeYjSB8AkHkkbnHbxHMDsNVCx0kT2AaD5BQn/cgSupIX66SRA3EjyUHOMfKTz8Ei/SAYa7nTTRRiRxx3+KaSmlvilfUWOa0lriWh3sIfoRv/ADN35rvez8z89S2En2ydRzzqf+/IZbJiErKqYHXUHz8k+oaYIIMSO5/O/wCiplh+HhPCjtGvj4/3IeaqXbG0zHaOZ/s/1f6yk0CJPbwUtxtva54aJcwENaGiAWt+gwNb9FbP1jwg212TSPaP5yPD97+ymmcYzjE/p3SaJBPZyqcTIvvOPVG4A73B3taPo7nvZu/9SLQf0Nu4D7Tts0Ia2oQP/BNyo9OyRiZE2GK7BtefDWWu/srT6v085rBl44m+tsOY3lzB9E1/8I3/AKajyymMgjxcESNJVxfaoVV7tO3oeWB+hLLj4A7TH9S3b/59WdY2yp5qtaa3jlrxDvxVjH6pm47oFnqMHLLdR8N384z/ADlt0343UcWcrHc5g4qcNR/Lqv8AbsZ/K/8AA0TPJj1yASj+9Hf7EaHZ5yZOpgzz2Sbq5sdiJVzM6c6qv7Vjy/GGjw7V9ZB/wu3b6lbv9Oz/AK56aqNLt7Wu7ODfLnuWqQSEhcTadtC//9DicXHzs3KOPhNpfbLQ1lt1dLnOeYY2oZNlPqu/4tRuOXiNFlzaTW55rFtdrLWl7W13PaLKLLGeyu+rd/23/OJdNvqw/rBiZWQS2nHuZZaQNxDGmXu2j3OVvoXWm9PxsHGde+qoZxt6hWxpLX45rx6dloH8/W7bksfjfnqSU8sJmhYHh/e/S9X7v7q+QvQtnpnW8aqq1uRj1PcWkMMvEOH0vovCysnqQdZIZWWzMAuiPk785bVHXenjDwq3WtbTS3DacQsve5j6LKLMzJYz1P2ZX6noZNv2mhtmXf8Aa7Mayj9Ndcp1fWHGFVhvyg+yyy+3L9dmQ/7Qx7GV4uP6WNZTj3egyp+N6Oc+ijGrs9TG/wAJWnnmspifRL+X+As4BpqHlXZLp1a0H5qByDxA11jVbn1X6nj9Nba+zKfjWm7HdsHqhr6qzY67XB25Ft7d36HGtyMXBs+nf766vTuY31gx6bqaabnMxKsfJbTpYyqnJtyMuyjL9LF9O7+g3V4/r436xj13/o/5r0lHLNk4pAQMuHr30/urgPF5f1zEw2PHVIZHBIEf3Lbs6nij6y0dSsc2yqv0xZfXW8zYyv0vtnpZr33ZL6b9l2/I9KzN9H1LaqfVVmnqzg01O649ucXUOf1UV3HdXW7IdZh7/T+3ZO316Lm/a6aqb31/ZrP0OHiISy5BXpOwPX/vU088651ba3nZFg3N2uBIAc6v3bHOdU/c36FjfU2enb/NWJhkOngGefmujyuu0tx8g9HdZgXWM2Y7Km+m6tpzs3PFLLav5rZi5GP/ADT/APgEbL6r0+/E6ljMvLce+7KsxseuuypxNtvq4ofWN/TsjG/mn2WZDcTqOJ6fp41lnoYyIyZdLgdTX9vypouAav8AYE3oiDJAIiAZkz4f1Vftp2kgjugGsucGgTK0DAKlEhh0/HNufj1jvY2fgPfx/ZXXPxHWjdYNgIgsdrI4QuidKqw2i5zd2Q4e6x3LWn81v7jVoZcNZuGqyebmJz9Pyw/6TJj9I8S8pmfV59Ti7HfLOQ09vg791P09ufizU6svZ+YJjZrr9Ie5n/BroGVucJ+ke6fYASIS+9TMKmBLxKDjjehpojomBnu+05G1ljezDIe793Ibp/5NTyqr8RsOaC3hz2at/wCj9Fv9ZHfgWutbdjh25p1aJjX89v8AKVLF6ll35hlm2lhjc72H+1/W/dUHFll14oxHynThXcMRt1a9eSyu/wBGfdbL2zxoAH1uH9UrI6jhNxMoCkEU3xZWJ0br76v7H5i3uo9WxDeyat7x7mvDGumTt9r/AOysjLvsy7mWOaGtboxg5An8/wDlOV3lYTsS4TGMo+q/+bwscwCT3f/R5l2Ph0t6rZmUOurqpx3taxza37jexul767/Ra5m/fsr96lmdEw8anLL2331dPfmba27K3vFd2FisdZc2ix/6NuX62R/O/Q/QfZ2W2oTm5HVcq+umsvsIoqa1jmhrnWWtxqm2+q9ntdZY3b9P9L/OenX+kTHpfVsdv25tzQa22X1205LXWEN9mZZj+lb6r3UR+t+n+Z/pqlJmEfclWQD1fKT4aRZ5AEkuoOk4LOu0PdhZD/WyjQzHDWBtQpxcW8ty8b0HMtst+0Osyf6PsZRdb/xVOj6s4FrcKp1t/rXNwLLXsD3y3NdRW5m37I3FxvT+0P8AQvdnX+rdi2Vvq/T+njAr6V1St5rqvBN7jXe6rKaWh1TDklmdbXb6bfQoZZdvtfZVX6N3v31JO6V1BtVdRyGV4tfp30vOS1uOHXGxuO+gusFTMi19OR+5bX6V1l3o/pFFwkDTMNh1/wCd/wBwtMfJz+pYmEzBozcKu2uu919Tq73ixwOOav0rba2Ufzrcn31bP0b2fT/SLYzOj9OGVkU2DIdk3W9SFVrXVsrYMFrrqt2NXQ1r/W2bL2V/Z66/5ypY2RjW44sruaQ6kvDqnE+14O21rmfmv3M2WrcyPqyG5F1Yuz2/Z7KmHJvp202faLacS37Lf6v89Z9p9ZrP+1dFVvqJ0/RwgzI+auv93/uFVTX+rGNhZDK3X44seeo41ZsIa6Kn05T7KPSsY5nv9L89/wDO+l/oVPC6RgX41V1LMhlGXTQ59Xsvtn7aMC30H+gxz3vrb6tTa21fpv0H6Wn9Eg1dMy6KLba37azufsbYBY+mmx1X2t2Kx3qejXcz2u/M/nf5pnrLRp6LeQ1m6tzAXsIrta9jDU37ReLH1ucz9Gxvrfub/wCa32J0gLMvcqyOv7nzJAaHUOmU0Opdit/V76y+t+82Alr31WbH2U4WQ3bs2Orycat/qfv1KlbT6ciNZC6G3Byr7C82Nuse5tVb33B5teW766cZ73u+0O9N7fY13+EZX/PWemsi5os1a3dugN8eeVJjlYAu6+qQU+UwlztwjU/ervQOmNyLHZFghrTtYVrZ31dzW12OFe57XEaDwMf67lfxsSrF6W6y+xtDWQ2X6ax/1bla5qYGM8Ju9NGfIIVYO5eaysvqH7YbjYz7H1lwDqRt9MN/OdY3b6jdm1/6X1fprUup9UyTHl4BGGb097gyqwFz9B+aX/M/9Sp2D2/wWRks16eEBiAA63bTdl0Y7GM1fY8wyqsbrHn+Qz/qn/QrQMXMxM97jSSy6oxbTYCx7T4PYf8Aq2IWR0dz7X312Gt9tT8expBILH/S2P8ApVq10T6t4WG5tpcbrdp9x0aGn81iVQMN/V2W6iW2jp1Nc6otIG1wj4fylRz8NjCTUZke7tJ7+0rbtqZW0eegHKz8qoF5AM/wUZgV8JB47qFRfW3JMixnscNB7R9H6P0dqqVj3Ag9xqD46La6vQRRZtHGsDxHuWLWCQHAaAgHXuT/AOYrU5WXFiHgaRKPq0f/0uJxOsP6XmPuaxtkupfDiYmi1uZW32n6L31enZ/ISd1LJwgMC+ltd2LTk4b2vkPBvL/VL2z/ADlLrPapYF1TBnNF1OLmvbW2i/IEsDJf9rpHst9Oy5mz3+l/M1XYv/an0rtSzqnSLcnKuGRR9hsyMyzOodUfUyW2OecB2KHML/5t1VeIz1Kf2bkV2ZFnpfzlhyTqcvReuu/8v6rKdygd9bftNzasljacd77HP3vtuYwW03Yr8WnHa+r7L0/bfsYzFb9oxP5z9b9GupPZ9ZsfDsGNgt3YjaaGWejbfjF1lLsi3ey7d9qdQ/7bdVd6zK/tH89XXh/ofSp/V/qWJg1Vi51TbH5+P9p9SsWH7Jtsbmt91dn6u/2/aKm/zqM3OwKulhtd9H2evGLWYYrJv+3B+5mWHur8vX+1et/Qf8n/APddRkRuuA8Ogqzw+aL8WllXWWWXC+r7PkF9v2mS+d7nnc17L3PdW6j+a+nvf/hv0qvZOVk29Tb1PIaKrTZVmU0vc41kEsspFMk+21rPb/walbn4j/rT1HN+0VPGQ7IswcwtJqZZaN+HdYw1+x1bHelvdT+rZX6b/A+otHG6p01tjy7IodkBmG19/wDNVPrqqdXmUN3YeV6lX2j+k0VVU/bv8F6ql9zQegy9Pj+nw8UVwLXf1XMrwq6MhpZW+stpJtsFZpdZY+XYW8Y9zvU9fF9Wz6dX85j+r+lWi/rr7C226vbWbH3Vk22+1xHpObi2Sz7JTQ4/oPs/8x/hPWVTB6l0wUsZXbXRkCmuutz3GttdYyc+67F9e7Gz/wDBX4Njmen+sY7PR9b1P1e8tfVunEMay6tjKvtrMKsE1Cl9t9d1FjLLse51NVuF6tGLfZVZ6F3859k/pDARGyPaOkjrch88d0p7OvWixzw0kFwsY1t1tcvDGUbsiyh1b8v1fRrsu9TZZZb/AIWv1LFz7rbKXeptL2NIk+Bn6Xt+i9G6pl4z8i2yiyqxgLGbai4bnem3172bqcdr633799np0/pv5qj0XrPdk2AQRIkGO/8AnqbFCMRYHDYFhNaPp1H1mxa6jTY31arydjXTvb29079zXLF+teTXf0+mmNza7fUAmDxtnaNzX/ubVznq2DJFu4amWtbMydAGu/6S28rFyL8Kt9euQ3UtImG9zDvpOU3M8MSCBVnVdk4aIHd5yjpeTdaDjulrolp0j4fyl6Nj0VegwWsLnBgBLiBwInlcTRm5OPaxxYLNmhLQWGPh9By3GfWfDLQGNtsc7R1batZ/de76KqZNRswxPc06rcZomfo+HKMGMOoER2Gmip4XUDksLjW6oE+0Oifj7JVhodYZd9EceajoDoy1eqV10c8CVn5Fg3GNR4q36ZOriB5BAyaDtmDqNB5HhNldLowcbMLn1vPE6fJc4ykMt2HncNTxz/5FdZZSdsHSAey57NqDcnTuR+VWeQlpKJZOB//T8zvcfVdPKHKuswTkY+bkssAswgyx1JBl1Tn/AGe21r/+Butxv0f7l3/Aoz/q9nufVXjgXWuopttZLawx+SHW4eIx9z2faMrIxfTurpp/T2fpa2VfoLE6WSNmz1Xndy5U2OIM6HyMH8qs/sfqQwvt3oH7OWueHbm7tjH+hZaKd3r+lXd+ist9P02WKeH0bNyM44JDab/QdkgXODRsbQc+v3OO39LRt2/1/wBL/hEBOIs2NP2IawMkTMeI14Vms1+mC4uBGhM6HWeFYyfq91KhtNlVbsivIbjGo1wXb8upt9NTqGufeze9z6KbHs9PJfVZ6Sj+xOsF4pbU0g1m11jLajT6bHil9jstlrsXZVc5rbd136L/AAicMsN+Ifaustc2jcQ0mPzfFRa8udzp31Vt/QuoVUl1lThbTZksyqSINTcVmNbbddY53p7H/bPTr/ffs9L1X31ItXQM45DK8ln2Vr6737ztftfj0PzXY1zKrHPx8hzGNb6OR6d1XqfzScM0a+Yf7yjItVj2nvA7x4qJJkbTIn4BVw/QE8FO2wzpopLW8ResdbYQLMdra7CXRDACSP8ARu92zeuh6cXOoHqCCf8AWCuP/ar27W1xuJ9zv3e7Wsauo6W8/ZW2Ey9w1BR52Q4fqmFk6th+NjMJ2gyTMDgTzyq/o0N4boDoOB+CO9wcT2cOyHIDo017Hus7iZGbHuEADaO0K03IdEOM9pHaFnvv9wj6I7eKcXueJHbgoiQTZDcfewcfiq12Q6TJgcn/AHKG+NdTGs8aoRe/1W7CN4MgcmfihOVskZshlOsOurR46/8AmSyc+3HN2pLD28P87+UtiunT38Ey4jn5LmuvN25bAIALtCVY5IkT16hJzVs//9TzvAzjg9Q9d1YyKYsqyKdxYLabA6rIr9Rv83vrf+jt2/orPTtWjh/WixlmW7Oofd9qyW5h9F7anNsaLG+mx11OVtp9O3YzYxltPp1+jYsQuIc7tqfyqdGz1WmwONYINmw+7bPu2uPta5KWOMtwvF93XwOsV5HVMG7PIqoxqrqs0vdY431X25WRmU17WvtbkZFGfbj07rP539N9orVdmffV1azqnUKH2DMbebK2n0i5mVXdivOPY5lrGem213o/o7K/0aoudX6hNU7JOwOMmO0x+cii0PaJ5Gkf9SVJDDA34jh/ig6N/H662u82W4LcitzcFj6Hulrm4LaanMfNbtzMv7P9D/B/8Mp9Q+sbMrDfh14r2NfQ/HD3vaSN+RjZ+/0qKMehjW/ZPS9KqtjP0n+flgky2eTzKm28b2ljQfa5kOAMyHN3t/qtO7+uiOWxkg9qr6I4js6l/wBaHZOLdhWYhOHkOe+6rfy404uNiWsd6fsswrcL7Qz/AEtd92L9BRy/rDXkMqd9lsbawWNN7rWvtDbKn432am9+P9odht9Xdszn5t/pfq9GTR+lyLctsF3MeXKU+cDgH4I/dcYo+aOIlANIkJGY0BHkjCduus8Jy4jj4J9fypVJ8ba7Jq9QlrC8BzgNxAP8n27l3fS2RjNJ0EcdlwuGx1t9YaNZGq7zEaa6GtPMKLmZaBfFlkhvB/2qo6sTGp8wrdxJEAAaQT5oG3gDSOVROpZBsquhsGZMcAjuiR+7AA7eKQmDt0j7lINkggDTgzA/BPCFgAXQZDv3jwfgiNYGt+PZMQHCHAk8xujVFZtiPzvGEQEWw2gjSI+C5jr1f6w0ngEflXU2WAaaSOIXM9cub6jZaDOgDvEg+8bf3PzFLgl+sASRoS//1fMfbuPjJn71axI3/opnvHP8lZySkx7ri3c3b6x+juj3bf3u++ENsx56z4yqySd+kfNDbHAU6/W9K7052bW+vEcbv0e787+c/dVFJSBa22cecolfynXnxVBJOjuFOgdsCPpd/iha6qokhJIen+rf2b1/0v0/NdoPTgfuryRJVOY3XxfU37tfwUR5fS/BeXJKqN2QvqY2+XzSd6W07vKOZn5fnbV5YknrX1Srd2+j+bPKKZ26ryZJHorq+n5G/Zp9LuuY6x6u9m6I3j/YuXSR5b+d6L5fK//ZOEJJTQQhAAAAAABVAAAAAQEAAAAPAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwAAAAEwBBAGQAbwBiAGUAIABQAGgAbwB0AG8AcwBoAG8AcAAgAEMAUwA1AAAAAQA4QklNBAYAAAAAAAcAAQEBAAEBAP/hDiNodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxNS0wNy0wNlQxODowNzoxNy0wNDowMCIgeG1wOk1vZGlmeURhdGU9IjIwMTUtMDctMDZUMTg6MjQ6MTgtMDQ6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTUtMDctMDZUMTg6MjQ6MTgtMDQ6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvanBlZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkE0QUFDNEJEMkQyNEU1MTE4Q0Q0RTY1QTg0QkFFOEM1IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkEzQUFDNEJEMkQyNEU1MTE4Q0Q0RTY1QTg0QkFFOEM1IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6QTNBQUM0QkQyRDI0RTUxMThDRDRFNjVBODRCQUU4QzUiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOkEzQUFDNEJEMkQyNEU1MTE4Q0Q0RTY1QTg0QkFFOEM1IiBzdEV2dDp3aGVuPSIyMDE1LTA3LTA2VDE4OjA3OjE3LTA0OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNvbnZlcnRlZCIgc3RFdnQ6cGFyYW1ldGVycz0iZnJvbSBpbWFnZS9wbmcgdG8gaW1hZ2UvanBlZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6QTRBQUM0QkQyRDI0RTUxMThDRDRFNjVBODRCQUU4QzUiIHN0RXZ0OndoZW49IjIwMTUtMDctMDZUMTg6MjQ6MTgtMDQ6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0idyI/Pv/iDFhJQ0NfUFJPRklMRQABAQAADEhMaW5vAhAAAG1udHJSR0IgWFlaIAfOAAIACQAGADEAAGFjc3BNU0ZUAAAAAElFQyBzUkdCAAAAAAAAAAAAAAABAAD21gABAAAAANMtSFAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEWNwcnQAAAFQAAAAM2Rlc2MAAAGEAAAAbHd0cHQAAAHwAAAAFGJrcHQAAAIEAAAAFHJYWVoAAAIYAAAAFGdYWVoAAAIsAAAAFGJYWVoAAAJAAAAAFGRtbmQAAAJUAAAAcGRtZGQAAALEAAAAiHZ1ZWQAAANMAAAAhnZpZXcAAAPUAAAAJGx1bWkAAAP4AAAAFG1lYXMAAAQMAAAAJHRlY2gAAAQwAAAADHJUUkMAAAQ8AAAIDGdUUkMAAAQ8AAAIDGJUUkMAAAQ8AAAIDHRleHQAAAAAQ29weXJpZ2h0IChjKSAxOTk4IEhld2xldHQtUGFja2FyZCBDb21wYW55AABkZXNjAAAAAAAAABJzUkdCIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAEnNSR0IgSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYWVogAAAAAAAA81EAAQAAAAEWzFhZWiAAAAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAG+iAAA49QAAA5BYWVogAAAAAAAAYpkAALeFAAAY2lhZWiAAAAAAAAAkoAAAD4QAALbPZGVzYwAAAAAAAAAWSUVDIGh0dHA6Ly93d3cuaWVjLmNoAAAAAAAAAAAAAAAWSUVDIGh0dHA6Ly93d3cuaWVjLmNoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGRlc2MAAAAAAAAALklFQyA2MTk2Ni0yLjEgRGVmYXVsdCBSR0IgY29sb3VyIHNwYWNlIC0gc1JHQgAAAAAAAAAAAAAALklFQyA2MTk2Ni0yLjEgRGVmYXVsdCBSR0IgY29sb3VyIHNwYWNlIC0gc1JHQgAAAAAAAAAAAAAAAAAAAAAAAAAAAABkZXNjAAAAAAAAACxSZWZlcmVuY2UgVmlld2luZyBDb25kaXRpb24gaW4gSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGluIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdmlldwAAAAAAE6T+ABRfLgAQzxQAA+3MAAQTCwADXJ4AAAABWFlaIAAAAAAATAlWAFAAAABXH+dtZWFzAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAACjwAAAAJzaWcgAAAAAENSVCBjdXJ2AAAAAAAABAAAAAAFAAoADwAUABkAHgAjACgALQAyADcAOwBAAEUASgBPAFQAWQBeAGMAaABtAHIAdwB8AIEAhgCLAJAAlQCaAJ8ApACpAK4AsgC3ALwAwQDGAMsA0ADVANsA4ADlAOsA8AD2APsBAQEHAQ0BEwEZAR8BJQErATIBOAE+AUUBTAFSAVkBYAFnAW4BdQF8AYMBiwGSAZoBoQGpAbEBuQHBAckB0QHZAeEB6QHyAfoCAwIMAhQCHQImAi8COAJBAksCVAJdAmcCcQJ6AoQCjgKYAqICrAK2AsECywLVAuAC6wL1AwADCwMWAyEDLQM4A0MDTwNaA2YDcgN+A4oDlgOiA64DugPHA9MD4APsA/kEBgQTBCAELQQ7BEgEVQRjBHEEfgSMBJoEqAS2BMQE0wThBPAE/gUNBRwFKwU6BUkFWAVnBXcFhgWWBaYFtQXFBdUF5QX2BgYGFgYnBjcGSAZZBmoGewaMBp0GrwbABtEG4wb1BwcHGQcrBz0HTwdhB3QHhgeZB6wHvwfSB+UH+AgLCB8IMghGCFoIbgiCCJYIqgi+CNII5wj7CRAJJQk6CU8JZAl5CY8JpAm6Cc8J5Qn7ChEKJwo9ClQKagqBCpgKrgrFCtwK8wsLCyILOQtRC2kLgAuYC7ALyAvhC/kMEgwqDEMMXAx1DI4MpwzADNkM8w0NDSYNQA1aDXQNjg2pDcMN3g34DhMOLg5JDmQOfw6bDrYO0g7uDwkPJQ9BD14Peg+WD7MPzw/sEAkQJhBDEGEQfhCbELkQ1xD1ERMRMRFPEW0RjBGqEckR6BIHEiYSRRJkEoQSoxLDEuMTAxMjE0MTYxODE6QTxRPlFAYUJxRJFGoUixStFM4U8BUSFTQVVhV4FZsVvRXgFgMWJhZJFmwWjxayFtYW+hcdF0EXZReJF64X0hf3GBsYQBhlGIoYrxjVGPoZIBlFGWsZkRm3Gd0aBBoqGlEadxqeGsUa7BsUGzsbYxuKG7Ib2hwCHCocUhx7HKMczBz1HR4dRx1wHZkdwx3sHhYeQB5qHpQevh7pHxMfPh9pH5Qfvx/qIBUgQSBsIJggxCDwIRwhSCF1IaEhziH7IiciVSKCIq8i3SMKIzgjZiOUI8Ij8CQfJE0kfCSrJNolCSU4JWgllyXHJfcmJyZXJocmtyboJxgnSSd6J6sn3CgNKD8ocSiiKNQpBik4KWspnSnQKgIqNSpoKpsqzysCKzYraSudK9EsBSw5LG4soizXLQwtQS12Last4S4WLkwugi63Lu4vJC9aL5Evxy/+MDUwbDCkMNsxEjFKMYIxujHyMioyYzKbMtQzDTNGM38zuDPxNCs0ZTSeNNg1EzVNNYc1wjX9Njc2cjauNuk3JDdgN5w31zgUOFA4jDjIOQU5Qjl/Obw5+To2OnQ6sjrvOy07azuqO+g8JzxlPKQ84z0iPWE9oT3gPiA+YD6gPuA/IT9hP6I/4kAjQGRApkDnQSlBakGsQe5CMEJyQrVC90M6Q31DwEQDREdEikTORRJFVUWaRd5GIkZnRqtG8Ec1R3tHwEgFSEtIkUjXSR1JY0mpSfBKN0p9SsRLDEtTS5pL4kwqTHJMuk0CTUpNk03cTiVObk63TwBPSU+TT91QJ1BxULtRBlFQUZtR5lIxUnxSx1MTU19TqlP2VEJUj1TbVShVdVXCVg9WXFapVvdXRFeSV+BYL1h9WMtZGllpWbhaB1pWWqZa9VtFW5Vb5Vw1XIZc1l0nXXhdyV4aXmxevV8PX2Ffs2AFYFdgqmD8YU9homH1YklinGLwY0Njl2PrZEBklGTpZT1lkmXnZj1mkmboZz1nk2fpaD9olmjsaUNpmmnxakhqn2r3a09rp2v/bFdsr20IbWBtuW4SbmtuxG8eb3hv0XArcIZw4HE6cZVx8HJLcqZzAXNdc7h0FHRwdMx1KHWFdeF2Pnabdvh3VnezeBF4bnjMeSp5iXnnekZ6pXsEe2N7wnwhfIF84X1BfaF+AX5ifsJ/I3+Ef+WAR4CogQqBa4HNgjCCkoL0g1eDuoQdhICE44VHhauGDoZyhteHO4efiASIaYjOiTOJmYn+imSKyoswi5aL/IxjjMqNMY2Yjf+OZo7OjzaPnpAGkG6Q1pE/kaiSEZJ6kuOTTZO2lCCUipT0lV+VyZY0lp+XCpd1l+CYTJi4mSSZkJn8mmia1ZtCm6+cHJyJnPedZJ3SnkCerp8dn4uf+qBpoNihR6G2oiailqMGo3aj5qRWpMelOKWpphqmi6b9p26n4KhSqMSpN6mpqhyqj6sCq3Wr6axcrNCtRK24ri2uoa8Wr4uwALB1sOqxYLHWskuywrM4s660JbSctRO1irYBtnm28Ldot+C4WbjRuUq5wro7urW7LrunvCG8m70VvY++Cr6Evv+/er/1wHDA7MFnwePCX8Lbw1jD1MRRxM7FS8XIxkbGw8dBx7/IPci8yTrJuco4yrfLNsu2zDXMtc01zbXONs62zzfPuNA50LrRPNG+0j/SwdNE08bUSdTL1U7V0dZV1tjXXNfg2GTY6Nls2fHadtr724DcBdyK3RDdlt4c3qLfKd+v4DbgveFE4cziU+Lb42Pj6+Rz5PzlhOYN5pbnH+ep6DLovOlG6dDqW+rl63Dr++yG7RHtnO4o7rTvQO/M8Fjw5fFy8f/yjPMZ86f0NPTC9VD13vZt9vv3ivgZ+Kj5OPnH+lf65/t3/Af8mP0p/br+S/7c/23////uACFBZG9iZQBkgAAAAAEDABADAgMGAAAAAAAAAAAAAAAA/9sAhAAMCAgICQgMCQkMEQsKCxEVDwwMDxUYExMVExMYEQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQ0LCw0ODRAODhAUDg4OFBQODg4OFBEMDAwMDBERDAwMDAwMEQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wgARCAEGAaMDASIAAhEBAxEB/8QA7QAAAQUBAQAAAAAAAAAAAAAAAgABAwQFBgcBAAMBAQEAAAAAAAAAAAAAAAABAgMEBRAAAgEEAgIBAwIEBAcBAAAAAQIDABEEBSESEwYQMSIUIEEjFRYHM0MmFzAyQiQ0JTYnEQABAwIDBQQGBgYGCQIHAAABAAIDEQQhMRJBUSITBWFxMkIQgZFSYhShsXKCIzPBorLCQwYg8NGSU2Ph0uJzg6OzJBVFdTDxkzRkdGUSAAEDAgIGBwUGBAcAAAAAAAEAEQIhEjEiEEFRgTJSIDBhcUIDE0BicoKSkaGiwuIjsbLSQ2DwwdHyM6P/2gAMAwEBAhEDEQAAAOLRR9Ohp4nMjAzUgM1ImFqkihQyOJwcozAXaNMxZIYXFCTuwAsQMQkoBSJNxdgMhJMXR3IOQ0OTbGNYrdFFm8JtitrOenC0ZRuNJ3TZkk5UkF1pCThGSOpFOzliT3MSNADuA2ZlLNhSFIAgyYkxdmaRiyqxUJgF3SGZ2Eiew1XSlHZqdhy+VRxC3Rn0Whk63l7YxNidE9RPyN2Teyr1qDkV1+J0zlEBahOKTlRILsYqbJktMyd7GucL602y56PQqQVgljysElFJnBOQWcSTON3FxpjcIURMBGmABpIU6E08VtPrcbYqeX08mtXK9XlPoOcmzOowNW1yVxrbuJ35NuQ6+FtT0qHHvDidVU6Muedj65nUaTmry2caov11PNYM8UfVl0l7AidNUmEmGARzZtbqTSUkg67CwjViqnIrEidRlMyJpFRM5F1ONpU5jCxHKi0aO/jWk1s/I6s/H6ODWOSh6mt24Y2q8suW5De8/WnFsVk8iOxDuhnxdS4zszqeX68yRrZKlepY30j1VzFvU5Haa1DywknuZEtFbOOa1vzYd/nuptcbu6keTZz7WzfrPi6W9mu3K+cVF1qdwMo5F61QNLGRGEl/OH6mC15WxQ2q+RUjaXOwc3uQYiTrZ+zAqQ1MSp6m9hXcxos+v2Z3cKePtlKVaJV9W5hty029QyzyLGrpyuRtaWlU8pHvV6WMukry8O3BrU8tunyisySXqEci3Y5CeUPRHb55WFq6xTgjTjmi7NaymAzboA0+BJ+Vk5Z6itJFhdayFpCA20moZhndqzFYFlZHT1VebWt0tHivdpexzImJuROk9FreLGlwc+PlnValJKtqhMLez84ZLSy1Sp9Jz9mzQlx3RX6fm9qmOvh21WpJlaGZhFYbeacFuGq0AvN6HZmzFtZZ3wu1fLx5GboZc5iUw41BG+C1cz58Lrx6XY4zs8NbE5lk2rTVZqnjblF6U8fbxPUxRRn0qZCkSV49HBZjdPYwrkX6MGYL9XWRgB0d2VxgdjyupB0WD1WZRpalXNZFjpptHzFrV00c6W/TiceHsMgOfhmbsrobG5odOvBbd2XOpaI8hw8/Vhy1uHvCSydSveaXjLYLSC0K9lKeOas0FW3WLq1b1fPTLw+jxO5U3Gx2DIkFK9Qpc2e+WLDmuh0eOUnXV+Y25NipQxkdDSzT2djZw5rYa1Fha02QMPqJebmk3ZcNROtn04bqvPBX6H6L0fC6HVp1Ofkzcs4PObmPnhmWb1lLptWnfyderfix1gsJXLESEYAKDqTVJsYDrRceVrZ+5iSGvUJFKk8aaDX4sdbmb78yjwN7F0nUsu8FGxKTd/lNrA0e5uZimxmtiwGDVRka9MGSRaNBGXGMXS7A1Wpbg1oOvbd0uf2eaM6vdyObm0dXnrrXXT5cuOltqjTd8QBuQY5UCKdOOK1EOnBcrZVHTvwaVhQX6XrBJJrJmrVOPl6XJoNkuh59mFffPQtK9gGPUoC2j1L/ADkhepaxHbv3MRU9gsQUdDXx5EtGkLWGAu51DtydZW6HL1OWZMXpK/GcuO8bOek1il5epLZVWZKk60sHE1Ej12dTvWiijhjPKwhlGnk5mxm+qMnVrna1mtx8KSUymSQkmERATZOL0zkiJu60ddkjROUSFEynEqmyVdNEKIe3Zq3uua2zT0OWtI4T4LaMRihZkDOMwDLFI3KUDWWI4GVSQyQ52oiiinljanWqvk+stFZy2MqvY6HzeTlSbp1PLLospFJ+gyWVCt2mZi7ajD5cp9rQ58NDSRgLpMsKg6JWs0Oq5RonEdFI8Jj3beQuqdLZ5np+XTUIB8/RRupYs4BMwQiOSuI7YRSsdCzCiIIoHKVNOaucXn+j5r0YJTLacuWvBwrt8Y8DE6w6lOW2vznUWsenQm1XUYOrg5vsc+B4fQ8bpYei7qrlUUXbefMyLGu0d5dM9ykhHcYC1d/pMXd560ncuWoa1qDOoQkaajcyaCSZqkUkx2ck41KbQo0xgkClkc30uB1EKmW6xwIeWUJpDKSaqq6WfLU3aViLaYCkUEaKdlR5rTM4pGajKUU4lIKAU4jjUroY2enodTy/T4PSQrluOGzXhgDqWRxyWjZnadCQMpBAijmpA8hBEMsaeXz3R4nQUUS6oxmceVO4kyW2A3VZC6k5q0mkkDsBnENIimhY0kL0pATy3Ekmk7IYXZMzjthp9Jl7XNZs7c1hFIKAScGd2pEnTSdhHKUZtKQU1IwiqeFocrqYWvg9cOgXVGWoFzFiSmrNWXFW03IYVkTnVTLJVFattVTVwKyHZkpIVyTPTNNs1aLQjpqHaeooq9scypPTr3ka5q9cj8nWN+ot5eor1B/LlU+ol5YmvVH8qTPVh8rTPT5vKkj1gvJVS9Xj8sWd+n0/PFF9piYy78thY63n/9oACAECAAEFAAPgUP0E1er1er1cWPPxY/CijUkqpQyY6WWNv1CrVagKI+L1er/JPxb4FftBP2NSA944InRsRhSySRmPIRqPyKWkWhHTLajR+T82q1datR/5Q5SSJw65EHeo3aNo5FcZMiEA1DPY1zTsVpcg9UkNdyS0psWau9671c12vXfjtyG5C8WoqKyGCR2N4ZmjKZYNTSxuJJnWkmJIKmpI+q40nZbUw5KnwSRmul1ljAchhB0apIgrKreEopVlvTRcdbSgcWpyFE8pdj9LXIBFG9A0uMrU8TXTHm6wwiMVlN4x5QQ04BM4B8yEiZCe1ikyOXl6ukysvmQfK/SsmQmjFYMaQcngE3q1KzKEYmkcMvxloWp42LeOQV45BQhYERt1dCSsbCnRixjazxvXaloDiU9VlezPLcWpASyotTIAa5pDY4h+34yZDYztRmIVcjsDkWETiQZBsQ7Cvyl7PkEOsxZosgORXnUCeQENH2ow2orQFj5WFXLG1WphziN8zL2oILNECShURxtZEYUygl07ARcnHrwHskJU08YdXj6/BpwKA56irfF6c1jmxHNWrIZgCXVlYhi8ly7gQ37OXZRLIT3cEF2eOSRvm9hkGlNGmN6ANE1evrRFPUJsYz9t6kAahEgCoq11U0Y0JVFBMUbHxRljGhHijAEUYZQFFxV+Mig9q8tGQUZCav8AJa1Go/rDcrY03wfgVegavXar3ofJ+mR9Gq/yKBotTH4U2OM569hUj9QXswkRqV1ai4C+dLmRFppUFdwG8ido37Ver12Fp2vTHkmr1eg1quTV6NAE0q8454phcKjEBHpwVTx2jRT26SAJGbeFrlX7xi1cUavUtEUfmw+QKt8QGr0efi1KiEsq10ApIwxEQoIL9AKKqK6rVhQqU0TyfgfoHwTWM1z89TYGlajyb2ANBhTG56mrUR8StRPwP0D4JovesUVf4Wlo/VaFCm+g+i/U/V6H0f6NTfAofI+Gr98f6V//2gAIAQMAAQUAJ/4dqI+b/BNCgCa6miD8X+L1ejV6Jq9D5t+gUf0ulhX7FyD3FEA0QRQ+TRomrE0DQofIq1Wq3wfgUFBV1IKtamFEEUimgoIZbfHFH6laIq9W5H6ea5rn4Pwgub2p1DUYqVGFCKutvi9yy2NMK/6gavyDwLdqFzRAvze3xbgrwRVqUAC9XsCaFXpnoWolbnmrVInPWuldDXU11NAURarV1q3zbgrQAFF+QKY0BegK5rg11orYgfEhuaIq3yBRofF6vQoILMlh1vQj5NNwCTSNcUKFOOQKtRJuPkVarURVuLcGupr6UJeJHFg5rvV6P06CiAAKBpTTUBVqb63rtXa9FufqaNXomrcURcGM2ZftPFA83NweDerUBQFKKNAfDfXijXFcVf4PxarVarUz9aeTsGNA0oq4q1WoCgKUVarfDHkk0STV6BNA1egavXau1qLUWNGQEdiaIvXWgtAWoH4FWNCrVarU36r1er1er/F6vSNeh+i9q7UGoNQNdq8xFeaiObcWIogigOepoAmrH4saIt82vSi36LfoBotRaiavRPNwKuKHJvyTxcUTXYWuLH4HwKvQ+b/F6Jq/wat8WoLweKHwTYX/AE2+B8D4P6gKfgfIejRH6RV6vV/gf8ECgtP8D4P6z8D4FCh8H9B+BQqT4//aAAgBAQABBQB2YODwK7g0vSyngkWZrnyGxJct07s8YJNRzSQ0Hr6hmJK3NNcUSwokWver1zci9EC7BBRJNAihcnvH4LGydWZkKUCKAvR+l7FZJFWJIilxSGxsQBVxb93t2ZiATxyBbi9dV8cjMKNeK0JtXezG4oM1ywFFr0wA+CbsDR5orwxiKTNCT+7DmQMjsGBok2C9qljZCbXuLWWiCKZVFSRSxi5JiDtIylZAOL3BIoqQsMUssmNpIFU6rWqW0+uam0Z7ZWvz1cqy1f4N67noE+z9+L3HjkuHsKNrFj1Ymg4AvUigO1qDHsbXlV4n7tYNQN6vxa5eMLGWr9mt2JYUb3ileFs/Pyc7IHS4UmiDXNwxFXYhUJJ4Kr2MutyY4gBfHyXxpWdyNdBFDipa2TtRDkw7fFao5o5AkljkYuLlLkaCRS8ckT/9J4qxB6v1ACjjxTFTJjxCZ5Y/G5C9SAaCklUNzYVc2YCnkaWSR3kY2q16BJocUewosbGmF6vyRauOoAKnrXU11FupNX+LEHBz8jBdjzhrfMycdTBnwmKRuD+2ryA+PFIAm7wCxPNAupxdxlRnF2GNkgMakwsfMGw0mTgi/NwFEj9OLWXxnxmXty1xQFyQVAjJJiow06WDABiQA1r354NXtRdlYFrBgWJUlbhmSRGaR2brdWT7DagpoCiDRRLcWsALXoC1YX/lse0OwwvOjoVYp1OPkNjS4+QjoCrjaakwHmwsTYhtVk5YEk+TIIpnx59jpo5gFcyMjI1/u6x+OQ/xLg12ULY0oFQxFqxteWOVrGSpoujyDllF2+tqYWq60Sa5FAG9gDY19aA4HcJ5V8QuatXUrTckrRWipr6UBzrUV8sD+CyhhtMA3+gYWOLlNjSY2QkiXDjYaQOXR0bWatiYYEFSBesqBDC94dprly05BBUi/wDDmYqfyZa/KlpcuYKuXNUOdOG1W7y4n2m/y5EydhkMXzJzU2fkyj8iSvPID53oyyV5XrzSV5nrzSV5WoTvYSyXaWRSZ3t5ZABNJSksvUGipuF5KOo63r9tHD3zBItHFdzLiOy5mmU1JgTx00UtYcsmPNHsIZ5I5gaj0uPlVk4M8bO3Wml5cdlgmXqshU7rXrG5I6/5eSSK1W11WHj52T6ziaTRjTbr2SPV7RsWM8tgbTGhLTTVmYmZjoNTtmx+CDxS6TdmGKGaeSTX50WNj6ja5UJ4Nqh0+3ngsSZ9PtseDSNAMpMbJePK1ezwkxcHMzJMnCy8OSEWjsRXWnUAvPM0duxtZvXcW4TFRTYAMakCtUuKjF8BSBrhdMMK0GSY3GaAIZQUyoceYz4GSGaCeNM13SaGVXTJh8mKEIa38PJt8bv/AOQ/t8wX2fVe0bub2LTa7HT3DDO+h2OiTDwfc9JlZ/sW+zf6kn2XukOEu40ck8W4lxfcE2ixRxf3Zfa7Lf7n2CHdzbX3SPHkbQYUefvPYPaN0+90exgz9vrva97Fttdr4NZ7165scjW+metbLP2OF63lQS6De4/s+HpIktGYwB14I5Nq6m+s0vnrGhSNCtOAKkYUCWrqKKCwVb9eZ8Ysqd/LHlFRNnRGseYsS6lc6PHYp4UTMy48ePqC3VfHlqaANbPY4eT676lscTWbrWTx42xX2HGx/aMTE9MxsjSbfX4+51uxi1rzYXpmXlb3L12XsfVttBpt5+H6ni5D7/VH+4EeS+PnZ6eqbvM32Rppp8PKmwc3Li9Q2ucvtGAm/wAPD9MwcnVewwv7Jg52LF6t63nYuvbXHQ5WsmytTrfX4o/4LLamAFEUBc6/GMjY8QRIgTVwKm4Lm7i1uhNdRYAgDmrVlYncZkyY0JMksuujnWpMp1qfbjzNtXsoeagvP+XmxWXE1+VPC5Lvj6/MycbmotfmS4d+YsHMkwixsxvRq1qAscnXZeLAOtMSWsRRwcoZWVh5GHk4+PJPNk4c+JkLGWoRV1FuldbCJB4HWmFPGVrHx/K+BiLGi9BTSAV2PWeU3DC8MZNdAA6WDMRUdzUcIajjRePY40OS0euSKTxEBYJ2qdf4qiKwsAixE9Yemwg6x+n4QzMHH9e0OyGswHytVrtFgfyoYWBD6ZgaHXLqWwcLH9JwtFr11my0mIuvj9Z1ceo2uiwYNW7B22Ot/Hwtj6369pcvf6Y6fM1y4r5ntsWuHuPsur9di9hy9A+v3iaD8j2CPT6LLjULQj46AVJYVGbY7qTTqe1r1r9eDUsZgi2EMjvqp58dpH4lhYUsVJYAn7mYU8asIwqskpARwFMLO2XigVIvWizhs/D6EChe9WHjz4j4NCOun9IFvZdAP/QbxTN6trIMgem+wAy+v4OPOvpObk4UfrTZ80vre+v/AEvAP9AdSBvOdX70f9V+2n/tY/8AE9lFve/a1J9n3Ck7if8AmcXtWv8A5L7DkiEgrFUiAFxUMZ8DpcN2NYGMZcjFh8a7Et+PshFJmaLVSiRUAogsZbKGyVQZGznnlzH32ufV7qPNKFWEK2JSlfpU7hxPGGqWFo5ZVLRMOrgpX1H2+PYf+HBl5WNBhZ2VrsvHz8rFg1u52OsGd7Juc6DWbrZaxc32LcZ8Gt3Oz1ibbe7TaR5GdlZOIudlpruhrI2GZkQ7DNytnl5WxzMxUjJrL3u0zoMiSbOzJs3JyHizdg2fJvds0PXgi1TKLvDIEgj7YjY1wUUHXYyBPHZH7OP5Zj97UFo2AyVuu1bJEelmTF18pnLY2HkSyYeLKFSNwLEUwIqRuHFZEALyrYS8Si1+Sv8Al5eXMseDk4HgP3UYypKBSsasTGAREWJhZUMPd5IB2KU1+v4HrGHo8HW+o7vI1mox5sGJe7vCBUCsCmKWqOIktGLeMmjxT3NSObYuDKcKXBsr4x/JwILmXDARoVjLOGLOoKi4awWVSVbDiyEGmET43r0Rkx8DFx1hjsOp6uqirAnIjCu6kmdRU6WrMULkCRrAG3PjynLD1k/+o12ybX+lw7yfI9aTaZm69a0eXu/5Vs4NxL6rLnzevaNtxJsfUIcTe4Wi2GLtZ/XzIjllvU+BgZfq2ri9W0OVpJnydZo8PY4nrr4W4zdZop9kMDIi2L6fWtlS6rbvmmPPx93iV7BiTfg3BUAF9fiwLhHVxyJla6COXFxwr+xb0a0T73ySfzhCMLdKzw/ejIxDJysYu8LXx1YuqhHR+QQRMrtRBVZSSTxUy3EqFq2UFnHUGR0kPHjyzXr2Vjw62TLgHp2LmYyeo6nNxotEuTDtPXe2nwvXEyNbutXNj6zE9LEuBv8AVbHD0mt1TY2KmqWQ1tszFn9eKcaTKxodTiTYW00hwdRrddBPFm6HGGtw9YkGBl42ymji0+amJuptvHqseF3tUEsZGvMcWu12fjzRZ4jKRSCOva4PyZ54qcurwSAtpY74aYlxkYiBQhFKppI1VTG1KhuJAldqlJNS2BY1K4s5Ns4F1VSaAU11Tx5V7KbGOLMzp+1d6L3HY2xt5q59dtN9hza696UGl+IcaeZMZIneSOMN+FK0dgrRuDS9QiT9gzg00vLXp43p2dK1W2f8afYwRVi7cuJMhid4qvIjKzjHVqw9QFfXBogjzMJvLYRlqC9QGJI5ojk9ezNYvJYzHksalNywsMpL1IPHIt+viXx5NxWj0eTusj1DSY0O90eiytzK/q8WRB240vrWXucST1WCTD0ehyNuJ/Wo3w/Xtfgz+oH7X02hk2OPqdYmJqdPqJc7HytUkWFK5/ouHRR/gZerfBr2HGxItXFp44cXMwJ8V3c3MwtGQTkEMIpRHBJmSyHByUVfIemV2ZhiBikXiOvYPUfdY0NOx7JR61dLu/WhMzAk0WoqTTpzJYDpdnQqs8YNZcfU2rv/AA8k1qiT6R6AJj7LriT6D6EJz7dmmL83Tuy+k+iH/vgWP9uf7ehz7JqCP6MBrLJPonrHl/lkU2rj9J1uy1SY8jW9G9kytHFl5mdjS+u7+Tph+0Zejh2uxzIX9f8AKDTzJSyuGM1iMhpIbZBGOxUYavINzCYW8eStLm5CLg7OMvjy/YHLUcuICPMjdw/ZXa1D7mVQKN2YJRQ00fEsdl63LoamhdazI7ggV1HjywynU7ubUjH94yMJ9Ru83Tzv7hPHikADG2+RjarUbjI1M2n3udqGyfbchsDRexZOmEjrJLqd9laxG9szJMbVb3L1keX7PPNgNtZ21OH7HPFibf2HJ2aS+xyz6jH9lkXF2vsGXtGztrLmwixpr0wvWM1oS1nwoJMh8ZfHHNirlLm4Xjf8eYk4r9Y8nNxneXZSmHBnZdfiCGo2cEAuVRFBIoeJa7JX2kyKsbSxcmFwSgBmF6ygbEV1/h5JAb4vXJo/X5QrTGISXAoGouxfrIrKrmu1q7UWNi9Brki9dmIa5rubK3Y40GPJiGHDUQ5katjuGHUrWXhGRVxHNfjAV+HGH/HZqTGACKqgOahnK0rCmc1ZqPFFkUNMRRmuVlZaaZGop2GXGRTqVPZuk5s16B+OavxV/gVer0nUNG6o6zFgZuXe7XIBau1RlwoYCl+pZSGFgO1Y0ojhnSJkMMsORgqaQ2VrGiFBeRCWKhu1FjQZhSlqW5q5WhICPKLM1iXJEjV24kkpJDXfqs+RXlWZ/IOmS1yKI+frQv8AF6B4F7AjqvQhKiu5Z+e1XPZjdlJFK5AoNajJwGoXrEj7RyJ3qDHhtjtElI4NOxpzZi16djexYAcgBhbqAbjsRXe9FzRcgFQEJNBHlaaCWF0DMJO1swkCWbrX5DeOe9yrBb0wkYVxbiib0OSDSdmKqzN9KR7U7Ve9IGIAJodQDQUlbi4egaubrJWLkOIHyIYETN8lYQMoisis6mmB+LilJFF1qaUig5BMiivJcFyaXsKIDFwtPJag9mJMrKFC/jsybBbCdh37Hxz2Lert/NNIitI3ukgw1Ho22EZ1Gwj2uR6PucXE2usy9TnZupzMHE9W1y7Hdx619d/cnK9J20+wOs2H8wHo20E2Lo9jl7aH0XczV6HHNB7fqNJsNtJqtHnbZ9p65sMLEikH+2YFzdQC1wKTiopSqTSeYYrFhqmKAsCDQkK05BFdgCSBTPcd6aSlBrqAxeh9bgliq0irIywgBIioJIXYLU4tNfC6T/dJo9pJqdvjaLFwvd9DkHa+570eoz7rYbDAz9/7nPLP7Tn4UnsmF7jnw5e+9cH+oMIf/qOynnm9g3GLs8v+5H4np+Nmpb/d3FyZpd9hhf8AdjdSYeZ6rodrg4+ul0+G+oTNiHpv0q16619K7cK48d6wuRgXAjuQRUkZpmdD5XuXa5dqW5ro1hCaCBaAUkkX5FMAQsKMfGAAhrqacGtgx65I/i2/h5Cskp5E/t80/rcU0kMsvs+i2E2w9oythvNrnjY7X0/NztHoR2rDnkw8rI9owH3884mzJPb8gezjfaDEk/q0f1bBP4cuL2oR+2aLdzabP1/sONhJN7HrYNaufhfyW/Hau4q96NIVsL9NTjFsXBU2jWw5tJwHtRjJANKoNeJRQhZVBIDAtViqqVFWDV0FAEk/bXWupNPGRWetxkK3foPHkt3nWJmco7N1NwleNgPG6jYbzdbeKLWwPhywsKSJifG1eG5/HcjxNYwuB4jXgehCxPj+zwtcRmjGbrE5IiYV4XIj4AFxqzzgAUgNr3pyae4JNWBKoLqlqK0bChIoAN6ki7kKygN2HCi1wCTRPWpCGGaAVy1Ha/8ADl/xe9MyGuppVvWTizREiwjKio3UqOafgxdw5qAXpiA2a2LI7IQqi1EL2P1b7avVgy9auoon7UKirCtcecIfaAbAipugEh4VKcFaSzUBwXFKLkqxCgigrMZIpJQsRjKqCCAKUqAeKkas1rKUxpJ+PHLbyK7K4BoWBhcqdhts3OamY3hfo7SC7P8AYFNJYkTvDLe5Br9x1CykVzawA/c3BXspN65pAxCfc2tg7Njp1UV9Ke7M60brRXsAFA7G5CsAtqXuWERoXsGNgCKVgK7KQQKN1qRjbMlYrmPH5OfHKwEoFfSgpukMLifCKhvqCOy3Zl7UXJoUGtRDVgYn5cjupHZiAetNalDEBCaPYUzG5Bt2NfuLXxYy7a7GK1Gn2kGiTRtR+v1Cg3K0L12euRXZivnNkcvVqH0CpcsRTycMxFSy2rKckZn2yfd45P8AF4pelk8dRjg9gMoyGVrXUgBb2riw+i0O3U0OtGv3XuFPfrHYl7Xe1+bniordtYIe+IIrALX7z9K57NXNuLAm5+v0of8ANezyeIuQO6djQ7Vc0aPa8lrS96nMt8rv3ufH/9oACAECAgY/APY6ncFrCpIezEoxOOiT4ugQ4OuutPEv2GhTV+GSY5ZeyHuTjahIK6PEPxJx80SnjvGtWsJf6JmorZ4apaN6oDLsH6kZGMhGL1y+CnMqSw2FCQmabCnvx7ViVSTt2p7uzFYqhdk4L9xTP96a6ux0NMjuTqhVQsGlzBNEW+8Fmr2hUKjPVL+ZMcY/wW9BTixc3011nJTEIsDADKMWlw/QvMEQSDERYeX6UeLZ7qe1oW2xA8v1BjK/LHhuTMZSs4ZcRphK1TYFvSlHLD0o3eGI8SiQGgIsGh6mbXljzJg4laWuyyHKrYeWQ0WlSyjxu8v37lL04ERtbhsuldlaPurzJW5rwQWzMLOFUiS83IMP/SPnR/Mh3aHVTTUOjXBEg2qjSQFp+1HWTiVvQl8P2SlaiRQgxBuEo8Z5UBGucQdjbjmzICNc4hhK33mkmD42uxtu5b+FMCcbXY23Dw3KIpV/uCAiTUPFwYiXwurGPBKbsWyp8DbfWMraY28yAL4AkiMrRdg8vDpHdoYJyUw6LatAI0b0ANsT9M7lIhqny/8AzndJCIEbRO+5623+o1vMowAjbGd1z1tuv4eZAM4ErrjOeD3f9fDcoilJme66UlEjw3fijavKw/bjbL6bUCGa2UD87N/KoCmWEoHvlGP9KFrCTRAmJSg1vPH+5pHdpYa9DYJk46BGjegS+MRSmM048t43ny+Kplw4NwIvECUZWSeTeWKXXX/oQtiJSMjCksmUXGV/L8qrERlcYZpWwyi669EhqG02m6L9kl5YJlGJkQbLn4JciNpnZd5bSmDE3SnnAuzW2ojLaJWcf7jvY/p8tytIiM1vF+58Vn6kQwDEjiz5fFKCiMufhaV0ubPHw6A+xUT6XGiul023RvQHcfplcmfCfqfiuTvW68UurZ6eCcGUpXX3C26Lxt4eG1OSRO4zBlaZZsubwoPMmtxfX7vuqMiWsL/ULPzJjSsZfTK5ZZkRuuMQ2L3GN/LcmEiI3XsAOK6/NJAmRIiSQG/MhnNseGP9R8WgAnuKZ36oJ1vQtLEkRfluOKmBJ5H04iRHDddijAm5gJPrzf8AFTldSEgBFseF7vqU/MupAkWNqjtPNJea5Jz/AJYoyMmiPMjGxtUPNEceZGQBtE7LWhZbGVnHd6lyEIvmn5pJiIylkn7+XxLyjJwQZhsua36lCUgW8zaIRhFxdGzNfpAxp0X6QQW9MQ4ZENxY9qNoxxRDcVSnIq77+5GQxlirjFy7/MPE3MrjGr3dl3Nbw3JiNZlsN0sS6iBFhA3R7CrhGow7LsbY+FMMBoHd0MOmNG/rh3dbvT9odRjzOe6MUWkCyyyB7kZPQP8Acg5ABiJAvtQukA9dyrIDepA0ERE3H31bcLtilRrZGP06Qj1m9EHWGU7qSI9Md3N8yZpUiRmMba6o2qBjxRaIHxZVYOW1OYtkEa7RcgGPBGOSzi13yl+VFx/bhD5o3XBCbVhGDR8MpRuu+blWWJrIE1ifKbmldmjL4FKjPInRTr66QSASMDsQAGiqNcPY9/RbRRP7Lq6B06lr3dfq0asV/9oACAEDAgY/APa39hcaBoqnHUP1zJimOGl1VU07Ezvpw6waK6X+7SR0Ae5AmtUO/bcu16ubVsqh37bl2vtW9OSqody/z/DqmxWxEvpA7NG51ufrW6sd2l0f9lu0Ht6Q7tBTnoV6Y7ujUdQHwVNnSp093WMsHTbOs3rcvtToBsQgNqHd0aaR3dGnUb+ur1WrTv8Aa9+h1UKoTLBU0utz9dToBu9asUXwxT9qx1recVvJTbSVU6t63exvoOnD/BX/2gAIAQEBBj8Afu1HD1rE1O7aartrTTtWONBQV2I6qk0wA37Puo0wpnjmsdntW4ZYdiplvPYia4nH9KAaSW0Fa0BrTiRLCSCTQOpl7zvjRxwTnMNNTSwnA4EcWa3okA7q96LnHi7AKUpREUNWjE7h7zkct9SqOb2HDEVxWNa51RIGWJ9FVuR3IUOrDHClCqk1JONdqx+j0FumkmoHUKnAYODv2lqBFN21EudpNKtoK4jwt+FNdqFXA1AzH2gstxWAOY25IDaFhuKc2MlrXYuAzoPeKdK94qwt/DxDnA56HU08CApTYUeHVUUAOw70cabCFWmCzrVUJoK47aIhldOzVSvrog0kuDRgDsqamiNKUrXtRb7UMe8fpRJBJP8AWqzw5df107GlXOoKbDwu4lT6VzdY8QaG14q01E6V9aww3Ib1nQjI12LDD6UdgzwQ4g6orhs7FUnBVOJ371j6Mwabk3QHa/OTSldmlN5TS3hAdU1q7a773urHBADGuXenMceJpo41rWnagHYVxpt9nopkDjQZVVEQWmrPEDXD7QQptwof2kMsDTtRoK4d3r9GDtVRupim6hQOGpvaDtWOPZ3INZWsh0gbyUWy1BbUOoQcRhp9FNhx9a0+xAkHE4HZghHECXuBGG456ihznF7jmBgEQ5mPeSUdLpGH2oOhma6mx4pitckDS2taxDD+61Ygiu//AEoVx7F3rHA12otIFTTHaAEXVyIFNtCNy+tZ1GwrL+H9OtO3aj9aA3/Wvi2jYiM8RTeFQoilQdpr6BXFpAIP/wAlu3IOwJFMCMDTeuGoFck+N4IIOLXAg/3T4VWuOXq9GQNNiI+lYJj8fxAcdmBpuVED9CJA0jaK1Wk7qDGtPMqYbsE17HaXNNQdxBUlzcyGWaZ1XvOBPqCOupwNKGlDsWzLCvYq0o3JEDAbd2C7DhRUPhGXZ3LDNUzxz2IAYk4AJr3GraZbQM1TErmxgawCBqAcOIaTwu70GlxLW1LWnIVUbm/mSDVIe/JVUkZjcS00JrRUcTGdtcvauB7XDsKwwWmeMEjJ7cCFrtnc2P3Dg76eFyLJGlrgaEEbVuIOK3neFTAFaqHTXTqphXOlUHYE1yP9fMvuV/5idTea+1Bge1jjlrOkV2N1fEnRuI1NJadJqMDThch720qtcTsx9q079pyVBQ4VKqM9ipWuOVFw5Ci1vdxEYuPYKN8Pci95LnHEkmv1o0WxaczXh25ok4FuzLFCtQHDAnCo7EBsA2r+tVQUNNozNf8AVR0mgy7wqZHtQwxWPiB9VFWueaqMRnhsQ37Ue6uKpsGQXYi04OGY7U+SAhrnsdGSQCaOz06gdKrnXPCihGzWPrVAMUSBgVnXt9DWk1dHwkdnlRaQDrGe1fNRipAAeP3/AEBzCWkYimdEGykSsG/P+8uB9H+47AruX/cRg7nDxBOljHPhNaupUt+JzVuRbStcnblyy86AdWnZXKqxzNKUX3Kfr5p5ccnE6fex8OoeFdmxY+vvVAVpyO0Kgz7Flj7MQq0yX6FwigpkccVSncVgscVuXb+lBzTiMQe1BwxIxIIqBuVXZHaNn2QqkUOOW9ClQ4Yhw2IxvaWuaaFpzBTnPJc93iccTgiaE73big6oFSRpBxw2obwty9S9WCbQ8VOKuQPw+9wojOv9cF21x7ljWg7ENvYoa1we360BgRTYnAEMI4gT2eVFhwI2HtRBI4cO9CRo7HDeE1zDgVQjDcnTQgmImrm+7/srDJCvCK4uVW7MiMMN6HzAMjNlfEiAeVFsAzP2nLmMcTXB7Tk5p8QRnshR+bodjhvatGTyaUOBruRY7MGjh2hVHDuAXiw5NcvNr8Cca46j31qt25Y11bNy/Sq5V2BYDbQH6kGganVxOxEvb60NQwaMQMKhEnGu1YYd6Kx9SrmDtVaGtMKHaqFU2FaSKbSdqxrT6VTdiq1qTn2LZh7VtDHH1Ej95GMtAqQ4OpxfZ1e4qLSDh34VVfVXeqCtMSFvVfX6OxbtyjqKaRXDaRtVNtEQjNGKkDiG8Km/FUIoRgQqtqYicWlCRjqitKbVpdmjLbUa45sOR+ytLgWuBxacwVz5hRvlBwzWAoBsRFKmmB3I4V2lRvBxoR3UKNxCKXDBxN97/aVCEAaA5l2JoKeFbPy/31IRmCae30Uw9iIBFDmN9MlmPYhQj2IEOYO9gP6UW643DDHQFUkVHwoYjDAYBNa9wIjbpYKZCuqiph7FWuK2Y9izC3+jGhqtixRxx2YKgI7PWi0kGh2Yj1ICgBBONMcUMRitnsQr3+1AfQsdmGCruQfSmqoBpgfeXd9KoMkXbGtr7VozO4LUMOwqhIKLouE7dxKxAJ2UKLS2u3BB+guaCC9laagNic6NhhBJIjJyFcg5UONdiEs7OLy0wPrQawa4h4iNio3A/SqFEhCA4PqXNG8YIEbF85GPwpcSBscf9ZNAGLa1O+q+5++pewnD1p0d90mLqMjnamyyPewgU8H4ZXTOpj+X4HP6jzdUZkkAZyi1uB1cWrUo4x02O2tDbS6rUOc5utjHv5weTrXzjbOc21NXPEbtFPe16fChT1L5ma0nhhwPMfG5rcfiITtDXSaG636QXUaM3u0+FrVHLcW8sEcorG+Rha1wz4C4cSN2yyuHW4FRKInltPe1afCq17u30fMDp1yYvEJBC8in91cuFjpZDWkbGlzjTPgamXkltKy1l/LncwiNx+GSmlfMW1lcTwjOSONzm4Z0c0cSoRQjAjb6/R8zBY3EtvSvNZE5zaDaHAKgFXZU21XzFxY3EMGfOkje1tO11NLVL8xYu6jGYZAImAkscRwXHB/guQkZE97NQj1taS3WfDHqb/Ed7ia+9tJrZj/A6WNzAT9pwXKtLeW4fSpZE0uNN50rlXkElvJSoZKwsNOzWm7MAf7Ee3P0YeuuCZCXF0cYOhpxDdXE7QgAMsxRUIxGY7lJcAFofwtb2Batu9fpXeqURWGZWAosRkuW5tabaYoEHFVdmcyqltD7wwPrX4R1jZXAomRhB3UUT2cBBOezJCQYtcMKLkSDEg1G7cqZnJfcp+upa1rU09vo/lzvuv2o1A4iobFMSN4DHHSrS5fdyUmnYx0ANIhG92nkNh8HL0LrT42xNHTPmJbVsp0xNfq0xOk92OLUm30/XbKcOcPmIn3Opj2E/ixOhLOXoc3yLqbbItmsore4fC0HUx0egTNi+Jn8NWFt1ed1xbc4zcp3gBDdWljPKzg06U6+Z1+ygex5MMTLrSxjQeCJsbWaNLWoT2b4Xtu4I5pxbkGMTmrLkM0+HVIzmK0ktrUX07JAYrY4h7hkF/5DqXWYOnS8wPMT7qump/JFtBr+xoWiIBjXTB5DcBWSEOlcPtuUfTLqdw6fcXjGi0bQRMY15ZGyNg9yNSNtetWdha2juXaWrLrlctjOFuuNjfzf8RdPvufbz39xCWdRdbODmOmiIa2Z2nzzRO41YWcuMc87GyDeK8QU7ra6ktYbOZ0VpBE4sYxkTuWzgbw+TiXVP5mfaRsuLCyNw2JuMbrgARfM6PLrf+I9R3c13Lcc2QC4hkdqjkY46XxOhP4ejSfdXWLO1GiBlpdGJg8rXxc0R/c1rq91bUE7Z7dsLyAdDngs5zNX8VrNWhy630/qE8l3busJZw2Zxfplj445Ga/C7UrjpEPUW9I6hLOJee+rWyx6dPIdPHxxaXplp1QMvrATCS36iyTn6HUpymTg6mMm9yVM3gBZ1OwDd6MUQBnlXYht7Ag+eob7nZ2oRxgNaMhlkuz0HYhhiFjmu9GiIGRwK1R+MfSquJDhnsVHYt3jNUBArkDmhVUKaHRtdTeAc1pA0tHha0I6jV7gdDNvegQaVxJ3LPyfTrUpOOJ+v0dGsInk3FkZ/mGkEAcwsdGdXmyTLq8eWQCKVjnAF2L2OYzAfErS4lJEcMzHvOZ0tcHOXUb7QbrpnUHzRzMHCXwTYVbq8L0LqXqcl3axnW2yNuRK6nhilfq5f21e3kkbbO2uYLiOGGMEtYZGlsMStb2BpN3bSB5qeEtAo5n3mp14OpSWVvI4yPsnQF0jCTqfFFMw6HM9xSS9MtW2dkA1kUYFHENFObL/AJkqgv52OfC0OY/R4g140cyP4mI30vVZOpBr+ZHbMhcyWQ11BtxPI4sZ/mOUPXhIRYOMb3u0mrDy+U9jmebQ9C7gdR8UvNjd2h2tid1N98/pU1weZd2roTKOYfzH20rHeCTxcaii6Pb8m1toxHznDTJM4eO4mb+yoLyDCW3e2Rne01UnU39Rk6c25cZbmxMJe4PdxStt5mHRoe7wamqe4js9PR7i3+Rlt2gMe6Cmjnv0cPzLvzU2+l6nLewwuEkVk2AslcRxMjmkLuX9rSr/AKx1E8kXsNwwAAuDXSMMcEeHlbwsXUOmveW3VzPBJG2hoWx15vEuo/MuLBdWM1vEaE1keOBpoj0/qR+RumScyDqDI+ZqaRR1vdMBa5zP8NzVedJ6fdv6jN1B0ZlfoMcMTYzr4GvLvxXqMj3R6DtGVR6N3emkjAbggKLHALDJYblQe1ADCgW3tKwHdVU+r0VyqtTBjk4Kubsmt3lF7yS4lAucQBjiVSle3JFrmkDsNRhvXAylcicfoUkr5BqbQkOOLuxi719399SntP1q4uoY9cVk0SXDqjhaTpa4td4m6kXYcRrQYDFXF1BHrgs2h9y6oGhrjoa7STqdxe76J7+OPVa2pa24kqOEvNI+Hxcaqpb9keq0t3tjllqOFz/y2lvj4lT04etVVtPcRlkV4wyW76gh7QdOoaTw/eX9c0Sdqoa9yZaPiMdxIWhsTxpdV9OX4/Dr1KW1uWGKeBxZKw0NHDNtW8KjgibqllcGRtrSrnGjRqKltrlnLngcWSsNMHDxNwQAFScqIVw3rJURGwqMj3R9SoPRpc2hIBHcRhkjrrlgRv2IErjcGjYCc0KHA7QfRnhtVciViMPRUD1o0qScyqHDuQJFKb0S0UcmO5TWljaCgp94ol2NVgctiMlw4VJ4WDIKTDznFODtWXCcBxfFnwrCtf0JgcS1ubjSvsovNl2eHX3eNTHM4/Wuu2pkZAJbRodNJ4GNbIHve+nutaprfo3UJ5b+KN0scdxEGRzCManthc062O0+DmLq12LiSE2cDHmJnhla54j5c2XhX/mOtXb7W1keYrWKFofNK5vjLA/haxi61cdOuvmbaZ9s0B7dEzHNfxNuI+Jmri4Xx+NN6v1u7ktbedxZaQQND5pS3xv4+FsbV1Saxuvm7ae5ttOpuiVhaeKO4jxbr4vImdW61dvtLedxZaQQMD5pdPjeA/hZG1f+W6Tcuu7FrxFO2VoZNC935fOY3Ux8UvklYrLrXUuoPt7W6a4GJjA6Yytdp5Vu3w6NHG+WRQ9Z6TdPu7CSXkStmYGSxSU1Na8N4HMeidIbXcMqBdGldcyTR38TniN2UPHy3shx83jTrXq3U5i9x1Qx20Yc4REcEtzq4WOd/hsTImzC6triJtxa3AGnXG/LUzyvbp4lE28kfFBXifE0PcPd4XafMopIZ5H3jri3+YhcyjGtDYuW6OWv4mpXruq9QmbcXMxkEVrGHiJr/D8w6T+J5tDFD0583MjmdE6G6jFNUUtOVM1p8Lmq/sJ7twiszK+6vXjU4xxeORzfM9ylb0q+mbcxsc9kd0xrGyhnE9kUjHcEunwNkVS2opwhZLFUGSj+wKI03VPcm1Zy6gUrWhHv8XvKgG1AkIu01oMgpXXFyW3ApWMVoK4iIfYZ43KKGSVsrZxVjAauZjT8T3VQLGpJ2diB+hCiFFgaqoGKocCfYqAfpRBzKwFKqlKHejsRxqSjJGcHYvHbvVMVStFXftVaHw/RrU4OAxJw7V/MOw/JtH/Marb/AHc3/Tev5iH/AOLH/wBVq6DcxY29u2a3mIyZMXiSj/d5jF1y5cDyJX2zWOOTnNk4tP2dS6BdRY20UElu9wybMH63Md7rnsXVZ3NIgluLZsTjk4tc7WW/3l0e6lsLe9hjt3RcyYvBbK1/HbjlOa1ur83jXUn2XR7a06fNy4rm4je4HWHB8PLZM53N4v8ADX8uD4Lk/wDMYrv/ANxh/Ycgd+K/lgnM27/+sF1CpyMYHdy2LoBp/wCnNwGH8SRMPxD6wnHImW29mmJdVJx/7h/1BdDds+Vs/wBpdWu+mBpltnzPlY6h1RZTN5Tvzm++xNspenssrucO0XVmSGNcAXVmt3cGhEEjDCuxU9HcoieEFoNfUjt7lxEnAAVTTThbt7UK4FAtzDgTTPA1U5xrI4uBxxqjcyNIaMI9WBO9y7d6+EZqiJOQzXyvThzJnZv8rR2psz3smjeSA5ha8EjxAtbxNXLkHLmAwBODt6DtuRRpgDkaYIOGYzXCA402qpGKr9CqPDXAFFopWhxWIx7cliTQYYfuqoFdp7Fnjy9+3Wrk1qDUfSrmKE6YrtnJnBANW15lK+XiCbeWjgyaOoa4jUKOGh3CfhKubaBwbDesEc7SK1aDrbj5eJPbaSDlTfmwSNEkT6Za4pNTFNbXErflpwxroGMDGNEZ1s5TGfl8SfHayDky4yQStEkTiMnOikBbqU1tcyh1vPorC1oaxvLOqPksb+WpIrWQcmTGSCRokicRtdFJqZqUcN3I3kRGscETRHGD73Lj8ytbOZwdDZh4gbQAgSEOeNXm8Kf00OHyksrZnspjzGYNdqWOAKtIJXB0dgCy2AFCGuPM0k+biUl7dEPuJaGRwAaDpAjB0j4Wq1bcPDhZR8mCjQCIwS8NPv8AE5fpVtHdStlNm4SQyFgEjS0aWB8nnUt1cEPmncZJXtFKk5nSPCoJZX1ltWMZC4ACjY+KL+6ndSEpjvHvMhlZwmp8XD4eJPjD2RiUFsjoo2RucD4qvja3xKgy2rt9AfSjTgCouyMZ/oRoW4Z1VHDi2JlMzmO1E59qoTXYaoSOFaZA5INaKNGQC4u5YbESCuw4GmWKmlaK3BrqG3DJAuBJca4duxNfECw1o07z2fZTdWJoNR7VlQLcidiocNwVSq5ohO1DGpx39pWOHdvRplgKHNZDwfvqZtd49VVdC9EhmMf/AGbo/CJK/wAYf4ehdpVHAtIzBwPsKo4FtcQCCP2lRoLjuGJ+haaEHcRQ+woNYC47gCT9CFcGu2d29VoSTsaK/qtR0ggbnZgrJAVJ05Dcum3/AFG2uZp75smrky6WgxnT4XDzakOn2Au+n30oPyz5ntlic8CojkFNTdS60+6a5tz0yIOjo6ga8ScmRsjfOsG6idgGPsCArQ5uaQQR2OqhorqpkP8AQgMQ6hJBFPrVKOdQYUFV3IgAnfQE0WrxAZqoHqWnEf2q3cG1a+NqBY0g4Ak5VHiqgxxJANSCKUom6cMVwmp2hFzjQbisMkQqkHTtoqEY1zRAxRikFQckX27s82OxBohzBjWuJJp3JrWAFwFAf7F+hYhYqlaAquZ3rDPfsCKwTu2hWmgIrWmxZr/h/vqXZ4vrX8w12WII7+Y1Q3UTGG8+dkjtppAHcqrNUskerz6W6WK46pfMjvOodPuGR2VxK0EsMwzfp/N5dODWurjqjhcSWAintpnNAewufy5GBzQOBzUbX+X7GT5kyk3XUGtBJbT8OFkj/wAvT51eydf5cl3aSwutZdTHTND3aJY5XQ+R3xrp8PTyIbvqUZurm6ABk06uXFFG4+Hwrqcly1jruGa3D7gNDXSNLuAy6fFIynjVj/4GFonvozPd3mqNrxU/hW8XOc3S3TxK4u+txsbf2DmOhuA6MvlhedEsU3JLtfKdpcx7luJ9HQzedRZ07lifRrY5+urxXTyyNPLomdUk6oepXFvV9vbQxOYC+nBre8uX8z3ElA+a3Ej91XTB5+tRXvSYWvvr979dy4sDo42cLGR89zfzXK8b1trHTWsZns7ovjdIHMP4tu4xO1SRSR++nW/SrR/PdJqnvWAE6KcETXv/AC1eHqhbK+3dG+2eXMdMzU7RIx5i4uW9vvqODpc7Ibtr3m6j1COV2P4Jic/xx6FHH1GAx3kdRz3DS6Vh8HM08Ejo/wDFTLLpQEFvCxtZGvja+R5Gp8j9btfiVrf3UbIr573w3XLLSH6RrhuHNiJjbI9n5i9a0nA7yrOLU1x5LXOcDlUcLT7qBkFHHOn6FpcQ4ippWpx3oOaMRSg2FMijFZHCrnVpQdiLnhxByqaqrHua73UGzY184/eQe11WHdkUTTuWXorSg3hUoQ3aVtzzQAWOxAg4blUtoQty7VgtLRUnBF3hLcHAoitaZHemaGNio0NNK4n3zVfc/fUu6pp7V12GWRrJbmzEcDDm9+trtDPi0q2suY0Xcd/JJJAcHhhj0h5b7upX9qZGi5ku4JGRV4ixocHvb9ldcglkaya4hiELHHF5bIHODPstVhYWXUYeny2hf81bTvdEJC46mTtlaHcz7Dl1bp0V/HddQl5MrntqInct/wCTbvk4pnsbxPVnaXV6zp/UOmtdFG+YOMUsLjzGtL46ujlicuqRWVz87KLi2+YuGtLYySeCODVxO0Kxt5L2Ow6n05hgAuCWxTQ11xubKwO5c0aMAu2dQ6vM8EPt3OMUMY8TXVo2Zz1Dex3bX3Mkpjls6UcxoBLZtWriY/7KrVdFgika+a3+YE0deJmpzHN1/aWoDhy9a65DLI1klxbNbAx2b3CRri1vxaVB0m6um2N5YyPktJpa8p7JfzIJXs/Lfq/Lepufdx3/AFGUAW8ds9xZH78ssnDq4fIrWwhvWWU1s95nilJjbLqNY5Wyta7Vpb5F1C0bdtuLydkb9TaiM8t+rkxPf45MdSiBljtLyOokE2rRIK/hyxSAP0P8r41F08XIvJRK6QSNq5sbS3Tyo3v4vFxJt5HdRWt29rW3ME+po1tGjmwSNa9r45KeFQ29lJ8xcRguurkFwjcT4I42O9331qBxOYXHQHaVC9rs42VO6o4sE2N0g1gUFTmiQRqGDtIxICdqOPlw/aRmhc0yNAD2k0qN7QUAKEgUNFjUUWkGurIJjCKaRQYrjzKJGY+lVyot6AGBOartRrhXagfF35ejD2LHEqtQCv0okYHenA0rSnfRZVoq5diz8tP1/EpT2uH0oEYEGoKIhjfczuBcQwFziBi51B7voxxVKDfVdig6f1qyfcMtNQtrm3eI5Q12LoZNTXNlj9xM6R0m0NlYNkE0pe/mSyyAaWOlf7rPd9BIHhxNNg9MkkUbnthbqlc0EhrffkPlagJDpaBiQiG4tBwdTFMuHsc23cdDZSDpJGbWu8Lnt91cIrQqh/tWqpqTgCMKDbVAErDAhY1rsR21TXRnFqo6uA4ez/ZVvEW1Y1rRw51Hwprohr2hwNMSiNRc4mrgc/uqjiAdhzFDjsQlacW4Edi3BUDA+uFEDpAO2mYUYLScPq7UKgNNPChUiozVcMM8FkEMVTasVmsPaqZneFh6MFTaiiWVaXZEGmB8QWnyk1XjFeXTZ4uZ4c/D/mKXDafrT44nsggt2GW5uZTSONg8zk276b1KHqMMEUwn0B0UjKxua1/Kl/Mic7zxqRsL2QW9uzmXN1MaRxt3uU0nRepw9VktmmSa2Yx8UuhvjkhZJ+e1nwrsKubm2miYLR7GyiUloaxwJdcOk8PLi08aubvpXVIOqOsW8y5t2NfG8RjxyRa/zWNU84ljtLG1Gq5vJ/AwHJoA8cjlNedH6hD1SO0Gu5jja6OVjP8AG5Mv5kTfM5i6rzOoQwfMOt+a97Xfg6X8LZS0cfN/y05ocHAEgOGRANNQ+0p76e4jsen2tBLdSgkaj4Y442eN667dWt3FfWj7IxiWOrHB+truXNbycbOH7imu5Z4rLp9uQJbqWp4j/Cja3ie/4U++sLqPqNtCQLgsDmPj1cMbpYH8XK92Vitj/wD0JP8ApqK96lex9PjuP/t2Oa6SR7R/EEbPCxQy85k9nc/k3kQJYQMJNTMJGSxfxInLpkjb2N7obUBkYa4GVpkdWaOvhz86hu+p3sdi24GqGJzXSSOb77mR00MTDrZPb3DTJb3MZ4HtHjpqo5kkfnjcqqhGG9cOIOCOGA3ZgKMx0aC0Gp7Bi37SrrDC41IAo3H9n7C1OFSRRp7fiVMAKV0oineAmimda96BFdOdclqYC7ENzAr8X3U5kLQ2n5Zrn7xRLnkCmA7Vic0ar9CyRIQH0FYhFd6qqICtKmg3IgjAbdiKxFCMDXYq7V9yn66l31I+ldcEP5omtjMG58nVjX4Naj5VdIhn5pHuct3i+8urCHxi7tzcac+V5dXwc1dO5NcHkyUy5ek8zV8KuOVTlc2TlgZadTtFPur+YS001SWrT3F+IXUf/bbqv9xDk5N6kPm6bjGeRr+HUmn+A2Cc3J8vK0O1a1/MFPDzLWndrNPR07lfltvphc0y1lv4Gv7urQv5gIryRYEPOzVrbo/eXT3X1tLdRfNzB4hk5QbLTg5vC/Vqj/LXUB0zpN04PtZI7lxmEjWMeOGWRmhvge3UrY1/9Qk/6atfm7KecmzgMMsc3LYY9P8ADZpd4XeP41yrSwnt7V90JGXMj+YzmBpZJG1+lviYuhHZ8jWn/Eeg26sp5nmCExysn0MdHoHL5ceh3CoI7SxmtrQXLpIZ5XiQFxaWzRsdRvuqh8QzRoM9n6VRgNNyJIqmMa3EtAbTOtEAcKGlMM9/xIDPTgXdpxW8HPFBjAWhwq5w3oHmONDWlcexUlaXVpSuGCo4mOtQ05UBTSxxoBQY1+8hU005FULw2mOaDY5Qa5DescxmsFiaKtcVTMlZ0VKo4HHKirWgRrlsOSoHVCo4acK47jtR9qzGGa215f62vJSB2GZAzzKM9pT5hxMc0cgD4pYXDihmjPiQPTOnWlgw6ueyJp/FqCzTI9xL2xt1atDE6W0LSyVhjnglGuORhzjmjd4lNbdLsLXpRuGlk01u08xzT4mMkkLuXqQoa1HsV70pjGuhv3Rukca6mmI6maFPNAxkhuIJLZ4fWmmVuhxbTzNUrYRHNb3DQy5tZ264pGjw8xn7ylsOnWVt0uG5Gm5Ns08x7fcdLIXO5blPE23hu7W6DRPbXDdTHaDqYnyNYI2vcXBgyaCa6G/CxSwNZHdWlzQXFpO3VG+nhf8ADI332Kfp1nZ29pZ3URhdbQNI4nEO5+snW+Xh8ylt2sjubS4pz7S4brjcRk7T5JG++xP6dZ2tv021mpz227SHSU8skjy5+hR9JLG8iKc3DX46tTm8tzfd0KOxu7WDqNtCTyGXDSXR1zbFKwtfo+BQwlkdta24/BtYRpjaT4n/ABPTOl3FvBKIgGW9yW/ixt1czQx/uuUVpe2tv1GC3wg+ZadUYOPLZKwtfy/gcoWytZDb24LYLaEaI2V8VB7zveVrHLFG35SIxB7BQuBODpfekaq5BYetYnv7Aow3E0wRfWuym1ahkMygAcVpf7UWt8O9EUJAy7QjVhBBp2JpjcXaf4Zyx95FxncA4VDRgFzZpTVpFCTnXeg4NAOxyqdqoga4dipTBVwI3qoK8So14LuwrGpOwBYg02BY+goge1fc/fUjW44mp9f/AMGhB9WzeiYgXMBwDsz309IDAS8mgAxJKoQQduCwBKps3f0QQPUtJFdyFTh9CI2HNU1AYYVUL6lzw1tWjArW5lCMMcu9cmIUaR4gMygFjgdqqMDuQbTiBRY5uIzqq0rtIWAwXdsOSHZsWGQVdRasDVb67FjjVUWNV9W9YkrB2CyoVWtT2LHBGi+7X9dSdrj9f9AkiuH9Hd6MUNYqAcQD+lB7Kgg1HYqlD6UTvKqcisckaDDYFTTUO8Jp9SBrWufYga4eg6FliogKklrdX+hAVLSTUhRtFKHHhNcxVDHEKpxJKONRvXCqUpvQNMNq3LegciMcVXfuVVhluXFsyWBNdiqTh2I0dgcwq0H1qpwW3s9Fa+oLiGA25osj0hzstRoBhjxFfdr+untzo51BjhU+jOvpqV9Ho780PQRt2J2okOpwCmBPb6NIIbgTVxoMMfTvptRIFATUDP0d3owVBt2rHNVCixzaCqAgUwQqKBuJd2oaVgsVT2+jDLNasu1UIVMSqjAE4HuVciquGe1EBYDFUJwCLiQTXIZI0wCDRQE4AbyUWuBBacQqHZkFQ+xV+jYqNHFvqtvg3/Gn45udh60HaTpOAdQ09voDyDQ4A0wPd/QwGGYGawzPoo0Fx2ACq0gcRNKdqosFQbfQWhmoncCSO6noyR9q1Uo33iDQ9mrwrP0du9bqZ+r0MYMMEXPOpx2IECgOxA7BmF2rDNHetyxWGzMIbytLcgNiqD3hVGC7lh7VjSo3IV9aGOA2Kmz6VU1BG1HMnfvWmtD2Jz2tJ0irkdhRA2HJZeT99SbOI/Wurfy2/ikdH87YA5iWHjkYz/exprGCrnkNaN5OAXTf5ahOpvS4AZwNtzN+JL/cbpaojc3FnZzztDorW4nDJiD4eCmlmr/Mem9Jmj5F6ZGw6JTQBzvDV3FwO99Pubp9tbCJ2l0UsobJp18jn6NP5Ln+BS2F40Nnhpq0nU0hwD2OY/zMc1ys7u40CPqDDLA0Oq/Q06NcjPJqd4FawvMIjbIx8jJ3Boe0OGqJtfzHu/w1av1w8q5vZHRshe12hgcRypY2fku0/wANTF01pb3FxNI+GznmDJnBz3GPTHR2nmN8HMcj00wP+eEnJNvTi1g00IWxvLBt6MBZm4HN1f4fh5fM/wCIj0gMEd8C9phkOkh0YLnMdnu4E2PmWsN5I3UywkmDbg7QDFTS17vce9QQzNMcsQnjkjcKEFrHtex6mFoGtjga6SeaV3LiY3/MldwtU3yzomwWorNdSv0QtbWjTzHDz+ThX/kOZBeWQcI3XFrIJGMcfCyUUY+PV9lTsOY6iwAHtGpdvo7vR2IHYGiiMlA0NoDQ/wBfEmgbMFjlRYexVGaxVcsKrt9GquOxV9qr7Fh7FiajbRYGi4Kk70XUI7AVUjYsTXeqNHqWJoiW4byUQK450VSnYbV4ZKZ5trp1ZeHx6lKRxAVJpsx7VadRZnbyBzhvb4ZG/eYrm5kFek2DHdVa7YYXN59swf8AEfylZ3V7Rzru8EsgOWpztbWfZV7LfXnUTdc94l/CjIDmuLdDdTvy2U0MX8uutBOXwCGCWW5ZofIGSfgyYcL/AMN2ldUfK4uLbh8banJrDoY0fC1rV0DqEGN1M4dKvCM9ceMErvt2znf/AE1NFbn/ALSxa2ytqZBkI0ah9uTW9dN//Zi/aC7P/JSftPV1cSPLpvm3nWTjhJRtPsqWPpUwtrsiOT5g5MAhjdLK5B0nU7vqV1zQa28TY2ukLvFzpXOd407/AHlf+QFDdPeTO+7a90hPEXGTeroZAyzV9cXEU+P+WXPZ07p05HUbcj8SUOP4F/K4cUkOryfw1d9O6tazTdKvXsL5oDpeyWPwaXn8N3+7cr+4/ljqsk9tGwSX/T5m8uQxtOD+H8OblOU1lrHNd1COQR14tIifx6fd1eipWCx9DWnaBVbxvTO3FChwVfRUKlarNdqIrms/UqoOPqXeq7dq4d6xPct3csWVXCKbys1ms6Ionfke5Z/w/wB9SNcC0gnA9uPoHRPl2ibSyGS9rxvgjc6WO3cKeV7kyaJxZJG4OY4Zgg1aUL3rPRhcdQw5ssMzomSuH8SeEDxu8+hW3VpomtjsjGLa0YaMZHEdTIW/66uuoNi5ZupXS8onVQvNdPxLrN/PGWW7WNFpzGkE3btUUTotXuMdqeqnE7T2qG8jA1wSNkYDkS06lZ9etem/LXEMpmvGCQubM846m6vyfP4VLdadPMldLprlqcZNKP8AMMEDWOe1rJLZ51Nc0MbBIwu/zNK+a6X0blXtaxPuJjNFE73oYKN1afJzU3+ZfleLhMlvrwLtHJe5r6ebxplwG15cgk0nbR2vSpf5j+WrzXOd8tqy1s5R/EovmmME0UjXRXNs/wAEsT8HxSK8sH2fzXRrx4f8lK8h8Zb+XJFcM8Msfh1+dXNh0PpxsTetEdzcyymWQx11GFlQ1rGuTunusmG75wkb1AeMM80H2Fl/RGoEt07M60/1kO9OuQ6KkRDDG4jUdWriazz6UPRQ+1HaFnU7exEjIZlEEBVpVAgFB9CAcQTkUcKrGoHYqZgLEgHYFTLtVFgt6qVh9KJJRQIKy8lfXryUhpSrjgNmK0NIJOW5BhoKcNch61njvRFRvqsf9KDsq4t9RUMHUbt08UH5bHYAGmnVwjidp95STG4Y2VpaGQ0JLgfEdXwqmFN4WyvagKhEE4AEkj/SqimGawQOwrcswtiDaDVXxVNfRsWfrWY34rs9Awxbmqk47BRDvXFt+tUrsrmsVTYPRgtQ9fow2qmp2GyuCocQPUqVw2rAV3IO8JGRCxxHYhuG5Z07AsiqEetYn1rM07URT1rxaSMRtr61n5K/rp/2j9aBGBGAouFpaKDAmqqcMKgb9mCpsOKBla5ri0O4wQSDkfsrvzWr6EW1NTs2rTtO07O1UGzcmhh0udwgk08WHi9a7tqNcajhAxNdyO3HP9Cj5EfIYWMDuMyVePHIf9RVwIOXtVSMEXAaWk4CtVUZb14q9xXbsWZLsA0Uz7F3CqFK12nYsBjXEoh1S3DLDAKjca5bEAgq7FQoUdxbRuWJzyVTRAmlD2qjqU2UQLa0QFT2o0GxUbTvVXOruVa9gqtOrSBuWJr6NvrRrQ96wNVl7Udy/wC6c6KMNcdTGhxqBwjSdPmWfl+jWn/aP1rWwlrgM645UK78fRgCScqJj7mZ0ro42xNLtjGijWKowpT2o41Ode05rVXTTKi1tydgtI8RP9aIh2GnZvQpsGNcqpskJLHNrRwNDjgt1cV2rFDKpriDX2hAVxyKqBhlVVoOIbTt7PQD4Tnhgg4GlDgcwq57O/u9DnAYNxPcTRYCgdsXACQBXtCw9Fe1GhwWOJWnAUVD7EQcVQrHNcWz2KuTdyc4PpTIf2IYkdq3lYhZKhHrWBW9b+wLScWjIbqpoaSDTi3Vqs9n061JQeY9uRVKe1Zqm71qhqDhxDAhF8TtXZtRG1YjAihJxp8QQaNuArggHDA4iuXeq41rgVVxW6q1KUPlbEyGF8z3u3MGEbfjkdpYxAMFBQah20xVNmaxGKw7yjQVpiqnBFu/PtRLjqLqCpNckXAcBNAe3NHdtoqjYsq7kBT1IYUqFQf0M/aqn2qv0qpzVTjVAg0IFB3Kpx7Ea5oahiMgF+hVKxxWIWGR2Lcsz2IiqoMSVXMkV3+pfcr+upO8/WstnaiTTZQHP6UcScDSmVVUkgbk7VU51qhrAa2nBSlKdmlYZbEQRUnadixrRYr693pNMvNT04k1xrVYLhxFcaLhrs1V7+FUdw7Q49nloPeWNK02LDJdi3oVQxx9aFCFWvqx9FW4V8orgsvRuGyiwyWIwWGP9iwx+pdqBcKgHLeifCNgzRLTxUxAWOCwWIWHoNMEd6yx2LFeHyUz+PNf/9k="
            traceback.print_exc()
            return

        data="<img src=\"data:image/png;base64,"+b64img+"\"/>"
        self.webview.setHtml(data)

    def Accept(self):
        self.accept()
        self.hide()
class WMarket(QtGui.QWidget):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(600, 330)        
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Dialog.sizePolicy().hasHeightForWidth())
        Dialog.setSizePolicy(sizePolicy)
        Dialog.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.verticalLayout_2 = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.verticalLayout = QtGui.QVBoxLayout()
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.textBrowser = QtGui.QTextBrowser(Dialog)
        self.textBrowser.setObjectName(_fromUtf8("textBrowser"))
        self.horizontalLayout3 = QtGui.QHBoxLayout()
        self.horizontalLayout3.setObjectName(_fromUtf8("horizontalLayout3"))
        self.horizontalLayout3.addWidget(self.textBrowser)
        self.textBrowser2 = QtGui.QTextBrowser(Dialog)
        self.textBrowser2.setObjectName(_fromUtf8("textBrowser"))
        self.textBrowser2.setMaximumSize(QtCore.QSize(300, 16777215))
        self.horizontalLayout3.addWidget(self.textBrowser2)
        self.verticalLayout.addItem(self.horizontalLayout3)
        spacerItem = QtGui.QSpacerItem(20, 10, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.verticalLayout.addItem(spacerItem)


        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.pushButton_3 = QtGui.QPushButton(Dialog)
        self.pushButton_3.setObjectName(_fromUtf8("pushButton_3"))
        self.horizontalLayout.addWidget(self.pushButton_3)
        spacerItem2 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem2)
        self.pushButton_2 = QtGui.QPushButton(Dialog)
        self.pushButton_2.setObjectName(_fromUtf8("pushButton_2"))
        self.horizontalLayout.addWidget(self.pushButton_2)
        spacerItem3 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem3)
        self.pushButton = QtGui.QPushButton(Dialog)
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.horizontalLayout.addWidget(self.pushButton)
        spacerItem4 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem4)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        ApplyCSS(self)

        #Signals
        self.pushButton_3.clicked.connect(self.Accept)
        self.pushButton_2.clicked.connect(self.Counter)
        self.pushButton.clicked.connect(self.Delete)
        #self.pushButton.clicked.connect(self.Delete)
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        self.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"></p></body></html>")
        self.textBrowser2.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"></p></body></html>")
        self.pushButton_3.setText(_translate("Dialog", " Accept Offer ", None))
        self.pushButton_2.setText(_translate("Dialog", " Counter-Offer ", None))
        self.pushButton.setText(_translate("Dialog", " Delete Request ", None))
        self.pushButton.hide()
        self.order={}
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        Dialog.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def showorder(self, order):
        if order != []:
            b64img=order['Details']['image']
            width=0
            height=0
            data=""
            f=0
            self.order=order
            self.pushButton_3.show()
            self.pushButton_2.show()
            if self.order['Process']=="Market Offer":
                self.pushButton_2.hide()
            else:
                if 'allowcounters' in self.order['Market Data']:
                    self.pushButton_2.show()
                else:
                    self.pushButton_2.hide()
            if 'lock' in self.order and "MCount" in self.order['Process']:
                if self.order['lock']=='0':
                    self.pushButton_3.hide()
                    self.pushButton_2.hide()
            try:
                b64img=order['Details']['image']
                #b64img += "=" * ((4 - len(b64img) % 4) % 4) #This is for incorrect padding error
                image_string = StringIO.StringIO(base64.b64decode(b64img))
                image = Image.open(image_string)
                tup=image.size
                width=tup[0]
                height=tup[1]
                if width>330 and height<200:
                    height=200
                if height>200 and width<330:
                    width=330
                if width>330 or height>200:
                    self.resize((width+50)+300, height+210)
                #We convert to PNG
                b64img=ConvertImage(b64img, "base64", False)

                data+="<img src=\"data:image/png;base64,"+b64img+"\"/>"
                image_string.close()
                image_string=""
            except Exception, e:
                image_string.close()
                image_string=""
                traceback.print_exc()
                pass
            usd,btc=GetMarketValue(order['Market Data']['Payment Method'],CoinMarketCap)
            t=ConvertDate(order['Market Data']['date'],1)
            t=t.strftime('%m/%d/%Y')
            data+="<br />"
            data+="Contract Halo version " + str(order['version'])+"<br />"
            data+="From: " + str(order['TheirBMAddress']) + "<br />"
            if "Custom" in order['Market Data']['Template']:
                data+="Preferred contact method: "
                if "@" in order['Market Data']['Preferred']:
                    data+="Email"
                    if "BM-" not in order['Market Data']['Preferred']:
                        data+="<br />"
                    else:
                        data+=", "
                if "BM-" in order['Market Data']['Preferred']:
                    data+="Bitmessage" + "<br />"
                if "@" not in order['Market Data']['Preferred'] and "BM-" not in order['Market Data']['Preferred']:
                    data+="Coin address  (Spam filter enabled)" + "<br />"
                data+="Type: " + str(order['Market Data']['Template']) + "<br />"

                conv=""
                if usd!="" and usd!=" ":
                    st=str(int(Decimal(order['amount'])/Decimal(1e8)*Decimal(usd)*Decimal(100)))
                    st=str(Decimal(st)/Decimal(100))
                    conv=", $"+st
                data+="Price: " + str(Decimal(order['amount'])/Decimal(1e8))+conv+", "+order['Market Data']['Payment Method'] + "<br />"
                data+="Date: " + str(t) + "<br />"
                data+="Deposits: " + str(order['Market Data']['style']) + "<br />"
            data+=str(order['whopays'])+"<br />"
            data+="Amount: "+str(Decimal(order['amount'])/Decimal(1e8))+"<br />"
            if order['Process']=="Market Order":
                self.pushButton.hide()
                data+="Their Deposit: "+str(Decimal(order['mydeposit'])/Decimal(1e8))+"<br />"
                data+="My Deposit: "+str(Decimal(order['theirdeposit'])/Decimal(1e8))+"<br />"
            if order['Process']=="Market Offer" or "MCount" in order['Process']:
                self.pushButton.show()
                data+="My Deposit: "+str(Decimal(order['mydeposit'])/Decimal(1e8))+"<br />"
                data+="Their Deposit: "+str(Decimal(order['theirdeposit'])/Decimal(1e8))+"<br />"
            if order['instantamount'] != 0:
                f+=.5
                data+="Instant refund: ("+str(order['instantwhopays'])+")<br />"
                data+="Amount: " + str(Decimal(order['instantamount'])/Decimal(1e8))+"<br />"
            f+=1#Temporary account
            f+=1#Split escrow fund/release
            data+="<br />"
            data+="Fee: "+str(Decimal(order['fee']*f)/Decimal(1e8))+"<br />"
            data+="Time limit: "+str(order['timeout'])+" Hours -- "+str(round((order['timeout']/24),2))+" Days<br />"
            data+="Order number: "+str(order['ordernumber'])
            data+="<br /><br />"
            data+="Description: <br />"
            data+=order['Details']['description']

            self.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+data+"</span></p></body></html>")

            data=""
            try:
                data+="User Profile:<br />"+order['Market Data']['orgpublic'][:10]+"<br /><br />"
                if Markets['Reputation'][order['Market Data']['orgpublic']]['Reputation']['Reviews']==[] and Markets['Reputation'][order['Market Data']['orgpublic']]['Reputation']['Rating'] == 0:
                    data+="New User!<br />"
                data+="Rating:<br />"+ str(Markets['Reputation'][order['Market Data']['orgpublic']]['Reputation']['Rating'])
                data+="<br /><br />Reviews:<br />"
                r=1
                for Review in Markets['Reputation'][order['Market Data']['orgpublic']]['Reputation']['Reviews']:
                    data+=str(r)+")<br />" +Review+"<br />"
                    r+=1
            except:
                pass
            self.textBrowser2.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:16px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">"+data+"</span></p></body></html>")
    def Accept(self):
        global MyContracts, OnOrders
        if self.order['Process']=="Market Order" or "MCount" in self.order['Process']:
            window.Tabs.setCurrentIndex(5)
            window.ClearPage()
            window.ContractTo.setText("Accept Market: "+self.order['ordernumber'])
            self.hide()
            window.SendMyContract()
        if self.order['Process']=="Market Offer":
            AcceptOffer(self.order)
            if 'dontclear' not in self.order['Market Data']:
                leng=len(MyContracts)
                i=0
                while i<leng:
                    next1=1
                    if MyContracts[i]['Process']=="Market Order":
                        if MyContracts[i]['ordernumber']==self.order['oldordernumber']:
                            l=0
                            for o in OnOrders:
                                if 'ordernumber' in o:
                                    if o['ordernumber']==MyContracts[i]['ordernumber']:
                                        OnOrders[l]['ordernumber']=self.order['ordernumber']
                                        break
                                l+=1
                            RemoveFromMarket(MyContracts[i],self.order['ordernumber'])
                            next1=0
                    if MyContracts[i]['Process']=="Market Offer" or "MCount" in MyContracts[i]['Process']:
                        if MyContracts[i]['oldordernumber']==self.order['oldordernumber'] and MyContracts[i]['ordernumber']!=self.order['ordernumber']:
                            DeleteOrder(MyContracts[i]['ordernumber'])
                            next1=0
                    if next1==0:
                        leng-=1
                        DeleteContract(i)
                    else:
                        i+=1
            i=0
            for o in OnOrders:
                if 'ordernumber' in o:
                    if o['ordernumber']==self.order['ordernumber']:
                        if 'oldtotal' in OnOrders[i]:
                            OnOrders[i]['total']=OnOrders[i]['oldtotal']
                            OnOrders[i]['mychangetotal']=OnOrders[i]['oldmychangetotal']
                i+=1
            self.hide()

    def Counter(self):
        global GlobalImage, GlobalID
        window.Tabs.setCurrentIndex(5)
        window.ContractTo.setText("Counter Market: "+self.order['ordernumber'])
        window.ContractAmount.setText(str(Decimal(self.order['amount'])/Decimal(1e8)))
        window.InstantAmount.setText(str(Decimal(self.order['instantamount'])/Decimal(1e8)))
        window.YouDeposit.setText(str(Decimal(self.order['mydeposit'])/Decimal(1e8)))
        window.TheyDeposit.setText(str(Decimal(self.order['theirdeposit'])/Decimal(1e8)))
        window.ContractTime.setText(str(self.order['timeout']))
        window.ContractFee.setText(str(Decimal(self.order['fee'])/Decimal(1e8)))
        window.DescriptionBox.setText(self.order['Details']['description'])
        if self.order['Details']['image']!="":
            window.ImageBox.setText(str("Image Attached"))
        GlobalImage=self.order['Details']['image']
        GlobalID=self.order['Details']['pastebin']
        if "I pay this" in self.order['whopays']:
            window.WhoPays.setCurrentIndex(0)
        else:
            window.WhoPays.setCurrentIndex(1)
        if "I am" in self.order['instantwhopays']:
            window.InstantWhoPays.setCurrentIndex(0)
        else:
            window.InstantWhoPays.setCurrentIndex(1)
        window.DaysMultiplier.setCurrentIndex(1)
        #change to hours
        self.hide()
    def Delete(self):
        global MyContracts, OnOrders
        i=0
        for c in MyContracts:
            if c['ordernumber']==self.order['ordernumber']:
                DeleteContract(i)
            i+=1
        DeleteOrder(self.order['ordernumber'])
        self.hide()
class AdvancedSettings(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(762, 693)        
        self.AmountLabel = QtGui.QLabel(Form)
        self.AmountLabel.setGeometry(QtCore.QRect(20, 125, 66, 40))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.AmountLabel.setFont(font)
        self.AmountLabel.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.AmountLabel.setObjectName(_fromUtf8("AmountLabel"))
        self.PayToLabel = QtGui.QLabel(Form)
        self.PayToLabel.setGeometry(QtCore.QRect(20, 70, 71, 40))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.PayToLabel.setFont(font)
        self.PayToLabel.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.PayToLabel.setObjectName(_fromUtf8("PayToLabel"))
        self.BitAmount = QtGui.QLineEdit(Form)
        self.BitAmount.setGeometry(QtCore.QRect(100, 120, 300, 40))
        self.BitAmount.setMinimumSize(QtCore.QSize(300, 40))
        self.BitAmount.setMaximumSize(QtCore.QSize(300, 40))
        self.BitAmount.setStyleSheet(_fromUtf8("font: 19px \"Arial\";\ncolor: #24282C;\nbackground-color:rgba(251, 251, 251, 80%);\nborder-radius: 8px;\n     border-style: inset;\nborder-width: 2px;\nborder-color: lightgrey;\n"""))
        self.BitAmount.setObjectName(_fromUtf8("BitAmount"))
        self.BitPayTo = QtGui.QLineEdit(Form)
        self.BitPayTo.setGeometry(QtCore.QRect(101, 65, 300, 40))
        self.BitPayTo.setMinimumSize(QtCore.QSize(300, 40))
        self.BitPayTo.setMaximumSize(QtCore.QSize(300, 40))
        self.BitPayTo.setStyleSheet(_fromUtf8("font: 19px \"Arial\";\ncolor: #24282C;\nbackground-color:rgba(251, 251, 251, 80%);\nborder-radius: 8px;\n     border-style: inset;\nborder-width: 2px;\nborder-color: lightgrey;\n"))
        self.BitPayTo.setObjectName(_fromUtf8("BitPayTo"))
        self.MultiPay = QtGui.QLabel(Form)
        self.MultiPay.setGeometry(QtCore.QRect(150, 20, 180, 19))
        self.MultiPay.setMinimumSize(QtCore.QSize(180, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.MultiPay.setFont(font)
        self.MultiPay.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.MultiPay.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.MultiPay.setAlignment(QtCore.Qt.AlignCenter)
        self.MultiPay.setObjectName(_fromUtf8("MultiPay"))
        self.Email = QtGui.QLabel(Form)
        self.Email.setGeometry(QtCore.QRect(140, 240, 180, 19))
        self.Email.setMinimumSize(QtCore.QSize(180, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.Email.setFont(font)
        self.Email.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.Email.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.Email.setAlignment(QtCore.Qt.AlignCenter)
        self.Email.setObjectName(_fromUtf8("Email"))
        self.APPLY = QtGui.QPushButton(Form)
        self.APPLY.setGeometry(QtCore.QRect(460, 400, 81, 31))
        self.APPLY.setObjectName(_fromUtf8("APPLY"))
        self.CANCEL = QtGui.QPushButton(Form)
        self.CANCEL.setGeometry(QtCore.QRect(580, 400, 81, 31))
        self.CANCEL.setObjectName(_fromUtf8("CANCEL"))
        self.BitPayTo_2 = QtGui.QLineEdit(Form)
        self.BitPayTo_2.setGeometry(QtCore.QRect(101, 285, 300, 40))
        self.BitPayTo_2.setMinimumSize(QtCore.QSize(300, 40))
        self.BitPayTo_2.setMaximumSize(QtCore.QSize(300, 40))
        self.BitPayTo_2.setStyleSheet(_fromUtf8("font: 19px \"Arial\";\ncolor: #24282C;\nbackground-color:rgba(251, 251, 251, 80%);\nborder-radius: 8px;\n     border-style: inset;\nborder-width: 2px;\nborder-color: lightgrey;\n"))
        self.BitPayTo_2.setObjectName(_fromUtf8("BitPayTo_2"))
        self.PayToLabel_2 = QtGui.QLabel(Form)
        self.PayToLabel_2.setGeometry(QtCore.QRect(20, 290, 66, 40))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.PayToLabel_2.setFont(font)
        self.PayToLabel_2.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.PayToLabel_2.setObjectName(_fromUtf8("PayToLabel_2"))
        self.line = QtGui.QFrame(Form)
        self.line.setGeometry(QtCore.QRect(20, 220, 381, 16))
        self.line.setFrameShape(QtGui.QFrame.HLine)
        self.line.setFrameShadow(QtGui.QFrame.Sunken)
        self.line.setObjectName(_fromUtf8("line"))
        self.line_2 = QtGui.QFrame(Form)
        self.line_2.setGeometry(QtCore.QRect(410, 10, 20, 431))
        self.line_2.setFrameShape(QtGui.QFrame.VLine)
        self.line_2.setFrameShadow(QtGui.QFrame.Sunken)
        self.line_2.setObjectName(_fromUtf8("line_2"))
        self.APPLYEMAIL = QtGui.QPushButton(Form)
        self.APPLYEMAIL.setGeometry(QtCore.QRect(320, 400, 81, 31))
        self.APPLYEMAIL.setObjectName(_fromUtf8("APPLYEMAIL"))
        self.ADD = QtGui.QPushButton(Form)
        self.ADD.setGeometry(QtCore.QRect(320, 180, 81, 31))
        self.ADD.setObjectName(_fromUtf8("ADD"))
        self.Advanced = QtGui.QLabel(Form)
        self.Advanced.setGeometry(QtCore.QRect(450, 20, 180, 19))
        self.Advanced.setMinimumSize(QtCore.QSize(180, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.Advanced.setFont(font)
        self.Advanced.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.Advanced.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.Advanced.setAlignment(QtCore.Qt.AlignCenter)
        self.Advanced.setObjectName(_fromUtf8("Advanced"))
        self.Note = QtGui.QLabel(Form)
        self.Note.setGeometry(QtCore.QRect(20, 190, 271, 16))
        self.Note.setObjectName(_fromUtf8("Note"))
        self.AmountLabel_2 = QtGui.QLabel(Form)
        self.AmountLabel_2.setGeometry(QtCore.QRect(19, 340, 66, 40))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.AmountLabel_2.setFont(font)
        self.AmountLabel_2.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.AmountLabel_2.setObjectName(_fromUtf8("AmountLabel_2"))
        self.BitAmount_2 = QtGui.QLineEdit(Form)
        self.BitAmount_2.setGeometry(QtCore.QRect(100, 340, 300, 40))
        self.BitAmount_2.setMinimumSize(QtCore.QSize(300, 40))
        self.BitAmount_2.setMaximumSize(QtCore.QSize(300, 40))
        self.BitAmount_2.setStyleSheet(_fromUtf8("font: 19px \"Arial\";\ncolor: #24282C;\nbackground-color:rgba(251, 251, 251, 80%);\nborder-radius: 8px;\n     border-style: inset;\nborder-width: 2px;\nborder-color: lightgrey;\n"))
        self.BitAmount_2.setObjectName(_fromUtf8("BitAmount_2"))
        self.Autosign = QtGui.QCheckBox(Form)
        self.Autosign.setGeometry(QtCore.QRect(460, 60, 231, 17))
        self.Autosign.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 13px \"Arial\";"))
        self.Autosign.setObjectName(_fromUtf8("Autosign"))
        self.Forward = QtGui.QLabel(Form)
        self.Forward.setGeometry(QtCore.QRect(437, 230, 311, 19))
        self.Forward.setMinimumSize(QtCore.QSize(180, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(13)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.Forward.setFont(font)
        self.Forward.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.Forward.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 13px \"Arial\";"))
        self.Forward.setAlignment(QtCore.Qt.AlignCenter)
        self.Forward.setObjectName(_fromUtf8("Forward"))
        self.ForwardEmail = QtGui.QLineEdit(Form)
        self.ForwardEmail.setGeometry(QtCore.QRect(440, 250, 300, 40))
        self.ForwardEmail.setMinimumSize(QtCore.QSize(300, 40))
        self.ForwardEmail.setMaximumSize(QtCore.QSize(300, 40))
        self.ForwardEmail.setStyleSheet(_fromUtf8("font: 19px \"Arial\";\ncolor: #24282C;\nbackground-color:rgba(251, 251, 251, 80%);\nborder-radius: 8px;\n     border-style: inset;\nborder-width: 2px;\nborder-color: lightgrey;\n"))
        self.ForwardEmail.setObjectName(_fromUtf8("ForwardEmail"))
        self.AutoExplain = QtGui.QTextBrowser(Form)
        self.AutoExplain.setGeometry(QtCore.QRect(440, 90, 301, 111))
        self.AutoExplain.setObjectName(_fromUtf8("AutoExplain"))
        self.ForwardExplain = QtGui.QTextBrowser(Form)
        self.ForwardExplain.setGeometry(QtCore.QRect(440, 300, 301, 61))
        self.ForwardExplain.setObjectName(_fromUtf8("ForwardExplain"))
        self.line_3 = QtGui.QFrame(Form)
        self.line_3.setGeometry(QtCore.QRect(20, 440, 721, 16))
        self.line_3.setFrameShape(QtGui.QFrame.HLine)
        self.line_3.setFrameShadow(QtGui.QFrame.Sunken)
        self.line_3.setObjectName(_fromUtf8("line_3"))
        self.ExoticLabel = QtGui.QLabel(Form)
        self.ExoticLabel.setGeometry(QtCore.QRect(20, 460, 721, 31))
        self.ExoticLabel.setMinimumSize(QtCore.QSize(180, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.ExoticLabel.setFont(font)
        self.ExoticLabel.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.ExoticLabel.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.ExoticLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.ExoticLabel.setObjectName(_fromUtf8("ExoticLabel"))
        self.comboBox = QtGui.QComboBox(Form)
        self.comboBox.setGeometry(QtCore.QRect(20, 500, 271, 31))
        self.comboBox.setObjectName(_fromUtf8("comboBox"))
        self.OwnerBefore = QtGui.QLineEdit(Form)
        self.OwnerBefore.setGeometry(QtCore.QRect(300, 540, 300, 40))
        self.OwnerBefore.setMinimumSize(QtCore.QSize(300, 40))
        self.OwnerBefore.setMaximumSize(QtCore.QSize(300, 40))
        self.OwnerBefore.setStyleSheet(_fromUtf8("font: 19px \"Arial\";\ncolor: #24282C;\nbackground-color:rgba(251, 251, 251, 80%);\nborder-radius: 8px;\n     border-style: inset;\nborder-width: 2px;\nborder-color: lightgrey;\n"))
        self.OwnerBefore.setObjectName(_fromUtf8("OwnerBefore"))
        self.AddBefore = QtGui.QPushButton(Form)
        self.AddBefore.setGeometry(QtCore.QRect(610, 540, 71, 41))
        self.AddBefore.setObjectName(_fromUtf8("AddBefore"))
        self.dateTimeEdit = QtGui.QDateTimeEdit(Form)
        self.dateTimeEdit.setGeometry(QtCore.QRect(400, 500, 201, 31))
        self.dateTimeEdit.setObjectName(_fromUtf8("dateTimeEdit"))
        self.OwnerAfter = QtGui.QLineEdit(Form)
        self.OwnerAfter.setGeometry(QtCore.QRect(300, 590, 300, 40))
        self.OwnerAfter.setMinimumSize(QtCore.QSize(300, 40))
        self.OwnerAfter.setMaximumSize(QtCore.QSize(300, 40))
        self.OwnerAfter.setStyleSheet(_fromUtf8("font: 19px \"Arial\";\ncolor: #24282C;\nbackground-color:rgba(251, 251, 251, 80%);\nborder-radius: 8px;\n     border-style: inset;\nborder-width: 2px;\nborder-color: lightgrey;\n"))
        self.OwnerAfter.setObjectName(_fromUtf8("OwnerAfter"))
        self.DateTitle = QtGui.QLabel(Form)
        self.DateTitle.setGeometry(QtCore.QRect(290, 500, 100, 31))
        self.DateTitle.setMinimumSize(QtCore.QSize(100, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.DateTitle.setFont(font)
        self.DateTitle.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.DateTitle.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.DateTitle.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.DateTitle.setObjectName(_fromUtf8("DateTitle"))
        self.OwnAfterTitle = QtGui.QLabel(Form)
        self.OwnAfterTitle.setGeometry(QtCore.QRect(20, 590, 271, 41))
        self.OwnAfterTitle.setMinimumSize(QtCore.QSize(100, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.OwnAfterTitle.setFont(font)
        self.OwnAfterTitle.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.OwnAfterTitle.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.OwnAfterTitle.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.OwnAfterTitle.setObjectName(_fromUtf8("OwnAfterTitle"))
        self.AddAfter = QtGui.QPushButton(Form)
        self.AddAfter.setGeometry(QtCore.QRect(610, 590, 71, 41))
        self.AddAfter.setObjectName(_fromUtf8("AddAfter"))
        self.OwnBeforeTitle = QtGui.QLabel(Form)
        self.OwnBeforeTitle.setGeometry(QtCore.QRect(20, 540, 271, 41))
        self.OwnBeforeTitle.setMinimumSize(QtCore.QSize(100, 0))
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Arial"))
        font.setPixelSize(16)
        font.setBold(True)
        font.setItalic(False)
        font.setWeight(75)
        self.OwnBeforeTitle.setFont(font)
        self.OwnBeforeTitle.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.OwnBeforeTitle.setStyleSheet(_fromUtf8("color:#24282C;\nfont: bold 16px \"Arial\";"))
        self.OwnBeforeTitle.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.OwnBeforeTitle.setObjectName(_fromUtf8("OwnBeforeTitle"))
        self.APPLYCUSTOM = QtGui.QPushButton(Form)
        self.APPLYCUSTOM.setGeometry(QtCore.QRect(20, 650, 81, 31))
        self.APPLYCUSTOM.setObjectName(_fromUtf8("APPLYCUSTOM"))
        self.CopyScript = QtGui.QPushButton(Form)
        self.CopyScript.setGeometry(QtCore.QRect(140, 650, 171, 31))
        self.CopyScript.setObjectName(_fromUtf8("CopyScript"))
        self.MakeCustom = QtGui.QPushButton(Form)
        self.MakeCustom.setGeometry(QtCore.QRect(350, 650, 261, 31))
        self.MakeCustom.setObjectName(_fromUtf8("MakeCustom"))

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        self.APPLY.clicked.connect(self.Apply)
        self.APPLYEMAIL.clicked.connect(self.Apply)
        self.CANCEL.clicked.connect(self.Cancel)
        self.ADD.clicked.connect(self.Add)
        self.comboBox.connect(self.comboBox,QtCore.SIGNAL("currentIndexChanged(int)"),self.comboChange)
        self.AddAfter.clicked.connect(self.AddThisAfter)
        self.AddBefore.clicked.connect(self.AddThisBefore)
        self.APPLYCUSTOM.clicked.connect(self.ApplyExotic)
        self.CopyScript.clicked.connect(self.CopyRedeem)
        ApplyCSS(self)
        #text=AdvancedWindow.dateTimeEdit.dateTime()
        #text=str(timestamp)+"  "+str(text.toTime_t())

    def retranslateUi(self, Form):
        self.AmountLabel.setText(_translate("Form", "Amount:", None))
        self.PayToLabel.setText(_translate("Form", "Address:", None))
        self.MultiPay.setText(_translate("Form", "Pay Multiple Addresses", None))
        self.MultiPay.adjustSize()
        self.Email.setText(_translate("Form", "Pay To Email", None))
        self.Email.adjustSize()
        self.APPLY.setText(_translate("Form", "APPLY", None))
        self.CANCEL.setText(_translate("Form", "CANCEL", None))
        self.PayToLabel_2.setText(_translate("Form", "Email:", None))
        self.APPLYEMAIL.setText(_translate("Form", "APPLY", None))
        self.ADD.setText(_translate("Form", "ADD", None))
        self.Advanced.setText(_translate("Form", "Advanced Settings:", None))
        self.Note.setText(_translate("Form", "Address added! To add another fill out\nthe form again. To complete the\norder click apply.", None))
        self.Note.adjustSize()
        self.AmountLabel_2.setText(_translate("Form", "Amount:", None))
        self.Autosign.setText(_translate("Form", "Autosign Two Step Spend Offers", None))
        self.Autosign.adjustSize()
        self.Forward.setText(_translate("Form", "Forwarding Email/Bitmessage", None))
        self.AutoExplain.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12px;\">" + _translate("","If you want an ultra high security account, you can use two different computers to send your transactions. This makes it impossible for hackers to get into your account since the keys can be in two totally different locations. If it's a joint account, you can use this option to automatically approve the expenses of your partner without reviewing them.")+"</span></p></body></html>")
        self.ForwardExplain.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:12px;\">" + _translate("","Use this option to save the Email or Bitmessage address of your second location or partner without having to add it again.")+"</span></p></body></html>")

        self.ExoticLabel.setText(_translate("Form", "Exotic Payments - Freeze, Notary, Time Locked or Atomic Payments", None))
        self.comboBox.blockSignals(True)
        self.comboBox.clear()
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.setItemText(0, _translate("Form", "Freeze", None))
        self.comboBox.setItemText(1, _translate("Form", "Advanced Time Lock", None))
        self.comboBox.setItemText(2, _translate("Form", "Notarize/Burn Message", None))
        self.AddBefore.setText(_translate("Form", "ADD", None))
        self.DateTitle.setText(_translate("Form", "Date:", None))
        self.OwnAfterTitle.setText(_translate("Form", "Owner After Date:", None))
        self.AddAfter.setText(_translate("Form", "ADD", None))
        self.OwnBeforeTitle.setText(_translate("Form", "Owner Before Date:", None))
        self.APPLYCUSTOM.setText(_translate("Form", "APPLY", None))
        self.CopyScript.setText(_translate("Form", "COPY REDEEM SCRIPT", None))
        self.MakeCustom.setText(_translate("Form", "MAKE A CUSTOM TRANSACTION", None))

        #self.CopyScript.hide()
        self.MakeCustom.hide()

        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            self.ExoticLabel.setText(_translate("Form", "Exotic Payments - Peg transfers, Freeze, Notary, Time Locked or Atomic Payments", None))
            self.comboBox.clear()
            self.comboBox.addItem(_fromUtf8(""))
            self.comboBox.addItem(_fromUtf8(""))
            self.comboBox.addItem(_fromUtf8(""))
            self.comboBox.addItem(_fromUtf8(""))
            self.comboBox.addItem(_fromUtf8(""))
            self.comboBox.addItem(_fromUtf8(""))
            self.comboBox.addItem(_fromUtf8(""))
            self.comboBox.setItemText(0, _translate("Form", "Move Reserve Funds(1 month freeze)", None))
            self.comboBox.setItemText(1, _translate("Form", "Voluntary Liquid Freeze(4 month freeze)", None))
            self.comboBox.setItemText(2, _translate("Form", "Freeze", None))
            self.comboBox.setItemText(3, _translate("Form", "Advanced Time Lock", None))
            self.comboBox.setItemText(4, _translate("Form", "Notarize/Burn Message", None))
            self.comboBox.setItemText(5, _translate("Form", "Bridge to another chain", None))
            self.comboBox.setItemText(6, _translate("Form", "Mint from another chain", None))
        self.comboBox.setCurrentIndex(0)
        self.comboBox.blockSignals(False)
        if CoinSelect['HaloName']!="BitBay":
            self.AddAfter.hide()
            self.AddBefore.hide()
            self.APPLYCUSTOM.hide()
            self.OwnAfterTitle.hide()
            self.OwnBeforeTitle.hide()
            self.comboBox.hide()
            self.ExoticLabel.hide()
            self.DateTitle.hide()
            self.dateTimeEdit.hide()
            Form.resize(762, 447)
        else:    
            self.AddAfter.show()
            self.AddBefore.show()
            self.APPLYCUSTOM.show()
            self.OwnAfterTitle.show()
            self.OwnBeforeTitle.show()
            self.comboBox.show()
            self.ExoticLabel.show()
            self.DateTitle.show()
            self.dateTimeEdit.show()
            Form.resize(762, 693)
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            self.dateTimeEdit.hide()
            self.DateTitle.hide()
            self.OwnAfterTitle.hide()
            self.AddAfter.hide()
            self.OwnerAfter.hide()
            self.OwnBeforeTitle.setText(_translate("Form", "Destination:", None))
            self.OwnerBefore.setText("")
            self.AddBefore.show()
        self.OwnerAfter.setDisabled(True)
        self.OwnerBefore.setDisabled(True)
        self.dateTimeEdit.setCalendarPopup(True)

        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        Form.setWindowTitle(CoinSelect['HaloName'])        

    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)

    def Add(self):
        if str(window.BitPayTo.text())=="":
            window.BitPayTo.setText(str(self.BitPayTo.text()))
            window.BitAmount.setText(str(self.BitAmount.text()))
        else:
            pay=str(window.BitPayTo.text())
            amount=str(window.BitAmount.text())
            window.BitPayTo.setText(str(pay)+","+str(self.BitPayTo.text()))
            window.BitAmount.setText(str(amount)+","+str(self.BitAmount.text()))
        self.BitPayTo.setText("")
        self.BitAmount.setText("")
        self.Note.show()
    def Cancel(self):
        self.hide()
        return

    def Apply(self):
        global AdvanceArray
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if multisig not in AdvanceArray:
            AdvanceArray[multisig]={}
        if self.Autosign.isChecked():
            AdvanceArray[multisig]['AutoSign']=1
        else:
            AdvanceArray[multisig]['AutoSign']=0
        AdvanceArray[multisig]['ForwardEmail']=str(self.ForwardEmail.text())
        if str(self.BitPayTo_2.text())!="":
            window.BitPayTo.setText(str(self.BitPayTo_2.text()))
            window.BitAmount.setText(str(self.BitAmount_2.text()))
        SaveOtherdata()
        self.hide()
    
    def CopyRedeem(self):
        global AdvanceArray
        if 'tipredeem' not in AdvanceArray:
            res=QuestionBox('This will copy the redeem script for your ' + CoinSelect['name'] + ' address. You can use this "special" address to receive and send exotic payments.', ' Thanks ', ' Do not show this message again. ')
            if res==1:
                AdvanceArray['tipredeem']=1
        msigaddr,mscript = create_multisig_address(PrivKeyFilename1,PrivKeyFiledir1)
        clipboard = app.clipboard()
        clipboard.setText(str(mscript))
        QuestionBox("Redeem script copied to clipboard.", " OK ")

    def comboChange(self):
        self.OwnAfterTitle.show()
        self.AddAfter.show()
        self.OwnerAfter.show()
        self.dateTimeEdit.show()
        self.DateTitle.show()
        offset=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if self.comboBox.currentIndex() == 0 or self.comboBox.currentIndex() == 1:
                self.dateTimeEdit.hide()
                self.DateTitle.hide()
                self.OwnAfterTitle.hide()
                self.AddAfter.hide()
                self.OwnerAfter.hide()
                self.OwnBeforeTitle.setText(_translate("Form", "Destination:", None))
                self.OwnerBefore.setText("")
                self.AddBefore.show()                
            offset=2
        if self.comboBox.currentIndex() == 0+offset:
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                if 'frozenpegnotify' not in AdvanceArray:
                    res=QuestionBox("Please note, this type of freeze does NOT get any special stake rewards. It is only a feature people use to experiment and only advanced users should proceed.", " OK  ", " Do not show this message again. ")
                    if res==1:
                        AdvanceArray['frozenpegnotify']=1
            self.OwnerBefore.setText(Gtranslate("Frozen"))
            self.AddBefore.hide()            
            self.OwnerAfter.setText("")
            self.OwnAfterTitle.setText(_translate("Form", "Owner After Date:", None))
            self.OwnBeforeTitle.setText(_translate("Form", "Owner Before Date:", None))
        if self.comboBox.currentIndex() == 1+offset:
            self.OwnerBefore.setText("")
            self.AddBefore.show()
            self.OwnerAfter.setText("")
            self.OwnAfterTitle.setText(_translate("Form", "Owner After Date:", None))
            self.OwnBeforeTitle.setText(_translate("Form", "Owner Before Date:", None))            
        if self.comboBox.currentIndex() == 2+offset:
            self.OwnerBefore.setText("")
            self.AddBefore.show()
            self.OwnerAfter.setText("")            
            self.OwnAfterTitle.setText(_translate("Form", "Notary/Burn Message:", None))
            self.OwnBeforeTitle.setText(_translate("Form", "    Notify Address:", None))
        if self.comboBox.currentIndex() == 3+offset:
            self.AddBefore.show()
            self.OwnerAfter.setText("")
            self.OwnBeforeTitle.setText(_translate("Form", "Network to burn coins:", None))
            self.OwnAfterTitle.setText(_translate("Form", "   Recipient address:", None))
            res=QuestionBox("Would you like to send liquid coins or reserve coins?", " Send liquid coins  ", " Send reserve coins ")
            if res==0:
                self.OwnerBefore.setText("Send liquid: ")
            else:
                self.OwnerBefore.setText("Send reserve: ")
        if self.comboBox.currentIndex() == 4+offset:
            self.AddBefore.show()
            self.OwnerBefore.setText("")
            self.OwnerAfter.setText("")
            self.OwnBeforeTitle.setText(_translate("Form", "Receipt for minting coins:", None))
            self.OwnAfterTitle.setText(_translate("Form", "       Recipient address:", None))
    def AddThisBefore(self):
        offset=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            offset=2
            if self.comboBox.currentIndex() == 0:
                offset=-2
            if self.comboBox.currentIndex() == 1:
                offset=-1
        if self.comboBox.currentIndex() == 1+offset:
            res=QuestionBox("Please choose what you want to add.", "Add an address script", "Add a password(hash puzzle)")
            if res==0:
                scrp=str(self.OwnerBefore.text())
                if scrp != "":                
                    readthis=deserialize_script(str(scrp))
                    if str(readthis[0])!='169' and str(readthis[2]!='136') and len(readthis)>3:#Not a hash puzzle or there is already a script
                        res2=QuestionBox("There is already a script in this field. Do you want to change it?", " Yes ", " No ")
                        if res2==1:
                            return                                  
                        else:
                            self.OwnerBefore.setText(str(""))
                text=self.AddMultisigScript()
            if res==1:
                if str(self.OwnerBefore.text())!="":
                    res2=QuestionBox("Hash puzzles must be added before the recipient. Would you like clear this section and add the hash puzzle?", " Yes ", " No ")
                    if res2 == 0:
                        self.OwnerBefore.setText(str(""))
                    else:
                        return
                text=self.AddHashPuzzle()
            if text==False:
                return
            self.OwnerBefore.setText(str(self.OwnerBefore.text())+str(text))
            return
        if self.comboBox.currentIndex() == 2+offset:
            res=QuestionBox("Please choose what you want to add.", "Add an address", "Cancel")
            if res==0:
                text, ok = QtGui.QInputDialog.getText(self, "Halo", Gtranslate('Please enter the address of the recipient:'))
                text=str(text)
                self.OwnerBefore.setText(str(text))
        global thisMsgBox
        if self.comboBox.currentIndex() == 3+offset:            
            thisMsgBox = QtGui.QDialog()
            thisMsgBox.setWindowTitle(CoinSelect['HaloName'])
            thisMsgBox.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
            thisMsgBox.resize(300,150)
            comboBox = QtGui.QComboBox(thisMsgBox)
            comboBox.setGeometry(QtCore.QRect(15, 50, 270, 31))
            comboBox.setObjectName(_fromUtf8("comboBox"))
            for bridged in ThePeg.Pegdatabase['bridgedb']['bridges']:
                comboBox.addItem(_fromUtf8(""))
                comboBox.setItemText(0, bridged['n'])
            mylabel = QtGui.QLabel(thisMsgBox)
            mylabel.setGeometry(QtCore.QRect(15, 10, 270, 31))
            font = QtGui.QFont()
            font.setFamily(_fromUtf8("Arial"))
            font.setPixelSize(14)
            font.setWeight(75)
            mylabel.setFont(font)
            mylabel.setText(_translate("thisMsgBox", "Please select the network to send to", None))

            OkayButton = QtGui.QPushButton(thisMsgBox)
            OkayButton.setGeometry(QtCore.QRect(15, 90, 80, 30))
            OkayButton.setFont(font)
            OkayButton.setObjectName(_fromUtf8("OkayButton"))
            OkayButton.setText(" OK ")

            CancelButton = QtGui.QPushButton(thisMsgBox)
            CancelButton.setGeometry(QtCore.QRect(125, 90, 80, 30))
            CancelButton.setFont(font)
            CancelButton.setObjectName(_fromUtf8("CancelButton"))
            CancelButton.setText(" Cancel ")
            ApplyCSS(thisMsgBox)

            CancelButton.clicked.connect(lambda: thisMsgBox.reject())
            OkayButton.clicked.connect(lambda: thisMsgBox.accept())

            res=thisMsgBox.exec_()
            if res==1:
                text=comboBox.currentText()
                beforetext=str(self.OwnerBefore.text())
                if beforetext!="Send reserve: " or beforetext!="Send liquid: ":                    
                    beforetext=beforetext[:13]
                    if ": " not in beforetext:
                        beforetext+=" "
                self.OwnerBefore.setText(beforetext+str(text))
        if self.comboBox.currentIndex() == 4+offset:
            thisMsgBox = QtGui.QDialog()
            thisMsgBox.setWindowTitle(CoinSelect['HaloName'])
            thisMsgBox.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
            thisMsgBox.resize(300,150)
            comboBox = QtGui.QComboBox(thisMsgBox)
            comboBox.setGeometry(QtCore.QRect(15, 50, 270, 31))
            comboBox.setObjectName(_fromUtf8("comboBox"))
            for bridged in ThePeg.Pegdatabase['bridgedb']['bridges']:
                comboBox.addItem(_fromUtf8(""))
                comboBox.setItemText(0, bridged['n'])
            mylabel = QtGui.QLabel(thisMsgBox)
            mylabel.setGeometry(QtCore.QRect(15, 10, 270, 31))
            font = QtGui.QFont()
            font.setFamily(_fromUtf8("Arial"))
            font.setPixelSize(14)
            font.setWeight(75)
            mylabel.setFont(font)
            mylabel.setText(_translate("thisMsgBox", "Please select the network the coins were sent from", None))

            OkayButton = QtGui.QPushButton(thisMsgBox)
            OkayButton.setGeometry(QtCore.QRect(15, 90, 80, 30))
            OkayButton.setFont(font)
            OkayButton.setObjectName(_fromUtf8("OkayButton"))
            OkayButton.setText(" OK ")

            CancelButton = QtGui.QPushButton(thisMsgBox)
            CancelButton.setGeometry(QtCore.QRect(125, 90, 80, 30))
            CancelButton.setFont(font)
            CancelButton.setObjectName(_fromUtf8("CancelButton"))
            CancelButton.setText(" Cancel ")
            ApplyCSS(thisMsgBox)

            CancelButton.clicked.connect(lambda: thisMsgBox.reject())
            OkayButton.clicked.connect(lambda: thisMsgBox.accept())

            res=thisMsgBox.exec_()
            if res==1:
                text=comboBox.currentText()
                text2, ok = QtGui.QInputDialog.getText(self, "Halo", Gtranslate('Please enter the receipt with the merkle proof:'))
                try:
                    text2=ast.literal_eval(str(text2))
                    newdata={}
                    newdata['w'] = txhash(str(text))[:64]
                    newdata['n'] = text2['nonce']
                    newdata['f'] = text2['from']
                    newdata['a'] = text2['address']
                    newdata['s'] = text2['section']
                    newdata['r'] = copy.deepcopy(text2['reserve'])
                    newdata['t'] = text2['root']
                    newdata['p'] = text2['proof']
                except:
                    res=QuestionBox("Receipt was not valid", " OK ")
                    return
                tot = 0
                try:
                    fee = str(window.BitFee.text())
                    fee = int(abs(Decimal(fee)*Decimal(1e8)))              
                    for val in newdata['r']:
                        tot+=int(val)
                    tot -= fee
                except:
                    res=QuestionBox("Transaction fee or receipt data was not valid", " OK ")
                    return
                tot=str(Decimal(tot)/Decimal(1e8))
                self.OwnerBefore.setText("Mint:"+str(newdata))
                window.BitAmount.setText(tot)        
    def AddMultisigScript(self):
        text, ok = QtGui.QInputDialog.getText(self, "Halo", Gtranslate('Please enter the redeem script of the recipient:'))
        if len(str(text))<40:
            QuestionBox('Invalid redeem script! You must enter the script of their address. You may ask the recipient to supply this to you if you do not have it.', 'OK')
            return False
        readthis=deserialize_script(str(text))
        if str(readthis[0])!='2' or str(readthis[3])!='2' or str(readthis[4])!='174' or len(readthis)>5:
            res=QuestionBox('This redeem script is not a standard Halo dual key multisignature address. The software may not recognize this destination. Are you sure you want to proceed?', 'Yes', 'No')
            if res==1:
                return False
        return text
    def AddHashPuzzle(self):
        text, ok = QtGui.QInputDialog.getText(self, "Halo", Gtranslate('Please enter the password for the puzzle:'))
        text2, ok = QtGui.QInputDialog.getText(self, "Halo", Gtranslate('Please confirm the password for the puzzle:'))
        if len(str(text))>20:
            QuestionBox('Password is too long. It must be less than 20 characters.', 'OK')
            return False
        if not re.match(r'^[A-Za-z0-9]+$', str(text)):
            QuestionBox('Password must only contain numbers and letters with no special characters. Please try a different password.', 'OK')
            return False            
        if str(text)!=str(text2):
            QuestionBox('Password did not match.', 'OK')
            return False
        if str(text)=="":
            QuestionBox('Password was blank.', 'OK')
            return False
        #Hash puzzle should check size first OP_SIZE(CODE 130, hex 82) followed by max hash size, then
        #perhaps something like OP_LESSTHANOREQUAL(CODE 161, hex a1)
        text=hash160(str(text))
        return "a9"+hexlen(text)+text+"88"
    def AddThisAfter(self):
        offset=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            offset=2
        if self.comboBox.currentIndex() == 0+offset:
            if str(self.OwnerAfter.text())!="":
                res=QuestionBox("There is already a script in this field. Do you want to change it?", " Yes ", " No ")
                if res==1:
                    return
            text=self.AddMultisigScript()
            if text==False:
                return
            self.OwnerAfter.setText(str(text))
            return
        if self.comboBox.currentIndex() == 1+offset:
            res=QuestionBox("Please choose what you want to add.", "Add an address script", "Add a password(hash puzzle)")
            #"Burn/Destroy the funds" will be used after checksequenceverify activates
            if res==1:
                res+=1
            if res==0:
                scrp=str(self.OwnerAfter.text())
                if scrp != "":                
                    readthis=deserialize_script(str(scrp))
                    if str(readthis[0])!='169' and str(readthis[2]!='136') and len(readthis)>3:#Not a hash puzzle
                        res2=QuestionBox("There is already a script in this field. Do you want to change it?", " Yes ", " No ")
                        if res2==1:
                            return                                  
                        else:
                            self.OwnerAfter.setText(str(""))
                text=self.AddMultisigScript()
            if res==1:
                res2=QuestionBox("Burning funds after some time expires is commonly used in unbreakable contracts. Please make sure you read up on the risks and advantages of this before proceeding. Proceed anyways?", " Yes ", " No ")
                if res2==1:
                    return
                if str(self.OwnerAfter.text())!="":
                    res2=QuestionBox("All of your other scripts in this section will become invalid! Would you like clear this section and simply burn/destroy it?", " Yes ", " No ")
                    if res2 == 0:
                        self.OwnerAfter.setText(str(""))
                    else:
                        return                    
                text="6a"
            if res==2:
                if str(self.OwnerAfter.text())!="":
                    res2=QuestionBox("Hash puzzles must be added before the recipient. Would you like clear this section and add the hash puzzle?", " Yes ", " No ")
                    if res2 == 0:
                        self.OwnerAfter.setText(str(""))
                    else:
                        return
                text=self.AddHashPuzzle()
            if text==False:
                return
            self.OwnerAfter.setText(str(self.OwnerAfter.text())+str(text))
            return
        if self.comboBox.currentIndex() == 2+offset:
            res=QuestionBox("What would you like to Notarize/Burn?", " Message/Text "," Hash of a file ")
            if res==0:
                text, ok = QtGui.QInputDialog.getText(self, "Halo", Gtranslate('Please enter the data you would like to burn/notarize:'))
                text=str(text)
            else:                    
                path = QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Please open the file you wish to use."),MacDir()+"","All Files (*.*)")
                path = strOUT(strIN(path))
                text=checksum_sha256(path)
                if CoinSelect['6aLength'] < len(text):
                    res=QuestionBox(Gtranslate("The maximum length of the data you are allowed to burn is:\n")+str(CoinSelect['6aLength'])+Gtranslate("\n\nTherefore, the first " + str(CoinSelect['6aLength']) + " characters of the Sha256 hash of your file will be burned into the chain: ") + str(text), " OK ", " Copy Hash To Clipboard ")
                    if res==1:
                            clipboard = app.clipboard()
                            clipboard.setText(str(text))
                    text=text[:(CoinSelect['6aLength'])]                
                else:
                    res=QuestionBox(Gtranslate("The following Sha256 hash of your file will be burned into the chain: ") + str(text), " OK ", " Copy Hash To Clipboard ")
                    if res==1:
                        clipboard = app.clipboard()
                        clipboard.setText(str(text))                         
            if len(text)>CoinSelect['6aLength']:
                QuestionBox(Gtranslate("The maximum length of the data you are allowed to burn is:\n")+str(CoinSelect['6aLength']), "OK")
                return
            if text=="":
                return
            if len(text)>75:
                hexleng="4c"
            else:
                hexleng=""
            text=hexlify(text)
            hexleng+=num_to_var_int((len(text)/2)).encode('hex')
            self.OwnerAfter.setText(str("6a"+hexleng+text))
        if self.comboBox.currentIndex() == 3+offset:
            mbox1=QtGui.QInputDialog()
            ApplyCSS(mbox1)
            text, ok = mbox1.getText(mbox1, "BitBay", Gtranslate("Please enter the recipient address."))
            self.OwnerAfter.setText(text)
        if self.comboBox.currentIndex() == 4+offset:
            msigaddr,mscript = create_multisig_address(PrivKeyFilename1,PrivKeyFiledir1)            
            self.OwnerAfter.setText(msigaddr)
    def ApplyExotic(self):
        global AdvanceArray
        if 'exoticwarn' not in AdvanceArray and self.comboBox.currentIndex() != 2:
            res=QuestionBox("Before proceeding please understand that you are responsible for checking the accuracy of these exotic payments.", " OK  ", " Do not show this message again. ")
            if res==1:
                AdvanceArray['exoticwarn']=1
        offset=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            offset=2
            addy=str(self.OwnerBefore.text())
            if self.comboBox.currentIndex() == 0:
                window.BitPayTo.setText("Move Reserve:"+addy)
                self.hide()
                return
            if self.comboBox.currentIndex() == 1:
                window.BitPayTo.setText("Voluntary Freeze:"+addy)
                self.hide()
                return
        if self.comboBox.currentIndex() == 0+offset:
            try:
                thescript=str(FreezeScript(int(self.dateTimeEdit.dateTime().toTime_t()),str(self.OwnerAfter.text())))
                meaning=translate_script(thescript)
                if meaning=={}:
                    QuestionBox("The script is not a valid Halo exotic script.", " OK ")
                    return
                else:
                    QuestionBox("Please confirm the exotic script: \n\n"+meaning['description'], " OK ", 1)
            except:
                QuestionBox("There was an error creating the script.", " OK ")
                return
            window.BitPayTo.setText("Script:"+thescript)
            self.hide()
        if self.comboBox.currentIndex() == 1+offset:
            try:
                thescript=str(TimelockScript(int(self.dateTimeEdit.dateTime().toTime_t()),str(self.OwnerBefore.text()),str(self.OwnerAfter.text())))
                meaning=translate_script(thescript)
                if meaning=={}:
                    QuestionBox("The script is not a valid Halo exotic script.", " OK ")
                    return
                else:
                    QuestionBox("Please confirm the exotic script: \n\n"+meaning['description'], " OK ")                
            except:
                QuestionBox("There was an error creating the script.", " OK ")
                return                
            window.BitPayTo.setText("Script:"+thescript)
            self.hide()
        if self.comboBox.currentIndex() == 2+offset:
            notify=""
            if str(self.OwnerBefore.text())!="":
                notify=":"+str(self.OwnerBefore.text())
            window.BitPayTo.setText("Script:"+str(self.OwnerAfter.text())+notify)
            window.BitAmount.setText("0.0001")
            self.hide()
        if self.comboBox.currentIndex() == 3+offset:
            if 'bridgewarn' not in AdvanceArray:
                res=QuestionBox("Please be aware that bridging a transaction to another network burns your funds on BitBay. Therefore BitBay is not responsible for the security of the corresponding network. Stakers will attempt to mint funds on the network you selected after at least a day of confirmations. Also, because every network has a different address format, please make completely sure the recipient address is correct and is properly typed before proceeding. Only proceed if you understand the risk of using a decentralized bridge.", " OK  ", " Do not show this message again. ")
                if res==1:
                    AdvanceArray['bridgewarn']=1
            beforetext=str(self.OwnerBefore.text())
            if "Send reserve: " in beforetext:
                beforetext=beforetext.replace("Send reserve: ","")
                beforetext=beforetext.replace("Send liquid: ","")
                if beforetext == "":
                    res=QuestionBox("Invalid bridge","OK")
                    return
                text=MakeCipherOutputs("**Z**"+txhash(beforetext)[:64]+str(self.OwnerAfter.text()),1)[0]
                window.BitPayTo.setText("Move Reserve:"+text)
            else:
                beforetext=beforetext.replace("Send liquid: ","")
                if beforetext == "":
                    res=QuestionBox("Invalid bridge","OK")
                    return
                text=MakeCipherOutputs("**Z**"+txhash(beforetext)[:64]+str(self.OwnerAfter.text()),1)[0]
                window.BitPayTo.setText(text)
            self.hide()
        if self.comboBox.currentIndex() == 4+offset:
            beforetext=str(self.OwnerBefore.text())
            window.BitPayTo.setText(beforetext)
            self.hide()
class Wizard(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(510, 360)
        self.stackedWidget = QtGui.QStackedWidget(Form)
        self.stackedWidget.setGeometry(QtCore.QRect(0, 0, 511, 361))
        self.stackedWidget.setObjectName(_fromUtf8("stackedWidget"))
        self.page = QtGui.QWidget()
        self.page.setObjectName(_fromUtf8("page"))
        self.HaloIcon = QtGui.QPushButton(self.page)
        self.HaloIcon.setGeometry(QtCore.QRect(350, 20, 151, 161))
        self.HaloIcon.setText(_fromUtf8(""))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(application_path+'/images/' + CoinSelect['HaloName'] + ".png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.HaloIcon.setIcon(icon)
        self.HaloIcon.setIconSize(QtCore.QSize(100, 100))
        self.HaloIcon.setObjectName(_fromUtf8("HaloIcon"))
        self.WelcomeText = QtGui.QTextBrowser(self.page)
        self.WelcomeText.setGeometry(QtCore.QRect(10, 20, 341, 161))
        self.WelcomeText.setObjectName(_fromUtf8("WelcomeText"))
        self.Next1 = QtGui.QPushButton(self.page)
        self.Next1.setGeometry(QtCore.QRect(10, 190, 111, 41))
        self.Next1.setObjectName(_fromUtf8("Next1"))
        self.SkipSetup = QtGui.QPushButton(self.page)
        self.SkipSetup.setGeometry(QtCore.QRect(314, 312, 150, 31))
        self.SkipSetup.setObjectName(_fromUtf8("SkipSetup"))

        self.stackedWidget.addWidget(self.page)
        self.page_3 = QtGui.QWidget()
        self.page_3.setObjectName(_fromUtf8("page_3"))
        self.FirstWallet = QtGui.QPushButton(self.page_3)
        self.FirstWallet.setGeometry(QtCore.QRect(10, 240, 210, 41))
        self.FirstWallet.setObjectName(_fromUtf8("FirstWallet"))
        self.CreateText = QtGui.QTextBrowser(self.page_3)
        self.CreateText.setGeometry(QtCore.QRect(10, 20, 491, 211))
        self.CreateText.setObjectName(_fromUtf8("CreateText"))
        self.KeysIcon = QtGui.QPushButton(self.page_3)
        self.KeysIcon.setGeometry(QtCore.QRect(410, 240, 91, 111))
        self.KeysIcon.setText(_fromUtf8(""))
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(_fromUtf8(application_path+'/images/' + "Keys.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.KeysIcon.setIcon(icon1)
        self.KeysIcon.setIconSize(QtCore.QSize(100, 100))
        self.KeysIcon.setObjectName(_fromUtf8("KeysIcon"))
        self.stackedWidget.addWidget(self.page_3)
        self.page_2 = QtGui.QWidget()
        self.page_2.setObjectName(_fromUtf8("page_2"))
        self.PasswordText = QtGui.QTextBrowser(self.page_2)
        self.PasswordText.setGeometry(QtCore.QRect(10, 20, 491, 181))
        self.PasswordText.setObjectName(_fromUtf8("PasswordText"))
        self.Skip2 = QtGui.QPushButton(self.page_2)
        self.Skip2.setGeometry(QtCore.QRect(394, 322, 101, 31))
        self.Skip2.setObjectName(_fromUtf8("Skip2"))
        self.PasswordKeys = QtGui.QPushButton(self.page_2)
        self.PasswordKeys.setGeometry(QtCore.QRect(10, 210, 210, 41))
        self.PasswordKeys.setObjectName(_fromUtf8("PasswordKeys"))
        self.stackedWidget.addWidget(self.page_2)
        self.page_4 = QtGui.QWidget()
        self.page_4.setObjectName(_fromUtf8("page_4"))
        self.PhotoText = QtGui.QTextBrowser(self.page_4)
        self.PhotoText.setGeometry(QtCore.QRect(10, 20, 491, 191))
        self.PhotoText.setObjectName(_fromUtf8("PhotoText"))
        self.KeysToPhotos = QtGui.QPushButton(self.page_4)
        self.KeysToPhotos.setGeometry(QtCore.QRect(10, 220, 215, 41))
        self.KeysToPhotos.setObjectName(_fromUtf8("KeysToPhotos"))
        self.DogeDream = QtGui.QPushButton(self.page_4)
        self.DogeDream.setGeometry(QtCore.QRect(270, 220, 231, 131))
        self.DogeDream.setText(_fromUtf8(""))
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(_fromUtf8(application_path+'/images/' + "Dreams.png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.DogeDream.setIcon(icon2)
        self.DogeDream.setIconSize(QtCore.QSize(229, 150))
        self.DogeDream.setObjectName(_fromUtf8("DogeDream"))
        self.Skip3 = QtGui.QPushButton(self.page_4)
        self.Skip3.setGeometry(QtCore.QRect(10, 322, 101, 31))
        self.Skip3.setObjectName(_fromUtf8("Skip3"))
        self.stackedWidget.addWidget(self.page_4)
        self.page_5 = QtGui.QWidget()
        self.page_5.setObjectName(_fromUtf8("page_5"))
        self.BackupText = QtGui.QTextBrowser(self.page_5)
        self.BackupText.setGeometry(QtCore.QRect(10, 20, 491, 181))
        self.BackupText.setObjectName(_fromUtf8("BackupText"))
        self.BackupKeys = QtGui.QPushButton(self.page_5)
        self.BackupKeys.setGeometry(QtCore.QRect(10, 210, 181, 41))
        self.BackupKeys.setObjectName(_fromUtf8("BackupKeys"))
        self.Skip4 = QtGui.QPushButton(self.page_5)
        self.Skip4.setGeometry(QtCore.QRect(10, 320,101, 31))
        self.Skip4.setObjectName(_fromUtf8("Skip4"))
        self.stackedWidget.addWidget(self.page_5)
        self.page_6 = QtGui.QWidget()
        self.page_6.setObjectName(_fromUtf8("page_6"))
        self.FirstCoinsText = QtGui.QTextBrowser(self.page_6)
        self.FirstCoinsText.setGeometry(QtCore.QRect(10, 20, 491, 301))
        self.FirstCoinsText.setObjectName(_fromUtf8("FirstCoinsText"))
        self.Next2 = QtGui.QPushButton(self.page_6)
        self.Next2.setGeometry(QtCore.QRect(10, 320, 101, 31))
        self.Next2.setObjectName(_fromUtf8("Next2"))
        self.stackedWidget.addWidget(self.page_6)
        self.page_7 = QtGui.QWidget()
        self.page_7.setObjectName(_fromUtf8("page_7"))
        self.SetupEmailText = QtGui.QTextBrowser(self.page_7)
        self.SetupEmailText.setGeometry(QtCore.QRect(10, 20, 491, 241))
        self.SetupEmailText.setObjectName(_fromUtf8("SetupEmailText"))
        self.Skip5 = QtGui.QPushButton(self.page_7)
        self.Skip5.setGeometry(QtCore.QRect(394, 322, 101, 31))
        self.Skip5.setObjectName(_fromUtf8("Skip5"))
        self.SetupEmail = QtGui.QPushButton(self.page_7)
        self.SetupEmail.setGeometry(QtCore.QRect(10, 270, 181, 41))
        self.SetupEmail.setObjectName(_fromUtf8("SetupEmail"))
        self.stackedWidget.addWidget(self.page_7)
        self.page_8 = QtGui.QWidget()
        self.page_8.setObjectName(_fromUtf8("page_8"))
        self.ContractsText = QtGui.QTextBrowser(self.page_8)
        self.ContractsText.setGeometry(QtCore.QRect(10, 20, 491, 131))
        self.ContractsText.setObjectName(_fromUtf8("ContractsText"))
        self.BackupContracts = QtGui.QPushButton(self.page_8)
        self.BackupContracts.setGeometry(QtCore.QRect(10, 160, 181, 41))
        self.BackupContracts.setObjectName(_fromUtf8("BackupContracts"))
        self.stackedWidget.addWidget(self.page_8)
        self.page_9 = QtGui.QWidget()
        self.page_9.setObjectName(_fromUtf8("page_9"))
        self.CongratsText = QtGui.QTextBrowser(self.page_9)
        self.CongratsText.setGeometry(QtCore.QRect(10, 20, 491, 121))
        self.CongratsText.setObjectName(_fromUtf8("CongratsText"))
        self.ReturnHalo = QtGui.QPushButton(self.page_9)
        self.ReturnHalo.setGeometry(QtCore.QRect(10, 150, 181, 41))
        self.ReturnHalo.setObjectName(_fromUtf8("ReturnHalo"))
        self.stackedWidget.addWidget(self.page_9)

        self.retranslateUi(Form)
        self.stackedWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(Form)
        self.WelcomeText.setOpenLinks(False)
        self.WelcomeText.anchorClicked.connect(self.Navigate)
        self.FirstCoinsText.setOpenLinks(False)
        self.FirstCoinsText.anchorClicked.connect(self.Navigate)
        self.myindex=0
        self.filedir1=""
        self.file1=""
        self.filedir2=""
        self.file2=""
        self.hiddenimages=0
        self.Next1.clicked.connect(self.Next)
        self.SkipSetup.clicked.connect(self.SkipMySetup)
        self.ReturnHalo.clicked.connect(self.ReturnToHalo)
        self.Skip2.clicked.connect(self.Next)
        self.Skip3.clicked.connect(self.Next)
        self.Skip4.clicked.connect(self.Next)
        self.Skip5.clicked.connect(self.Next)
        self.Next2.clicked.connect(self.Next)
        self.FirstWallet.clicked.connect(self.MyFirstWallet)
        self.PasswordKeys.clicked.connect(self.PasswordMyKeys)
        self.KeysToPhotos.clicked.connect(self.MyKeysToPhotos)
        self.BackupKeys.clicked.connect(self.BackupMyKeys)
        self.SetupEmail.clicked.connect(self.SetupMyEmail)
        self.BackupContracts.clicked.connect(self.BackupMyContracts)
    def retranslateUi(self, Form):
        Form.setWindowTitle(_translate("Form", "Form", None))
        self.WelcomeText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:19px; font-weight:600;\">" + _translate("","Welcome to The Setup Wizard")+"</span><span style=\" font-size:19px;\">!</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","This wizard will help you get started and introduce you to cryptocurrency. It will also guide you, step by step, to get everything set up properly. Halo is revolutionary contracting software. It has the ability to make unbreakable contracts and more. Please scroll down to learn more.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","Below is a useful video to explain currency:")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"https://www.youtube.com/watch?v=ktK6Yx3_czs\"><span style=\" font-size:11px; text-decoration: underline; color:#0000ff;\">https://www.youtube.com/watch?v=ktK6Yx3_czs</span></a></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:11px; text-decoration: underline; color:#0000ff;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","What is cryptocurrency?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","It is money without a central bank. The history is shared by all the users including you. The transactions are also verified by the users. Therefore, it is one of the first currencies in history that cannot be counterfeit.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","What is Bitcoin?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","Bitcoin was the first cryptocurrency. There are many others and each one is unique. There is Blackcoin, Dogecoin, Litecoin, Peercoin, BitBay and hundreds more. Anyone can create a currency and each currency is open source. Open source means that anyone can read the code and make sure it is secure. Currencies get their value from free trade and supply and demand. This usually means the most popular and useful currencies are the most valued. Since Bitcoin is currently the most popular coin, it is the most traded and valued. However, every day new currencies are made with new exciting ideas.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","What else can Cryptocurrency do?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","They can be used to represent anything. It can represent time, money, commodities such as houses or gold, it can be used to issue shares in an idea or company, it can be used to count votes, notarize documents. There is no limit to this groundbreaking technology.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","What is Halo?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","Halo is the worlds first smart contracting software. It was also the first multisignature software and the first multicoin software.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","What is a smart contract?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","A smart contract is a contract that can execute on its own. Without the need for complex paperwork. It can be enforced without laws and without violence. It is a way to form agreement and trust between people.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","How does Halo work?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","Halos smart contracts are the most pure, simple contracts possible. They solve the issue of enforcement. It uses a technique called double deposit escrow. The way it works is, both parties put deposits into the deal based on their level of trust. Between untrusted parties, the deposits normally are equal to or exceed the value of what is being negotiated. The deals are timed and if the timer runs out, both parties lose. So it allows total strangers to trust each other and forces them to work together. It can also be used to force networks of computers to honor any set of rules.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","What problems does Halo solve?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","There is too many to list. Halo removes the middle man. So no more frivolous lawsuits, no more theft, no more deception. Halo can be used for unbreakable employment contracts, bartering such as trading corn for wheat, trusted wires and western unions, microtrading, long term contracts, replacing insurance with self-assurance, backing, binary derivatives that always get paid, and so much more. It can be useful to anyone. It can restore trade to countries without trust, bring trust internationally between strangers, make society more efficient, restore faith in any industry, and reduce the cost of any business.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","What else can this software do?")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","The software has decentralized markets. These markets have no server so there is no single point of failure and no owner. It is also an international market which connects everyone in the world. The markets are whitelisted and meant for the masses. Halo can also make joint accounts for two parties, spend from two computers, make unhackable accounts, hide files in images, ")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","keep accounting records, stake from two computers, decentralized trade of currencies and much more.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","Halo is free software and soon will be open sourced. There is no middlemen. Thank you for reading. To continue, please follow the instructions in the wizard.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","Here is a video about Halo")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"https://www.youtube.com/watch?v=WhwM3cH_Kgk\"><span style=\" font-size:11px; text-decoration: underline; color:#0000ff;\">https://www.youtube.com/watch?v=WhwM3cH_Kgk</span></a></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:11px; text-decoration: underline; color:#0000ff;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px; text-decoration: underline; color:#000000;\">" + _translate("","Acceptable use and disclaimer:")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px; color:#000000;\">" + _translate("","We are not responsible for misuse of the program/protocol. This computer program should only be obtained from our main websites or built from its source code and never from an untrusted source. We are not responsible for any loss of coins during program use or during contracting. We are not responsible for unforseen bugs in the program, it is your responsibility to make sure the source code is secure and can run on your computer. It is recommended you run the program from the source code to prevent any risk of hacked executables. You and the counterparty must work out any differences and plan for any delays. There is no escrow agent and we do not profit from escrows. Thus, if your contract defaults due to lack of backup, acts of nature, unforseen events or disputes with your counter-party, we are not responsible. You must follow instructions carefully and never allow your escrows to time out. Keep your software running at all times during contracting and in case of power outages or computer problems, make sure you have backed up everything on multiple locations so you can continue to contract. You may give one of your keys to a spouse or a friend in case of emergencies. We are not responsible if you lose your keys. When using the markets the software logs your encrypted IP address inside every public offer. So anyone who is given a moderator account will be able to remove offers, perform IP bans, and control markets. So you must not use this software to violate any laws in your country. This program is an open source protocol. Similar to email, a protocol is not responsible for it's misuse. Although there is a graphical interface guiding you on how to use it, there is no middle man, no escrow agent, and no owner to this protocol/program. The developer who works on this project was not the founder of Bitcoin, Blackcoin or BitBay. He works only as a freelancer and he improves this code base freely on his own good will. When on github the program may get multiple contributors and experience changes. We are under absolutely no obligation to moderate these markets. The moderation system is decentralized using a shared key. It is not possible to control the internet. The markets create an entirely new peer to peer protocol and layer of the internet. You as a user can report spam or abuse of the markets and even flag orders. The moderation key is available on request which allows for decentralized moderation to keep the markets clean. This is a community driven effort and they are also not responsible for your actions. Moderation attempts are usually done in good faith when things are brought to the attention of the community. Laws vary for each country so when performing a contract please be aware of the ones that apply to you. Please keep things fun and clean for everyone so we can all enjoy a new paradigm shift into a world we can trust.")+"</span></p></body></html>")
        self.Next1.setText(_translate("Form", "Next", None))
        self.SkipSetup.setText(_translate("Form", "Skip Setup", None))
        self.FirstWallet.setText(_translate("Form", "Create My First Wallet", None))
        self.CreateText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px; font-weight:600;\">" + _translate("","Create your account")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px; font-weight:600;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Your account is made up of 2 keys, stored in two files. You must guard those keys. You will be the only person in the world who can access the funds in your account.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","The keys are used to make an address such as... bMDqFjNxhLNgE63F7F5ixDSRyMP7xwWL8K")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Send that address to anyone to receive payments.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Please create your account, name your two keys, choose a location to save them and proceed to the next step.")+"</span></p></body></html>")
        self.PasswordText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px; font-weight:600;\">" + _translate("","Password Protect Your Keys")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Now we encourage you to put a password on your keys. Although it is not required, anyone who finds both of the keys can access your account. You can choose the same password for both keys or a different password for each key. You can have a password on one key or both. Its up to you. If you forget your passwords, you will not be able to get into your account. If you want to backup your keys first and protect later, you may want to skip this step.")+"</span></p></body></html>")
        self.Skip2.setText(_translate("Form", "Skip", None))
        self.PasswordKeys.setText(_translate("Form", "Password Protect My Keys", None))
        self.PhotoText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px; font-weight:600;\">" + _translate("","Hide keys in a photo/picture")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","If you want maximum security, you can also hide each key inside a photo. Perhaps you wish to use a picture of your dog or family. This makes them impossible for hackers to find them. We have some default photos located in the Halo directory if you decide to use them.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Important:")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","If you do this, keep a copy of the original files. Never edit the photos or save them with a photo editor or recompress them since that could change the data and thus make the key invalid.")+"</span></p></body></html>")
        self.KeysToPhotos.setText(_translate("Form", "Hide My Keys In Two Photos", None))
        self.Skip3.setText(_translate("Form", "Skip", None))
        self.BackupText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px; font-weight:600;\">" + _translate("","Backup Your Keys")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Now that you have your keys protected, we recommend you backup your keys. You may also want to email your keys to yourself. If they are hidden in images, it will be indistinguishable from a normal email. Also we recommend optical drives over flash drives for backup. So if you have a CD or DVD, those backups last longer. Flash drives have been known to expire after a few years. Another way is to print the contents of the original keyfile out on a piece of paper so it never expires.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","So please insert a flash drive into your computer and proceed with backup.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p></body></html>")
        self.BackupKeys.setText(_translate("Form", "Backup My Keys", None))
        self.Skip4.setText(_translate("Form", "Skip", None))
        self.FirstCoinsText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px; font-weight:600;\">" + _translate("","Your First Coins.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px; font-weight:600;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","One of the most common questions about cryptocurrency is, ")+"&quot;"+ _translate("","How do I easily buy coins?")+"&quot;" + _translate(""," With Halo ")+"</span><span style=\" font-size:13px; font-weight:600;\">" + _translate("","markets")+"</span><span style=\" font-size:13px;\"> " + _translate("","you may wish to purchase coins here. However, some people may require a deposit. Others may be willing to guarantee their coins in a contract without requiring a deposit from you. So here are some other ways to obtain your first coins.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Coinbase")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"https://coinbase.com\"><span style=\" font-size:11px; text-decoration: underline; color:#0000ff;\">https://coinbase.com</span></a></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:11px; font-style:italic;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Coinbase is one of the most popular ways to buy Bitcoins in the world and have started expanding to other countries. Once your first Bitcoin is purchased you may trade it for any currency on a cryptocurrency exchange.")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Other options are listed below however we consider most of them to be risky. It is much safer to find a buyer on here. If you dont find one, try finding a local Bitcoin ATM.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><a href=\"https://en.bitcoin.it/wiki/Buying_Bitcoins_%28the_newbie_version%29\"><span style=\" font-size:11px; text-decoration: underline; color:#0000ff;\">https://en.bitcoin.it/wiki/Buying_Bitcoins_%28the_newbie_version%29</span></a></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p></body></html>")
        self.Next2.setText(_translate("Form", "Next", None))
        self.SetupEmailText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px; font-weight:600;\">" + _translate("","Setup an email")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Email and Bitmessage are used to receive contracts and offers. We encrypt all emails for your privacy. Its recommended to create a new email exclusively for Halo. Email is a bit more reliable than Bitmessage. If you received a ")+"&quot;" + _translate("","Pay to Email")+"&quot;" + _translate(""," from a friend then please use that email to redeem the coins. If the email that received it is not in the supported providers please forward that email to a new account that is supported. The supported providers are: Gmail, Outlook, Hotmail and AOL. This list can also be found later in the 'Receive' tab.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:13px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px; text-decoration: underline;\">" + _translate("","Bitmessage")+"</span></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","Bitmessage is decentralized email used for Halo markets and receiving contracts. It is used to make computers talk to each other privately without a server. Your Bitmessage address is automatically generated  and will be shown shortly. Since it's newer software it continues to go through updates with improved performance and security.")+"</span></p></body></html>")
        self.Skip5.setText(_translate("Form", "Skip", None))
        self.SetupEmail.setText(_translate("Form", "Setup My Email", None))
        self.ContractsText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px; font-weight:600;\">" + _translate("","Backup Contracts Automatically")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px; font-weight:600;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","This part is highly recommended because if you are in negotiations with someone and your computer fails you want to always make sure you have a backup of your contracts. This file backs up with every change. We recommend using a flash drive. However, even a secondary backup on your computer is also sufficient. Some people also like to use cloud based backup systems.")+"</span></p></body></html>")
        self.BackupContracts.setText(_translate("Form", "Backup Contracts", None))
        self.CongratsText.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16px;\">" + _translate("","Congratulations! You are ready to use Halo.")+"</span></p>\n"
    "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:16px;\"><br /></p>\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","If you wish to receive any more support you can check the documentation. Also, you may find other users to help you over IRC chat. There is also forums on reddit where people are happy to answer more questions. We hope you love the software and hope that it enlightens you to the future of trade.")+"</span></p></body></html>")
        self.ReturnHalo.setText(_translate("Form", "Return To Halo", None))
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        Form.setWindowTitle(_translate(CoinSelect['HaloName'], CoinSelect['HaloName'], None))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(_fromUtf8(application_path+'/images/' + CoinSelect['HaloName'] + ".png")), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.HaloIcon.setIcon(icon)
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def MyFirstWallet(self):
        result=False
        while result==False:
            result=NewWallet("","",1)
            print result
            if result==False:
                mbox = QuestionBox("You must create two keys to continue. Would you prefer to exit the wizard and setup manually?", " Yes ", " No ")
                if mbox == 0:
                    UpdateCfg('#Wizard#',"0")
                    self.hide()
                    return
        self.Next()
    def PasswordMyKeys(self):
        EncryptPrivateKey(self.filedir1,self.file1)
        EncryptPrivateKey(self.filedir2,self.file2)
        self.Next()
    def MyKeysToPhotos(self):
        global NewUser        
        mbox = QuestionBox("Would you like to use the default photos of 'Dream.png' and 'Hobbes.png'? If not, you will be prompted to choose your own photos for each key. Also, the photos will be saved in the same location as the keys. If you want to dispose of your original keys and use the photo exclusively, you can do so manually after backing them up.", " Yes " , " No ")
        path=os.path.join(self.filedir1,self.file1)
        with open(path,'r') as fi:
            data=fi.readlines()
            fi.close()
        path3=os.path.join(self.filedir2,self.file2)
        with open(path3,'r') as fi:
            data2=fi.readlines()
            fi.close()
        if mbox == 1:
            path2 = strOUT(strIN(QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Open the image you wish to use for hiding the first key. PNG is preferred, both JPEG and PNG supported."),MacDir()+"","Image File (*.jpg *.jpeg *.png)")))
            if path2=="":
                return
            path4 = strOUT(strIN(QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Open the second image you wish to use for hiding the second key. PNG is preferred, both JPEG and PNG supported."),MacDir()+"","Image File (*.jpg *.jpeg *.png)")))
            if path4=="":
                return
            path5=os.path.join(self.filedir1,self.file1.replace(".private",".png"))
            path6=os.path.join(self.filedir2,self.file2.replace(".private",".png"))
            try:
                if os.path.exists(path5) or os.path.exists(path6):
                    QuestionBox("You must not overwrite an existing image. Please try again.", " OK ")
                    return
            except:
                traceback.print_exc()
                QuestionBox("Saving of private key image failed!", " OK ")
                return
            HideInImage(path2,str(data),path5)
            HideInImage(path4,str(data2),path6)
            self.hiddenimages=1
        else:
            path2=os.path.join(application_path+'/images/',"Dreams.png")
            path4=os.path.join(application_path+'/images/',"Hobbes.png")
            path5=os.path.join(self.filedir1,self.file1.replace(".private",".png"))
            path6=os.path.join(self.filedir2,self.file2.replace(".private",".png"))
            try:
                if os.path.exists(path5) or os.path.exists(path6):
                    QuestionBox("You must not overwrite an existing image. Please try again.", " OK ")
                    return
            except:
                traceback.print_exc()
                QuestionBox("Saving of private key image failed!", " OK ")
                return
            HideInImage(path2,str(data),path5)
            HideInImage(path4,str(data2),path6)
            self.hiddenimages=1
        NewUser=[]
        NewUser.append(self.file1.replace(".private",".png"))
        NewUser.append(self.file2.replace(".private",".png"))
        NewUser.append(self.filedir1)
        NewUser.append(self.filedir2)
        NewUser.append(str("2"))
        NewUser.append(" ")
        NewUser.append(0)
        self.Next()
    def BackupMyKeys(self):    
        if self.file1==self.file2:
            QuestionBox("You chose the same name for both keys. In order to avoid overwriting a key, please backup manually in the file menu once setup is complete.", "OK")
            return
        dir1 = strOUT(strIN(QtGui.QFileDialog.getExistingDirectory(self,Gtranslate("Open a folder for your backup"),MacDir()+"",QtGui.QFileDialog.ShowDirsOnly)))
        if dir1=="":
            return
        file1 = os.path.join(self.filedir1,self.file1)
        file2 = os.path.join(self.filedir2,self.file2)
        dest1 = os.path.join(dir1,self.file1)
        dest2 = os.path.join(dir1,self.file2)
        try:
            if os.path.exists(dest1) or os.path.exists(dest2):
                QuestionBox("You must not overwrite an existing private key. Please try again.", " OK ")
                return
        except:
            traceback.print_exc()
            QuestionBox("Backup failed!", " OK ")
            return
        shutil.copyfile(file1, dest1)
        shutil.copyfile(file2, dest2)
        file1 = os.path.join(self.filedir1,self.file1.replace(".private",".share"))
        file2 = os.path.join(self.filedir2,self.file2.replace(".private",".share"))
        dest1 = os.path.join(dir1,self.file1.replace(".private",".share"))
        dest2 = os.path.join(dir1,self.file2.replace(".private",".share"))
        shutil.copyfile(file1, dest1)
        shutil.copyfile(file2, dest2)
        if self.hiddenimages==1:
            file1 = os.path.join(self.filedir1,self.file1.replace(".private",".png"))
            file2 = os.path.join(self.filedir2,self.file2.replace(".private",".png"))
            dest1 = os.path.join(dir1,self.file1.replace(".private",".png"))
            dest2 = os.path.join(dir1,self.file2.replace(".private",".png"))
            try:
                if os.path.exists(dest1) or os.path.exists(dest2):
                    QuestionBox("You must not overwrite an existing image. Please try again.", " OK ")
                    return
            except:
                traceback.print_exc()
                QuestionBox("Backup of private key image failed!", " OK ")
                return
            shutil.copyfile(file1, dest1)
            shutil.copyfile(file2, dest2)
        self.Next()
    def BackupMyContracts(self):
        window.BrowseBackup()
        self.Next()
    def SetupMyEmail(self):
        window.NewEmail()
        self.Next()
    def Next(self):
        self.myindex += 1
        self.stackedWidget.setCurrentIndex(self.myindex)
    def Navigate(self, item):
        t=str(item)
        t=t.lstrip("PyQt4.QtCore.QUrl(u'")
        t=t.rstrip("')")
        webbrowser.open(t)
        self.WelcomeText.backward()
    def SkipMySetup(self, event):
        mbox = QuestionBox("Are you sure you want to exit the first time user wizard? This will keep it from showing again.", " Yes " , " No ")
        if mbox == 1:
            return
        UpdateCfg('#Wizard#',"0")
        self.hide()
        window.show()
    def ReturnToHalo(self, event):
        UpdateCfg('#Wizard#',"0")
        self.hide()
        window.show()
    def closeEvent(self, event):
        mbox = QuestionBox("Are you sure you want to exit the first time user wizard? This will keep it from showing again.", " Yes ", " No ")
        if mbox == 1:
            event.ignore()
            return
        UpdateCfg('#Wizard#',"0")
        event.accept()
        window.show()
        self.hide()
class WDetails(QtGui.QWidget):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(460, 330)        
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Dialog.sizePolicy().hasHeightForWidth())
        Dialog.setSizePolicy(sizePolicy)
        Dialog.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.verticalLayout_2 = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.verticalLayout = QtGui.QVBoxLayout()
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.textBrowser = QtGui.QTextBrowser(Dialog)
        self.textBrowser.setObjectName(_fromUtf8("textBrowser"))
        self.verticalLayout.addWidget(self.textBrowser)
        spacerItem = QtGui.QSpacerItem(20, 10, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.verticalLayout.addItem(spacerItem)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        ApplyCSS(self)

        #Signals
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        self.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"></p></body></html>")
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        Dialog.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
class WOutbox(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(370, 300)        
        self.CL = QtGui.QListWidget(Form)
        self.CL.setGeometry(QtCore.QRect(10, 10, 351, 281))
        self.CL.setObjectName(_fromUtf8("listView"))
        QtCore.QObject.connect(self.CL, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.EmailClick)
        #self.MarketBox.connect(self.MarketBox,QtCore.SIGNAL("currentIndexChanged(int)"),self.MarketChange)
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        ApplyCSS(self)

    def retranslateUi(self, Form):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def populate(self):
        global AdvanceArray
        self.CL.clear()
        for account in AdvanceArray['OUTBOX']:
            for msgid in AdvanceArray['OUTBOX'][account]:
                text = str(account[:11])+"...   "+str(AdvanceArray['OUTBOX'][account][msgid]['status']).ljust(15)+ "   " + str(msgid)
                self.CL.addItem(text)
    def EmailClick(self, item):
        global AdvanceArray
        t=str(item.text())
        ps=self.CL.currentRow()
        pos=0
        if "Email Failed" in t:
            mbox = QuestionBox("Sending this email failed. If it was encrypted email, Halo will try and re-send. If it was Bitmessage you must re-send manually. Do you wish to clear this notification?", " Yes " , " No ")
        else:
            mbox = QuestionBox("Would you like to clear this notification from your outbox?", "Yes", "No", "Clear All")
        if mbox == 1:
            return
        for account in AdvanceArray['OUTBOX']:
            if mbox == 2:
                AdvanceArray['OUTBOX'][account]={}            
            else:
                for msgid in AdvanceArray['OUTBOX'][account]:
                    if pos==ps:
                        AdvanceArray['OUTBOX'][account].pop(msgid)
                        break
                    pos+=1
        self.hide()
class Explanations(QtGui.QDialog):
    def __init__(self, parent=None):
        QtGui.QDialog.__init__(self, parent)
        uic.loadUi(application_path+'/images/'+'Explanation.ui', self)
        ApplyCSS(self)
    def retranslateUi(self, Form):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            uic.loadUi(application_path+'/images/'+'Explanation2.ui', self)
        else:
            uic.loadUi(application_path+'/images/'+'Explanation.ui', self)
class ChangeList(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(270, 300)        
        self.CL = QtGui.QListWidget(Form)
        self.CL.setGeometry(QtCore.QRect(10, 10, 251, 281))
        self.CL.setObjectName(_fromUtf8("listView"))
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

        QtCore.QObject.connect(self.CL, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.clickedme)
        ApplyCSS(self)        

    def retranslateUi(self, Form):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def clickedme(self,item):
        t=str(item.text())
        t=t.split("ID:")[1].strip()
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            for i in Spendable:
                if 'liquidity' in i and i['output']==t:
                    res=QuestionBox("Liquidity Rating: " + "\n" + str(i['liquidity']['rating']) + "\n\n" + "Reserve Total: " + "\n" + str(Decimal(i['liquidity']['rtotal'])/Decimal(1e8)) + "\n\n" + str("Liquid Total: ") + "\n" + str(Decimal(i['liquidity']['ltotal'])/Decimal(1e8)), Gtranslate(" OK "), 1)

class StakeList(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(270, 300)        
        self.CL = QtGui.QListWidget(Form)
        self.CL.setGeometry(QtCore.QRect(10, 10, 251, 281))
        self.CL.setObjectName(_fromUtf8("listView"))
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        QtCore.QObject.connect(self.CL, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.ClearItem)
        ApplyCSS(self)

    def retranslateUi(self, Form):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def populate(self):
        global stakelist
        self.CL.clear()
        for item in stakelist:
            self.CL.addItem(item)
    def ClearItem(self, item):
        global stakelist, updatesomething
        t=str(item.text())
        orig=t        
        t=t.replace("Order number:  ","")
        matchObj = re.match( r'(.*?) (  Confirmation TXID:) (.*)', str(t), re.M|re.I)
        ordernumber=str(matchObj.group(1))
        txid=str(matchObj.group(3)).strip()
        mbox = QuestionBox(Gtranslate("You have staked a block and earned some coins for securing the network. Please wait until the transaction confirms on the network. Staked transactions takes longer to confirm (") + str(CoinSelect['stakeconfirmations']) + Gtranslate(" blocks). So please give the transaction some time to appear in your account."), " OK ", " Clear from history ")
        if mbox == 0:
            return
        mbox = QuestionBox(Gtranslate("Warning! This is usually not a good idea and can result in future transactions being declined forcing a rescan. This will clear the following inputs from this computers history. The only reason you would do this is if the order never confirmed. It can also happen if the TXID gets changed in the mining process. It is recommended you wait for it to clear automatically.") + "\nOrder # " + ordernumber + "\nTXID: " + txid, Gtranslate(" Clear from history "), Gtranslate(" Okay, I will wait "),1)
        if mbox == 1:
            return
        #Ok they want to clear it... lets find the order in spendable and remove it
        updatesomething=1
        if orig in stakelist:
            stakelist.remove(orig)
        self.populate()
        DeleteOrder(str(ordernumber))

class WContracts(QtGui.QWidget):
    def setupUi(self, Form):
        Form.setObjectName(_fromUtf8("Form"))
        Form.resize(560, 421)        
        self.label = QtGui.QLabel(Form)
        self.label.setGeometry(QtCore.QRect(10, 10, 91, 16))
        self.label.setObjectName(_fromUtf8("label"))
        self.Details = QtGui.QTextBrowser(Form)
        self.Details.setGeometry(QtCore.QRect(10, 30, 281, 201))
        self.Details.setObjectName(_fromUtf8("Details"))
        self.Requests = QtGui.QListWidget(Form)
        self.Requests.setGeometry(QtCore.QRect(300, 30, 256, 201))
        self.Requests.setObjectName(_fromUtf8("Requests"))
        self.label_2 = QtGui.QLabel(Form)
        self.label_2.setGeometry(QtCore.QRect(300, 10, 91, 16))
        self.label_2.setObjectName(_fromUtf8("label_2"))
        self.Complete = QtGui.QPushButton(Form)
        self.Complete.setGeometry(QtCore.QRect(10, 250, 141, 41))
        self.Complete.setObjectName(_fromUtf8("Complete"))
        self.Cancel = QtGui.QPushButton(Form)
        self.Cancel.setGeometry(QtCore.QRect(10, 310, 141, 41))
        self.Cancel.setObjectName(_fromUtf8("Cancel"))
        self.Description = QtGui.QPushButton(Form)
        self.Description.setGeometry(QtCore.QRect(10, 370, 141, 41))
        self.Description.setObjectName(_fromUtf8("Description"))
        self.comboBox = QtGui.QComboBox(Form)
        self.comboBox.setGeometry(QtCore.QRect(300, 250, 251, 31))
        self.comboBox.setObjectName(_fromUtf8("comboBox"))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))        
        self.textEdit = QtGui.QTextEdit(Form)
        self.textEdit.setGeometry(QtCore.QRect(300, 300, 251, 31))
        self.textEdit.setObjectName(_fromUtf8("textEdit"))
        self.Send = QtGui.QPushButton(Form)
        self.Send.setGeometry(QtCore.QRect(300, 350, 61, 31))
        self.Send.setObjectName(_fromUtf8("Send"))

        self.Complete.clicked.connect(self.CompleteContract)
        self.Cancel.clicked.connect(self.CancelContract)
        self.Send.clicked.connect(lambda: self.SendMessage())
        self.Description.clicked.connect(self.DescriptionW)
        QtCore.QObject.connect(self.Requests, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.RequestClick)
        self.comboBox.connect(self.comboBox,QtCore.SIGNAL('currentIndexChanged(int)'), self.ChangeIndex)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        ApplyCSS(self)
        if CoinSelect['moderngui'] == 1:
            font = QtGui.QFont()
            font.setPixelSize(11.5)
            self.Complete.setFont(font)
            self.Cancel.setFont(font)

    def retranslateUi(self, Form):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
        self.label.setText(_translate("Form", "Escrow Details", None))
        self.Details.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'"+globfont+"\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:13px;\">" + _translate("","All details go here")+"</span></p></body></html>")
        self.label_2.setText(_translate("Form", "Requests/History", None))
        self.Complete.setText(_translate("Form", "Send Completion Request", None))
        self.Cancel.setText(_translate("Form", "Send Cancellation Request", None))
        self.Description.setText(_translate("Form", "Contract Details", None))
        self.comboBox.setItemText(0, _translate("Form", "Escrow Options & Filtered Messages", None))
        self.comboBox.setItemData(0,QtCore.QVariant(0))
        self.comboBox.setItemText(1, _translate("Form", "Unlock Chat", None))
        self.comboBox.setItemData(1,QtCore.QVariant(999))
        self.comboBox.setItemText(2, _translate("Form", "Send Western Union or Confirmation Number", None))
        self.comboBox.setItemData(2,QtCore.QVariant(2))
        self.comboBox.setItemText(3, _translate("Form", "Request More Time (In days)", None))
        self.comboBox.setItemData(3,QtCore.QVariant(3))
        self.comboBox.setItemText(4, Gtranslate("Leave review on markets"))
        self.comboBox.setItemData(4,QtCore.QVariant(4))
        self.comboBox.setItemText(5, Gtranslate("Import Message"))
        self.comboBox.setItemData(5,QtCore.QVariant(997))
        self.comboBox.setItemText(6, Gtranslate("Export Messages"))
        self.comboBox.setItemData(6,QtCore.QVariant(998))                        
        self.Send.setText(_translate("Form", "Send", None))
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)
    def makeComboBox(self):
        self.comboBox.blockSignals(True)
        self.comboBox.clear()
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.addItem(_fromUtf8(""))
        #May want to change the order of options listed by iterating
        self.comboBox.setItemText(0, Gtranslate("Escrow Options & Filtered Messages"))
        self.comboBox.setItemData(0,QtCore.QVariant(0))
        self.comboBox.setItemText(1, Gtranslate("Unlock Chat"))
        self.comboBox.setItemData(1,QtCore.QVariant(999))
        self.comboBox.setItemText(2, Gtranslate("Send Western Union or Confirmation Number"))
        self.comboBox.setItemData(2,QtCore.QVariant(2))
        self.comboBox.setItemText(3, Gtranslate("Request More Time (In days)"))
        self.comboBox.setItemData(3,QtCore.QVariant(3))
        self.comboBox.setItemText(4, Gtranslate("Leave review on markets"))
        self.comboBox.setItemData(4,QtCore.QVariant(4))
        self.comboBox.setItemText(5, Gtranslate("Import Message"))
        self.comboBox.setItemData(5,QtCore.QVariant(997))
        self.comboBox.setItemText(6, Gtranslate("Export Messages"))
        self.comboBox.setItemData(6,QtCore.QVariant(998))                     
        self.comboBox.blockSignals(False)
    def addComboItem(self, item, pos, variant):
        self.comboBox.blockSignals(True)
        self.comboBox.addItem(_fromUtf8(""))
        self.comboBox.setItemText(pos, Gtranslate(item))
        self.comboBox.setItemData(pos,QtCore.QVariant(variant))        
        self.comboBox.blockSignals(False)        
    def checkMessages(self):
        global CoinMarketCap, ContractSelected, MyContracts
        contract=ContractSelected
        #Check unread messages
        if 'MyMessages' not in ContractSelected:
            ContractSelected['MyMessages']=[]
        l=len(ContractSelected['MyMessages'])
        ps=0
        mk=0
        for message in ContractSelected['MyMessages']:
            if ps+1==l:
                tex="OK"
            else:
                tex="Next Message"
            if 'read' not in message and mk==0:
                foundme=0
                if "Received request for funds(click to respond): " in message['message']:
                    foundme=1
                    if "Something" in ContractSelected['Market Data']['Template']:
                        try:                            
                            amt=message['message'].replace("Received request for funds(click to respond): ","")
                            amt=str(Decimal(amt)/Decimal(1e8))
                            amt2=amt
                            usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)
                            if usd != "":
                                rateusd=str((Decimal(amt)*Decimal(usd)).quantize(Decimal('.01')))
                                amt+="\nAmount in USD:\n"+rateusd
                            res2=QuestionBox(Gtranslate("Your counter-party has requested funds for shipping based on the destination. Please review the amount and then decide if you want to accept now or review and negotiate within the escrow panel.")+"\n\nCoins Requested:\n"+amt,Gtranslate(" Accept request for funds "),Gtranslate(" Review in escrow panel "),"",1)
                            if res2==0:
                                if Decimal(amt2)>(Decimal(ContractSelected['theirdeposit'])/Decimal(1e8)):
                                    res2=QuestionBox("Their deposit is less than the amount they are asking for. We strongly recommend caution when proceeding because there will no longer be a disincentive for them to break the contract.", " I understand ", " Cancel Payment ")
                                if res2==0:
                                    window.Tabs.setCurrentIndex(1)
                                    window.BitPayTo.setText(str(ContractSelected['theiraddress']))
                                    window.BitAmount.setText(str(amt2))                            
                                    QuestionBox("Please review the information to confirm their address is correct. You should also carefully review the amount. When ready, simply click 'Send'. Once sent you might wish to send them a message to confirm they got the payment.", "OK")
                            res=0
                        except:
                            traceback.print_exc()
                if "Received confirmation number: " in message['message']:
                    foundme=1
                    res=QuestionBox(Gtranslate("New Confirmation Number!")+"\n\n"+message['message'].replace("Received confirmation number: ",""),Gtranslate(tex),Gtranslate("Mark all as read"),"",1)
                if "Time extended: " in message['message']:
                    foundme=1
                    res=QuestionBox(Gtranslate(message['message']), Gtranslate(tex),Gtranslate("Mark all as read"),"",1)
                if "Time extension request: " in message['message']:
                    foundme=1
                    res=QuestionBox(Gtranslate(message['message'] + "\n\nPlease click on the request in the requests/history panel to respond."), Gtranslate(tex),Gtranslate("Mark all as read"),"",1)
                if foundme==0:
                    res=QuestionBox(Gtranslate("New Message!")+"\n\n"+message['message'],Gtranslate(tex),Gtranslate("Mark all as read"),"",1)
                if res==1:
                    mk=1
            ContractSelected['MyMessages'][ps]['read']=1
            ps+=1
    def showme(self, tip=0):
        global timestamp, ContractSelected, MyContracts
        self.makeComboBox()
        setting=self.comboBox.itemData(1).toInt()[0]
        contract=ContractSelected        
        if 'Market Data' not in contract:
            self.checkMessages()
            self.comboBox.setItemText(1, Gtranslate("Send Message"))
            self.comboBox.setItemData(1, QtCore.QVariant(1))
            self.show()
            return
        if "Something" in contract['Market Data']['Template']:
            if "I pay" not in contract["whopays"]:
                if 'shipping' in ContractSelected['Market Data']:
                    if ContractSelected['Market Data']['shipping']=="Buyer Pays During Escrow":
                        self.addComboItem("Request funds for shipping", 7, 7)
        self.checkMessages()
        if 'Market Data' not in contract:
            self.comboBox.setItemText(1, Gtranslate("Send Message"))
            self.comboBox.setItemData(1, QtCore.QVariant(1))
            self.show()
            return
        if 'Chat requested!(click to respond)' in ContractSelected['MyRequests']:
            if 'tip99' not in ContractSelected:
                if contract['Market Data']['allowchat']==0:
                    res=QuestionBox("Your partner has requested to chat! This will allow unfiltered chat. Do you wish to unlock chat?","OK","Not now","Don't show this message again")
                    if res==0:
                        ContractSelected['Market Data']['allowchat']=1
                        ContractSelected['tip99']=1
                        self.hide()
                    if res==2:
                        ContractSelected['tip99']=1
        if setting==999:
            if contract['Market Data']['allowchat']==1:
                self.comboBox.setItemText(1, Gtranslate("Send Message"))
                self.comboBox.setItemData(1,QtCore.QVariant(1))
        if "Python" in contract['Market Data']['Template']:
            try:
                exec(validateCode(contract['Market Data']['code3']))
            except:
                QuestionBox("Code execution failed", " OK ")
                traceback.print_exc()
                return
        if "Barter" in contract['Market Data']['Template']:
            if 'barterescrow' not in AdvanceArray:
                res=QuestionBox('When bartering if multiple shipments or trades are involved users should take turns trading. This way the amount being traded will be within the range of the deposits. If there is any concerns about shipments or bills they should be handled within escrow. A barter contract may be kept open if a good trading relationship is formed so users may trade to their liking.',' OK ', ' Do not show this message again. ')
                if res==1:
                    AdvanceArray['barterescrow']=1
        if "Hire" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template']:
            if 'billing' not in ContractSelected:
                if "Week" in contract['Market Data']['Pay Frequency'] or "Month" in contract['Market Data']['Pay Frequency']:
                    mytime=ConvertDate(contract['time'], 1) - datetime.timedelta(hours=contract['timeout'])#Time the contract confirmed
                    if "Week" in contract['Market Data']['Pay Frequency']:
                        NewTime=mytime+ datetime.timedelta(hours=168)
                    if "Month" in contract['Market Data']['Pay Frequency']:
                        NewTime=addmonths(1,mytime)
                    ContractSelected['billing']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
            previousexchangerate=""
            if 'prevrate' in contract:
                previousexchangerate="\nPrevious exchange rate: "+str(contract['prevrate'])+ "\n(always confirm exchange rates for accuracy)"
            if 'ratematch' in contract:
                if contract['ratematch']==1:
                    previousexchangerate+="\nRate matches the exchange history"
                else:
                    previousexchangerate+="\nRate not found in records, please confirm independently"
            if "Week" in contract['Market Data']['Pay Frequency'] or "Month" in contract['Market Data']['Pay Frequency']:
                if "I pay" in contract['whopays']:
                    self.addComboItem("Make Payment", 7, 1000)
                    self.addComboItem("Autopay Options", 8, 1001)                    
                if 'frequencytip' not in ContractSelected:
                    res=QuestionBox("A pay schedule was chosen for this contract. Therefore, the project will continue until a completion or cancellation request is sent which should be done on the last billing cycle. Both parties should keep the software running to track exchange rates and to automatically extend the contracts time limit after valid payments to avoid default.", " OK ", " Do not show this message again. ")
                    if res==1:
                        ContractSelected['frequencytip']=1
            if "I pay" in contract['whopays']:
                if 'paytip' not in contract:
                    if "Flat" not in contract['Market Data']['Pay Frequency']:
                        res=QuestionBox("Please note, it is very important to never make payments outside of escrow. This is because payments are officially registered in the contract and for some types of contracts it will extend the time limit.", " OK ", " Do not show this message again. ")
                        if res==1:
                            ContractSelected['paytip']=1
                if 'autopayoff' in contract:
                    QuestionBox(Gtranslate("Automated payments have failed. This can happen for a variety of reasons for your protection. It is recommended you pay this invoice manually and if you want to enable autopay after a successful payment you may do so.\n\nReason for failed payment:\n")+contract['autopayoff'], Gtranslate(" OK "), 1)
                    contract.pop('autopayoff')
                if 'autopay' in contract['Market Data'] and contract['Market Data']['autopay']==1:
                    if 'autotip' not in ContractSelected:
                        if contract['Market Data']['tracking']!=0:
                            res=QuestionBox("Please note, you have chosen to automate payments while tracking the exchange rate. For your security if there is any major fluctuation of the exchange rate beyond 30 percent of the previous billing cycle the feature will automatically disable itself. Your software must be running during the duration of the contract so it is able to track the exchange rate. You should also make sure your account is always unlocked to make the payments. Otherwise the feature will disable itself. The escrow extends it's time automatically once both parties see valid payments.", " OK ", " Do not show this message again. ")
                        else:
                            res=QuestionBox("Please note, you have chosen to automate payments. You should make sure your account is always unlocked to make the payments. The escrow extends it's time automatically once both parties see valid payments.", " OK ", " Do not show this message again. ")
                        if res==1:
                            ContractSelected['autotip']=1
                    res=QuestionBox(Gtranslate("Next payment due: ")+str(ConvertDate(ContractSelected['billing'], 1))+previousexchangerate,Gtranslate(" Autopay Options "),Gtranslate(" Continue to escrow window "),1)
                    if res==0:
                        res=QuestionBox("Automated payments is currently enabled. Would you like to disable autopay?", " Yes ", " No ")
                        ContractSelected['Market Data']['autopay']=0
                    if res==0:
                        QuestionBox("If you want to make a payment or enable automated payments again you can do so in the escrow window.", " OK ")
                else:
                    if "Week" in contract['Market Data']['Pay Frequency'] or "Month" in contract['Market Data']['Pay Frequency']:
                        res=QuestionBox(Gtranslate("Next payment due: ")+str(ConvertDate(ContractSelected['billing'], 1))+previousexchangerate,Gtranslate(" Make Payment "),Gtranslate(" Continue to escrow window "),1)
                        if res==0:
                            self.EscrowPayment()
                    if "Milestone" in contract['Market Data']['Pay Frequency']:
                        if 'billing' in contract:
                            self.addComboItem("Make Payment", 7, 1000)
                            res=QuestionBox(Gtranslate("Received milestone invoice: ")+str(ConvertDate(ContractSelected['billing'], 1)),Gtranslate(" Make Payment "),Gtranslate(" Continue to escrow window "),1)
                            if res==0:
                                self.EscrowPayment()
                        else:
                            QuestionBox("Currently waiting for counter-party to complete next milestone.", " Continue to escrow window ")
            else:
                if 'requirereport' in contract['Market Data'] and contract['Market Data']['requirereport']==1:
                    self.addComboItem("Submit Report", 7, 1002)
                    if 'reportnotify' not in ContractSelected:
                        res=QuestionBox("The employer has required that you submit reports before each billing cycle. Please note that they will be unable to pay you until those reports are submitted. Therefore you should always submit them shortly before the end of each cycle through escrow. The reports might contain detailed notes on what you accomplished in the week/month and anything else the employer requests.", " OK ", " Do not show this message again. ")
                        if res==1:
                            ContractSelected['reportnotify']=1
                if "Week" in contract['Market Data']['Pay Frequency'] or "Month" in contract['Market Data']['Pay Frequency']:
                    if 'requirereport' in contract['Market Data'] and contract['Market Data']['requirereport']==1:                        
                        res=QuestionBox(Gtranslate("Next payment due: ")+str(ConvertDate(ContractSelected['billing'], 1))+previousexchangerate,Gtranslate(" Submit report and request current payment "),Gtranslate(" Continue to escrow window "),1)
                        if res==0:
                            self.submitreport(str(ConvertDate(ContractSelected['billing'], 1)))
                    else:
                        res=QuestionBox(Gtranslate("Next payment due: ")+str(ConvertDate(ContractSelected['billing'], 1))+previousexchangerate,Gtranslate(" Continue to escrow window "),1)
                if "Milestone" in contract['Market Data']['Pay Frequency']:
                    self.addComboItem("Complete Milestone", 7, 1003)
                    if 'billing' in contract:                        
                        res=QuestionBox(Gtranslate("Sent milestone invoice: ")+str(ConvertDate(ContractSelected['billing'], 1)),Gtranslate(" Continue to escrow window "),1)
                    else:
                        previnvoice=''
                        if 'billingpaid' in contract:
                            previnvoice+='Previous invoice: '+str(contract['billingpaid'])+"\n"+previousexchangerate+'\n\n'
                        res=QuestionBox(previnvoice+Gtranslate("The next payment is due upon the completion of this milestone."), Gtranslate(" Complete milestone "),  Gtranslate(" Complete project "), Gtranslate(" Continue to escrow window "),1)
                        if res==0:
                            self.submitmilestone()
                        if res==1:
                            QuestionBox('When you complete the project your last milestone payment arrives at the close of escrow.', ' OK ')
                            self.CompleteContract()
        if "Something" in contract['Market Data']['Template']:
            if 'tip' not in ContractSelected or tip==1:
                if "I pay" not in contract["whopays"]:
                    if ContractSelected['Market Data']['Profiles']['Mail']!=[]:
                        if tip==0:
                            shipduringescrow=0
                            if 'shipping' in ContractSelected['Market Data']:
                                if ContractSelected['Market Data']['shipping']=="Buyer Pays During Escrow":
                                    shipduringescrow=1
                            if shipduringescrow==1:
                                res=QuestionBox("You have chosen to have the buyer pay for shipping during escrow. Would you like to send a quote now?", " Request funds from buyer for shipping ", " Will ship later ", " Don't show this message again ")
                                if res==0:
                                    res=QuestionBox("How would you like to proceed?", " Estimate with Fedex shipping calculator ", " Send an exact quote ")
                                    if res==0:
                                        rate=shippingcalculator(ContractSelected['Market Data']['Profiles']['Mail'][0])
                                    if res==1:
                                        rate=shippingcalculator(ContractSelected['Market Data']['Profiles']['Mail'][0],1)
                                    if rate=="":
                                        return
                                    else:
                                        res=QuestionBox(Gtranslate("The amount decided for shipping is: \n\n") + str(rate), Gtranslate(" Request these funds from the buyer "), Gtranslate(" Cancel "), 1)
                                        rate=int(Decimal(rate)*Decimal(1e8))                                        
                                        if res==0:
                                            self.RequestFunds(rate)
                                            QuestionBox("The funds have been requested. Please watch your account for when it funds. Once it funds, you may use the escrow messaging system to send the tracking number.", " OK ")
                                    QuestionBox("If you want to see the shipping details again, they can be found in the details of the escrow window."," OK ")
                                    ContractSelected['tip']="0"
                                if res==2:
                                    ContractSelected['tip']="0"
                            else:
                                res=QuestionBox(Gtranslate("Ship the item(s) to:")+"\n\n"+ContractSelected['Market Data']['Profiles']['Mail'][0],Gtranslate(" The item(s) have been shipped "), Gtranslate(" Will ship later "), Gtranslate(" Don't show this message again "),1)
                                if res==0 or res==2:
                                    QuestionBox("If you want to see the shipping details again, they can be found in the details of the escrow window."," OK ")
                                    ContractSelected['tip']="0"
                                if res==0:
                                    res2=QuestionBox("Would you like to send a tracking number now?", " Yes ", " No ")
                                    if res2==0:
                                        text, ok = QtGui.QInputDialog.getText(self, CoinSelect['HaloName'], Gtranslate('Please enter the tracking number:'))
                                        if text!="" and ok:
                                            tracking= "Tracking number:\n\n"+str(text)
                                            self.SendMessage(tracking)
                                if res==0:
                                    res=QuestionBox("Would you like to complete the contract?","Complete now","Not right now")
                                    if res==0:
                                        self.CompleteContract()
                                        return
                        else:
                            res=QuestionBox(Gtranslate("Ship the item(s) to:")+"\n\n"+ContractSelected['Market Data']['Profiles']['Mail'][0],Gtranslate("OK"),"","",1)
        if "Coins" in contract['Market Data']['Template']:
            if 'selected' in contract['Market Data']['reply']:
                ContractSelected['Market Data']['selected']=contract['Market Data']['reply']['selected']
            if 'selected' in contract['Market Data']:
                ContractSelected['Market Data']['reply']['selected']=contract['Market Data']['selected']
            else:
                for pro in ContractSelected['Market Data']['Profiles']:
                    if pro!="Contact" and ContractSelected['Market Data']['Profiles'][pro]!=[]:
                        if ContractSelected['Market Data']['Profiles'][pro][0]!="":
                            ContractSelected['Market Data']['reply']['selected']=pro
            if 'tip' not in ContractSelected or tip==1:
                if "I pay" not in contract["whopays"] or tip==1:
                    if tip==0:
                        res=QuestionBox(Gtranslate("Send the funds to:")+"\n\n"+ContractSelected['Market Data']['Profiles'][ContractSelected['Market Data']['reply']['selected']][0],Gtranslate(" The funds have been sent "), Gtranslate(" Will send later "), Gtranslate(" Don't show this message again "),1)
                        if res==0 or res==2:
                            QuestionBox("If you want to see the funding details again, they can be found in the details of the escrow window.","OK")
                            ContractSelected['tip']="0"
                        if res==0:
                            if ContractSelected['Market Data']['reply']['selected']=="MG" or ContractSelected['Market Data']['reply']['selected']=="WU":
                                QuestionBox("Because you have sent the funds, the next step is to send the confirmation number for your money order. This can be done from this escrow window using the filtered messages. Please let your partner know the number so they may pick up the cash.","OK")
                            else:
                                res=QuestionBox("Would you like to complete the contract?","Complete now","Not right now")
                                if res==0:
                                    self.CompleteContract()
                                    return
                    else:
                        res=QuestionBox(Gtranslate("Send the funds to:")+"\n\n"+ContractSelected['Market Data']['Profiles'][ContractSelected['Market Data']['reply']['selected']][0],Gtranslate("OK"),"","",1)

        self.show()
    def DescriptionW(self):
        global MyContracts
        contract=ContractSelected
        if 'Market Data' in contract:
            Templates.showorder(contract,4)
            return
        try:
            if contract != []:
                b64img=contract['Details']['image']
                width=0
                height=0
                f=0
                data=""
                try:
                    #b64img=GlobalImage
                    #b64img += "=" * ((4 - len(b64img) % 4) % 4) #This is for incorrect padding error
                    image_string = StringIO.StringIO(base64.b64decode(b64img))
                    image = Image.open(image_string)
                    tup=image.size
                    width=tup[0]
                    height=tup[1]
                    if width>460 and height<200:
                        height=200
                    if height>200 and width<460:
                        width=460
                    if width>460 or height>200:
                        MyDetails.resize(width+50, height+210)
                    b64img=ConvertImage(b64img,"base64",False)
                    data+="<img src=\"data:image/png;base64,"+b64img+"\"/>"
                    image_string.close()
                    image_string=""
                except Exception, e:
                    image_string.close()
                    image_string=""
                    traceback.print_exc()
                    pass
                data+="<br />"
                data+="Contract Halo version " + str(contract['version'])+"<br />"
                data+="From: " + str(contract['TheirBMAddress']) + "<br />"
                data+=str(contract['whopays'])+"<br />"
                data+="Amount: "+str(Decimal(contract['amount'])/Decimal(1e8))+"<br />"
                data+="My Deposit: "+str(Decimal(contract['mydeposit'])/Decimal(1e8))+"<br />"
                data+="Their Deposit: "+str(Decimal(contract['theirdeposit'])/Decimal(1e8))+"<br />"
                if contract['instantamount'] != 0:
                    f+=.5
                    data+="Instant refund: ("+str(contract['instantwhopays'])+")<br />"
                    data+="Amount: " + str(Decimal(contract['instantamount'])/Decimal(1e8))+"<br />"
                f+=1#Temporary account
                f+=1#Split escrow fund/release
                data+="<br />"
                data+="Fee: "+str(Decimal(contract['fee']*f)/Decimal(1e8))+"<br />"
                data+="Time limit: "+str(contract['timeout'])+" Hours -- "+str(round((contract['timeout']/24),2))+" Days<br />"
                data+="Order number: "+str(contract['ordernumber'])
                data+="<br /><br />"
                data+="Description: <br />"
                data+=contract['Details']['description']

                MyDetails.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
                "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
                "p, li { white-space: pre-wrap; }\n"
                "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
                "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">"+data+"</span></p></body></html>")
                MyDetails.show()
        except Exception, e:
            traceback.print_exc()
            pass
    def CompleteContract(self):
        global MyContracts, myblockcount
        mbox = QuestionBox("Do you wish to complete the contract? Once a request is sent, it cannot be undone.", " Yes, this deal is complete " , " Cancel ")
        if mbox == 1:
            self.hide()
            return
        contract=ContractSelected
        inputs=[]
        outputs=[]
        inp={}
        theirs={}
        mine={}
        theirtotal=0
        mytotal=0
        theirtotal+=contract['theirdeposit']
        mytotal+=contract['mydeposit']
        if "I pay this" in contract['whopays']:
            theirtotal+=contract['amount']
        else:
            mytotal+=contract['amount']
        pos=-1
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==contract['ordernumber']:
                break
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        inp['output']=unicode(str(contract['tx3'])+":0")
        inp['value']=theirtotal+mytotal
        inp['address']=contract['escrow']
        inputs.append(inp)
        clearsig=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before trying to spend.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                return
            #Eventually it would be nice to simply send tons of signatures iterating for each supply up to a limit
            pegsigs={}
            supply2=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
            supply=0
            ftot=0
            ltot1=0
            rtot1=0
            if 'theircompletesig' in contract:
                #Their signature probably was based on a different supply so as long as totals match it's okay to use their data
                supply=contract['theircompletesig']['supply']
                if supply2-8>supply:#things have drifted too far... lets delete their signature
                    QuestionBox('The counterparties request for completion has expired due to a change in the supply. Their signature will now be removed and they will have to send another one after they receive yours.', ' OK ')
                    clearsig=1
                    supply=supply2
                else:
                    ltot1=contract['theircompletesig']['ltot']
                    rtot1=contract['theircompletesig']['rtot']
            else:
                supply=supply2
            #Get liquidity
            try:
                busy=NetSplash(1, checkwait=1)
                if TestnetPeg:
                    liquid, reserve=ThePeg.checktransaction(str(contract['tx3'])+":0")
                else:
                    fractions=BLK.getfractions(str(contract['tx3'])+":0")
                    liquid, reserve=ThePeg.formatfractions(fractions, inp['address'], inp['value'], supply=supply)
                combined=ThePeg.checkliquidity(liquid,reserve, supply=supply)
                liq=json_deep_copy(combined)
                supply2=liq['supply']
                if 'theircompletesig' not in contract:                    
                    supply=supply2
                NetSplash(0)
            except:
                NetSplash(0)
                traceback.print_exc()
                QuestionBox("Transaction lookup failed. Software is busy, please try again.", " OK ")
                return
            ltot=liq['ltotal']
            rtot=liq['rtotal']
            pegsigs['supply']=supply
            ftot=liq['future']
            if 'theircompletesig' in contract:
                ftot=contract['theircompletesig']['ftot']
            ltot-=ftot
            rtot+=ftot
            sigs1=''
            if ltot1!=ltot or rtot!=rtot1:
                if 'theircompletesig' in contract and clearsig!=1:
                    res=QuestionBox('The counterparties data does not match your records. Their signature will now be removed and they will have to send another one after they receive yours.', ' OK ', ' Cancel ')
                    if res==1:
                        return
                    clearsig=1
            if rtot>0:
                myratio=Decimal(mytotal)/(Decimal(mytotal)+Decimal(theirtotal))
                theirratio=Decimal(theirtotal)/(Decimal(mytotal)+Decimal(theirtotal))
                myrtot=int(Decimal(rtot)*myratio)
                theirrtot=int(Decimal(rtot)*theirratio)
                remainder=rtot-theirrtot-myrtot
                if mytotal>theirtotal:
                    myrtot+=remainder
                else:
                    theirrtot+=remainder
                myltot=mytotal-myrtot
                theirltot=theirtotal-theirrtot
                if mytotal>0:
                    if myrtot==0:
                        myrtot=5590
                if theirtotal>0:
                    if theirrtot==0:
                        theirrtot=5590
                if myltot<0:
                    myltot=0
                if theirltot<0:
                    theirltot=0
                outs=[]
                if ltot==0:
                    theirs={'value':int(theirtotal),'script':address_to_script(contract['theiraddress'])}#two fees deducted so one can be added
                    mine={'value':int(mytotal),'script':address_to_script(multisig)}
                    if theirtotal>0 and mytotal>0:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1:2'))/2)).encode('hex')+hexlify('**F**1:2')}]
                    else:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')}]
                    if "I pay this" in contract['whopays']:
                        if mytotal>0:
                            outs.append(mine)
                        if theirtotal>0:
                            outs.append(theirs)
                    else:
                        if theirtotal>0:
                            outs.append(theirs)
                        if mytotal>0:
                            outs.append(mine)
                else:                    
                    theirs={'value':int(theirltot),'script':address_to_script(contract['theiraddress'])}#two fees deducted so one can be added
                    mine={'value':int(myltot),'script':address_to_script(multisig)}
                    theirs2={'value':int(theirrtot),'script':address_to_script(contract['theiraddress'])}#two fees deducted so one can be added
                    mine2={'value':int(myrtot),'script':address_to_script(multisig)}
                    if theirtotal>0 and mytotal>0:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1:2'))/2)).encode('hex')+hexlify('**F**1:2')}]
                    else:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')}]
                    if "I pay this" in contract['whopays']:
                        if mytotal>0:
                            outs.append(mine2)
                        if theirtotal>0:
                            outs.append(theirs2)
                        if mytotal>0:
                            outs.append(mine)
                        if theirtotal>0:
                            outs.append(theirs)
                    else:
                        if theirtotal>0:
                            outs.append(theirs2)
                        if mytotal>0:
                            outs.append(mine2)
                        if theirtotal>0:
                            outs.append(theirs)
                        if mytotal>0:
                            outs.append(mine)
                if contract['firstsign']=="me":
                    sigs1,result=create_sig_for_tx(inputs, outs, contract['myprivate'], contract['mypublic'],contract['theirpublic'], contract['timestamp']+30)
                else:
                    sigs1,result=create_sig_for_tx(inputs, outs, contract['myprivate'], contract['theirpublic'],contract['mypublic'], contract['timestamp']+30)
                if result == False:
                    QuestionBox("Signature failure. Please check your signature and try again later.", "OK")
                    self.hide()
                    return
                #str(verify_tx_input(result,0,mscript,sigs1[0],contract['mypublic']))
                pegsigs['2']={'sigs':sigs1,'outs':outs}
            pegsigs['ltot']=ltot
            pegsigs['rtot']=rtot
            pegsigs['ftot']=ftot
        theirs={'value':int(theirtotal),'address':str(contract['theiraddress'])}#two fees deducted so one can be added
        mine={'value':int(mytotal),'address':str(multisig)}#Now if they screw up the id, they will have to get our permission to sign again
        if "I pay this" in contract['whopays']:
            if mytotal>0:
                outputs.append(mine)
            if theirtotal>0:
                outputs.append(theirs)
        else:
            if theirtotal>0:
                outputs.append(theirs)
            if mytotal>0:
                outputs.append(mine)
        if contract['firstsign']=="me":
            sigs,result=create_sig_for_tx(inputs, outputs, contract['myprivate'], contract['mypublic'],contract['theirpublic'], contract['timestamp']+30)
        else:
            sigs,result=create_sig_for_tx(inputs, outputs, contract['myprivate'], contract['theirpublic'],contract['mypublic'], contract['timestamp']+30)
        if result == False:
            QuestionBox("Signature failure. Please check your signature and try again later.", "OK")
            self.hide()
            return
        if 'Market Data' in contract:
            if "Hire" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template']:
                if "I pay this" in contract['whopays']:
                    if "Flat" not in contract['Market Data']['Pay Frequency']:
                        QuestionBox("By completing this contract, the payment for the final invoice will clear once both parties have accepted this request.", " OK ")
        if 'Market Data' in contract:
            if "Hire" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template']:
                if "I pay this" in contract['whopays']:
                    if 'autopay' in contract['Market Data'] and contract['Market Data']['autopay']==1:
                        contract['Market Data']['autopay']=0
        
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if clearsig==1:
                pegsigs['keep']=1
            pegsigs['1']={'sigs':sigs,'outs':outputs}
            if sigs1=='':
                pegsigs['2']=pegsigs['1']
            MyContracts[pos]['mycompletesig']=pegsigs
        else:
            MyContracts[pos]['mycompletesig']=sigs
        MyContracts[pos]['Process']="Sent completion request"
        BitAddr=GetfromCfg("#BitMessage#")
        Reply={}
        Reply['Process']='Received completion request'#Ok we will look for the message id
        Reply['Command']='Send'
        Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
        Reply['TheirBMAddress']=contract['TheirBMAddress']
        Reply['ordernumber']=contract['ordernumber']
        Reply['theircompletesig']=MyContracts[pos]['mycompletesig']
        self.ExportReply(Reply)
        if clearsig==1:
            MyContracts[pos].pop('theircompletesig')
        if 'theircompletesig' in contract:
            WinContracts.Requests.addItem("Broadcasting completion")
            MyContracts[pos]['Process']="Broadcasting completion"
            MyContracts[pos]['MyRequests'].append("Broadcasting completion")
        else:
            WinContracts.Requests.addItem("Sent completion request")
            MyContracts[pos]['MyRequests'].append("Sent completion request")
        self.hide()
    def CancelContract(self):
        global MyContracts
        mbox = QuestionBox("Do you wish to cancel the deal? This will refund the amount and deposits. Once a request is sent, it cannot be undone.", " Yes ", " No ")
        if mbox == 1:
            self.hide()
            return
        contract=ContractSelected
        inputs=[]
        outputs=[]
        inp={}
        theirs={}
        mine={}
        theirtotal=0
        mytotal=0
        theirtotal+=contract['theirdeposit']
        mytotal+=contract['mydeposit']
        if "I pay this" in contract['whopays']:
            mytotal+=contract['amount']
        else:
            theirtotal+=contract['amount']
        pos=-1
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==contract['ordernumber']:
                break
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        inp['output']=unicode(str(contract['tx3'])+":0")
        inp['value']=theirtotal+mytotal
        inp['address']=contract['escrow']
        inputs.append(inp)
        clearsig=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before trying to spend.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                return
            pegsigs={}
            supply2=ThePeg.CurrentSupply(ThePeg.Pegdatabase['blockcount'])
            supply=0
            ftot=0
            ltot1=0
            rtot1=0
            if 'theircancelsig' in contract:
                #Their signature probably was based on a different supply so as long as totals match it's okay to use their data
                supply=contract['theircancelsig']['supply']
                if supply2-8>supply:#things have drifted too far... lets delete their signature
                    QuestionBox('The counterparties request for cancellation has expired due to a change in the supply. Their signature will now be removed and they will have to send another one after they receive yours.', ' OK ')
                    clearsig=1
                    supply=supply2
                else:
                    ltot1=contract['theircancelsig']['ltot']
                    rtot1=contract['theircancelsig']['rtot']
            else:
                supply=supply2            
            #Get liquidity
            try:
                busy=NetSplash(1, checkwait=1)
                if TestnetPeg:
                    liquid, reserve=ThePeg.checktransaction(str(contract['tx3'])+":0")
                else:
                    fractions=BLK.getfractions(str(contract['tx3'])+":0")
                    liquid, reserve=ThePeg.formatfractions(fractions, inp['address'], inp['value'], supply=supply)
                combined=ThePeg.checkliquidity(liquid,reserve, supply=supply)
                liq=json_deep_copy(combined)
                supply2=liq['supply']
                if 'theircompletesig' not in contract:                    
                    supply=supply2
                NetSplash(0)
            except:
                NetSplash(0)
                traceback.print_exc()
                QuestionBox("Transaction lookup failed. Software is busy, please try again.", " OK ")
                return
            ltot=liq['ltotal']
            rtot=liq['rtotal']
            pegsigs['supply']=supply
            ftot=liq['future']
            if 'theircancelsig' in contract:
                ftot=contract['theircancelsig']['ftot']
            ltot-=ftot
            rtot+=ftot
            sigs1=''
            if ltot1!=ltot or rtot!=rtot1:
                if 'theircancelsig' in contract and clearsig!=1:
                    res=QuestionBox('The counterparties data does not match your records. Their signature will now be removed and they will have to send another one after they receive yours.', ' OK ', ' Cancel ')
                    if res==1:
                        return
                    clearsig=1
            if rtot>0:
                myratio=Decimal(mytotal)/(Decimal(mytotal)+Decimal(theirtotal))
                theirratio=Decimal(theirtotal)/(Decimal(mytotal)+Decimal(theirtotal))
                myrtot=int(Decimal(rtot)*myratio)
                theirrtot=int(Decimal(rtot)*theirratio)
                remainder=rtot-theirrtot-myrtot
                if mytotal>theirtotal:
                    myrtot+=remainder
                else:
                    theirrtot+=remainder
                myltot=mytotal-myrtot
                theirltot=theirtotal-theirrtot
                if mytotal>0:
                    if myrtot==0:
                        myrtot=5590
                if theirtotal>0:
                    if theirrtot==0:
                        theirrtot=5590
                if myltot<0:
                    myltot=0
                if theirltot<0:
                    theirltot=0
                outs=[]
                if ltot==0:
                    theirs={'value':int(theirtotal),'script':address_to_script(contract['theiraddress'])}#two fees deducted so one can be added
                    mine={'value':int(mytotal),'script':address_to_script(multisig)}
                    if theirtotal>0 and mytotal>0:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1:2'))/2)).encode('hex')+hexlify('**F**1:2')}]
                    else:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')}]
                    if "I pay this" in contract['whopays']:
                        if mytotal>0:
                            outs.append(mine)
                        if theirtotal>0:
                            outs.append(theirs)
                    else:
                        if theirtotal>0:
                            outs.append(theirs)
                        if mytotal>0:
                            outs.append(mine)
                else:                    
                    theirs={'value':int(theirltot),'script':address_to_script(contract['theiraddress'])}#two fees deducted so one can be added
                    mine={'value':int(myltot),'script':address_to_script(multisig)}
                    theirs2={'value':int(theirrtot),'script':address_to_script(contract['theiraddress'])}#two fees deducted so one can be added
                    mine2={'value':int(myrtot),'script':address_to_script(multisig)}
                    if theirtotal>0 and mytotal>0:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1:2'))/2)).encode('hex')+hexlify('**F**1:2')}]
                    else:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')}]
                    if "I pay this" in contract['whopays']:
                        if mytotal>0:
                            outs.append(mine2)
                        if theirtotal>0:
                            outs.append(theirs2)
                        if mytotal>0:
                            outs.append(mine)
                        if theirtotal>0:
                            outs.append(theirs)
                    else:
                        if theirtotal>0:
                            outs.append(theirs2)
                        if mytotal>0:
                            outs.append(mine2)
                        if theirtotal>0:
                            outs.append(theirs)
                        if mytotal>0:
                            outs.append(mine)
                if contract['firstsign']=="me":
                    sigs1,result=create_sig_for_tx(inputs, outputs, contract['myprivate'], contract['mypublic'],contract['theirpublic'], contract['timestamp']+30)
                else:
                    sigs1,result=create_sig_for_tx(inputs, outputs, contract['myprivate'], contract['theirpublic'],contract['mypublic'], contract['timestamp']+30)
                if result == False:
                    QuestionBox("Signature failure. Please check your signature and try again later.", "OK")
                    self.hide()
                    return
                pegsigs['2']={'sigs':sigs1,'outs':outs}
            pegsigs['ltot']=ltot
            pegsigs['rtot']=rtot
            pegsigs['ftot']=ftot
        theirs={'value':int(theirtotal),'address':str(contract['theiraddress'])}#two fees deducted so one can be added
        mine={'value':int(mytotal),'address':str(multisig)}#Now if they screw up the id, they will have to get our permission to sign again
        if "I pay this" in contract['whopays']:
            if mytotal>0:
                outputs.append(mine)
            if theirtotal>0:
                outputs.append(theirs)
        else:
            if theirtotal>0:
                outputs.append(theirs)
            if mytotal>0:
                outputs.append(mine)
        if contract['firstsign']=="me":
            sigs,result=create_sig_for_tx(inputs, outputs, contract['myprivate'], contract['mypublic'],contract['theirpublic'], contract['timestamp']+30)
        else:
            sigs,result=create_sig_for_tx(inputs, outputs, contract['myprivate'], contract['theirpublic'],contract['mypublic'], contract['timestamp']+30)
        if result == False:
            QuestionBox("Signature failure. Please check your signature and try again later.", "OK")
            self.hide()
            return
        if 'Market Data' in contract:
            if "Hire" in contract['Market Data']['Template'] or "Find" in contract['Market Data']['Template']:
                if "I pay this" in contract['whopays']:
                    if 'autopay' in contract['Market Data'] and contract['Market Data']['autopay']==1:
                        contract['Market Data']['autopay']=0

        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if clearsig==1:
                pegsigs['keep']=1
            pegsigs['1']={'sigs':sigs,'outs':outputs}
            if sigs1=='':
                pegsigs['2']=pegsigs['1']
            MyContracts[pos]['mycancelsig']=pegsigs
        else:
            MyContracts[pos]['mycancelsig']=sigs
        
        MyContracts[pos]['Process']="Sent cancellation request"
        BitAddr=GetfromCfg("#BitMessage#")
        Reply={}
        Reply['Process']='Received cancellation request'#Ok we will look for the message id
        Reply['Command']='Send'
        Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
        Reply['TheirBMAddress']=contract['TheirBMAddress']
        Reply['ordernumber']=contract['ordernumber']
        Reply['theircancelsig']=MyContracts[pos]['mycancelsig']
        self.ExportReply(Reply)
        if clearsig==1:
            MyContracts[pos].pop('theircancelsig')
        if 'theircancelsig' in MyContracts[pos]:
            WinContracts.Requests.addItem("Broadcasting cancellation")
            MyContracts[pos]['Process']="Broadcasting cancellation"
            MyContracts[pos]['MyRequests'].append("Broadcasting cancellation")
        else:
            WinContracts.Requests.addItem("Sent cancellation request")
            MyContracts[pos]['MyRequests'].append("Sent cancellation request")
        self.hide()
    def ChangeIndex(self):
        global AdvanceArray, ContractSelected, MyContracts
        contract=ContractSelected
        index = self.comboBox.currentIndex()
        combo = self.comboBox.itemData(index).toInt()[0]
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        Reply={}
        if combo==7:
            res=QuestionBox("How would you like to proceed?", " Estimate with Fedex shipping calculator ", " Send an exact quote ")
            if res==0:
                rate=shippingcalculator(ContractSelected['Market Data']['Profiles']['Mail'][0])
            if res==1:
                rate=shippingcalculator(ContractSelected['Market Data']['Profiles']['Mail'][0],1)
            if rate=="":
                return
            else:
                res=QuestionBox(Gtranslate("The amount decided for shipping is: \n\n") + str(rate), Gtranslate(" Request these funds from the buyer "), Gtranslate(" Cancel "), 1)
                rate=int(Decimal(rate)*Decimal(1e8))                
                if res==0:
                    self.RequestFunds(rate)
                    QuestionBox("The funds have been requested. Please watch your account for when it funds. Once it funds, you may use the escrow messaging system to send the tracking number.", " OK ")            
        if combo==997:
            text, ok = QtGui.QInputDialog.getText(self, CoinSelect['HaloName'], Gtranslate('Paste the message you want to import here:'))
            try:
                message={}
                message['body']=json_deep_copy(text,1)
                message['archive']=1
                message['fromAddress']=message['body']['MyBMAddress']
                message['toAddress']=message['body']['TheirBMAddress']
                message['body']=str(message['body'])
                if 'Archive' not in AdvanceArray:
                    AdvanceArray['Archive']={}
                if multisig not in AdvanceArray['Archive']:
                    AdvanceArray['Archive'][multisig]=[]                
                AdvanceArray['Archive'][multisig].append(message)
                QuestionBox("Success! If the message is valid it will be applied to your account shortly.", "OK")
            except:
                traceback.print_exc()
                QuestionBox("The message is not valid.", "OK")
        if combo==998:
            res=QuestionBox("This will enable manual export of messages. This is really useful in case you lose access to your Bitmessage or Email address. This way, you can send them the escrow messages manually. Would you like to enable this option?", "Enable","Disable")
            if res==0:
                ContractSelected['allowexport']=1
            else:
                ContractSelected['allowexport']=0
            self.hide()
            self.comboBox.setCurrentIndex(0)            
        if combo==999:
            res=QuestionBox("This will enable unfiltered chat and will also send a request to your partner to unlock chat. Would you like to unlock the chat?", "Yes","No")
            if res==0:
                ContractSelected['Market Data']['allowchat']=1
                ContractSelected['Process']='Sent chat request!'
                Reply['Process']='Chat requested!'
                Reply['Command']='Send'
                Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
                Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
                Reply['TheirBMAddress']=contract['TheirBMAddress']
                Reply['ordernumber']=contract['ordernumber']
                self.ExportReply(Reply)
                WinContracts.Requests.addItem("Chat requested!")
                ContractSelected['MyRequests'].append("Chat requested!")
            self.hide()
            self.comboBox.setCurrentIndex(0)
            return
        if combo==1000:
            self.EscrowPayment()
        if combo==1001:
            if 'autopay' in contract['Market Data'] and contract['Market Data']['autopay']==1:
                res=QuestionBox("Automated payments is currently enabled. Would you like to disable autopay?", " Yes ", " No ")
                ContractSelected['Market Data']['autopay']=0
            if 'autopay' in contract['Market Data'] and contract['Market Data']['autopay']==0:
                res=QuestionBox("Automated payments is currently disabled. Would you like to enable autopay?", " Yes ", " No ")
                ContractSelected['Market Data']['autopay']=1
        if combo==1002:
            self.submitreport(str(ConvertDate(ContractSelected['billing'], 1)))
        if combo==1003:
            self.submitmilestone()
    def SendMessage(self, mess=""):
        global Markets, ContractSelected, MyContracts
        #The escrow window will be changed. If using translations, remember not to use current text
        contract=ContractSelected
        Reply={}
        pos=-1
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==contract['ordernumber']:
                break
        index = self.comboBox.currentIndex()
        combo = self.comboBox.itemData(index).toInt()[0]
        if mess!="":
            combo=1
        if combo==0:
            QuestionBox("Please select an option from the dropdown menu","OK")
            return
        if combo==1:
            if mess=="":
                res=QuestionBox("Would you like to send this message?","Yes","No")
                if res==1:
                    return
                data = strOUT(strIN(self.textEdit.toPlainText()))
            else:
                data=mess
            MyContracts[pos]['Process']='Sent message'
            Reply['Process']='Received message'
            Reply['Message']=data
            Reply['Command']='Send'
            Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
            Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
            Reply['TheirBMAddress']=contract['TheirBMAddress']
            Reply['ordernumber']=contract['ordernumber']
            self.ExportReply(Reply)
            WinContracts.Requests.addItem("Sent message: " + data.replace("\n"," ").replace("<br />"," ").replace("\r"," "))
            MyContracts[pos]['MyRequests'].append("Sent message: " + data.replace("\n"," ").replace("<br />"," ").replace("\r"," "))
            if mess=="":
                self.textEdit.clear()
                self.hide()
        if combo==2:
            res=QuestionBox("Would you like to send this confirmation number?","Yes","No")
            if res==1:
                return
            data = str(self.textEdit.toPlainText())
            try:
                data2=int(data)+1
            except:
                QuestionBox("Must only contain numbers.", "OK")
                self.hide()
                return
            MyContracts[pos]['Process']='Sent confirmation number'
            Reply['Process']='Received confirmation number '
            Reply['Message']=data
            Reply['Command']='Send'
            Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
            Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
            Reply['TheirBMAddress']=contract['TheirBMAddress']
            Reply['ordernumber']=contract['ordernumber']
            self.ExportReply(Reply)
            WinContracts.Requests.addItem("Sent message: " + str(data))
            MyContracts[pos]['MyRequests'].append("Sent message: " + str(data))
            self.textEdit.clear()
            self.hide()
        if combo==3:
            res=QuestionBox("Would you like to request more time?","Yes","No")
            if res==1:
                return
            data = str(self.textEdit.toPlainText())
            try:
                data2=int(data)+1
            except:
                QuestionBox("Must only contain numbers.", "OK")
                self.hide()
                return
            MyContracts[pos]['Process']='Sent extension request'
            Reply['Process']='Received extension request'
            Reply['Message']=data
            Reply['Command']='Send'
            Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
            Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
            Reply['TheirBMAddress']=contract['TheirBMAddress']
            Reply['ordernumber']=contract['ordernumber']
            self.ExportReply(Reply)
            WinContracts.Requests.addItem("Requesting time extension: " + str(data) + " Days")
            MyContracts[pos]['MyRequests'].append("Requesting time extension: " + str(data) + " Days")
            self.textEdit.clear()
            self.hide()
        if combo==4:
            data = strOUT(strIN(self.textEdit.toPlainText()))
            myst=QtCore.QString(data)
            if len(myst)>40:
                QuestionBox("The review must be no more than 40 characters long.", "OK")
                return
            pubs=get_ordered_pubkeys(PrivKeyFilename1)
            if pubs[0] not in Markets['Reputation']:
                Markets['Reputation'][pubs[0]]={'Bitmessage':[],'Address':[],'D':[], 'Reputation': {'Reviews':[],'Review Points':0,'Flags':[0,time.time()],'Rating':0}}
            points=Markets['Reputation'][pubs[0]]['Reputation']['Review Points']
            if points<3:
                QuestionBox("You need at least 3 review points to leave reviews. You get one point per transaction. Leaving a review costs 3 points.","OK")
                return
            res=QuestionBox("Would you like to send this review once the order completes?","Yes","No")
            if res==1:
                return
            MyContracts[pos]['review']=data
            WinContracts.Requests.addItem("Saved Review: " + data.replace("\n"," ").replace("<br />"," ").replace("\r"," "))
            MyContracts[pos]['MyRequests'].append("Saved Review: " + data.replace("\n"," ").replace("<br />"," ").replace("\r"," "))
            self.textEdit.clear()
            self.hide()
        return
    def RequestClick(self, item):#Will be useful in the future
        global CoinMarketCap, ContractSelected, MyContracts
        contract=ContractSelected
        Reply={}
        pos=-1
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==contract['ordernumber']:
                break
        t=item.text()        
        if 'Message: ' in t:
            for m1 in ContractSelected['MyMessages']:
                if strOUT(strIN(m1['message'].replace("\n"," ").replace("<br />"," ").replace("\r"," ")))==strOUT(strIN(t.replace('Message: ',''))):
                    res=QuestionBox(Gtranslate("New Message!")+"\n\n"+m1['message'],Gtranslate("OK"),"","",1)
                    break
        if 'Sent message: ' in t:
            res=QuestionBox(Gtranslate("Sent Message!")+"\n\n"+t.replace('Sent message: ',''),Gtranslate("OK"),"","",1)
        if 'Report Submitted: ' in t:
            res=QuestionBox(Gtranslate("Report Submitted!")+"\n\n"+t.replace('Report Submitted: ',''),Gtranslate("OK"),"","",1)
        if 'Milestone Submitted: ' in t:
            res=QuestionBox(Gtranslate("Milestone Submitted!")+"\n\n"+t.replace('Milestone Submitted: ',''),Gtranslate("OK"),"","",1)
        if 'Received progress report: ' in t:
            res=QuestionBox(Gtranslate("Received progress report!")+"\n\n"+t.replace('Received progress report: ',''),Gtranslate("OK"),"","",1)
        if 'Time extended: ' in t:
            res=QuestionBox(t,Gtranslate("OK"),"","",1)
        if 'Requesting time extension: ' in t:
            res=QuestionBox(t,Gtranslate("OK"),"","",1)
        if 'Received request for funds(click to respond): ' in t:
            if "Something" in ContractSelected['Market Data']['Template']:
                try:
                    amt=str(t).replace("Received request for funds(click to respond): ","")
                    amt=str(Decimal(amt)/Decimal(1e8))
                    amt2=amt
                    usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)
                    if usd != "":
                        rateusd=str((Decimal(amt)*Decimal(usd)).quantize(Decimal('.01')))
                        amt+="\nAmount in USD:\n"+rateusd
                    res2=QuestionBox(Gtranslate("Your counter-party has requested funds for shipping based on the destination. Please review the amount and then decide if you want to accept or cancel and negotiate.")+"\n\nCoins Requested:\n"+amt,Gtranslate(" Accept request for funds "),Gtranslate(" Cancel "),"",1)
                    if res2==0:
                        if Decimal(amt2)>(Decimal(ContractSelected['theirdeposit'])/Decimal(1e8)):
                            res2=QuestionBox("Their deposit is less than the amount they are asking for. We strongly recommend caution when proceeding because there will no longer be a disincentive for them to break the contract.", " I understand ", " Cancel Payment ")
                        if res2==0:
                            window.Tabs.setCurrentIndex(1)
                            window.BitPayTo.setText(str(ContractSelected['theiraddress']))
                            window.BitAmount.setText(str(amt2))                            
                            QuestionBox("Please review the information to confirm their address is correct. You should also carefully review the amount. When ready, simply click 'Send'. Once sent you might wish to send them a message to confirm they got the payment.", "OK")
                except:
                    traceback.print_exc()
        if 'Requested funds: ' in t:
            amt=str(t).replace("Requested funds: ","")
            amt=str(Decimal(amt)/Decimal(1e8))
            usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)
            if usd != "":
                rateusd=str((Decimal(amt)*Decimal(usd)).quantize(Decimal('.01')))
                amt+="\nAmount in USD:\n"+rateusd
            QuestionBox(Gtranslate("Your request for funds:")+"\n\nCoins Requested:\n"+amt,Gtranslate(" OK "),1)
        if 'Chat requested!(click to respond)' in t:
            if contract['Market Data']['allowchat']==0:
                res=QuestionBox("This will allow unfiltered chat. Do you wish to unlock chat?","OK","Not now")
                if res==0:
                    ContractSelected['Market Data']['allowchat']=1
                    self.hide()
        if "Received time extension request(click to respond): " in t:
            i=-1
            for x in MyContracts[pos]['MyRequests']:
                i+=1
                if str(x)==str(t):
                    break
            mbox = QuestionBox("Time extension request:\n" + t.replace("Received time extension request(click to respond): ", "") + "\n\nDo you want to accept the time extension?", " Yes ", " No ")
            if mbox == 1:
                mbox = QuestionBox("Do you want to clear the request?", " Yes ", " No ")
                if mbox == 1:
                    return
                MyContracts[pos]['MyRequests'].pop(i)
                self.hide()
                return
            t.replace("Received time extension request(click to respond): ","")
            t.replace(" Days","")
            MyContracts[pos]['Process']='Time extended'
            Reply['Process']='Accept extension request'
            Reply['Message']=str(t)
            Reply['Command']='Send'
            Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
            Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
            Reply['TheirBMAddress']=contract['TheirBMAddress']
            Reply['ordernumber']=contract['ordernumber']
            self.ExportReply(Reply)
            MyContracts[pos]['time']=ConvertDate(ConvertDate(MyContracts[pos]['time'],1)+ datetime.timedelta(hours=(int(t)*24)),0)
            MyContracts[pos]['blocks']=MyContracts[pos]['blocks']+(int(t)*144)
            MyContracts[pos]['MyRequests'].pop(i)
            WinContracts.Requests.addItem("Time extended: " + str(t) + " Days")
            MyContracts[pos]['MyRequests'].append("Time extended: " + str(t) + " Days")
            SaveContracts()
            self.hide()
            return
    def ExportReply(self, Reply):
        BitQueue.append(Reply)
        SaveQueue()
        #Even though messaging could possibly be down, we don't want to make it easy for someone to leave parties hanging in escrow.
        if 'allowexport' in ContractSelected and ContractSelected['allowexport']==1:
            ewindow=QtGui.QDialog(window)
            ewindow.resize(500, 500)
            Display = QtGui.QTextBrowser(ewindow)
            Display.setReadOnly(True)
            Display.setGeometry(QtCore.QRect(10, 10, 480, 480))
            Display.setPlainText(str(Reply))
            ewindow.setWindowTitle("Exported Message")
            ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
            ewindow.show()          
    def EscrowPayment(self):
        global ContractSelected, MyContracts
        contract=ContractSelected
        curtime=datetime.datetime.utcfromtimestamp(timestamp)
        btc=""
        if 'billing' in contract:
            if ConvertDate(contract['billing'], 1)<curtime:
                hours_difference = ConvertDate(contract['billing'], 1) - curtime
                hours_difference = abs(hours_difference.total_seconds()/3600.0)
                if hours_difference>24 and contract['Market Data']['tracking']!=0:#payment is late
                    QuestionBox("You are late making your payment. The software will attempt to find the exchange rate for the date of payment.", " OK ")
                    try:
                        found=0
                        for rate in AdvanceArray['charts'][CoinSelect['name']]:
                            thetime=ConvertDate(contract['billing'], 1)
                            thetime2=thetime + datetime.timedelta(hours=24)
                            starttime=datetime.datetime.utcfromtimestamp(rate['starttime'])
                            endtime=datetime.datetime.utcfromtimestamp(rate['endtime'])
                            if starttime > thetime and starttime < thetime2:
                                found=1
                                break
                            if endtime > thetime and endtime < thetime2:
                                found=1
                                break
                        usd=rate['price']
                    except:
                        usd=""
                        traceback.print_exc()
                    if usd=="":
                        res=QuestionBox("The rate was not found. Would you like to enter the rate manually?", " Yes ", " No ")
                        if res==1:
                            return
                        text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the exchange rate for ') + CoinSelect['name'] + Gtranslate(' in dollars. You can find this rate online. Please be as precise as possible.'))
                        try:
                            a=float(Decimal(str(text)))
                        except:
                            QuestionBox("The rate you entered was invalid.", "OK")                       
                            return
                        usd=Decimal(str(text))
                else:
                    usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)
            else:
                QuestionBox("Payments must be made within 24 hours after the due date. Please try again later.", " OK ")
                return
        else:
            print "Invoice not found."
            return #It might be a milestone contract
        burnmessage=("*E*"+txhash(str(contract['billing'])+str(contract['ordernumber'])))[:20]
        apicontract={'ui':1, 'address':contract['theiraddress'], 'fee':0, 'broadcast':1, 'notify': [contract['theiraddress'],multisig], 'burn': burnmessage}
        proceed=0
        if contract['Market Data']['tracking']==0:
            apicontract['amount']=str(Decimal(contract['amount'])/Decimal(1e8))
            proceed=1
        else:
            if 'prevrate' not in contract:
                contract['prevrate']=contract['Market Data']['rate']            
            if usd=="":
                res=QuestionBox("This contract has price tracking and the exchange rate is not loaded yet. Would you like to enter the rate manually?", " Yes ", " No ")
                if res==1:
                    return
                text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the exchange rate for ') + CoinSelect['name'] + Gtranslate(' in dollars. You can find this rate online. Please be as precise as possible.'))
                try:
                    a=float(Decimal(str(text)))
                except:
                    QuestionBox("The rate you entered was invalid.", "OK")                       
                    return
                usd=Decimal(str(text))
            else:
                if btc!="":
                    QuestionBox(Gtranslate("Please confirm the exchange rate online:")+"\n"+"USD:"+usd+"->"+CoinSelect['name']+"\nBTC:"+btc+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this. Otherwise, you may simply send the coins without denominating in dollars. If you are price tracking and do not agree with the rate posted, you might want to try again later."), Gtranslate("OK"),1)
                else:
                    QuestionBox(Gtranslate("Please confirm the exchange rate online:")+"\n"+"USD:"+usd+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this. Otherwise, you may simply send the coins without denominating in dollars. If you are price tracking and do not agree with the rate posted, you might want to try again later."), Gtranslate("OK"),1)
            if usd!="":                
                apicontract['amount']=str(Decimal(int((Decimal(contract['amount']))*(Decimal(contract['Market Data']['rate'])/Decimal(usd)))/Decimal(1e8)))
                contract['prevrate']=usd                                                    
                proceed=1
        if proceed==1:
            if 'payments' not in contract:
                contract['payments']={}                                            
            #We should only allow ONE calculation, otherwise payment failed and disable
            res=""
            if str(contract['billing']) not in contract['payments']:
                try:
                    print str(apicontract)
                    rawtx, res = window.SendNormal(apicontract)
                    print res
                except:
                    traceback.print_exc()
                    rawtx=False
                if "Success" in res:
                    contract['payments'][str(contract['billing'])]=rawtx
                    mytime=ConvertDate(contract['billing'], 1)
                    if "Week" in contract['Market Data']['Pay Frequency']:
                        NewTime=mytime+ datetime.timedelta(hours=168)
                        contract['billing']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                    if "Month" in contract['Market Data']['Pay Frequency']:
                        NewTime=addmonths(1,mytime)
                        contract['billing']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                    mytime=ConvertDate(contract['time'],1)
                    WinContracts.hide()
                    if "Week" in contract['Market Data']['Pay Frequency']:
                        NewTime=mytime+ datetime.timedelta(hours=168)
                        contract['time']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                        contract['blocks']=contract['blocks']+(int(7)*144)
                        WinContracts.Requests.addItem("Time extended: " + str(7) + " Days")
                        contract['MyRequests'].append("Time extended: " + str(7) + " Days")                                                        
                    if "Month" in contract['Market Data']['Pay Frequency']:
                        NewTime=addmonths(1,mytime)
                        contract['time']=ConvertDate(NewTime, 0)#0 is to tuple and 1 is back
                        contract['blocks']=contract['blocks']+(int(31)*144)
                        WinContracts.Requests.addItem("Time extended: " + str(1) + " Month")
                        contract['MyRequests'].append("Time extended: " + str(1) + " Month")
                    WinContracts.Requests.addItem("Escrow Payment: " + txhash(rawtx))
                    contract['MyRequests'].append("Escrow Payment: " + txhash(rawtx))
                    if 'Milestone' in contract['Market Data']['Pay Frequency']:
                        contract.pop('billing')
                        text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('It is recommended that after every completed\nmilestone you request a time extension.\nPlease enter the number of days to extend escrow.'))
                        data = str(text)
                        try:
                            data2=int(data)+1
                        except:
                            QuestionBox("Must only contain numbers. You can try sending the extension again in the escrow panel.", "OK")
                            return
                        QuestionBox(Gtranslate("Sent extension request for ") + str(data) + Gtranslate(" days."), " OK ", 1)
                        contract['Process']='Sent extension request'
                        Reply={}
                        Reply['Process']='Received extension request'
                        Reply['Message']=data
                        Reply['Command']='Send'
                        Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
                        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
                        Reply['TheirBMAddress']=contract['TheirBMAddress']
                        Reply['ordernumber']=contract['ordernumber']
                        self.ExportReply(Reply)
                        WinContracts.Requests.addItem("Requesting time extension: " + str(data) + " Days")
                        contract['MyRequests'].append("Requesting time extension: " + str(data) + " Days")
                    else:
                        QuestionBox("The escrow has been extended by one billing cycle.", " OK ")
            else:
                QuestionBox("This invoice appears to have already been paid.", " OK ")
    def RequestFunds(self,amount):
        global MyContracts, ContractSelected
        contract=ContractSelected
        Reply={}
        pos=-1
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==contract['ordernumber']:
                break        
        Reply={}
        try:
            data2=int(amount)+1
        except:
            QuestionBox("Must be an integer.", "OK")
            return
        MyContracts[pos]['Process']='Requested funds'
        Reply['Process']='Received request for funds'
        Reply['Message']=amount
        Reply['Command']='Send'
        Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
        Reply['TheirBMAddress']=contract['TheirBMAddress']
        Reply['ordernumber']=contract['ordernumber']
        self.ExportReply(Reply)
        WinContracts.Requests.addItem("Requested funds: " + str(amount))
        MyContracts[pos]['MyRequests'].append("Requested funds: " + str(amount))
    def submitreport(self, date):
        global MyContracts, ContractSelected
        contract=ContractSelected
        Reply={}
        pos=-1
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==contract['ordernumber']:
                break
        if 'MyReports' in MyContracts[pos]:
             if str(date) in MyContracts[pos]['MyReports']:
                QuestionBox("Report has already been sent!", "OK")
                return
        text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the link to your report or a brief summary of the work completed:'))
        try:
            text=strOUT(strIN(text))
            if text=="":
                QuestionBox("Nothing was entered, no report sent!", "OK")
                return
        except:
            QuestionBox("The information you entered is not valid.", "OK")
            return
        MyContracts[pos]['Process']='Report submitted'
        Reply['Process']='Received progress report'
        Reply['Message']=text
        Reply['Command']='Send'
        Reply['date']=date
        Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
        Reply['TheirBMAddress']=contract['TheirBMAddress']
        Reply['ordernumber']=contract['ordernumber']
        self.ExportReply(Reply)
        WinContracts.Requests.addItem("Report Submitted: " + text)
        MyContracts[pos]['MyRequests'].append("Report Submitted: " + text)
        if 'MyReports' not in MyContracts[pos]:
            MyContracts[pos]['MyReports']={}
        MyContracts[pos]['MyReports'][str(date)]=""
    def submitmilestone(self):
        global MyContracts, ContractSelected
        contract=ContractSelected
        Reply={}
        pos=-1
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==contract['ordernumber']:
                break        
        Reply={}
        if 'billing' not in ContractSelected:
            ContractSelected['billing']=ConvertDate(datetime.datetime.utcfromtimestamp(timestamp), 0)#0 is to tuple and 1 is back
        else:
            QuestionBox('You have already submitted your invoice. Please wait for this milestone to get paid so a new milestone can begin.', ' OK ')
            return
        text=""
        if 'requirereport' in contract['Market Data'] and contract['Market Data']['requirereport']==1:
            text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the link to your report or a brief summary of the work completed:'))
            try:
                text=strOUT(strIN(text))
                if text=="":
                    QuestionBox("Nothing was entered, no report sent!", "OK")
                    return
            except:
                QuestionBox("The information you entered is not valid.", "OK")
                return
        MyContracts[pos]['Process']='Milestone submitted'
        Reply['Process']='Received milestone invoice'
        Reply['Message']=text
        Reply['Command']='Send'
        Reply['date']=ContractSelected['billing']
        Reply['MessageID']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
        Reply['MyBMAddress']=contract['MyBMAddress']#We always do this it can change from time to time
        Reply['TheirBMAddress']=contract['TheirBMAddress']
        Reply['ordernumber']=contract['ordernumber']
        self.ExportReply(Reply)
        WinContracts.Requests.addItem("Milestone Submitted: " + text)
        MyContracts[pos]['MyRequests'].append("Milestone Submitted: " + text)
        if 'MyReports' not in MyContracts[pos]:
            MyContracts[pos]['MyReports']={}
        MyContracts[pos]['MyReports'][str(ContractSelected['billing'])]=""
class WContacts(QtGui.QWidget):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(391, 140)        
        self.pushButton = QtGui.QPushButton(Dialog)
        self.pushButton.setGeometry(QtCore.QRect(10, 110, 88, 23))
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.pushButton_2 = QtGui.QPushButton(Dialog)
        self.pushButton_2.setGeometry(QtCore.QRect(99, 110, 92, 23))
        self.pushButton_2.setObjectName(_fromUtf8("pushButton_2"))
        self.pushButton_3 = QtGui.QPushButton(Dialog)
        self.pushButton_3.setGeometry(QtCore.QRect(196, 110, 88, 23))
        self.pushButton_3.setObjectName(_fromUtf8("pushButton_3"))
        self.pushButton_4 = QtGui.QPushButton(Dialog)
        self.pushButton_4.setGeometry(QtCore.QRect(289, 110, 88, 23))
        self.pushButton_4.setObjectName(_fromUtf8("pushButton_3"))
        self.textBrowser = QtGui.QTextBrowser(Dialog)
        self.textBrowser.setGeometry(QtCore.QRect(10, 10, 371, 91))
        self.textBrowser.setObjectName(_fromUtf8("textBrowser"))
        ApplyCSS(self)

        #Signals
        self.pushButton.clicked.connect(self.CopyBitcoin)
        self.pushButton_2.clicked.connect(self.CopyBitmessage)
        self.pushButton_3.clicked.connect(self.CopyEmail)
        self.pushButton_4.clicked.connect(self.Delete)
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
    def retranslateUi(self, Dialog):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
        self.pushButton.setText(_translate("Dialog", "Copy Address", None))
        self.pushButton_2.setText(_translate("Dialog", "Copy Bitmessage", None))
        self.pushButton_3.setText(_translate("Dialog", "Copy Email", None))
        self.pushButton_4.setText(_translate("Dialog", "Delete Contact", None))
        self.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">" + _translate("","This is a basic contact database. You can choose to copy the "+CoinSelect['name']+", Bitmessage or Email address. You may also delete the contact.")+"</span></p></body></html>")
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)

    def CopyBitmessage(self):
        global ContactSelected
        clipboard = app.clipboard()
        clipboard.setText(str(ContactSelected['Bitmessage Address']))
        self.hide()

    def CopyEmail(self):
        global ContactSelected
        clipboard = app.clipboard()
        clipboard.setText(str(ContactSelected['Email Address']))
        self.hide()

    def CopyBitcoin(self):
        global ContactSelected
        clipboard = app.clipboard()
        clipboard.setText(str(ContactSelected['Blackcoin Address']))
        self.hide()

    def Delete(self):
        #Ok they want to clear it... lets find the order in spendable and remove it
        global ContactSelected, OnOrders
        y=-1
        for order in OnOrders:
            y+=1
            if order['type']=="History":
                if 'Contacts' in order:
                    o=-1
                    for Contact in order['Contacts']:
                        o+=1
                        if Contact==ContactSelected:
                            OnOrders[y]['Contacts'].pop(o)
        PopulateContacts()
        self.hide()
#Received offer window
class WReceived(QtGui.QWidget):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(460, 330)        
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Dialog.sizePolicy().hasHeightForWidth())
        Dialog.setSizePolicy(sizePolicy)
        Dialog.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.verticalLayout_2 = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.verticalLayout = QtGui.QVBoxLayout()
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.textBrowser = QtGui.QTextBrowser(Dialog)
        self.textBrowser.setObjectName(_fromUtf8("textBrowser"))
        self.verticalLayout.addWidget(self.textBrowser)
        spacerItem = QtGui.QSpacerItem(20, 10, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.verticalLayout.addItem(spacerItem)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.pushButton_3 = QtGui.QPushButton(Dialog)
        self.pushButton_3.setObjectName(_fromUtf8("pushButton_3"))
        self.horizontalLayout.addWidget(self.pushButton_3)
        spacerItem2 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem2)
        self.pushButton_2 = QtGui.QPushButton(Dialog)
        self.pushButton_2.setObjectName(_fromUtf8("pushButton_2"))
        self.horizontalLayout.addWidget(self.pushButton_2)
        spacerItem3 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem3)
        self.pushButton = QtGui.QPushButton(Dialog)
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.horizontalLayout.addWidget(self.pushButton)
        spacerItem4 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem4)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        ApplyCSS(self)

        #Signals
        self.pushButton_3.clicked.connect(self.Accept)
        self.pushButton_2.clicked.connect(self.Counter)
        self.pushButton.clicked.connect(self.Delete)
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        self.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"></p></body></html>")
        self.pushButton_3.setText(_translate("Dialog", " Accept Offer ", None))
        self.pushButton_2.setText(_translate("Dialog", " Counter-Offer ", None))
        self.pushButton.setText(_translate("Dialog", " Delete Request ", None))
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)

    def Accept(self):
        window.ClearPage()
        window.Tabs.setCurrentIndex(5)
        window.ContractTo.setText("Accept: "+PendingSelected['ordernumber'])
        clipboard = app.clipboard()
        clipboard.setText(str(PendingSelected['TheirBMAddress']))
        self.hide()
        window.SendMyContract()

    def Counter(self):
        global GlobalImage, GlobalID
        window.Tabs.setCurrentIndex(5)
        window.ContractTo.setText("Counter: "+PendingSelected['ordernumber'])
        window.ContractAmount.setText(str(Decimal(PendingSelected['amount'])/Decimal(1e8)))
        window.InstantAmount.setText(str(Decimal(PendingSelected['instantamount'])/Decimal(1e8)))
        window.YouDeposit.setText(str(Decimal(PendingSelected['mydeposit'])/Decimal(1e8)))
        window.TheyDeposit.setText(str(Decimal(PendingSelected['theirdeposit'])/Decimal(1e8)))
        window.ContractTime.setText(str(PendingSelected['timeout']))
        window.ContractFee.setText(str(Decimal(PendingSelected['fee'])/Decimal(1e8)))
        window.DescriptionBox.setText(PendingSelected['Details']['description'])
        if PendingSelected['Details']['image']!="":
            window.ImageBox.setText(str("Image Attached"))
        GlobalImage=PendingSelected['Details']['image']
        GlobalID=PendingSelected['Details']['pastebin']
        if "I pay this" in PendingSelected['whopays']:
            window.WhoPays.setCurrentIndex(0)
        else:
            window.WhoPays.setCurrentIndex(1)
        if "I am" in PendingSelected['instantwhopays']:
            window.InstantWhoPays.setCurrentIndex(0)
        else:
            window.InstantWhoPays.setCurrentIndex(1)
        window.DaysMultiplier.setCurrentIndex(1)
        #change to hours
        self.hide()

    def Delete(self):
        #Ok they want to clear it... lets find the order in spendable and remove it
        global updatesomething, PendingSelected, OnOrders
        if PendingSelected == {}:
            self.hide()
            return
        DeleteOrder(PendingSelected['ordernumber'])
        DeleteContract(PendingSelected)
        updatesomething=1
        PendingSelected={}
        self.hide()
#Sent offer window
class WSend(QtGui.QWidget):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(460, 330)        
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Dialog.sizePolicy().hasHeightForWidth())
        Dialog.setSizePolicy(sizePolicy)
        Dialog.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.verticalLayout_2 = QtGui.QVBoxLayout(Dialog)
        self.verticalLayout_2.setObjectName(_fromUtf8("verticalLayout_2"))
        self.verticalLayout = QtGui.QVBoxLayout()
        self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
        self.textBrowser = QtGui.QTextBrowser(Dialog)
        self.textBrowser.setObjectName(_fromUtf8("textBrowser"))
        self.verticalLayout.addWidget(self.textBrowser)
        spacerItem = QtGui.QSpacerItem(20, 10, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Fixed)
        self.verticalLayout.addItem(spacerItem)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.horizontalLayout = QtGui.QHBoxLayout()
        self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
        spacerItem1 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.pushButton_3 = QtGui.QPushButton(Dialog)
        self.pushButton_3.setObjectName(_fromUtf8("pushButton_3"))
        self.horizontalLayout.addWidget(self.pushButton_3)
        spacerItem2 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem2)
        self.pushButton_2 = QtGui.QPushButton(Dialog)
        self.pushButton_2.setObjectName(_fromUtf8("pushButton_2"))
        self.horizontalLayout.addWidget(self.pushButton_2)
        spacerItem3 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem3)
        self.pushButton = QtGui.QPushButton(Dialog)
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.horizontalLayout.addWidget(self.pushButton)
        spacerItem4 = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem4)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        ApplyCSS(self)

        #Signals
        self.pushButton.clicked.connect(self.SendAgain)
        self.pushButton_2.clicked.connect(self.CopyAddy)
        self.pushButton_3.clicked.connect(self.Cancel)
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
    def retranslateUi(self, Dialog):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
        self.pushButton.setText(_translate("Dialog", "Send request again", None))
        self.pushButton_2.setText(_translate("Dialog", "Copy Contact Address", None))
        self.pushButton_3.setText(_translate("Dialog", "Cancel request", None))
        self.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">" + _translate("","You have sent an offer! Give the counter-party time to review the offer. If they accept, your computer will attempt to automatically finalize all of the steps necessary for escrow. The moment they accept, the timer starts so check periodically to see how your offers are doing. You can always try sending it again as well. Canceling will free up the inputs set aside for the deal. If you cancel the offer, that action can not be reversed.")+"</span></p></body></html>")
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)

    def SendAgain(self):
        global PendingSelected, interneton, MyContracts
        res=QuestionBox("Are you sure you want to resubmit the order?", "Yes", "No")
        if res!=1:
            try:
                if interneton==1:
                    if PendingSelected['Process']=="Market Order":
                        if PendingSelected['Details']['image']!="":
                            ID=fpaste(PendingSelected['Details']['image'])
                            if ID == False:
                                float("A")
                            pos=0
                            for c in MyContracts:
                                if MyContracts[pos]['ordernumber']==PendingSelected['ordernumber']:
                                    MyContracts[pos]['Details']['pastebin']=ID
                                pos+=1                            
            except:
                pass
            Resubmit(PendingSelected)
        self.hide()
    def CopyAddy(self):
        clipboard = app.clipboard()
        clipboard.setText(str(PendingSelected['TheirBMAddress']))
        self.hide()

    def Cancel(self):
        #Ok they want to clear it... lets find the order in spendable and remove it
        global updatesomething, PendingSelected, OnOrders
        BitAddr=GetfromCfg("#BitMessage#")
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        if PendingSelected == {}:
            self.hide()
            return
        DeleteOrder(PendingSelected['ordernumber'])
        leng=len(MyContracts)
        i=0
        while i<leng:
            next1=1
            if MyContracts[i]['Process']=="Market Order":
                if MyContracts[i]['ordernumber']==PendingSelected['ordernumber']:
                    DeleteOrder(MyContracts[i]['ordernumber'])
                    RemoveFromMarket(MyContracts[i])
                    next1=0
            if MyContracts[i]['Process']=="Market Offer" or "MCount" in MyContracts[i]['Process']:
                if MyContracts[i]['oldordernumber']==PendingSelected['ordernumber']:
                    DeleteOrder(MyContracts[i]['ordernumber'])
                    next1=0
            if next1==0:
                leng-=1
                DeleteContract(i)
            else:
                i+=1
        DeleteContract(PendingSelected)
        updatesomething=1
        PendingSelected={}
        self.hide()
#Our handshake options window...
class Handshake(QtGui.QWidget):
    def setupUi(self, Dialog):
        Dialog.setObjectName(_fromUtf8("Dialog"))
        Dialog.resize(391, 140)        
        self.pushButton = QtGui.QPushButton(Dialog)
        self.pushButton.setGeometry(QtCore.QRect(10, 110, 111, 23))
        self.pushButton.setObjectName(_fromUtf8("pushButton"))
        self.pushButton_2 = QtGui.QPushButton(Dialog)
        self.pushButton_2.setGeometry(QtCore.QRect(130, 110, 141, 21))
        self.pushButton_2.setObjectName(_fromUtf8("pushButton_2"))
        self.pushButton_3 = QtGui.QPushButton(Dialog)
        self.pushButton_3.setGeometry(QtCore.QRect(280, 110, 101, 23))
        self.pushButton_3.setObjectName(_fromUtf8("pushButton_3"))
        self.textBrowser = QtGui.QTextBrowser(Dialog)
        self.textBrowser.setGeometry(QtCore.QRect(10, 10, 371, 91))
        self.textBrowser.setObjectName(_fromUtf8("textBrowser"))
        ApplyCSS(self)

        #Signals
        self.pushButton.clicked.connect(self.SendAgain)
        self.pushButton_2.clicked.connect(self.CopyAddy)
        self.pushButton_3.clicked.connect(self.Cancel)
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
    def retranslateUi(self, Dialog):
        self.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        self.setWindowTitle(CoinSelect['HaloName'])
        self.pushButton.setText(_translate("Dialog", "Send request again", None))
        self.pushButton_2.setText(_translate("Dialog", "Copy Contact Address", None))
        self.pushButton_3.setText(_translate("Dialog", "Cancel request", None))
        self.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
    "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
    "p, li { white-space: pre-wrap; }\n"
    "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
    "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">" + _translate("","Somebody is trying to contact you using "+CoinSelect['name']+"! Your client is asking for the contract details. If you do not get a response you can always try to send the handshake request again. Be patient, it may take them a moment to get the message. If you wish to cancel it, you will not be able to undo the action.")+"</span></p></body></html>")
    def __init__(self):
        QtGui.QWidget.__init__(self)
        self.setupUi(self)

    def SendAgain(self):
        global BitQueue, updatesomething, PendingSelected
        Reply=dict(PendingSelected)
        BitQueue.append(Reply)
        SaveQueue()
        updatesomething=1
        self.hide()

    def CopyAddy(self):
        clipboard = app.clipboard()
        clipboard.setText(str(PendingSelected['TheirBMAddress']))
        self.hide()

    def Cancel(self):
        #Ok they want to clear it... lets find the order in spendable and remove it
        global updatesomething, PendingSelected, OnOrders
        if PendingSelected == {}:
            self.hide()
            return
        DeleteOrder(PendingSelected['ordernumber'])
        DeleteContract(PendingSelected)
        updatesomething=1
        PendingSelected={}
        self.hide()

#initialization
class MyApp(QtGui.QMainWindow, SKIN):#Ui_MainWindow is the one in this file. Its possible to change interfaces later
    def __init__(self):
        global OnOrders, MyContracts, Markets, translations
        global CoinSelect, YandexAPI        
        QtGui.QMainWindow.__init__(self)
        Ui_MainWindow.__init__(self)
        self.ApplicationPath = application_path.replace("\\","/")
        self.language=mylang
        self.translations=translations
        if YandexAPI != "":
            self.yandexAPI = YandexAPI
        else:
            self.yandexAPI = ""
        if CoinSelect['moderngui']==1:
            self.setBitBayStyle()
        self.setupUi(self)
        translations=self.translations
        self.Tabs.setCurrentIndex(0)
        self.notifytext=""
        self.checkonce=0
        #GCQT = GarbageCollector(self)
        self.OfferTable.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)

        if CoinSelect['moderngui']==1:
            self.actionDynamic_Peg_Info.triggered.connect(self.DynamicPegInfo)
        self.actionBuy_me_a_beer.triggered.connect(self.Donate)
        self.actionOpen_Wallet.triggered.connect(self.OpenWallet)
        self.OpenAccount.clicked.connect(self.OpenWallet)
        self.JointAccount.clicked.connect(self.NewWallet)
        self.actionNew_Wallet.triggered.connect(self.NewWallet)
        self.actionSave_Copy.triggered.connect(self.BackUpWallet)
        self.actionEncrypt_Keyfile.triggered.connect(self.EncryptKeyfile)
        self.actionKey_To_Image.triggered.connect(self.KeyToImage)
        self.actionUnlock_Wallet.triggered.connect(self.UnlockWallet)
        self.actionOfficial_Website.triggered.connect(self.Website)
        self.actionEncrypt_Decrypt.triggered.connect(self.Encrypt_Decrypt)
        self.actionSign_Verify.triggered.connect(self.Sign_Verify)
        self.actionExit.triggered.connect(self.ExitHalo)
        self.actionAbout.triggered.connect(self.AboutUs)
        self.actionDocumentation_2.triggered.connect(self.Documentation)
        self.actionLanguage.triggered.connect(self.ChangeMyLanguage)
        self.actionGeneral_Settings.triggered.connect(self.Settings)
        self.actionAdvanced_Sending.triggered.connect(self.AdvanceMe)
        self.actionTranslation_Editor.triggered.connect(TranslationEditor)
        self.actionAPI.triggered.connect(self.ActivateAPI)
        self.DConsole.triggered.connect(self.DebugConsole)
        backup=GetfromCfg("#BackupPath#")
        if backup != " ":
            self.TxBackupPath.setText(strOUT(backup))
        global BitQueue, DontRepopulate, PrivKeyFilename1, PrivKeyFiledir1, EscrowResults, WatchlistQueue, HistoryDetail, AdvanceArray
        BitQueue=OpenQueue()
        DontRepopulate=OpenOtherdata()
        EscrowResults=OpenOtherdata(1)
        WatchlistQueue=OpenOtherdata(2)
        HistoryDetail=OpenOtherdata(3)
        AdvanceArray=OpenOtherdata(4)
        Markets=OpenOtherdata(5)
        if 'BackupOther' not in AdvanceArray:
            shutil.copyfile(os.path.join(application_path,"Other.dat"), os.path.join(application_path,"OtherBackup.dat"))
            AdvanceArray['BackupOther']=time.time()
        if time.time()-AdvanceArray['BackupOther']>86400:
            shutil.copyfile(os.path.join(application_path,"Other.dat"), os.path.join(application_path,"OtherBackup.dat"))
            AdvanceArray['BackupOther']=time.time()
        if 'OUTBOX' not in AdvanceArray:
            AdvanceArray['OUTBOX']={}            
        if 'StakingAccounts' in AdvanceArray:
            try:
                for acct in AdvanceArray['StakingAccounts']:
                    if checkformultisig(AdvanceArray['StakingAccounts'][acct]['dir1'], AdvanceArray['StakingAccounts'][acct]['key1']) == False:
                        AdvanceArray['StakingAccounts'].pop(acct, None)
                    else:
                        if AdvanceArray['StakingAccounts'][acct]['key2'] != '':
                            if checkformultisig(AdvanceArray['StakingAccounts'][acct]['dir2'], AdvanceArray['StakingAccounts'][acct]['key2']) == False:
                                AdvanceArray['StakingAccounts'].pop(acct, None)
                            
            except:
                traceback.print_exc()
        PrivKeyFiledir1=strOUT(GetfromCfg("#PrivKeyFiledir1#"))
        PrivKeyFilename1=strOUT(GetfromCfg("#PrivKeyFilename1#"))         

        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        BitAddr=GetfromCfg("#BitMessage#")
        try:
            GetEmailGlobals()
        except:
            pass
        Select=GetfromCfg("#CoinSelect#")
        if Select=="BTC":
            CoinSelect=copy.deepcopy(Coins[2])
        if Select=="BLK":
            CoinSelect=copy.deepcopy(Coins[0])
        if Select=="BAY":
            CoinSelect=copy.deepcopy(Coins[1])
        DataDirectory()
        global accounttype
        accounttype=GetfromCfg("#accounttype#")
        #System tray
        self.icon=QtGui.QSystemTrayIcon()
        r=self.icon.isSystemTrayAvailable()
        self.icon.setIcon( QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png') )
        self.icon.activated.connect(self.activate)
        #Tabs and buttons
        self.VideoLibrary.clicked.connect(self.WatchIntro)
        if CoinSelect['moderngui']==1:
            self.tab.supportButton.clicked.connect(self.SupportClicked)
            self.cardsViewTable.cellPressed.connect(self.MarketsClick2)
        self.ExplainSpend.clicked.connect(lambda: self.Explain(1))
        self.ExplainReceive.clicked.connect(lambda: self.Explain(2))
        self.ExplainHistory.clicked.connect(lambda: self.Explain(3))
        self.ExplainContracts.clicked.connect(lambda: self.Explain(4))
        self.ExplainAutoBackupOffer.clicked.connect(lambda: self.Explain(5))
        self.instantexplain.clicked.connect(lambda: self.Explain(6))
        self.ExplainPending.clicked.connect(lambda: self.Explain(7))
        self.ExplainOpen.clicked.connect(lambda: self.Explain(8))
        self.ExplainMarket.clicked.connect(lambda: self.Explain(9))
        self.Rescan.clicked.connect(self.scanchain)
        if CoinSelect['moderngui']==0:
            self.Rescan2.clicked.connect(self.scanchain)
        self.EnableBitmessage.clicked.connect(self.checkbox)
        self.EnableEmail.clicked.connect(self.checkbox)
        self.Refresh.clicked.connect(self.RefreshDownload)
        self.SendContract.clicked.connect(lambda: self.SendMyContract())
        self.SendMyBitcoins.clicked.connect(lambda: self.SendNormal())
        self.CreateSignatureOne.clicked.connect(self.TwoStepSendpt1)
        self.OpenBitSignatureAndSend.clicked.connect(lambda: self.TwoStepSendpt2())
        self.CopyAddressToClipboard.clicked.connect(self.CopyAddress)
        self.CopyAddressToClipboard_3.clicked.connect(self.CopyAddress)
        self.CopyAddressToClipboard_5.clicked.connect(self.CopyAddress)
        self.CopyAddressToClipboard_2.clicked.connect(self.CopyBMAddress)
        self.BackupContacts.clicked.connect(self.BackContacts)
        self.NewContact.clicked.connect(self.AddContact)
        if CoinSelect['moderngui']==0:
            self.switchcoin.clicked.connect(self.SwitchMe)
        self.BrowseTxBackup.clicked.connect(self.BrowseBackup)
        self.AddEmail.clicked.connect(self.NewEmail)
        self.AddEmail_2.clicked.connect(self.CopyEmail)
        self.AttachImage.clicked.connect(lambda: self.AddImage())
        QtCore.QObject.connect(self.HistorylistWidget, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.HistoryClick)
        QtCore.QObject.connect(self.MyPendingOffers, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.PendingClick)
        QtCore.QObject.connect(self.ContactTable, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.ContactsClick)
        QtCore.QObject.connect(self.MyOpenContracts, QtCore.SIGNAL("itemClicked(QListWidgetItem *)"), self.MyContractsClick)
        self.FullHistory.cellChanged.connect(self.MyCellChanged)
        self.FullHistory.cellClicked.connect(self.FullHistoryClick)
        if CoinSelect['moderngui']==0:
            self.textBrowser.anchorClicked.connect(self.Navigate)
            self.textBrowser.setOpenLinks(False)
            self.commandLinkButton.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_3.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_4.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_5.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_6.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_7.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_8.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_9.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_10.clicked.connect(self.ConnectNotify)
            self.commandLinkButton_11.clicked.connect(self.ConnectNotify)
        else:
            self.commandLinkButton.clicked.connect(self.ConnectNotify)

        self.checkBox.clicked.connect(lambda: self.ToggleCheckboxes(1))
        self.FilterCustom.clicked.connect(lambda: self.ToggleCheckboxes(2))
        self.DisableSpamFilter.clicked.connect(lambda: self.ToggleCheckboxes(3))

        self.ExportToCSV.clicked.connect(self.MakeCSV)
        self.ClearHistory.clicked.connect(self.ClearHistoryDetail)
        self.AdvancedSend.clicked.connect(self.AdvanceMe)
        self.MarketBox.connect(self.MarketBox,QtCore.SIGNAL("currentIndexChanged(int)"),self.MarketChange)
        self.JoinChan.clicked.connect(self.NewMarket)
        self.LeaveChan.clicked.connect(self.LeaveMarket)
        self.PostToMarket.clicked.connect(lambda: self.PostOffer())
        self.SettingsMarket.clicked.connect(self.Settings)
        self.Conversion.clicked.connect(self.ConvertMe)
        self.Search.clicked.connect(self.SearchMe)
        self.ShowWhat.connect(self.ShowWhat,QtCore.SIGNAL("currentIndexChanged(int)"),self.SearchMe)
        self.Custom.clicked.connect(lambda: self.PostOffer("  Custom Offer"))
        self.BuyCoins.clicked.connect(lambda: self.PostOffer("Cash"))
        self.BuyAnything.clicked.connect(lambda: self.PostOffer("Market"))
        self.HireSomeone.clicked.connect(lambda: self.PostOffer("  Employ Someone"))
        self.FindJob.clicked.connect(lambda: self.PostOffer("  Find A Job"))
        self.Barter.clicked.connect(lambda: self.PostOffer("  Barter Items/Services"))
        self.OfferTable.connect(self.OfferTable, QtCore.SIGNAL('customContextMenuRequested(const QPoint&)'), self.openMenu)
        self.OutboxButton.clicked.connect(self.ShowOutbox)
        self.OfferTable.cellPressed.connect(self.MarketsClick)
        self.OfferBox.connect(self.OfferBox,QtCore.SIGNAL("currentIndexChanged(int)"),self.OfferBoxChange)
        self.BitAmount.connect(self.BitAmount, QtCore.SIGNAL("textChanged(const QString&)"), self.AmountTip)
        self.OfferTable.horizontalHeader().sectionResized.connect(self.fitToTable)
        self.Tabs.connect(self.Tabs,QtCore.SIGNAL("currentChanged(int)"),self.TabChange)
        #self.textBrowser.anchorClicked.connect(self.Navigate)
    def ChangeMyLanguage(self):
        ChangeLanguage()
        UpdateMarketList()
    def ActivateAPI(self):
        #Newest protocol is to require specific filenames so that there is protection against memory attacks. In this way, a physical file is also required to exist.
        if os.path.exists(os.path.join(application_path, 'API.share')):
            try:
                with open(path,'r') as f:
                    public=f.readline().strip()
                    public=f.readline().strip()
                    f.close()
                RPC.public=str(public)
                QuestionBox("RPC API public key loaded!", " OK ")
            except:
                QuestionBox("Invalid public key file", " OK ")
        else:
            QuestionBox("If you wish to activate RPC API code execution then please place the public key which you want to use to verify all the remote API commands in the BitBay directory and name it API.share. Halo requires that all API commands be signed by a private key so that you may interact with the Python interpreter.", " OK ")
        QuestionBox("If you wish to activate any passive code execution and custom vote algorithms you can sign the code using the debug console by calling the SignCode function.", " OK ")
    def TabChange(self):
        global AdvanceArray, CoinMarketCap
        if CoinSelect['moderngui']==1:
            window.tb_dashboard.setChecked(False)
            window.tb_send.setChecked(False)
            window.tb_receive.setChecked(False)
            window.tb_chat.setChecked(False)
            window.tb_history.setChecked(False)
            window.tb_makeanoffer.setChecked(False)
            window.tb_pending_offer.setChecked(False)
            window.tb_contracts.setChecked(False)
            window.tb_market.setChecked(False)
            window.tb_contacts.setChecked(False)

            if self.Tabs.currentIndex() == 0:
                window.tb_dashboard.setChecked(True)
            if self.Tabs.currentIndex() == 1:
                window.tb_send.setChecked(True)
            if self.Tabs.currentIndex() == 2:
                window.tb_receive.setChecked(True)
            if self.Tabs.currentIndex() == 3:
                window.tb_history.setChecked(True)
            if self.Tabs.currentIndex() == 4:
                window.tb_chat.setChecked(True)
            if self.Tabs.currentIndex() == 5:
                window.tb_makeanoffer.setChecked(True)
            if self.Tabs.currentIndex() == 6:
                window.tb_pending_offer.setChecked(True)
            if self.Tabs.currentIndex() == 7:
                window.tb_contracts.setChecked(True)
            if self.Tabs.currentIndex() == 8:
                window.tb_market.setChecked(True)
            if self.Tabs.currentIndex() == 9:
                window.tb_contacts.setChecked(True)
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if self.Tabs.currentIndex() == 3:
                if 'peghistorynotify' not in AdvanceArray:
                    res=QuestionBox("Welcome to the history tab. Here you can get a detailed view of your balance, transactions and account history. This currency controls it's own supply. To achieve this coins will freeze and unfreeze for all users depending on when they were received. This tab will show you how liquid your account is by telling you how many coins you have liquid(movable), reserve(movable with a one month delay), subpremium(coins that will soon become reserve) and frozen(coins that can not be moved). For more information you can click the help box, ask the community, or read the whitepaper/documentation on the dynamic peg/stablecoin."," OK ", " Do not show this message again. ")
                    if res==1:
                        AdvanceArray['peghistorynotify']=1
        if self.Tabs.currentIndex() == 8:
            if 'tabnotify' not in AdvanceArray:
                QuestionBox("Welcome to the decentralized markets! These markets are based on Bitmessage channels which means they are peer to peer and serverless. If this is your first time using the markets and they are empty or the orders do not appear up to date, please be patient while the market loads. Once the markets synchronize, they speed up greatly. This is also true if you are contracting through Bitmessage. If you do not keep the software running, then it can take time to download the new messages. For more information and tips, please read all of the help boxes, documentation and ask the community for insight. Thank you and enjoy the free and open markets.","OK")
                AdvanceArray['tabnotify']=1
            if self.checkonce==0 and CoinMarketCap==" ":#If this turns out to be slow, we can choose not to do this later
                splash_px = QtGui.QPixmap(application_path+'/images/Exchange.png')
                xsplash = QtGui.QSplashScreen(splash_px)
                xsplash.setMask(splash_px.mask())   
                xsplash.show()
                xsplash.repaint()
                app.processEvents()                
                try:
                    usd,btc=GetMarketValue(CoinSelect['name'])
                except:
                    pass                    
                xsplash.hide()
                PopulateMarkets()
                self.checkonce=1                
    def Encrypt_Decrypt(self):
        ewindow=QtGui.QDialog()
        ewindow.resize(500, 500)
        
        font = QtGui.QFont()
        font.setPixelSize(15)
        IntroLabel = QtGui.QLabel(ewindow)
        IntroLabel.setGeometry(QtCore.QRect(10, 10, 450, 30))
        IntroLabel.setMaximumSize(QtCore.QSize(300, 16777215))
        IntroLabel.setFont(font)
        IntroLabel.setObjectName(_fromUtf8("IntroLabel"))
        IntroLabel.setText("Please enter text to encrypt/decrypt here:")

        ewindow.InputWin = QtGui.QTextEdit(ewindow)
        ewindow.InputWin.setGeometry(QtCore.QRect(10, 45, 480, 150))
        ewindow.InputWin.setMaximumSize(QtCore.QSize(480, 16777215))
        ewindow.InputWin.setFont(font)
        ewindow.InputWin.setObjectName(_fromUtf8("ewindow.InputWin"))

        ewindow.OutputWin = QtGui.QTextEdit(ewindow)
        ewindow.OutputWin.setGeometry(QtCore.QRect(10, 245, 480, 150))
        ewindow.OutputWin.setMaximumSize(QtCore.QSize(480, 16777215))
        ewindow.OutputWin.setFont(font)
        ewindow.OutputWin.setObjectName(_fromUtf8("ewindow.OutputWin"))
        ewindow.OutputWin.setText("The result of your encrypted/decrypted text will show here.")
        ewindow.OutputWin.setReadOnly(True)

        EncryptME = QtGui.QPushButton(ewindow)
        EncryptME.setGeometry(QtCore.QRect(10, 450, 150, 30))
        EncryptME.setMaximumSize(QtCore.QSize(300, 16777215))
        EncryptME.setFont(font)
        EncryptME.setObjectName(_fromUtf8("EncryptME"))
        EncryptME.setText(" Encrypt ")        
        def EncryptTHIS():           
            QuestionBox("Please open the public key you want to use for encryption. The encrypted message can then be decrypted by the corresponding private key."," OK ")
            path = strOUT(strIN(QtGui.QFileDialog.getOpenFileName(ewindow,Gtranslate("Please open the public key for encryption."),MacDir()+"","Share Key (*.share)")))
            with open(path,'r') as f:
                public=f.readline().strip()
                public=f.readline().strip()
                f.close()
            try:
                cipher = encrypt(str(ewindow.InputWin.toPlainText()), public)
                cipher = base64.b64encode(cipher)
                ewindow.OutputWin.setText(cipher)
            except:
                QuestionBox("Encryption Failed! Are you sure you loaded a public key file? Make sure you have a valid public key.", " OK ")
            return

        DecryptME = QtGui.QPushButton(ewindow)
        DecryptME.setGeometry(QtCore.QRect(170, 450, 150, 30))
        DecryptME.setMaximumSize(QtCore.QSize(300, 16777215))
        DecryptME.setFont(font)
        DecryptME.setObjectName(_fromUtf8("DecryptME"))
        DecryptME.setText(" Decrypt ")        
        def DecryptTHIS():          
            QuestionBox("Please open the private key you want to use for decryption."," OK ")
            path = QtGui.QFileDialog.getOpenFileName(ewindow,Gtranslate("Please open the private key for decryption."),MacDir()+"","Private Key (*.private)")
            path = strOUT(strIN(path))
            dir1=os.path.dirname(path)
            key=os.path.basename(path)
            priv,check=DecryptPrivateKey(key,dir1,"0", "", "1")
            if check=="3":
                QuestionBox("Incorrect Password!", " OK ")
                return
            try:
                cipher = base64.b64decode(str(ewindow.InputWin.toPlainText()))
                cipher = decrypt(cipher, priv)            
                ewindow.OutputWin.setText(cipher)
            except:
                QuestionBox("Decryption Failed!"," OK ")
            return

        ApplyCSS(ewindow)
        DecryptME.clicked.connect(lambda: DecryptTHIS())
        EncryptME.clicked.connect(lambda: EncryptTHIS())

        ewindow.setWindowTitle("Encrypt/Decrypt")
        ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        ewindow.exec_()
    def Sign_Verify(self):
        ewindow=QtGui.QDialog()
        ewindow.resize(500, 500)        
        font = QtGui.QFont()
        font.setPixelSize(15)
        IntroLabel = QtGui.QLabel(ewindow)
        IntroLabel.setGeometry(QtCore.QRect(10, 10, 450, 30))
        IntroLabel.setMaximumSize(QtCore.QSize(300, 16777215))
        IntroLabel.setFont(font)
        IntroLabel.setObjectName(_fromUtf8("IntroLabel"))
        IntroLabel.setText("Please enter text to sign/verify here:")

        ewindow.InputWin = QtGui.QTextEdit(ewindow)
        ewindow.InputWin.setGeometry(QtCore.QRect(10, 45, 480, 150))
        ewindow.InputWin.setMaximumSize(QtCore.QSize(480, 16777215))
        ewindow.InputWin.setFont(font)
        ewindow.InputWin.setObjectName(_fromUtf8("ewindow.InputWin"))

        ewindow.OutputWin = QtGui.QTextEdit(ewindow)
        ewindow.OutputWin.setGeometry(QtCore.QRect(10, 245, 480, 150))
        ewindow.OutputWin.setMaximumSize(QtCore.QSize(480, 16777215))
        ewindow.OutputWin.setFont(font)
        ewindow.OutputWin.setObjectName(_fromUtf8("ewindow.OutputWin"))
        ewindow.OutputWin.setText("The result of your signed text will show here. If you wish to verify the text or file above, please enter the corresponding signature in this box.")
        #ewindow.OutputWin.setReadOnly(True)
        AddFile = QtGui.QPushButton(ewindow)
        AddFile.setGeometry(QtCore.QRect(330, 450, 150, 30))
        AddFile.setMaximumSize(QtCore.QSize(300, 16777215))
        AddFile.setFont(font)
        AddFile.setObjectName(_fromUtf8("AddFile"))
        AddFile.setText(" Upload File ")
        def AddTHIS():          
            QuestionBox("Please open the file you wish to sign/verify. The software will generate a hash of the file which will be used for signing and verification."," OK ")
            path = QtGui.QFileDialog.getOpenFileName(ewindow,Gtranslate("Please open the file you wish to use."),MacDir()+"","All Files (*.*)")
            path = strOUT(strIN(path))
            ewindow.InputWin.setText(checksum_sha256(path))
            return

        SignME = QtGui.QPushButton(ewindow)
        SignME.setGeometry(QtCore.QRect(10, 450, 150, 30))
        SignME.setMaximumSize(QtCore.QSize(300, 16777215))
        SignME.setFont(font)
        SignME.setObjectName(_fromUtf8("SignME"))
        SignME.setText(" Sign ")
        def SignTHIS():          
            QuestionBox("Please open the private key you want to use for signing."," OK ")
            path = QtGui.QFileDialog.getOpenFileName(ewindow,Gtranslate("Please open the private key for signing."),MacDir()+"","Private Key (*.private)")
            path = strOUT(strIN(path))
            dir1=os.path.dirname(path)
            key=os.path.basename(path)
            priv,check=DecryptPrivateKey(key,dir1,"0", "", "1")
            if check=="3":
                QuestionBox("Incorrect Password!", " OK ")
                return
            try:
                text = str(ewindow.InputWin.toPlainText())
                sig = sign(text, priv)
                sig = binascii.hexlify(sig)            
                ewindow.OutputWin.setText(sig)
            except:
                QuestionBox("Signature Failed!"," OK ")
            return

        VerifyME = QtGui.QPushButton(ewindow)
        VerifyME.setGeometry(QtCore.QRect(170, 450, 150, 30))
        VerifyME.setMaximumSize(QtCore.QSize(300, 16777215))
        VerifyME.setFont(font)
        VerifyME.setObjectName(_fromUtf8("VerifyME"))
        VerifyME.setText(" Verify ")        
        def VerifyTHIS():           
            if str(ewindow.OutputWin.toPlainText())=="The result of your signed text will show here. If you wish to verify the text or file above, please enter the corresponding signature in this box.":
                QuestionBox("Please enter the signature that you wish to verify in the second box. This signature will be verified by it's corresponding public key."," OK ")
                return
            QuestionBox("Please open the public key you want to use for verifying the signature."," OK ")
            path = QtGui.QFileDialog.getOpenFileName(ewindow,Gtranslate("Please open the public key for verification."),MacDir()+"","Share Key (*.share)")
            path = strOUT(strIN(path))
            with open(path,'r') as f:
                public=f.readline().strip()
                public=f.readline().strip()
                f.close()
            try:
                sig=binascii.unhexlify(str(ewindow.OutputWin.toPlainText()))
                cipher = verify(str(ewindow.InputWin.toPlainText()), sig, public)
                if cipher:
                    QuestionBox("The signature matches. Success!", "OK")
                else:
                    QuestionBox("The signature does not match.", "OK")
            except:
                QuestionBox("Verification Failed!", " OK ")
            return

        ApplyCSS(ewindow)
        VerifyME.clicked.connect(lambda: VerifyTHIS())
        SignME.clicked.connect(lambda: SignTHIS())
        AddFile.clicked.connect(lambda: AddTHIS())

        ewindow.setWindowTitle("Sign/Verify")
        ewindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
        ewindow.exec_()
    def fitToTable(self):
        global CustomColumns
        CustomColumns=[]
        for i in range(self.OfferTable.columnCount()):
            CustomColumns.append(self.OfferTable.columnWidth(i))
    def DebugConsole(self):
        if True:#debug != 1:
            global dwindow
            dwindow=QtGui.QDialog()
            dwindow.resize(500, 500)            
            font = QtGui.QFont()
            font.setPixelSize(15)
            IntroLabel = QtGui.QLabel(dwindow)
            IntroLabel.setGeometry(QtCore.QRect(10, 10, 250, 30))
            IntroLabel.setMaximumSize(QtCore.QSize(300, 16777215))
            IntroLabel.setFont(font)
            IntroLabel.setObjectName(_fromUtf8("IntroLabel"))
            IntroLabel.setText("Please enter python command here:")

            dwindow.InputWin = QtGui.QTextEdit(dwindow)
            dwindow.InputWin.setGeometry(QtCore.QRect(10, 45, 480, 150))
            dwindow.InputWin.setMaximumSize(QtCore.QSize(480, 16777215))
            dwindow.InputWin.setFont(font)
            dwindow.InputWin.setObjectName(_fromUtf8("dwindow.InputWin"))

            dwindow.OutputWin = QtGui.QTextEdit(dwindow)
            dwindow.OutputWin.setGeometry(QtCore.QRect(10, 245, 480, 150))
            dwindow.OutputWin.setMaximumSize(QtCore.QSize(480, 16777215))
            dwindow.OutputWin.setFont(font)
            dwindow.OutputWin.setObjectName(_fromUtf8("dwindow.OutputWin"))
            dwindow.OutputWin.setText("Please store output to the variable 'text' if you want it seen here. Also proceed with caution, you can interact with live code and the python interpreter. Only use this if you are familiar with the Halo source code.")
            dwindow.OutputWin.setReadOnly(True)

            RunCode = QtGui.QPushButton(dwindow)
            RunCode.setGeometry(QtCore.QRect(10, 450, 150, 30))
            RunCode.setMaximumSize(QtCore.QSize(300, 16777215))
            RunCode.setFont(font)
            RunCode.setObjectName(_fromUtf8("RunCode"))
            RunCode.setText(" Execute code ")
            ApplyCSS(dwindow)

            RunCode.clicked.connect(lambda: DebugExec())

            dwindow.setWindowTitle("Python Interpreter Debugger")
            dwindow.setWindowIcon(QtGui.QIcon(application_path+'/images/' + CoinSelect['HaloName'] + '.png'))
            dwindow.exec_()
    def UnlockWallet(self):
        global unlockpasswords, keysconnected, lockforspending
        if unlockpasswords!=["",""]:
            if IsUnlocked():
                res=QuestionBox("Your wallet is already unlocked! Would you like to lock your wallet?", " Unlock ", " Lock ")
                if res==0:
                    return True
                else:
                    unlockpasswords=["",""]
                    return True
        res=QuestionBox("This will unlock the wallet for auto-accepting matching orders, autopay contracts, price tracked orders, and it will also unlock the wallet for staking. Because it will temporarily save your password to memory, some people feel it's more secure to leave it locked. Would you like to continue?", " Yes ", " No ", " Unlock for everything ")
        res2=1
        if res == 2:
            res=0
            res2 = QuestionBox("Are you sure you want to unlock your account for everything? This means you will be able to spend and sign without needing to enter your password. However if anyone else has access to your computer this is not recommended.", " Yes, unlock for all functions that require my password ", " No, unlock for staking and auto-accepting only ")
        if res==0:
            text,check=DecryptPrivateKey(PrivKeyFilename1,PrivKeyFiledir1,"5")
            if text=="Failed":
                QuestionBox("Incorrect password.", "OK")
                unlockpasswords=["",""]
                return False
            if check=="2":#No password
                unlockpasswords[0]=""
                text=""
            else:
                unlockpasswords[0]=str(text)
            if keysconnected=="2":
                unlockpasswords[0]=""
                text2,check=DecryptPrivateKey(PrivKeyFilename2,PrivKeyFiledir2,"5")
                if text2=="Failed":
                    QuestionBox("Incorrect password.", "OK")
                    unlockpasswords=["",""]
                    return False
                if check=="2":
                    unlockpasswords[0]=str(text)
                    unlockpasswords[1]=""
                else:
                    unlockpasswords[0]=str(text)
                    unlockpasswords[1]=str(text2)
                if unlockpasswords==["",""]:
                    QuestionBox("Neither of your keys contain a password. So you're wallet is already unlocked.", "OK")
                    return True
                if res2==0:
                    lockforspending=""
                QuestionBox("Success!", "OK")
            else:
                if res2==0:
                    lockforspending=""
                QuestionBox("Success!", "OK")
        return True
    def AmountTip(self):
        global AdvanceArray
        if 'tip' not in AdvanceArray:
            QuestionBox("Did you know by adding a dollar sign $ in front of the amount, Halo will automatically convert the amount entered to USD based on the exchange rate?", "OK")
            AdvanceArray['tip']=1
    def OfferBoxChange(self):
        global GlobalImage, GlobalID
        self.ClearPage()
        GlobalImage=""
        GlobalID=""
    def MarketsClick(self, x, y):
        HideWindows()
        buttons = QtGui.qApp.mouseButtons()
        if buttons == QtCore.Qt.LeftButton:
            try:
                ordernumber=str(self.OfferTable.item(x,self.OfferTable.columnCount()-1).text())
            except:
                ordernumber=""
            for order in Markets['Orders']:
                if order['ordernumber']==ordernumber:
                    Templates.showorder(order)
                    #MarketWindow.showorder(order)
                    #MarketWindow.show()
    def MarketsClick2(self, x, y):
        HideWindows()
        try:
            ordernumber=str(self.OfferTable.item(x,self.OfferTable.columnCount()-1).text())
        except:
            ordernumber=""
        for order in Markets['Orders']:
            if order['ordernumber']==ordernumber:
                Templates.showorder(order)
                #MarketWindow.showorder(order)
                #MarketWindow.show()
    def ShowOutbox(self):
        HideWindows()
        OutboxWindow.populate()
        OutboxWindow.show()
    def openMenu(self, point):
        global Markets
        BitAddr=GetfromCfg("#BitMessage#")
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        x=self.OfferTable.currentRow()
        y=self.OfferTable.currentColumn()
        try:
            st=self.OfferTable.item(x,y).text()
        except:
            st=""
        try:
            ordernumber=str(self.OfferTable.item(x,self.OfferTable.columnCount()-1).text())
        except:
            ordernumber=""
        if ordernumber == "":
            return
        menu = QtGui.QMenu()
        if Markets['Sort'][0]<2:
            sortAction = menu.addAction("Sort Ascending")
        if Markets['Sort'][0]==2:
            sortAction = menu.addAction("Sort Descending")
        copyAction = menu.addAction("Copy")
        if ModeratorKey==0:
            flagAction = menu.addAction("Flag")
        if ModeratorKey>0:
            removeAction = menu.addAction("Remove")
        if ModeratorKey>0:
            banAction = menu.addAction("Ban User")
            banAction1 = ""
            banAction2 = ""
            banAction3 = ""
            banAction4 = ""
        if ModeratorKey==2:
            banAction1 = menu.addAction("Ban Addresses")
            banAction2 = menu.addAction("Ban Identity")
            banAction3 = menu.addAction("Blacklist Market")
            banAction4 = menu.addAction("Reward User")
        point=QtGui.QCursor.pos()
        action = menu.exec_(point)
        if action==sortAction:
            self.OfferTable.setSortingEnabled(True)
            if Markets['Sort'][0]<2:
                self.OfferTable.sortItems(y,QtCore.Qt.AscendingOrder)
                Markets['Sort']=[2,y]
            else:
                self.OfferTable.sortItems(y,QtCore.Qt.DescendingOrder)
                Markets['Sort']=[1,y]
            self.OfferTable.setSortingEnabled(False)
            PopulateMarkets()
            app.processEvents()
        if action==copyAction:
            clipboard = app.clipboard()
            clipboard.setText(strOUT(strIN(st)))
        if Markets['Current']=="ALL":
            cur=CoinSelect['default market']
        else:
            cur=Markets['Current']
        if ModeratorKey==0:
            if action==flagAction:
                mbox = QuestionBox("Are you sure you want to flag the order?", " Yes ", " No ")
                if mbox == 1:
                    return
                Reply={}
                Reply['Process']='Ban'
                Reply['Command']='Send'
                priv,check=DecryptPrivateKey(PrivKeyFilename1,PrivKeyFiledir1,"0", "", lockforspending)
                if check=="3":#Looks like the password was wrong
                    return
                Reply['MyBMAddress']=BitAddr
                Reply['TheirBMAddress']=Markets['MyMarkets'][cur]
                Reply['ordernumber']=os.urandom(16).encode('hex')
                Reply['banlist']=[ordernumber]
                data=ModerationCheck(multisig, priv, Reply)
                if data==False:
                    return
                Reply=data
                try:
                    if Markets['Flags'][1]+2592000<time.time(): #A month has passed we get 5 more
                        Markets['Flags']=[0,time.time()]
                    if Markets['Flags'][0]>5:
                        QuestionBox("Sorry, this option is no longer available.", "OK")
                        return False
                    #We can fill in the rest of the market data later
                except:
                    traceback.print_exc()
                    return False
                res=VerifyMarketData(Reply)
                if res==True:
                    Markets['Flags'][0]+=1
                    BitQueue.append(Reply)
                    SaveQueue()
        if ModeratorKey>0:
            if action==removeAction:
                mbox = QuestionBox("Are you sure you want to flag the order?", " Yes ", " No ")
                if mbox == 1:
                    return
                Reply={}
                Reply['Process']='Ban'
                Reply['Command']='Send'
                priv=ModeratorPrivateKey
                Reply['MyBMAddress']=BitAddr
                Reply['TheirBMAddress']=Markets['MyMarkets'][cur]
                Reply['ordernumber']=os.urandom(16).encode('hex')
                Reply['banlist']=[ordernumber]
                data=ModerationCheck(multisig, priv, Reply)
                if data==False:
                    return
                Reply=data
                res=VerifyMarketData(Reply)
                if res==True:
                    BitQueue.append(Reply)
                    SaveQueue()
            if action==banAction or action==banAction1 or action==banAction2 or action==banAction3 or action==banAction4:
                if action==banAction4:
                    mbox = QuestionBox("Please confirm you want to reward this user.", " Reward this user ", " Cancel ")
                if action==banAction3:
                    mbox = QuestionBox("Are you sure you want to Blacklist this market?", " Yes ", " No ")
                if action==banAction2:
                    mbox = QuestionBox("Are you sure you want to ban the users identity?", " Yes ", " No ")
                if action==banAction1:
                    mbox = QuestionBox("Are you sure you want to ban the users addresses?", " Yes ", " No ")
                if action==banAction:
                    mbox = QuestionBox("Are you sure you want to ban the user?", " Yes ", " No ")
                if mbox == 1:
                    return
                Reply={}
                Reply['Process']='Ban'
                Reply['Command']='Send'
                priv=ModeratorPrivateKey
                Reply['MyBMAddress']=BitAddr
                Reply['TheirBMAddress']=Markets['MyMarkets'][cur]
                Reply['ordernumber']=os.urandom(16).encode('hex')
                for ord1 in Markets['Orders']:
                    if ord1['ordernumber']==ordernumber:
                        break
                Reply['banlist']=[ordernumber,"#"+ord1['Market Data']['orgpublic'][:10]]
                if ModeratorKey==2:
                    if action==banAction1 or action==banAction2:
                        Reply['banlist'].append("*"+ord1['TheirBMAddress'][:10])
                        Reply['banlist'].append("*"+ord1['theiraddress'][:10])
                    if action==banAction2:
                        Reply['banlist'].append('*'+ord1['Market Data']['ident'][:10])
                        Reply['banlist'].append('*'+ord1['Market Data']['ident'][-10:])
                    if action==banAction3:
                        Reply['banlist'].append('*'+ord1['MyBMAddress'][:10])
                    if action==banAction4:
                        Reply['banlist']=['*R*'+ord1['Market Data']['orgpublic']]
                data=ModerationCheck(multisig, priv, Reply)
                if data==False:
                    return
                Reply=data
                res=VerifyMarketData(Reply)
                if res==True:
                    BitQueue.append(Reply)
                    SaveQueue()
    def SearchMe(self):
        global CustomColumns
        Markets['Sort']=[0,0]
        CustomColumns=[]
        self.OfferTable.setSortingEnabled(False)
        PopulateMarkets()
    def ConvertMe(self):
        global CoinMarketCap
        #https://coinmarketcap-nexuist.rhcloud.com/api/blk/price
        #The above link is also a good api for conversion rates
        if CoinMarketCap==" ":
            usd,btc=GetMarketValue(CoinSelect['name'])
        else:
            usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap)
        bal=GetfromCfg('#prevbalance#')
        if usd=="":
            return
        if btc=="":
            return
        if CoinSelect['name']=="Bitcoin":
            balance=""
            if bal!=" " and bal!="":
                st=str(int(Decimal(bal)*Decimal(usd)*Decimal(100)))
                balance="\n"+Gtranslate("Balance:")+" $"+str(Decimal(st)/Decimal(100))
            QuestionBox(Gtranslate("Conversion Rates:")+"\nUSD->BTC: $"+usd+balance, Gtranslate("OK"),1)
        else:
            balance=""
            if str(bal)!=" " and str(bal)!="":
                st=str(int(Decimal(bal)*Decimal(usd)*Decimal(100)))
                balance="\n"+Gtranslate("Balance:")+" $"+str(Decimal(st)/Decimal(100))
                btcconv=str(int(Decimal(bal)*Decimal(btc)*Decimal(1e8)))
                btcrate="\n"+Gtranslate("Balance in BTC: ")+str(Decimal(btcconv)/Decimal(1e8))
            QuestionBox(Gtranslate("Conversion Rates:")+"\nUSD->"+CoinSelect['Symbol']+": $"+usd+"\nBTC->"+CoinSelect['Symbol']+": "+btc+balance+btcrate, Gtranslate("OK"),1)
    def Settings(self):
        MySettings.Load()
        MySettings.show()
        return
    def CustomScript(self, amount, script):
        #This function is a demo, not for official use
        timest=time.time()
        if keysconnected=="1":
            return
        multisig,mscript=create_multisig_address(PrivKeyFilename1)
        SpendThis=list(FilterSpendable(OnOrders,Spendable))
        fee=100000
        inputs,outputs,Total = MakeChange (SpendThis, amount+fee, multisig, 1)#We will only use one input
        #script="6a20931d236179670b00348f87bea4199fe18297f0ef26da02c7542bd54d5b7836d8"
        #6a is OP_RETURN
        #20 is the hex value for 32 which says how many bytes go to the stack
        #931d236179670b00348f87bea4199fe18297f0ef26da02c7542bd54d5b7836d8  is the payload

        #get the length of the stack after the first opcode, divide length by two for bytes then do num_to_var_int(length) for getting the char and then encode to hex
        #Check the validity with the RPC call decodescript to see if there was an error or if it was non-standard
        #If the OP_RETURN is less than or equal to 75 bytes then that is the protocol. Otherwise start with 4c(pushdata) and proceed as normal. If its bigger than 256 use 4d
        tmptx=mktx_script(timest, amount, script, inputs, outputs)

        priv,check=DecryptPrivateKey(PrivKeyFilename1,PrivKeyFiledir1,"0")
        priv2,check=DecryptPrivateKey(PrivKeyFilename2,PrivKeyFiledir2,"0")
        sig = multisign(tmptx.decode('hex'),0,mscript.decode('hex'),priv)#Adding a 2 will make it SIGHASH_NONE
        sig2 = multisign(tmptx.decode('hex'),0,mscript.decode('hex'),priv2)
        #With special SIGHASH, we should check the rules carefully about sequence numbers.
        sigs=[]
        sigs.append(sig2)
        sigs.append(sig)
        #The sigs will need to be reversed if the order was different
        print "PRINT X TO ABORT"
        c=m.getch()
        if c=="x":
            return
        tx=apply_multisignatures(tmptx,0,mscript,sigs)
        try:
            rspns = BLK.sendrawtransaction(tx)
        except:
            rspns = "TX rejected"
        print rspns
        print txhash(tx)
    def PostOffer(self, template=""):
        HideWindows()
        window.ClearPage()
        if template=="Cash":
            res=QuestionBox("", "Buy coins", "Sell coins")
            if res==0:
                template="  Buy Coins With Cash"
            else:
                template="  Sell Coins For Cash"
        if template=="Market":
            res=QuestionBox("", "Sell Something", "Buy Something")
            if res==0:
                template="  Sell Something"
            else:
                template="  Buy Something"
        if template=="":
            template=window.OfferBox.currentIndex()
            if template==0:template="  Select Offer Type"
            if template==1:template="  Buy Coins With Cash"
            if template==2:template="  Sell Coins For Cash"
            if template==3:template="  Sell Something"
            if template==4:template="  Buy Something"
            if template==5:template="  Employ Someone"
            if template==6:template="  Find A Job"
            if template==7:template="  Barter Items/Services"
            if template==8:template="  Custom Offer"
        else:
            index = window.OfferBox.findText(template, QtCore.Qt.MatchFixedString)
            if index >= 0:
                 window.OfferBox.setCurrentIndex(index)
        if template=="  Select Offer Type":
            QuestionBox("Please select an offer type.", "OK")
            return
        if template=="  Buy Coins With Cash":
            Templates.ClearMyForm(2,0)
            r=Templates.InitializeWindow(1)            
            Templates.Window.Pages.setCurrentIndex(9)
            if r:Templates.Window.show()
        if template=="  Sell Coins For Cash":
            Templates.ClearMyForm(1,0)
            r=Templates.InitializeWindow(0)
            Templates.Window.Pages.setCurrentIndex(0)
            if r:Templates.Window.show()
        if template=="  Sell Something":            
            Templates.ClearMyForm(5,0)
            r=Templates.InitializeWindow(4)
            Templates.Window.Pages.setCurrentIndex(12)
            if r:Templates.Window.show()
        if template=="  Buy Something":
            Templates.ClearMyForm(6,0)
            r=Templates.InitializeWindow(5)
            Templates.Window.Pages.setCurrentIndex(13)
            if r:Templates.Window.show()
        if template=="  Employ Someone":
            Templates.ClearMyForm(3,0)
            r=Templates.InitializeWindow(2)
            Templates.Window.Pages.setCurrentIndex(10)
            if r:Templates.Window.show()
        if template=="  Find A Job":
            Templates.ClearMyForm(4,0)
            r=Templates.InitializeWindow(3)
            Templates.Window.Pages.setCurrentIndex(11)
            if r:Templates.Window.show()
        if template=="  Barter Items/Services":
            r=Templates.InitializeWindow(6)
            Templates.Window.Pages.setCurrentIndex(14)
            if r:Templates.Window.show()
            if 'barternotify' not in AdvanceArray:
                res=QuestionBox("Barter contracts are fun and can become very creative and complex. When the recommended deposits are set, the software will choose double the highest minimum item value. These values are determined by maximum shipping values and minimum order sizes. When involved in a barter contract, users will take turns trading services and making shipments or deliveries. However because the timing of these trades can vary we recommend you plan this process with your counterparty and keep good communication with them.  If there is shipping involved, you should include shipping information in your contact information profile as well.", " Thanks! ", " Do not show this message again. ")
                if res==1:
                    AdvanceArray['barternotify']=1
            if 'barternotify2' not in AdvanceArray:
                res=QuestionBox("When adding items, you may choose to set a quantity of supply which can be taken by multiple contracts or parties. Additionally, you might choose a quantity for how much you demand as well.", " Thanks! ", " Do not show this message again. ")
                if res==1:
                    AdvanceArray['barternotify2']=1
        if template=="  Custom Offer":
            res=QuestionBox("Please select the type of contract you want.", "Normal Contract", "Python/Smart Contract")
            if res==0:
                CustomForm.UpdateMarketList()
                CustomForm.show()
                self.Tabs.setCurrentIndex(5)
            else:
                Templates.ClearMyForm(8,0)
                r=Templates.InitializeWindow(7)
                Templates.Window.Pages.setCurrentIndex(17)
                if r:Templates.Window.show()
    def LeaveMarket(self):
        global CustomColumns
        cur=Markets['Current']
        if cur==CoinSelect['default market']:
            QuestionBox("You cannot remove the default market.", "OK")
            return
        if cur=="ALL":
            return
        RemoveMarket(Markets['MyMarkets'][cur])
        Markets['Current']=CoinSelect['default market']
        Markets['Sort']=[0,0]
        CustomColumns=[]
        self.OfferTable.setSortingEnabled(False)
        Markets['MyMarkets'].pop(cur, None)
        UpdateMarketList()
        PopulateMarkets()
    def NewMarket(self):
        text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the market name you wish to create or join:'))
        try:
            text=str(text)
        except:
            QuestionBox("The market was not added! The market name must contain letters and numbers only.", "OK")
            return
        if ok and text != "":
            if text not in Markets['MyMarkets']:
                AddMarket(text)
                QuestionBox("The market was added! It will be listed in a few moments.", "OK")
            else:
                QuestionBox("The market is already in your list of markets.", "OK")
                return
    def MarketChange(self):
        global Markets
        Markets['Current']= str(window.MarketBox.currentText())
        Markets['Sort']=[0,0]
        self.OfferTable.setSortingEnabled(False)
        UpdateMarketList()
        PopulateMarkets()
    def AdvanceMe(self):
        global AdvanceArray, timestamp
        HideWindows()
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        AdvancedWindow.retranslateUi(AdvancedWindow)
        AdvancedWindow.ForwardEmail.setText("")
        AdvancedWindow.BitPayTo.setText("")
        AdvancedWindow.BitAmount.setText("")
        AdvancedWindow.BitPayTo_2.setText("")
        AdvancedWindow.BitAmount_2.setText("")
        AdvancedWindow.Autosign.setCheckState(0)
        AdvancedWindow.Note.hide()
        if multisig in AdvanceArray:
            if 'AutoSign' not in AdvanceArray[multisig]:
                AdvanceArray[multisig]['AutoSign']=0
            if 'ForwardEmail' not in AdvanceArray[multisig]:
                AdvanceArray[multisig]['ForwardEmail']=""
            if AdvanceArray[multisig]['AutoSign']==1:
                AdvancedWindow.Autosign.setCheckState(2)
            else:
                AdvancedWindow.Autosign.setCheckState(0)
            AdvancedWindow.ForwardEmail.setText(str(AdvanceArray[multisig]['ForwardEmail']))
        AdvancedWindow.comboBox.setCurrentIndex(0)
        my_time = QtCore.QDateTime()
        my_time.setTime_t(int(timestamp))
        AdvancedWindow.dateTimeEdit.setDateTime(my_time)
        AdvancedWindow.OwnerAfter.setText("")
        self.Tabs.setCurrentIndex(1)
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            AdvancedWindow.show()
            if 'pegexoticnotify' not in AdvanceArray:
                res=QuestionBox("Welcome to advanced spending. Here you can perform all kinds of special and exotic transactions. Because this currency is a stablecoin, you might have reserve funds that you want to move. This type of transaction is useful for getting higher rewards on stakes, liquidity swaps, trustless loans and subpremium payments. You might also want to voluntarily freeze liquid funds to get an even higher reward on stakes. For more information on all of the exotic payments, please read the help boxes, ask the community or read the documentation."," OK ", " Do not show this message again. ")
                if res==1:
                    AdvanceArray['pegexoticnotify']=1
        else:
            AdvancedWindow.OwnerBefore.setText(Gtranslate("Frozen"))
            AdvancedWindow.AddBefore.hide()
        AdvancedWindow.show()
    def MakeJointAccount(self):
        global MyEmail,BitHaloClient, CoinSelect, clientversion, currentblock
        path = strIN(QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Create your joint account key and store it somewhere you will remember."),MacDir()+"key1.private","Private Key File (*.private)"))
        if path=="":
            return
        text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the counterparties email or Bitmessage address:'))
        if text=="":
            NewWallet(strOUT(path))
            QuestionBox("You have created one private key. Since you have skipped sending the shared public key by email, you will need to combine your new key manually by opening the account with your key and your counterparties shared key. You can trade .share files with another party if you want a joint account.", "OK")
            return
        text=str(text)
        testaddr=text.replace("-","")
        testaddr=testaddr.replace(".","")
        if not re.match("^[A-Za-z0-9,@_+~|]*$", testaddr):
            QuestionBox("Invalid mailing address!", "OK")
            return
        Reply={}
        BitAddr=GetfromCfg("#BitMessage#")
        GetEmailGlobals()
        if "@" in text:
            Reply['MyBMAddress']=MyEmail#We always do this it can change from time to time
        else:
            Reply['MyBMAddress']=BitAddr
        if Reply['MyBMAddress']==text:
            QuestionBox("You can not make a joint account with the same mailing address!", "OK")
            return
        NewWallet(strOUT(path))
        with open(strOUT(path),'r') as fi:
            data1=fi.readlines()
            fi.close()
        Reply['type']='CONTRACT'
        Reply['status']='Joint Account Offer'

        Reply['Process']='Joint'
        Reply['version']=CoinSelect['HaloName'] + " " + clientversion
        Reply['currentblock']=CurrentBlock

        Reply['Command']='Send'
        Reply['ordernumber']=os.urandom(16).encode('hex')#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
        Reply['public']=str(data1[2])
        Reply['TheirBMAddress']=text
        Reply['BitHaloClient']=BitHaloClient
        BitQueue.append(Reply)
        Reply['path']=strIN(path)
        SaveQueue()
        MyContracts.append(Reply)
        SaveContracts()
        self.Tabs.setCurrentIndex(6)
    def ClearHistoryDetail(self):
        global HistoryDetail
        mbox = QuestionBox("Are you sure you want to clear the history?", " Yes ", " No ")
        if mbox == 1:
            return
        x=0
        for el in HistoryDetail[multisig]:
            try:
                if HistoryDetail[multisig][x]['Type']=="Bridge":
                    mbox = QuestionBox("There is a bridge transaction listed in your history which shows how to redeem itself. Clearing the history will clear this receipt. Are you sure you want to proceed?", " Yes ", " No ")
                    if mbox == 1:
                        return
                    break
            except:
                traceback.print_exc()
            x+=1
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        HistoryDetail[multisig]=[]
        PopulateHistory()
    def MakeCSV(self):
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        path = strOUT(strIN(QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Please choose the name and location for the CSV file."),MacDir()+"","CSV (*.csv)")))#date label amount[0]['Details']
        fieldnames = ['version', 'timestamp', 'currentblock', 'Label', 'Amount', 'fee', 'address', 'Confirmation TXID', 'tx3', 'txid', 'inputs', 'output', 'outputs', 'date', 'total', 'FROM', 'ContractResult', 'theiraddress', 'amount', 'whopays', 'mydeposit','theirdeposit','instantamount', 'instantwhopays','timeout','ordernumber','description']
        test_file = open(path,'wb')
        csvwriter = csv.DictWriter(test_file, delimiter=',', fieldnames=fieldnames, extrasaction='ignore')
        csvwriter.writerow(dict((fn,fn) for fn in fieldnames))
        for row in HistoryDetail[multisig]:
            row['Details']['Amount']=row['Amount']
            row['Details']['Label']=row['Label']
            csvwriter.writerow(row['Details'])
        test_file.close()
    def FullHistoryClick(self, x, y):
        global HistoryDetail, AdvanceArray
        HideWindows()
        data=""
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        try:
            HistoryDetail[multisig][x]['Details']['Details']['image']=""
        except:
            pass
        #for d in HistoryDetail[multisig][x]['Details']:
        #   print d
        #   m.getch()
        if y > 0:
            if 'rating' in HistoryDetail[multisig][x]['Details']:
                if int(HistoryDetail[multisig][x]['Details']['rating'])>550:
                    myrating=str(HistoryDetail[multisig][x]['Details']['rating']) + " (Excellent)"
                elif int(HistoryDetail[multisig][x]['Details']['rating'])>350:
                    myrating=str(HistoryDetail[multisig][x]['Details']['rating']) + " (Good)"
                elif int(HistoryDetail[multisig][x]['Details']['rating'])>ThePeg.subpremiumrating:
                    myrating=str(HistoryDetail[multisig][x]['Details']['rating']) + " (Low)"
                else:
                    myrating=str(HistoryDetail[multisig][x]['Details']['rating']) + " (Subpremium)"
            if HistoryDetail[multisig][x]['Type']=="Change":
                data+="Version: "+HistoryDetail[multisig][x]['Details']['version'] +"<br />"
                data+="Payment to self: <br />"
                if 'Pending' in HistoryDetail[multisig][x]['Details']:
                    if HistoryDetail[multisig][x]['Details']['Pending']==True:
                        data+="PENDING... <br />"
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"
                data+="Time Stamp: " + str(HistoryDetail[multisig][x]['Details']['timestamp']) + "<br />"
                if str(HistoryDetail[multisig][x]['Details']['currentblock']) != "0":
                    data+="Block: " + str(HistoryDetail[multisig][x]['Details']['currentblock']) + "<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"
                data+="Amount: " + str(HistoryDetail[multisig][x]['Amount']) + "<br />"
                data+="Fee: " + str(Decimal(HistoryDetail[multisig][x]['Details']['fee'])/Decimal(1e8)) + "<br />"
                data+="Total: " + str(Decimal(HistoryDetail[multisig][x]['Details']['total'])/Decimal(1e8)) + "<br />"
                data+="Address: " + str(HistoryDetail[multisig][x]['Details']['address']) + "<br />"
                if 'rating' in HistoryDetail[multisig][x]['Details']:
                    data+="Liquidity Rating: " + myrating + "<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['Confirmation TXID']) + "<br /><br />"
                data+="Inputs: " + str(HistoryDetail[multisig][x]['Details']['inputs']) + "<br /><br />"
                data+="Outputs: " + str(HistoryDetail[multisig][x]['Details']['output']) + "<br /><br />"
            if HistoryDetail[multisig][x]['Type']=="Pay To Email":
                data+="Version: "+HistoryDetail[multisig][x]['Details']['version'] +"<br />"
                data+="Pay To Email: <br />"
                if 'Pending' in HistoryDetail[multisig][x]['Details']:
                    if HistoryDetail[multisig][x]['Details']['Pending']==True:
                        data+="PENDING... <br />"
                if HistoryDetail[multisig][x]['Details']['Redeemed']==0:
                    data+="NOT YET REDEEMED<br />"
                else:
                    data+="PAYMENT WAS REDEEMED<br />"
                if 'explain' in HistoryDetail[multisig][x]['Details']:
                    data+=HistoryDetail[multisig][x]['Details']['explain']+"<br />"
                if 'theiraddress' in HistoryDetail[multisig][x]['Details']:
                    data+="Send Address: " + HistoryDetail[multisig][x]['Details']['theiraddress']+"<br />"
                data+="Temporary Address: " + str(HistoryDetail[multisig][x]['Details']['Temporary Address']) + "<br />"
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"
                data+="Time Stamp: " + str(HistoryDetail[multisig][x]['Details']['timestamp']) + "<br />"
                if str(HistoryDetail[multisig][x]['Details']['currentblock']) != "0":
                    data+="Block: " + str(HistoryDetail[multisig][x]['Details']['currentblock']) + "<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"
                data+="Amount: " + str(HistoryDetail[multisig][x]['Amount']) + "<br />"
                data+="Fee: " + str(Decimal(HistoryDetail[multisig][x]['Details']['fee'])/Decimal(1e8)) + "<br />"
                data+="Total: " + str(Decimal(HistoryDetail[multisig][x]['Details']['total'])/Decimal(1e8)) + "<br />"
                data+="Address: " + str(HistoryDetail[multisig][x]['Details']['address']) + "<br />"
                if 'rating' in HistoryDetail[multisig][x]['Details']:
                    data+="Liquidity Rating: " + myrating + "<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['Confirmation TXID']) + "<br /><br />"
                data+="Inputs: " + str(HistoryDetail[multisig][x]['Details']['inputs']) + "<br /><br />"
                data+="Outputs: " + str(HistoryDetail[multisig][x]['Details']['output']) + "<br /><br />"
            if HistoryDetail[multisig][x]['Type']=="Spent":
                data+="Version: "+HistoryDetail[multisig][x]['Details']['version'] +"<br />"
                data+="Sent coins: <br />"
                if 'Pending' in HistoryDetail[multisig][x]['Details']:
                    if HistoryDetail[multisig][x]['Details']['Pending']==True:
                        data+="PENDING... <br />"
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"
                data+="Time Stamp: " + str(HistoryDetail[multisig][x]['Details']['timestamp']) + "<br />"
                if str(HistoryDetail[multisig][x]['Details']['currentblock']) != "0":
                    data+="Block: " + str(HistoryDetail[multisig][x]['Details']['currentblock']) + "<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"
                data+="Amount: " + str(HistoryDetail[multisig][x]['Amount']) + "<br />"
                data+="Fee: " + str(Decimal(HistoryDetail[multisig][x]['Details']['fee'])/Decimal(1e8)) + "<br />"
                data+="Total: " + str(Decimal(HistoryDetail[multisig][x]['Details']['total'])/Decimal(1e8)) + "<br />"
                data+="Address: " + str(HistoryDetail[multisig][x]['Details']['address']) + "<br />"
                if 'rating' in HistoryDetail[multisig][x]['Details']:
                    data+="Liquidity Rating: " + myrating + "<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['Confirmation TXID']) + "<br /><br />"
                data+="Inputs: " + str(HistoryDetail[multisig][x]['Details']['inputs']) + "<br /><br />"
                data+="Outputs: " + str(HistoryDetail[multisig][x]['Details']['output']) + "<br /><br />"
            if HistoryDetail[multisig][x]['Type']=="Two Step":
                data+="Version: "+HistoryDetail[multisig][x]['Details']['version'] +"<br />"
                data+="Two Step Spend: <br />"
                if 'Pending' in HistoryDetail[multisig][x]['Details']:
                    if HistoryDetail[multisig][x]['Details']['Pending']==True:
                        data+="PENDING... <br />"
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"
                data+="Time Stamp: " + str(HistoryDetail[multisig][x]['Details']['timestamp']) + "<br />"
                try:
                    if str(HistoryDetail[multisig][x]['Details']['currentblock']) != "0":
                        data+="Block: " + str(HistoryDetail[multisig][x]['Details']['currentblock']) + "<br />"
                except:
                    pass
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"
                data+="Amount: " + str(HistoryDetail[multisig][x]['Amount']) + "<br />"
                data+="Fee: " + str(Decimal(HistoryDetail[multisig][x]['Details']['fee'])/Decimal(1e8)) + "<br />"
                data+="Total: " + str(Decimal(HistoryDetail[multisig][x]['Details']['total'])/Decimal(1e8)) + "<br />"
                data+="Address: " + str(HistoryDetail[multisig][x]['Details']['address']) + "<br />"
                if 'rating' in HistoryDetail[multisig][x]['Details']:
                    data+="Liquidity Rating: " + myrating + "<br />"
                try:
                    data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['Confirmation TXID']) + "<br /><br />"
                except:
                    pass
                data+="Inputs: " + str(HistoryDetail[multisig][x]['Details']['inputs']) + "<br /><br />"
                if 'output' in HistoryDetail[multisig][x]['Details']:
                    data+="Outputs: " + str(HistoryDetail[multisig][x]['Details']['output']) + "<br /><br />"
                if 'outputs' in HistoryDetail[multisig][x]['Details']:
                    data+="Outputs: " + str(HistoryDetail[multisig][x]['Details']['outputs']) + "<br /><br />"
            if HistoryDetail[multisig][x]['Type']=="Received":
                data+="Received: <br />"
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"
                data+="Amount: " + str(HistoryDetail[multisig][x]['Details']['Amount']) +"<br />"
                data+="From: " + str(HistoryDetail[multisig][x]['Details']['FROM']) +"<br />"
                if 'rating' in HistoryDetail[multisig][x]['Details']:
                    data+="Liquidity Rating: " + myrating + "<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['txid']) + ":" + str(HistoryDetail[multisig][x]['Details']['vout']) + "<br />"
            if HistoryDetail[multisig][x]['Type']=="Exotic":
                isspendable=HistoryDetail[multisig][x]['spendable']
                try:
                    meaning=translate_script(HistoryDetail[multisig][x]['script'])
                    isspendable=meaning['spendable']
                except:
                    pass
                data+="Received Exotic Transaction: <br />"                
                #type, timestamp, spendable, description, script
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"+"<br />"
                data+="Type: " + HistoryDetail[multisig][x]['type'] +"<br />"
                data+="Description: " + HistoryDetail[multisig][x]['description'] +"<br />"+"<br />"
                data+="Spendable: " + isspendable +"<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"
                data+="Amount: " + str(HistoryDetail[multisig][x]['Details']['Amount']) +"<br />"
                data+="From: " + str(HistoryDetail[multisig][x]['Details']['FROM']) +"<br />"
                if 'rating' in HistoryDetail[multisig][x]['Details']:
                    data+="Liquidity Rating: " + myrating + "<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['txid']) + ":" + str(HistoryDetail[multisig][x]['Details']['vout']) + "<br />"
                data+="Timestamp: " + str(HistoryDetail[multisig][x]['timestamp']) +"<br />"+"<br />"
                data+="Script: " + HistoryDetail[multisig][x]['script'] +"<br />"
            if HistoryDetail[multisig][x]['Type']=="Contract":
                f=0
                data+="Version: "+HistoryDetail[multisig][x]['Details']['version'] +"<br />"
                data+="Contract: <br />"
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"
                data+="Result: " + str(HistoryDetail[multisig][x]['Details']['ContractResult']) + "<br />"
                data+="Time Stamp: " + str(HistoryDetail[multisig][x]['Details']['timestamp']) + "<br />"
                if str(HistoryDetail[multisig][x]['Details']['currentblock']) != "0":
                    data+="Block: " + str(HistoryDetail[multisig][x]['Details']['currentblock']) + "<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"
                data+="Amount: " + str(HistoryDetail[multisig][x]['Amount']) + "<br />"
                data+="Fee: " + str(Decimal(HistoryDetail[multisig][x]['Details']['fee'])/Decimal(1e8)) + "<br />"
                data+="Total: " + str(Decimal(HistoryDetail[multisig][x]['Details']['total'])/Decimal(1e8)) + "<br />"
                data+="Their Address: " + str(HistoryDetail[multisig][x]['Details']['theiraddress']) + "<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['tx3']) + "<br /><br />"
                data+="Inputs: " + str(HistoryDetail[multisig][x]['Details']['inputs']) + "<br /><br />"
                ######
                data+=str(HistoryDetail[multisig][x]['Details']['whopays'])+"<br />"
                data+="Amount: "+str(Decimal(HistoryDetail[multisig][x]['Details']['amount'])/Decimal(1e8))+"<br />"
                data+="My Deposit: "+str(Decimal(HistoryDetail[multisig][x]['Details']['mydeposit'])/Decimal(1e8))+"<br />"
                data+="Their Deposit: "+str(Decimal(HistoryDetail[multisig][x]['Details']['theirdeposit'])/Decimal(1e8))+"<br />"
                if HistoryDetail[multisig][x]['Details']['instantamount'] != 0:
                    f+=.5
                    data+="Instant refund: ("+str(HistoryDetail[multisig][x]['Details']['instantwhopays'])+")<br />"
                    data+="Amount: " + str(Decimal(HistoryDetail[multisig][x]['Details']['instantamount'])/Decimal(1e8))+"<br />"
                f+=1#Temporary account
                f+=1#Split escrow fund/release
                data+="<br />"
                data+="Fee: "+str(Decimal(HistoryDetail[multisig][x]['Details']['fee']*f)/Decimal(1e8))+"<br />"
                data+="Time limit: "+str(HistoryDetail[multisig][x]['Details']['timeout'])+" Hours -- "+str(round((HistoryDetail[multisig][x]['Details']['timeout']/24),2))+" Days<br />"
                data+="Order number: "+str(HistoryDetail[multisig][x]['Details']['ordernumber'])
                data+="<br /><br />"
                data+="Description: <br />"
                data+=HistoryDetail[multisig][x]['Details']['Details']['description']
            if HistoryDetail[multisig][x]['Type']=="Notary/Burn" or HistoryDetail[multisig][x]['Type']=="Payment/Notary":
                try:
                    message=""
                    meaning=translate_script(HistoryDetail[multisig][x]['script'])
                    message=meaning['message']
                except:
                    pass
                data+=HistoryDetail[multisig][x]['Type']+": <br />"
                data+="Message: " + message +"<br /><br />"
                #type, timestamp, spendable, description, script
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"+"<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"

                data+="Amount: " + str(HistoryDetail[multisig][x]['Amount']) +"<br />"
                data+="From: " + str(HistoryDetail[multisig][x]['Details']['FROM']) +"<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['txid']) + "<br />"
                try:
                    if HistoryDetail[multisig][x]['notify']!="":
                        data+="Notification Address: " + HistoryDetail[multisig][x]['notify'] +"<br />"
                except:
                    pass                
                try:
                    data+="Script: " + HistoryDetail[multisig][x]['script'] +"<br />"
                except:
                    pass
            if HistoryDetail[multisig][x]['Type']=="Bridge":
                txid=HistoryDetail[multisig][x]['bridgedata']['txid']
                res=QuestionBox("Would you like to see how to redeem this transaction on the competing network?", " Yes ", " No ")
                #MIGHT WANT TO DO THIS IN BOTH SCENARIOS TO GENERATE PROOF HASH THEN MERKLE SEPARATE
                #OR PERHAPS BECAUSE IT HAS TO BE PROCESSED THEN OFFLOAD ELSEWHERE SINCE YOU NEED SHARDS ANYWAYS?
                try:
                    message=""
                    meaning=translate_script(HistoryDetail[multisig][x]['script'])
                    message=meaning['message']
                except:
                    pass
                mymerkle = False
                if res==0:
                    name = ''
                    z = 0
                    while z < len(ThePeg.Pegdatabase['bridgedb']['bridges']):
                        if message[5:][:64] == txhash(ThePeg.Pegdatabase['bridgedb']['bridges'][z]['n'])[:64]:
                            name=ThePeg.Pegdatabase['bridgedb']['bridges'][z]['n']
                            break
                        z+=1
                    if ThePeg.testthis==1:
                        #This shows how all the data can be found through the TXID
                        if 'bridgetx' not in AdvanceArray:
                            AdvanceArray['bridgetx']={}
                        if txid not in AdvanceArray['bridgetx']:
                            AdvanceArray['bridgetx'][txid]={'pool':[0]*1200}
                        loaded=1
                        if AdvanceArray['bridgetx'][txid]['pool']==[0]*1200:
                            loaded=0
                            try:
                                busy=NetSplash(1, checkwait=1)
                                fractions=BLK.getfractions(txid)['values']
                                AdvanceArray['bridgetx'][txid]['pool']=copy.deepcopy(fractions)
                                if 'bridgecheck' in AdvanceArray:
                                    try:
                                        if txid in AdvanceArray['bridgecheck']:
                                            AdvanceArray['bridgecheck'].remove(txid)
                                    except:
                                        traceback.print_exc()
                                NetSplash(0)
                                loaded==1
                            except:
                                NetSplash(0)
                                traceback.print_exc()
                                QuestionBox("Pool data failed to load please wait a moment or try again.", " OK ")
                        nonce = str(ThePeg.Pegdatabase['txidreference'][txid])
                        if 'finalTX' in ThePeg.Pegdatabase['merklelist'][nonce] and loaded == 1:
                            try:
                                myroot = ThePeg.Pegdatabase['merklelist'][nonce]['finalTX'][name]['root']
                                thissupply = ThePeg.Pegdatabase['merklelist'][nonce]['supply']
                                if len(AdvanceArray['bridgetx'][txid]['pool']) == 1200:
                                    AdvanceArray['bridgetx'][txid]['pool']=CompressFractions(AdvanceArray['bridgetx'][txid]['pool'],thissupply,ThePeg.Pegdatabase['netdata'][name]['pegsteps'],ThePeg.Pegdatabase['netdata'][name]['microsteps'])
                                thisaddy = message[5:][64:]
                                mydata = json.dumps([thisaddy,AdvanceArray['bridgetx'][txid]['pool'],txid])
                                myval = str(int(ThePeg.Pegdatabase['netdata'][name]['pegsteps']) + int(ThePeg.Pegdatabase['netdata'][name]['microsteps']))
                                leaf = BridgeDriver.execute_script("return getLeaf("+str(mydata)+","+myval+");")
                                proof = BridgeDriver.execute_script("return showProof('"+myroot+"','"+leaf+"');")
                                proof = ast.literal_eval(json.dumps(proof))
                                mymerkle = {'root':myroot,'proof':proof,'address':thisaddy,'txid':txid,'reserve':AdvanceArray['bridgetx'][txid]['pool']}
                            except:
                                QuestionBox("There was an error processing the merkle tree.", " OK ")
                                traceback.print_exc()
                        else:
                            if loaded == 1:
                                QuestionBox("This merkle has not been processed yet. Please check back later.", " OK ")
                    else:
                        try:
                            busy=NetSplash(1, checkwait=1)
                            mymerkle=BLK.bridgereceipt(txid)
                            if mymerkle['receipt_is_ready']==False or mymerkle['receipt_is_found']==False:
                                QuestionBox("This merkle has not been processed yet. Please check back later.", " OK ")
                                mymerkle=False
                            else:
                                mymerkle=mymerkle['receipt']
                            NetSplash(0)
                        except:
                            NetSplash(0)
                            QuestionBox("Pool data failed to load please wait a moment or try again.", " OK ")
                    if mymerkle != False:
                        QuestionBox("Network to redeem the funds:\n" + name + "\n\nReceipt:\n" + str(mymerkle), " Copy to Clipboard ", 1)
                        clipboard = app.clipboard()
                        clipboard.setText(str(mymerkle))
                        QuestionBox("The receipt has been copied to the clipboard. Please redeem the coins at the official bridge website after the merkle proof confirms(usually within 48 hours).", " OK ")
                data+=HistoryDetail[multisig][x]['Type']+": <br />"
                data+="Message: " + message +"<br /><br />"
                #type, timestamp, spendable, description, script
                if 'date' in HistoryDetail[multisig][x]['Details']:
                    t=ConvertDate(HistoryDetail[multisig][x]['Details']['date'],1)
                    t=t.strftime('%m/%d/%Y')
                    data+="Date: " + str(t) + "<br />"+"<br />"
                data+="Label: " + HistoryDetail[multisig][x]['Label'] +"<br />"

                data+="Amount: " + str(HistoryDetail[multisig][x]['Amount']) +"<br />"
                data+="From: " + str(HistoryDetail[multisig][x]['Details']['FROM']) +"<br />"
                data+="TXID: " + str(HistoryDetail[multisig][x]['Details']['txid']) + "<br />"
                try:
                    if HistoryDetail[multisig][x]['notify']!="":
                        data+="Notification Address: " + HistoryDetail[multisig][x]['notify'] +"<br />"
                except:
                    pass
                try:
                    data+="Script: " + HistoryDetail[multisig][x]['script'] +"<br />"
                except:
                    pass
                if mymerkle != False:
                    data+="<br />Network to redeem the funds: " + str(name)
                    data+="<br />Merkle Proof Receipt:<br />" + str(mymerkle)
            MyDetails.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">"+data+"</span></p></body></html>")
            MyDetails.show()
    
    def ToggleCheckboxes(self, x):
        if self.checkBox.isChecked():
            UpdateCfg("#Notify#","1")
        else:
            UpdateCfg("#Notify#","0")
        if self.FilterCustom.isChecked():
            UpdateCfg("#Market#","0")
        else:
            UpdateCfg("#Market#","1")
        if self.DisableSpamFilter.isChecked():
            UpdateCfg("#Spam#","1")
        else:
            UpdateCfg("#Spam#","0")
        NM=GetfromCfg("#Notify#")
        MM=GetfromCfg("#Market#")
        SM=GetfromCfg("#Spam#")
        print NM, MM, SM
    def ConnectNotify(self):
        global AdvanceArray
        text=str(self.notifytext)
        if text=="Email Timed Out!":
            if 'tipemail' not in AdvanceArray:
                res=QuestionBox("Fetching one of your Emails has timed out. Either the Email server dropped the connection or you have a large Email in your inbox and a slow connection. If you use your Email to receive large attachments on a slow connection please consider moving those Emails out of your inbox to another folder. Otherwise, you may ignore this message. Its usually recommended to use your Email account exclusively with Halo.", " Thanks! "," Don't show this message again ")
                if res==1:
                    AdvanceArray['tipemail']=1
            Notification(0, "")
            return
        if text=="You have been rewarded!":
            QuestionBox("Congratulations! A moderator has rewarded you with 100 reputation points for good behavior.", "OK")
            Notification(0, "")
            return
        if text=="Completion request failed!" or text=="Cancellation request failed!":
            QuestionBox("You and your counterparty submitted requests that do not match to finish the deal. This may happen due to both parties submitting at almost the same time before receiving the other parties signature and then there was a change in the supply. One of you should simply resubmit the request to finish this contract and when the request is received to respond and finish the deal.", "OK")
            Notification(0, "")
            return
        if text=="Message Failure!":
            OutboxWindow.populate()
            OutboxWindow.show()
            Notification(0, "")
            return
        if text=="Received Pay To Email!" or text=="Pay To Email Not Redeemed!":
            self.Tabs.setCurrentIndex(3)
            Notification(0, "")
            return
        if text=="New Pending Offer!" or text=="New Counter-Offer!" or text=="Pay To Email Request!" or 'Joint Account' in text or text=="Two Step Send Request!" or text=="New Offer From Market!" or text=="Market Order Accepted!" or text=="New Reply/Bid on Offer!":
            self.Tabs.setCurrentIndex(6)
            Notification(0, "")
            return
        else:
            self.Tabs.setCurrentIndex(7)
            Notification(0, "")
    def AddImage(self, mywin=""):
        global GlobalImage, interneton, GlobalID #The string usually exceeds the limit
        output = StringIO.StringIO() #We only save the image in memory
        if mywin=="":
            path = strOUT(strIN(QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Please choose the image you want to attach."),MacDir()+"","Image File (*.jpg *.jpeg *.png *.bmp)")))
        else:
            path = strOUT(strIN(QtGui.QFileDialog.getOpenFileName(Templates,Gtranslate("Please choose the image you want to attach."),MacDir()+"","Image File (*.jpg *.jpeg *.png *.bmp)")))
        try:            
            output=ResizeImage(path, 20000,1)            
            mybytes= base64.b64encode(output.getvalue())
            if mywin=="":
                window.ImageBox.setText(str("Image Attached"))
            if mywin=="Sell":
                Templates.Window.SellImageBox.setText(str("Image Attached"))
            if mywin=="Buy":
                Templates.Window.BuyImageBox.setText(str("Image Attached"))
            if mywin=="Python":
                Templates.Window.PythonImageBox.setText(str("Image Attached"))    
            GlobalImage=mybytes
            try:
                if interneton==1:
                    ID=fpaste(mybytes)
                    if ID == False:
                        float("A")
                    GlobalID=str(ID)
                    print GlobalID
                else:
                    float("A")
            except:
                GlobalID=""
                QuestionBox("Online Pastebin not used. If using Bitmessage, sending the message with the image might take up to 30 minutes.", "OK")
            output.close()
            output=""
        except Exception, e:
            output.close()
            output=""
            traceback.print_exc()
            pass
    def MyCellChanged(self, x, y):
        global HistoryDetail
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if multisig not in HistoryDetail:
            HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
        self.FullHistory.blockSignals(True)
        try:
            text = strOUT(strIN(self.FullHistory.currentItem().text()))#will be correct if typing
        except:
            text=""
        if y==0:
            self.FullHistory.setItem(x, y, QtGui.QTableWidgetItem(text))
            HistoryDetail[multisig][x]['Label']=text
            try:
                SaveOtherdata()
            except:
                pass
        self.FullHistory.blockSignals(False)
    def KeyToImage(self):
        SelectKeyForHide()
        return
    def scanchain(self):
        global rescanning
        mbox = QuestionBox("Would you like to rescan the blockchain? Normally, this is done to look for missing inputs to correct the balance or other rare issues. You should only rescan if you think it's necessary since it can take up to an hour and can interfere with other Halo functions.", " Rescan ", " Cancel ")
        if mbox == 1:
            return
        rescanning=1
    def checkbox(self):
        if self.EnableBitmessage.isChecked():
            UpdateCfg("#EnableBM#","Y")
        else:
            UpdateCfg("#EnableBM#","N")
        if self.EnableEmail.isChecked():
            UpdateCfg("#EnableEmail#","Y")
        else:
            UpdateCfg("#EnableEmail#","N")
    def SwitchMe(self):
        global CoinSelect, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, NewUser, updatesomething, accounttype, mycfg
        if NewUser!=[]:
            QuestionBox("Please wait for the account to finish loading.", "OK")
            return
        PleaseWait=copy.deepcopy(CoinSelect)
        if CoinSelect['name']=="Bitcoin":
            notifybuild=0
            with open(os.path.join(application_path,"Halo.cfg"),'r') as f:
                line=f.readline().strip()
                if "#Approved#" not in line:
                    notifybuild = line
                f.close()
            if notifybuild!=0:
                res=QuestionBox(CoinSelect['daemon'] + " was not built by the Halo dev. Instead, it was taken from the official project release page. For the best security you can build the software yourself. Would you like to launch " + CoinSelect['daemon'] + "?" + " If you cancel, you can compile your own build and restart the software.","Proceed","Cancel")
                if res==0:
                    mycfg+="#Approved#"
                    with open(os.path.join(application_path,"Halo.cfg"), 'a+') as f:
                        f.write("#Approved#")
                        f.flush()
                        os.fsync(f)
                        f.close()
                    if BlackHalo == None:
                        Reconnect()
                else:
                    return
            CoinSelect=copy.deepcopy(Coins[0])
            SelectTHIS=copy.deepcopy(Coins[0])
            self.progressBar.show()
            self.Rescan.show()
            self.labelProgress.show()
            if CoinSelect['moderngui']==0:
                self.progressBar2.show()
                self.Rescan2.show()
                self.labelProgress2.show()
            UpdateCfg('#CoinSelect#',str(CoinSelect['Symbol']))            
        else:
            CoinSelect=copy.deepcopy(Coins[2])
            SelectTHIS=copy.deepcopy(Coins[2])
            self.progressBar.hide()
            self.Rescan.show()
            self.labelProgress.hide()
            if CoinSelect['moderngui']==0:
                self.progressBar2.hide()
                self.Rescan2.hide()
                self.labelProgress2.hide()
            UpdateCfg('#CoinSelect#',str(CoinSelect['Symbol']))
        NewUser=[]
        if keysconnected=="1":
            NewUser.append(PrivKeyFilename1)
            NewUser.append(" ")
            NewUser.append(PrivKeyFiledir1)
            NewUser.append(" ")
            NewUser.append("1")
            NewUser.append(" ")
            NewUser.append(str(accounttype))
            NewUser.append(SelectTHIS)
        if keysconnected=="2":
            NewUser.append(PrivKeyFilename1)
            NewUser.append(PrivKeyFilename2)
            NewUser.append(PrivKeyFiledir1)
            NewUser.append(PrivKeyFiledir2)
            NewUser.append("2")
            NewUser.append(" ")
            NewUser.append(str(accounttype))
            NewUser.append(SelectTHIS)
        retranslateUi2()
        if NewUser!=[]:
            CoinSelect=copy.deepcopy(PleaseWait)
        updatesomething=1
    def WatchIntro(self):
        if CoinSelect['moderngui']==0:
            self.Explain(0)
        if 'videolibrary' not in CoinSelect:
            webbrowser.open("https://www.youtube.com/user/CryptoWorldNetwork?spfreload=10")
        else:
            webbrowser.open(CoinSelect['videolibrary'])
    def SupportClicked(self):
        #self.Explain(0)
        webbrowser.open("https://forum.bitbay.market/c/support")
    def CopyEmail(self):
        GetEmailGlobals()
        clipboard = app.clipboard()
        clipboard.setText(str(MyEmail))
    def NewEmail(self):
        global ManualPassword, AdvanceArray, OnOrders
        GetEmailGlobals()
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if MyEmail != "":
            res=QuestionBox("", " Add/Change Email ", " Remove Current Email ")
            if res==1:
                y=-1
                for order in OnOrders:
                    y+=1
                    if order['type']=="History":
                        if 'Contacts' in order:
                            o=-1
                            for Contact in order['Contacts']:
                                o+=1
                                if Contact['Name']=="Self:"+str(multisig):
                                    OnOrders[y]['Contacts'].pop(o)
                ManualPassword="*"
                return
        if MyEmail != "":
            QuestionBox("If you are changing an Email, please be aware that any current parties you are contracting with will not be able to contact you. It is recommended you complete open contracts first.", "OK")
        if internet_on() != True:
            QuestionBox("Not connected to the internet!", "OK")
            return
        if self.EmailBox.text()=="":
            text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the email address:'))
        else:
            text=str(self.EmailBox.text())
        if str(text)=="":
            return
        if AdvanceArray['MySettings']['AntiLogger']:
            AntiLogger.setWindowTitle("Please enter the email password:")
            AntiLogger.reset()
            AntiLogger.exec_()                
            text1=str(AntiLogger.inputString)
        else:
            text1, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the email password:'), QtGui.QLineEdit.Password)
        if str(text1)=="":
            return
        self.EmailStatus.setText(Gtranslate("Authenticating and sending test message..."))
        app.processEvents()
        #########################################
        providers=[{'@gmail': {'imap':'imap.googlemail.com','smtp':'smtp.googlemail.com','port':587,'SSL':0}},{'@hotmail':{'imap':'imap-mail.outlook.com','smtp':'smtp-mail.outlook.com','port':587,'SSL':0}}, {'@outlook':{'imap':'imap-mail.outlook.com','smtp':'smtp-mail.outlook.com','port':587,'SSL':0}},{'@aol.com':{'imap':'imap.aol.com','smtp':'smtp.aol.com','port':587,'SSL':0}}]
        username = str(text)
        EmailPassword = str(text1)
        foundit=0
        for prov in providers:
            for key, val in prov.items():
                pass
            if key in username.lower():
                foundit=1
                imapname = prov[key]['imap']
                smtpname = prov[key]['smtp']
                port = prov[key]['port']
                isSSL = prov[key]['SSL']
                break
        if foundit==0:
            QuestionBox("The email requested is not in the providers list. Please check the list of approved providers and try again.", "OK")
            return
        ret=True
        try:
            connection = imaplib.IMAP4_SSL(imapname)
            connection.login(username, EmailPassword)
            time.sleep(.1)
        except:
            ret = False
        try:
            connection = smtplib.SMTP(smtpname, port)
            connection.ehlo()
            connection.starttls()
            headers = ["from: " + username, "subject: " + "Test", "to: " + username,"mime-version: 1.0","content-type: text/html"]
            headers = "\r\n".join(headers)
            connection.login(username, EmailPassword)
            connection.sendmail(username, username, headers+"\r\n\r\n"+str("Test"))
            connection.close()
        except Exception, e:
            try:
                connection.close()
            except:
                pass
            ret = False
        if ret==False:
            print str(e)
            QuestionBox(Gtranslate("Authentication failed. Please check your password and also please make sure your email is in the list of providers. Also you may need to enable imap/smtp/applications in your email. We recommend using gmail.\n\nReply from server:\n")+str(e), Gtranslate("OK"),1)
            self.EmailStatus.setText("")
            return
        EmailPassword=password.EncryptWithAES("Halo Master", EmailPassword)
        Contact={}
        Contact['Name']="Self:"+str(multisig)
        Contact['Bitmessage Address']=""
        Contact['Blackcoin Address']=str(multisig)
        Contact['Email Address']=str(username)
        Contact['Password']=str(EmailPassword)
        if AdvanceArray['MySettings']['ManualLogin']:#They have decided not to save passwords
            Contact['Password']="*"
            ManualPassword=EmailPassword
        self.AddContact(Contact)
        QuestionBox("Authentication Success! However, please check your inbox and see if the test message arrives before giving out the Email for contracts and payments. Make sure that you don't have and never add any filters on your emails so as to not interfere with the softwares ability to use your inbox.", "OK")
        if str(username) not in AdvanceArray:
            AdvanceArray[str(username)]={}
            if 'uids' not in AdvanceArray[str(username)]:
                AdvanceArray[username]['uids']=[]
        self.EmailStatus.setText("")
    def MyContractsClick(self, item):
        global ContractSelected, DontRepopulate
        HideWindows()
        t=item.text()
        matchObj = re.match( r'(Order:) (.*?) (.*?)Time Remaining: (.*?) (.*?) ', t, re.M|re.I)
        Selected=matchObj.group(2)
        pos=-1
        WinContracts.Requests.clear()
        for c in MyContracts:
            pos+=1
            if c['ordernumber']==Selected:
                ContractSelected=c
                if "MyRequests" not in c:
                    MyContracts[pos]['MyRequests']=[]
                else:
                    for req in c['MyRequests']:
                        WinContracts.Requests.addItem(req)
        if True:
            f=0
            data=""
            if "Broadcasting c" in ContractSelected['Process'] or "Sent cancellation request" in ContractSelected['Process'] or "Sent completion request" in ContractSelected['Process']:
                mbox = QuestionBox("The client is waiting for a response. Would you like to unlock the escrow window?", " Yes ", " No ")
                if mbox == 1:
                    return
            if "Complete:*Counter party submitted first*" in ContractSelected['Process']:
                QuestionBox("The order will clear automatically once the transaction confirms.", " OK ")
                return
                mbox = QuestionBox("Do you want to clear the order? Please make sure everything went through before you continue. The order will clear automatically once it confirms.", " Yes ", " No ")
                if mbox == 1:
                    return
                DeleteContract(ContractSelected)
                return
            if "Complete: " in ContractSelected['Process']:
                QuestionBox("The order will clear automatically once the transaction confirms.", " OK ")
                return
                mbox = QuestionBox("Do you want to clear the order? Please make sure everything went through before you continue. The order will clear automatically once it confirms.",  " Yes ", " No ")
                if mbox == 1:
                    return
                DeleteContract(ContractSelected)
                return
            if ContractSelected['Process']=="Signing again...":
                QuestionBox("There was a malformed signature. Both clients are signing the deal. Please wait until signatures are complete.", "OK")
                return
            if ContractSelected != {}:
                data+="Escrow Halo version " + str(ContractSelected['version'])+"<br />"
                data+="Time Remaining: " + matchObj.group(4).replace("(hours)", "(hours)   ") + matchObj.group(5).replace("(approximate", "(blocks)") + "<br />"
                if ContractSelected['instantamount'] != 0:
                    data+="Refund Transaction ID: " + ContractSelected['tx5']+"<br />"
                data+="Escrow Address: " + ContractSelected['escrow']+"<br />"+"<br />"

                data+="Their Bitmessage Address: " + str(ContractSelected['TheirBMAddress']) + "<br />"
                data+="Their "+CoinSelect['name']+" Address: " + str(ContractSelected['theiraddress']) + "<br />"
                data+=str(ContractSelected['whopays'])+"<br />"
                data+="Amount: "+str(Decimal(ContractSelected['amount'])/Decimal(1e8))+"<br />"
                data+="My Deposit: "+str(Decimal(ContractSelected['mydeposit'])/Decimal(1e8))+"<br />"
                data+="Their Deposit: "+str(Decimal(ContractSelected['theirdeposit'])/Decimal(1e8))+"<br />"
                if ContractSelected['instantamount'] != 0:
                    f+=.5
                    data+="Instant refund: ("+str(ContractSelected['instantwhopays'])+")<br />"
                    data+="Amount: " + str(Decimal(ContractSelected['instantamount'])/Decimal(1e8))+"<br />"
                f+=1#Temporary account
                f+=1#Split escrow fund/release
                data+="<br />"
                data+="Fee: "+str(Decimal(ContractSelected['fee']*f)/Decimal(1e8))+"<br />"
                data+="Time limit: "+str(ContractSelected['timeout'])+" Hours -- "+str(round((ContractSelected['timeout']/24),2))+" Days<br />"
                data+="Order number: "+str(ContractSelected['ordernumber'])
                WinContracts.Details.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">"+data+"</span></p></body></html>")
        WinContracts.showme()
    def AddContact(self, Contact=None):
        global OnOrders
        added=0
        if Contact == None:
            Contact = {}
        if Contact == False:
            Contact={}
        if Contact=={}:
            #This is primitive it will be improved upon
            text, ok = QtGui.QInputDialog.getText(window, CoinSelect['HaloName'], Gtranslate('Enter a nickname for this contact:'))
            if str(text)=="":
                return
            text1, ok = QtGui.QInputDialog.getText(window, CoinSelect['HaloName'], Gtranslate('Please enter the BitMessage address:'))
            text2, ok = QtGui.QInputDialog.getText(window, CoinSelect['HaloName'], Gtranslate('Please enter the '+CoinSelect['name']+' address:'))
            text3, ok = QtGui.QInputDialog.getText(window, CoinSelect['HaloName'], Gtranslate('Please enter the Email address:'))
            if str(text1)=="":
                if str(text2)=="":
                    if str(text3)=="":
                        return
            Contact={}
            Contact['Name']=str(text)
            Contact['Bitmessage Address']=str(text1)
            Contact['Blackcoin Address']=str(text2)
            Contact['Email Address']=str(text3)
        else:
            pos=-1
            for o in OnOrders:
                pos+=1
                if o['type']=='History':
                    if "Contacts" in OnOrders[pos]:
                        pos2=-1
                        for contact1 in OnOrders[pos]["Contacts"]:
                            pos2+=1
                            if contact1['Name']==Contact['Name']:
                                OnOrders[pos]["Contacts"][pos2]=Contact
                                added=1
                                SaveContracts()
                                return
        pos=-1
        for o in OnOrders:
            pos+=1
            if o['type']=="History":
                if added==0:
                    if "Contacts" in OnOrders[pos]:
                        OnOrders[pos]['Contacts'].append(Contact)
                        window.ContactTable.addItem(str(Contact))
                    else:
                        OnOrders[pos]['Contacts']=[]
                        OnOrders[pos]['Contacts'].append(Contact)
                        window.ContactTable.addItem(str(Contact))
        SaveContracts()
    def BackContacts(self):
        global OnOrders
        privpath1 = strOUT(strIN(QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Choose a location for your backup."),MacDir()+"MyContacts.dat","Contacts File (*.dat)")))
        if privpath1=="":
            return
        for o in OnOrders:
            if o['type']=="History":
                if "Contacts" in o:
                    with open(privpath1,'a') as f:
                        f.close()
                    with open(privpath1,'w') as f:
                        for Contact in o['Contacts']:
                            f.write(str(Contact ['Name'])+"\n")
                            f.write(str(Contact['Bitmessage Address'])+"\n")
                            f.write(str(Contact['Blackcoin Address'])+"\n")
                            f.write(str(Contact['Email Address'])+"\n\n")
                        f.flush()
                        os.fsync(f)
                        f.close()
                else:
                    return
    def ContactsClick(self, item):
        global ContactSelected
        HideWindows()
        t=item.text()
        t=str(t)
        temp={}
        try:
            temp['Name']=""
            temp['Name'] = t.split('Name: ')[1].split('  Address: ')[0]
        except:
            temp['Name']=""
        try:
            temp['Blackcoin Address']=""
            temp['Blackcoin Address'] = t.split('  Address: ')[1].split('  Bitmessage: ')[0]
        except:
            temp['Blackcoin Address']=""
        try:
            temp['Bitmessage Address']=""
            temp['Bitmessage Address'] = t.split('  Bitmessage: ')[1].split('  Email: ')[0]
        except:
            temp['Bitmessage Address']=""
        try:
            temp['Email Address']=""
            temp['Email Address'] = t.split('  Email: ', 1)[1]
        except:
            temp['Email Address']=""
        current=temp
        ContactSelected=current
        WinContacts.show()
    def Navigate(self, item):
        t=str(item)
        t=t.lstrip("PyQt4.QtCore.QUrl(u'")
        t=t.rstrip("')")
        webbrowser.open(t)
    def RefreshDownload(self):
        global updatesomething, isdownloading
        window.KeysConnected.setText("Updating from internet...")
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        updatesomething=1
        isdownloading=1
    def PendingClick(self, item):
        HideWindows()
        global OnOrders, MyContracts, updatesomething, PendingSelected
        global AdvanceArray, CoinSelect, clientversion, currentblock, myblockcount
        global timestamp
        PendingSelected={}
        t=item.text()
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if "New Offer! - Click for description and actions: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Template: ')[0]).strip()
            for ord1 in Markets['Orders']:
                if ord1['ordernumber']==current:
                    current=ord1
                    break
            Templates.showorder(current)
        if "      Received Offer from Market - Click for actions: " in t:#This section appears to be obsolete
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            MarketWindow.showorder(current)
            MarketWindow.show()
        if "Offer Cancelled - Click for actions: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            res=QuestionBox("The counter-party has cancelled the offer. This can happen for a number of reasons depending on their situation. This order will now clear itself.", " Okay, thanks ", " Automatically clear in the future ")
            if res==1:
                AdvanceArray['autocancel']=1
            DeleteOrder(PendingSelected['ordernumber'])
            DeleteContract(PendingSelected)
        if "Broadcast expired" in t or 'broadcastexpired' in PendingSelected:
            try:
                if 'broadcastexpired' in PendingSelected:
                    PendingSelected.pop('broadcastexpired')
            except:
                pass
            QuestionBox('The broadcast has expired most likely due to a change in the supply. To avoid freezing too much funds, it is requested that you and your counter-party submit the requests again.', ' OK ')
        ff=0
        if "Broadcast failed: " in t:
            QuestionBox('The broadcast failed most likely due to a change in supply or a cancellation. Please follow the steps to cancel the transaction.', ' OK ')
            t="Broadcasting transactions - Click for description and actions: "
            mbox=1
            ff=1
        if "Broadcasting transactions - Click for description and actions: " in t or "Making transactions and sending to counter-party: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            if 'cancel' in PendingSelected:
                found=0
                if str(PendingSelected['cancel'])!="1" or 'cancelold' in PendingSelected:
                    try:
                        if BitHaloClient==False:
                            check= BLK.getrawtransaction(PendingSelected['cancel'],1)
                        else:
                            requestURL('https://blockchain.info/rawtx/'+PendingSelected['cancel'])
                        found=1
                    except:
                        try:
                            if BitHaloClient==False:
                                check= BLK.getrawtransaction(PendingSelected['cancelold'],1)
                            else:
                                requestURL('https://blockchain.info/rawtx/'+PendingSelected['cancelold'])
                            found=1
                        except:
                            pass
                if str(PendingSelected['cancel'])!="1" or found==1:#Its a txid then
                    if found==1:
                        mbox = QuestionBox("Your cancel request confirmed! Would you like to clear the order?", " Yes ", " No ")
                        if mbox==1:
                            return
                    else:
                        QuestionBox(str(PendingSelected['cancel'])+"\n\n"+Gtranslate("The above transaction ID can be checked on https://chainz.cryptoid.info/. If it shows in your account proceed and clear the order. You can also check back later to see if it confirms."), Gtranslate("OK"),1)
                        mbox = QuestionBox("Do you want to clear the order? Please note, once done, it cannot be reversed.", " Clear the order ", " Submit cancel request again ", " Wait more time ")
                    if mbox == 2:
                        return
                    if mbox == 1:
                        mbox = QuestionBox("Are you sure want to try and submit the cancellation again? It is recommended you wait.",  " Yes ", " No ")
                        if mbox == 1:
                            return
                        o=-1
                        for order in MyContracts:
                            o+=1
                            if order['ordernumber']==PendingSelected['ordernumber']:
                                if MyContracts[o]['cancel'] != 1:
                                    MyContracts[o]['cancelold']=MyContracts[o]['cancel']
                                    MyContracts[o]['cancel']=1
                        return
                    if found==0:
                        mbox = QuestionBox("Are you sure want to clear the order? You may risk losing the coins if the cancel request does not finish.",  " Yes ", " No ")
                    if mbox == 1:
                        return
                    updatesomething=1
                    DeleteOrder(PendingSelected['ordernumber'])
                    DeleteContract(PendingSelected)
                    return
            if "Failed" in PendingSelected['Process'] and ff==0:
                QuestionBox("The broadcast failed. Follow the instructions to complete your refund.", "OK")
            if 'cancel' not in PendingSelected and "Failed" not in PendingSelected and ff==0:
                mbox = QuestionBox("You are now creating and broadcasting the contract, please wait until it confirms.", " Okay, thanks ", " Cancel the contract ")
            else:
                mbox=1
            if mbox == 0:
                return
            if "Failed" not in PendingSelected['Process']:
                mbox = QuestionBox("There is no guarantee your cancellation will work. The transactions get sent out on the network. The only way to know if it will fund is to wait. Any tampering or attempts to stall will cause a delay or denial of the transaction. If days pass and the contract is still in the pending tab then you can choose to withdraw your funds. Otherwise, escrow will fund once it clears.", " Cancel the contract ", " Okay, I will wait ")
                if mbox == 1:
                    return
            mbox = QuestionBox("Are you sure you want to attempt to cancel? If escrow funds you will still be committed to the deal.", " Yes ", " No ")
            if mbox == 1:
                return
            if PendingSelected['mydeposit']==0:
                if PendingSelected['currentblock']+300<CurrentBlock:
                    QuestionBox("You may not cancel this type of deal for at least 50 hours.","OK")
                    return
                DeleteContract(PendingSelected)
                return
            multisig,multiscript=create_multisig_address(PrivKeyFilename1)
            valval=0
            for chg in PendingSelected['inputs']:
                valval+=chg['value']
            timest=timestamp
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                #Spending one input is enough to cancel if it hasn't left the account
                valval=PendingSelected['inputs'][0]['value']
                #Get liquidity                
                try:
                    busy=NetSplash(1, checkwait=1)
                    if TestnetPeg:
                        liquid, reserve=ThePeg.checktransaction(PendingSelected['inputs'][0]['output'])
                    else:
                        fractions=BLK.getfractions(PendingSelected['inputs'][0]['output'])
                        liquid, reserve=ThePeg.formatfractions(fractions, PendingSelected['inputs'][0]['address'], valval)
                    if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                        QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before trying to spend.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                        return False
                    combined=ThePeg.checkliquidity(liquid,reserve)
                    if combined == False:
                        float('a')
                    liq=json_deep_copy(combined)
                    NetSplash(0)
                except:
                    NetSplash(0)
                    traceback.print_exc()
                    QuestionBox("Transaction lookup failed. Software is busy, please try again.", " OK ")
                    return
                ltot=liq['ltotal']
                rtot=liq['rtotal']
                ftot=0
                #For now, we just freeze a buffer if we are close to a rate change
                if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                    ftot=liq['nfreeze']
                ltot-=ftot                                                                         
                rtot+=ftot
                if ltot==0:
                    outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':(int(PendingSelected['inputs'][0]['value'])-int(PendingSelected['fee'])),'script':address_to_script(multisig)}]
                else:
                    outs=[]
                    if rtot!=0:
                        outs=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':int(rtot),'script':address_to_script(multisig)}]
                    outs.append({'value':(int(PendingSelected['inputs'][0]['value'])-int(PendingSelected['fee'])-int(rtot)),'script':address_to_script(multisig)})
                ins=[PendingSelected['inputs'][0]]
            else:
                broadcastout={'value':valval-PendingSelected['fee'],'address':multisig}
                outs=[]
                outs.append(broadcastout)
                ins=PendingSelected['inputs']
            

            #Ok lets get the transaction id and the raw needed to make sure order works
            AmFirst=AmIFirst(PrivKeyFiledir1,PrivKeyFilename1)
            if AmFirst==1:
                sigs,result=create_sig_for_redemption(ins,outs, PrivKeyFilename1, PrivKeyFiledir1, timest, unlockthis = "1")
                if result == False:
                    QuestionBox("Incorrect password.", "OK")
                    return
                sigs2,result=create_sig_for_redemption(ins,outs, PrivKeyFilename2, PrivKeyFiledir2, timest, unlockthis = "1")
                if result == False:
                    QuestionBox("Incorrect password.", "OK")
                    return
            else:
                sigs,result=create_sig_for_redemption(ins,outs, PrivKeyFilename2, PrivKeyFiledir2, timest, unlockthis = "1")
                if result == False:
                    QuestionBox("Incorrect password.", "OK")
                    return
                sigs2,result=create_sig_for_redemption(ins,outs, PrivKeyFilename1, PrivKeyFiledir1, timest, unlockthis = "1")
                if result == False:
                    QuestionBox("Incorrect password.", "OK")
                    return
            if AmFirst==1:
                tx,result=broadcast_to_network(sigs,sigs2,ins,outs,PrivKeyFilename1, timest, splashme=1)
            else:
                tx,result=broadcast_to_network(sigs2,sigs,ins,outs,PrivKeyFilename1, timest, splashme=1)
            if "TX rejected" in str(result):
                pass
            else:
                QuestionBox(str(txhash(tx))+"\n"+Gtranslate("If the transaction goes through, it will reflect in your balance. Otherwise it will show up in the 'Open Contracts' tab. You can check back here later for a status update."), Gtranslate("OK"),1)
                o=-1
                for order in MyContracts:
                    o+=1
                    if order['ordernumber']==PendingSelected['ordernumber']:
                        MyContracts[o]['cancel']=str(txhash(tx))
                return
            #Ok it was rejected... we can try to spend from temporary but later because we would rather know the txid
            o=-1
            for order in MyContracts:
                o+=1
                if order['ordernumber']==PendingSelected['ordernumber']:
                    MyContracts[o]['cancel']=1#This will let us know to try a refund later(withdrawing from our temporary account)
                    if MyContracts[o]['status'] != "Broadcast":
                        MyContracts[o]['status']="Broadcast"#We do this because an email could have been missed or the first tx went through, if an email got deleted we could even be in escrow
                        MyContracts[o]['Broadcast']="them"#We don't want to submit anything by accident either also if we are broadcasting it prevents sending to escrow.
                        if MyContracts[o]['instantamount']!=0 and "I am" in MyContracts[o]['instantwhopays']:#Okay we don't want to broadcast anything but we will refuse to go into escrow without that signature(if they try to broadcast for us)
                            MyContracts[o]['noescrow']=1
            QuestionBox(str(txhash(tx))+"\n"+Gtranslate("The transaction did not go through yet. ")+CoinSelect['HaloName'] + Gtranslate(" will continue to check the accounts and attempt a refund. Please come back later to check on your cancellation."), Gtranslate("OK"),1)
        if "Offer accepted! Sending information to counter-party: " in t or "Market Offer: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            mbox = QuestionBox(Gtranslate("You have accepted an offer! You now are waiting for a reply. Your option at this point is to wait for their confirmation or acceptance."+"\nOrder # ") + current['ordernumber'], Gtranslate(" Okay, thanks "), Gtranslate(" Cancel this contract "),1)
            if mbox == 0:
                return
            res=QuestionBox("Waiting is recommended. Are you sure you want to cancel this order?"," Yes "," No ")
            if res==1:
                return
            #Ok they want to clear it... lets find the order in spendable and remove it
            updatesomething=1
            DeleteOrder(PendingSelected['ordernumber'])
            Reply={}#We must tell them we are canceling or they will be waiting at making transactions. This situation only happens if both parties assumed a delay.
            Reply['Process']='CancelTX'
            Reply['Command']='Send'
            Reply['MyBMAddress']=PendingSelected['MyBMAddress']
            Reply['TheirBMAddress']=PendingSelected['TheirBMAddress']
            Reply['ordernumber']=PendingSelected['ordernumber']
            BitQueue.append(Reply)
            DeleteContract(PendingSelected)
        if "Received Offer! - Click for description and actions: " in t or "Received Counter-Offer! - Click for description and actions: " in t:
            t=t.replace("Received Offer! - Click for description and actions: ", "")
            t=t.replace("Received Counter-Offer! - Click for description and actions: ", "")
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            f=0
            data=""
            if PendingSelected != []:
                b64img=PendingSelected['Details']['image']
                width=0
                height=0
                try:
                    #b64img=GlobalImage
                    #b64img += "=" * ((4 - len(b64img) % 4) % 4) #This is for incorrect padding error
                    image_string = StringIO.StringIO(base64.b64decode(b64img))
                    image = Image.open(image_string)
                    tup=image.size
                    width=tup[0]
                    height=tup[1]
                    if width>460 and height<200:
                        height=200
                    if height>200 and width<460:
                        width=460
                    if width>460 or height>200:
                        WindowReceived.resize(width+50, height+210)
                    b64img=ConvertImage(b64img,"base64",False)
                    data+="<img src=\"data:image/png;base64,"+b64img+"\"/>"
                    image_string.close()
                    image_string=""
                except Exception, e:
                    image_string.close()
                    image_string=""
                    traceback.print_exc()
                    pass
                data+="<br />"
                data+="Contract Halo version " + str(PendingSelected['version'])+"<br />"
                data+="From: " + str(PendingSelected['TheirBMAddress']) + "<br />"
                data+=str(PendingSelected['whopays'])+"<br />"
                data+="Amount: "+str(Decimal(PendingSelected['amount'])/Decimal(1e8))+"<br />"
                data+="My Deposit: "+str(Decimal(PendingSelected['mydeposit'])/Decimal(1e8))+"<br />"
                data+="Their Deposit: "+str(Decimal(PendingSelected['theirdeposit'])/Decimal(1e8))+"<br />"
                if PendingSelected['instantamount'] != 0:
                    f+=.5
                    data+="Instant refund: ("+str(PendingSelected['instantwhopays'])+")<br />"
                    data+="Amount: " + str(Decimal(PendingSelected['instantamount'])/Decimal(1e8))+"<br />"
                f+=1#Temporary account
                f+=1#Split escrow fund/release
                data+="<br />"
                data+="Fee: "+str(Decimal(PendingSelected['fee']*f)/Decimal(1e8))+"<br />"
                data+="Time limit: "+str(PendingSelected['timeout'])+" Hours -- "+str(round((PendingSelected['timeout']/24),2))+" Days<br />"
                data+="Order number: "+str(PendingSelected['ordernumber'])
                data+="<br /><br />"
                data+="Description: <br />"
                data+=PendingSelected['Details']['description']

                WindowReceived.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">"+data+"</span></p></body></html>")
            WindowReceived.show()
        if "Market Order: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            current = GetCurrentOrder(current)
            Templates.showorder(current, 1)
        if "Sent Offer... sent offer details awaiting response - Click for actions: " in t or "Sent Counter-Offer... sent offer details awaiting response - Click for actions: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            f=0
            data=""
            if PendingSelected != {}:
                b64img=PendingSelected['Details']['image']
                width=0
                height=0
                try:
                    #b64img=GlobalImage
                    #b64img += "=" * ((4 - len(b64img) % 4) % 4) #This is for incorrect padding error
                    image_string = StringIO.StringIO(base64.b64decode(b64img))
                    image = Image.open(image_string)
                    tup=image.size
                    width=tup[0]
                    height=tup[1]
                    if width>460 and height<200:
                        height=200
                    if height>200 and width<460:
                        width=460
                    if width>460 or height>200:
                        WindowSent.resize(width+50, height+210)
                    b64img=ConvertImage(b64img,"base64",False)
                    data+="<img src=\"data:image/png;base64,"+b64img+"\"/>"
                    image_string.close()
                    image_string=""
                except Exception, e:
                    image_string.close()
                    image_string=""
                    traceback.print_exc()
                    pass
                data+="<br />"
                data+="Contract Halo version " + str(PendingSelected['version'])+"<br />"
                data+="From: " + str(PendingSelected['TheirBMAddress']) + "<br />"
                data+=str(PendingSelected['whopays'])+"<br />"
                data+="Amount: "+str(Decimal(PendingSelected['amount'])/Decimal(1e8))+"<br />"
                data+="My Deposit: "+str(Decimal(PendingSelected['mydeposit'])/Decimal(1e8))+"<br />"
                data+="Their Deposit: "+str(Decimal(PendingSelected['theirdeposit'])/Decimal(1e8))+"<br />"
                if PendingSelected['instantamount'] != 0:
                    f+=.5
                    data+="Instant refund: ("+str(PendingSelected['instantwhopays'])+")<br />"
                    data+="Amount: " + str(Decimal(PendingSelected['instantamount'])/Decimal(1e8))+"<br />"
                f+=1#Temporary account
                f+=1#Split escrow fund/release
                data+="<br />"
                data+="Fee: "+str(Decimal(PendingSelected['fee']*f)/Decimal(1e8))+"<br />"
                data+="Time limit: "+str(PendingSelected['timeout'])+" Hours -- "+str(round((PendingSelected['timeout']/24),2))+" Days<br />"
                data+="Order number: "+str(PendingSelected['ordernumber'])
                data+="<br /><br />"
                data+="Description: <br />"
                data+=PendingSelected['Details']['description']

                WindowSent.textBrowser.setHtml("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        "p, li { white-space: pre-wrap; }\n"
        "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:11px; font-weight:400; font-style:normal;\">\n"
        "<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:11px;\">"+data+"</span></p></body></html>")
            WindowSent.show()
        if "Received Counter-Offer from Market - Click for actions: " in t or "Received Matching Offer from Market - Click for actions: " in t or "Received Matching Bid/Offer from Market" in t or "Received Bid/Offer from Market - Click for actions: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            Templates.showorder(PendingSelected)
        if "Sent Bid/Offer - Click for actions: " in t or "Sent Counter-Offer - Click for actions: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            Templates.showorder(PendingSelected, 3)
        if "Incoming Offer... requesting handshake - Click for actions: " in t:
            t=t.replace("Incoming Offer... requesting handshake - Click for actions: ","")
            current=GetCurrentOrder(t)
            PendingSelected = current
            WindowHandshake.show()

        if "Sent Offer... sent encrypted message with Email/Bitmessage address - Click for actions: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            mbox = QuestionBox(Gtranslate("You sent the counter-party a")+" "+CoinSelect['name']+" "+Gtranslate("encrypted message. Your only option at this point is to cancel the request or wait for the response. Be patient their client will have to be open and see the request before you get a reply."), Gtranslate(" Okay, Thanks "), Gtranslate(" Cancel Order "),1)
            if mbox == 0:
                return
            mbox = QuestionBox(Gtranslate("Are you sure you want to clear the order?")+"\n" + "\nOrder # " + PendingSelected['ordernumber'], Gtranslate(" Yes "), Gtranslate(" No "),1)
            if mbox == 1:
                return
            #Ok they want to clear it... lets find the order in spendable and remove it
            updatesomething=1
            DeleteOrder(PendingSelected['ordernumber'])
            DeleteContract(PendingSelected)
        if "Failed: " in t:
            t=t.replace("Failed: ","")
            t=str(t).encode('unicode-escape').decode('utf-8')[:80]
            matchObj = re.match( r'(.*)(Order number: )(.*)( )', t, re.M|re.I|re.U)
            current=str(matchObj.group(3)).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            mbox = QuestionBox(Gtranslate("Your only option at this point is to clear the order. Signature failure is the most common reason." + "\nReason for failure: ")+current['Reason']+"\nOrder # " + current['ordernumber'], Gtranslate(" Clear now "), Gtranslate(" Clear later "),1)
            if mbox == 1:
                return
            #Ok they want to clear it... lets find the order in spendable and remove it
            updatesomething=1
            DeleteOrder(current['ordernumber'])
            DeleteContract(current)
        if "Expired" in t:
            t=t.replace("Expired","")
            t=str(t).encode('unicode-escape').decode('utf-8')[:80]
            matchObj = re.match( r'(.*)(Order number: )(.*)( )', t, re.M|re.I|re.U)
            current=str(matchObj.group(3)).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            #Eventually it might be nice to give the option to automatically clear these.
            #Because a valid offer requires signed inputs, the buffer of change will determine the expiration time.
            mbox = QuestionBox("This offer has expired. This can happen because of changes in the supply made the offer invalid. To avoid this situation it's best for users to be quick to respond to offers the same day that they are received."," Clear now ", " Clear later ",1)
            if mbox == 1:
                return
            #Ok they want to clear it... lets find the order in spendable and remove it
            updatesomething=1
            DeleteOrder(current['ordernumber'])
            DeleteContract(current)
        if "Sent Offer - Click for actions: " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            mbox = QuestionBox("An offer has been privately sent, you are waiting for a reply.", " Okay, thanks ", " Cancel Offer ")
            if mbox == 0:
                return
            res=QuestionBox("Are you sure you want to cancel this offer?","Yes","No")
            if res==1:
                return
            updatesomething=1
            DeleteOrder(current['ordernumber'])
            DeleteContract(current)
        if "Joint Account Offer: " in t or "Joint Account Confirmed! " in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            if current['status']=="Joint Account Offer":
                mbox = QuestionBox(Gtranslate("Do you want to cancel the Joint Account Offer?") + "\nOrder # " + current['ordernumber'], Gtranslate(" Yes "), Gtranslate(" No "),1)
                if mbox == 1:
                    return
                DeleteContract(current)
                SaveContracts()
                return
            if current['status']=="Joint Account Offer2":
                QuestionBox("Joint account created! In order to test it, please go to file/open and load the key. Once loaded, please remember to backup your key. You can change the settings for the account in 'Advanced Sending' in the Send tab in the client.\n\nMake sure your counter-party has their account loaded and backed up successfully before funding.", "OK")
                mbox = QuestionBox("Do you want to clear the notification?", " Yes ", " No ")
                if mbox == 1:
                    return
                DeleteContract(current)
                SaveContracts()
                return
            if current['status']=="Joint Account Offer1":
                mbox = QuestionBox("You got an offer to form a joint account. If you accept, you will get 50% control of the new account and you can pay in two steps, pay multiple addresses in single payments and do joint accounting. This is also good for two factor authentication with two computers for high security accounts.\n\n Do you accept the offer?", " Accept Offer ", " Reject Offer ")
                if mbox == 1:
                    mbox = QuestionBox(Gtranslate("Do you want to clear the order?") + "\nOrder # " + current['ordernumber'], Gtranslate(" Yes "), Gtranslate(" No "),1)
                    if mbox == 1:
                        return
                    DeleteContract(current)
                    SaveContracts()
                    return
                try:
                    privpath1 = QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Create your joint account key and store it somewhere you will remember."),MacDir()+"key1.private","Private Key File (*.private)")
                    file1=QtCore.QDir(privpath1)
                    filedir1=strOUT(strIN(QtCore.QString(file1.path().replace(file1.dirName(),""))))
                    file1=strOUT(strIN(QtCore.QString(file1.dirName())))
                    tmp,pub,priv=create_tmp_address_and_store_keypair(file1,filedir1,current['public'])
                    if pub=="":
                        return
                except:
                    QuestionBox("Joint account creation failed.", "OK")
                    return
                Reply={}
                Reply['type']='CONTRACT'
                Reply['status']='Joint Account Offer2'
                Reply['Command']='Send'

                Reply['Process']='Joint'
                Reply['version']=CoinSelect['HaloName'] + " " + clientversion
                Reply['currentblock']=CurrentBlock

                Reply['oldordernumber']=current['ordernumber']#We send this to make sure they dont keep re-reading the same messages. Its not turn based anymore.
                Reply['ordernumber']=os.urandom(16).encode('hex')
                Reply['public']=pub
                Reply['TheirBMAddress']=current['TheirBMAddress']
                Reply['MyBMAddress']=current['MyBMAddress']
                Reply['BitHaloClient']=BitHaloClient
                BitQueue.append(Reply)
                SaveQueue()
                QuestionBox("Joint account created! In order to test it, please go to file/open and load the key. Once loaded, please remember to backup your key. You can change the settings for the account in 'Advanced Sending' in the Send tab in the client.\n\nMake sure your counter-party has their account loaded and backed up successfully before funding.", "OK")
                DeleteContract(current)
                SaveContracts()
                return
        if "Received Two Step Spend Request: "  in t:
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            self.TwoStepSendpt2(current)
            mbox = QuestionBox(Gtranslate("Do you want to clear the order?") + "\nOrder # " + current['ordernumber'], Gtranslate(" Yes "), Gtranslate(" No "),1)
            if mbox == 1:
                return
            DeleteContract(current)
            SaveContracts()
        if "Received Pay To Email! - Password requested: " in t:
            t=t.replace("Received Pay To Email! - Password requested: ","")
            current=(str(t).split(' Order number: ')[1].split('  Their Address: ')[0]).strip()
            PendingSelected = GetCurrentOrder(current)
            current=PendingSelected
            text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Enter the password for this payment:'), QtGui.QLineEdit.Password)
            priv = password.DecryptWithAES(str("Halo Master"), current['priv'])
            priv = priv.replace("PASSWORDPROTECTED:","")
            try:
                priv = password.DecryptWithAES(str(text), priv)
            except:
                res=QuestionBox("Password was incorrect would you like cancel the payment or try again later?", " Try again ", " Cancel Payment ")
                if res==1:
                    res=QuestionBox("Are you sure you want to clear the payment?"," Yes "," No ")
                    if res==0:
                        DeleteContract(current)
                        return
                    else:
                        return
                return
            if BitHaloClient == True:
                tmptx = pybit.transaction.mktx([{'output':str(current['Confirmation TXID'])+":0",'value':int(current['amount']),'address':str(current['Temporary Address'])}],[{'value':(int(current['amount'])-int(current['fee'])),'address':str(multisig)}])
            else:
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    #Get liquidity
                    try:
                        busy=NetSplash(1, checkwait=1)
                        if TestnetPeg:
                            liquid, reserve=ThePeg.checktransaction(str(current['Confirmation TXID'])+":0")
                        else:
                            fractions=BLK.getfractions(str(current['Confirmation TXID'])+":0")
                            liquid, reserve=ThePeg.formatfractions(fractions, current['Temporary Address'], int(current['amount']))
                        if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                            QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before trying to spend.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                            return False
                        combined=ThePeg.checkliquidity(liquid,reserve)
                        if combined==False:
                            float('a')
                        liq=json_deep_copy(combined)
                        NetSplash(0)
                    except:
                        NetSplash(0)
                        traceback.print_exc()
                        QuestionBox("Transaction lookup failed. Software is busy, please try again.", " OK ")
                        return
                    ltot=liq['ltotal']
                    rtot=liq['rtotal']
                    ftot=0
                    #For now, we just freeze a buffer if we are close to a rate change
                    if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                        ftot=liq['nfreeze']
                    ltot-=ftot                                                                         
                    rtot+=ftot
                    if ltot==0:
                        p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':(int(current['amount'])-int(current['fee'])),'script':address_to_script(multisig)}]
                    else:
                        p2mouts=[]
                        if rtot!=0:
                            p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':int(rtot),'script':address_to_script(multisig)}]
                        p2mouts.append({'value':(int(current['amount'])-int(current['fee'])-int(rtot)),'script':address_to_script(multisig)})
                    tmptx = mktx_script(timestamp,[{'output':str(current['Confirmation TXID'])+":0",'value':int(current['amount']),'address':str(current['Temporary Address'])}],p2mouts)
                else:
                    tmptx = mktx(timestamp,[{'output':str(current['Confirmation TXID'])+":0",'value':int(current['amount']),'address':str(current['Temporary Address'])}],[{'value':(int(current['amount'])-int(current['fee'])),'address':str(multisig)}])
            tx = signall(tmptx,priv)
            hist={}
            hist['Amount']=str(dropzeros((Decimal(current['amount'])/Decimal(1e8)),1))
            hist['Details']=current
            hist['Details']['date']=ConvertDate(HaloTime,0)
            hist['Details']['Pending']=False
            hist['Type']="Pay To Email"
            hist['Label']=''
            if multisig not in HistoryDetail:
                HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
            if rescanning==1:
                QuestionBox("The blockchain is currently rescanning. Please wait until this completes.", "OK")
                return
            if interneton==0:
                QuestionBox("You are not connected to the internet.", "OK")
                return
            if BitHaloClient:
                rspns = sendBTCtx(tx)
            else:
                try:
                    busy=NetSplash(1, checkwait=1)                    
                    rspns = BLK.sendrawtransaction(tx)
                    NetSplash(0)
                except:
                    NetSplash(0)
                    rspns = "TX rejected"
                    print tx
            if "TX rejected" in str(rspns):
                if current['currentblock']==0 and CurrentBlock > 11:
                    current['currentblock']=CurrentBlock-10
                if current['currentblock']+18>CurrentBlock:#They may have sent it last minute. For now, we can have the protocol remove the order
                    pass
                mbox = QuestionBox(Gtranslate("The transaction was rejected! Its possible the order expired or the counter-party canceled or the TXID changed and they will have to redeem it. Do you want to clear the offer from this computers history?\n") + "\nOrder # " + current['ordernumber'], Gtranslate(" Yes "), Gtranslate(" No "),1)
                if mbox == 1:
                    return
                hist['Details']['Redeemed']=0
                hist['Details']['explain']="Payment not redeemed! May have expired or counterparty canceled the transaction."
                if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
                    HistoryDetail[multisig]=[hist]
                else:
                    HistoryDetail[multisig].insert(0,hist)
                PopulateHistory()
                DeleteContract(current)
                SaveContracts()
            else:
                QuestionBox(str(txhash(tx))+"\n"+Gtranslate("Pay to email completed."), Gtranslate("OK"),1)
                hist['Details']['Redeemed']=1
                if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
                    HistoryDetail[multisig]=[hist]
                else:
                    HistoryDetail[multisig].insert(0,hist)
                PopulateHistory()
                DeleteContract(current)
                SaveContracts()
    def BrowseBackup(self):     
        privpath1="contracts.dat"
        while "contracts.dat" in privpath1.lower():
            privpath1 = strOUT(strIN(QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Choose a location for your backup."),MacDir()+"ContractsBackup.dat","Contract File (*.dat)")))
            if "contracts.dat" in privpath1.lower():
                QuestionBox("Please choose a different name for your backup path.", "OK")
            elif "pegdatabase" in privpath1.lower():
                QuestionBox("Please choose a different directory for your backup path.", "OK")
            else:
                try:
                    if not os.path.isfile(privpath1):
                        with open(privpath1,'w') as f:
                            f.flush()
                            os.fsync(f)
                            f.close()
                except:
                    traceback.print_exc()
                    res=QuestionBox("Error writing file. Please choose a different directory or file name.", "OK", "Cancel")
                    privpath1="contracts.dat"
                    if res==1:
                        return
        UpdateCfg('#BackupPath#',privpath1)
        self.TxBackupPath.setText(strOUT(privpath1))

    def ClearPage(self):
        window.ContractTo.setText("")
        window.ContractAmount.setText("")
        window.InstantAmount.setText("")
        window.YouDeposit.setText("")
        window.TheyDeposit.setText("")
        window.ContractTime.setText("")
        window.DescriptionBox.setText("")
        window.ImageBox.setText("")
        window.WhoPays.setCurrentIndex(0)
        window.InstantWhoPays.setCurrentIndex(0)
        window.DaysMultiplier.setCurrentIndex(0)
    def BufferCheck(self, spendme, contract=0):
        future=0
        liquid=0
        for i in spendme:
            if contract==0:
                future+=i['liquidity']['nfreeze']
            else:
                future+=i['liquidity']['future']
            liquid+=i['liquidity']['ltotal']
        return future, liquid
    def RateLiquid(self, inputs):
        global BlackUnspent
        txidlist={}
        liq={}
        for i in inputs:
            txidlist[i['output']]=1
        for i in BlackUnspent:
            if i['txid']+':'+str(i['vout']) in txidlist:
                for l in i['liquidity']:
                    if len(str(l))>20:
                        a=l
                        break
                for l in i['liquidity'][a]:
                    if len(str(l))<5:
                        if str(l) not in liq:
                            liq[str(l)]=i['liquidity'][a][str(l)]
                        else:
                            liq[str(l)]+=i['liquidity'][a][str(l)]
        rating=ThePeg.rateliquidity(liq)
        print "Liquidity: " + str(rating)
        return rating[0]
    def SendMyContract(self, apicontract=None, mode=1):
        global Spendable, OnOrders, MyContracts, updatesomething, MyEmail, BitHaloClient, GlobalImage, Markets, GlobalID, SALT, SilenceUI, globperc, exoticnotify, btcfeekb, myblockcount
        if apicontract==None:
            apicontract={}
        backup=GetfromCfg("#BackupPath#")
        lockme=""
        if apicontract=={}:
            lockme = lockforspending            
        Templates.reply2={}#We will send them whatever is needed
        #We need to make sure api calls don't interfere with the UI, FOR NOW apicontract is only used in one template and acceptance.
        if apicontract=={} and globperc < 97 and BitHaloClient==False:
            QuestionBox("Please wait for the software to finish synchronizing before using contracts.", "OK")
            return False
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:                
                QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before using contracts.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                return False
        if apicontract!={}:
            if mode==1:#accept a market order
                address="Accept Market: "+apicontract['ordernumber']
                if 'selected' in apicontract['Market Data']['reply'] and apicontract['Market Data']['Template']=="Sell Coins":#The original offer was accepted(we were the offeror)
                    Templates.reply2['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
                    try:
                        fnd=0
                        for c in MyContracts:
                            if 'oldordernumber' in apicontract:
                                if c['ordernumber']==apicontract['oldordernumber']:
                                    fnd=1
                                    break
                        if fnd==1:
                            Templates.reply2['Profiles'][apicontract['Market Data']['reply']['selected']].append(c['Market Data']['Profiles'][apicontract['Market Data']['reply']['selected']][0])
                    except:
                        traceback.print_exc()
            SilenceUI=1
        if backup == " ":
            QuestionBox("Please configure an automatic backup path before proceeding and try again.", "OK")
            if SilenceUI==0:
                self.BrowseBackup()
            return False
        GetEmailGlobals()
        global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, updatesomething
        if keysconnected == "0":
            QuestionBox("No keys connected!", "OK")
            return False
        if keysconnected == "1":
            QuestionBox("You need both keys connected to send a contract!", "OK")
            return False
        testblank=str(self.ImageBox.text())
        if testblank!="Image Attached" and apicontract=={}:
            self.ImageBox.setText("")
            GlobalImage=""
            GlobalID=""
        balance=GetfromCfg("#prevbalance#")
        Accept=0
        if apicontract=={}:
            address = str(self.ContractTo.text())
            if address=="":
                QuestionBox("The destination address is blank! Please enter an address to send this contract to. Consider using the templates to help automate this process.", "OK")
                return False                
        marketorder=0
        marketreply=0
        marketdata={}
        tempcon={}
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if "Market Order: " in address:
            address=address.replace("Market Order: ", "")
            marketorder=1
        PreferredMarketAddress=""
        BitAddr=GetfromCfg("#BitMessage#")
        if self.EnableBitmessage.isChecked():
            PreferredMarketAddress+=BitAddr
        if BitAddr==" " or BitAddr=="":
            QuestionBox("Since there is no Bitmessage address loaded, Bitmhalo may not be running.", "OK")
            return False
        if not self.EnableBitmessage.isChecked():
            if not self.EnableEmail.isChecked():
                QuestionBox("Please enable either Bitmessage or Email so you can receive messages.", "OK")
                return False                
        if self.EnableEmail.isChecked():
            if MyEmail!=" " and MyEmail !="":
                BitAddr=MyEmail
                if PreferredMarketAddress!="":
                    PreferredMarketAddress+=", "
                PreferredMarketAddress+=BitAddr
        #We used to default to email, now we allow a combination of preferences
        #For now, we don't let them do exclusive Email offers to the markets.
        if "BM-" in address and "@" not in address:
            if self.EnableBitmessage.isChecked():
                BitAddr=GetfromCfg("#BitMessage#")
            else:
                QuestionBox("Bitmessage is currently disabled. Please enable it or use encrypted Email instead.", "OK")
                return False
        if "@" in address:            
            if self.EnableEmail.isChecked():
                if MyEmail!=" " and MyEmail !="":
                    BitAddr=MyEmail
                    PreferredMarketAddress=BitAddr
                else:
                    QuestionBox("Your Email did not load. Please check to make sure you have an Email connected and try again.", "OK")
                    return False
            else:
                QuestionBox("Email is currently disabled. Please enable it or use Bitmessage instead.", "OK")
                return False
        if "Accept: " in address:
            address=address.replace("Accept: ","")
            pos=-1
            for c in MyContracts:
                if c['ordernumber']==address:#ok lets populate the form(even if the party changes this data it will not do any good. Invalid data will just make escrow not fund both parties know what needs to be signed
                    Accept=1
                    if c['ordernumber']==address:
                        if "BM-" in c['TheirBMAddress']:
                            if self.EnableBitmessage.isChecked():
                                BitAddr=GetfromCfg("#BitMessage#")
                            else:
                                QuestionBox("Bitmessage is currently disabled. Please enable it in order to continue.", "OK")
                                return False
                        if "@" in c['TheirBMAddress']:
                            if self.EnableEmail.isChecked():
                                BitAddr=MyEmail
                            else:
                                QuestionBox("Email is currently disabled. Please enable it in order to continue.", "OK")
                                return False
                    window.ContractAmount.setText(str(Decimal(c['amount'])/Decimal(1e8)))
                    window.InstantAmount.setText(str(Decimal(c['instantamount'])/Decimal(1e8)))
                    window.YouDeposit.setText(str(Decimal(c['mydeposit'])/Decimal(1e8)))
                    window.TheyDeposit.setText(str(Decimal(c['theirdeposit'])/Decimal(1e8)))
                    window.ContractTime.setText(str(c['timeout']))
                    window.ContractFee.setText(str(Decimal(c['fee'])/Decimal(1e8)))
                    window.DescriptionBox.setText(c['Details']['description'])
                    if c['Details']['image']!="":
                        window.ImageBox.setText(str("Image Attached"))
                    GlobalImage=c['Details']['image']
                    GlobalID=""
                    #window.ImageBox.setText(str(c['Details']['image']))
                    if "I pay this" in c['whopays']:
                        window.WhoPays.setCurrentIndex(0)
                    else:
                        window.WhoPays.setCurrentIndex(1)
                    if "I am" in c['instantwhopays']:
                        window.InstantWhoPays.setCurrentIndex(0)
                    else:
                        window.InstantWhoPays.setCurrentIndex(1)
                    window.DaysMultiplier.setCurrentIndex(1)#change to hours
        ContOrder=[]
        ContOrdernumber=""
        if "Accept Market: " in address:
            address=address.replace("Accept Market: ","")
            fnd=0
            for c in Markets['Orders']:
                if c['ordernumber']==address:#ok lets populate the form(even if the party changes this data it will not do any good. Invalid data will just make escrow not fund both parties know what needs to be signed
                    fnd=1
                    break
            if fnd==0:
                for c in MyContracts:
                    if c['ordernumber']==address:
                        fnd=2
                        if multisig==c['theiraddress']:
                            QuestionBox("You can not accept your own order.", "OK")
                            return False
                        break
            if fnd==2:#We are accepting a counter, perhaps we need the inputs from the original order to make this work if the amount exceeds what is available
                for o in OnOrders:
                    if 'ordernumber' in o:
                        if o['ordernumber']==c['oldordernumber']:
                            for inp in o['inputs']:
                                if inp not in ContOrder:
                                    ContOrder.append(inp)
                                    ContOrdernumber=c['oldordernumber']
                    if 'oldordernumber' in o:
                        if o['oldordernumber']==c['oldordernumber']:
                            for inp in o['inputs']:
                                if inp not in ContOrder:
                                    ContOrder.append(inp)
                                    ContOrdernumber=c['oldordernumber']
            if fnd==0:
                QuestionBox("Order number not found.", "OK")
                return False
            Accept=1
            marketreply=1
            if (CoinSelect['HaloName'] + " " + clientversion) != c['version']:
                if CoinSelect['HaloName'] not in c['version']:
                    QuestionBox(Gtranslate("You must load the correct currency, this order only accepts contracts in")+" " + c['version'] + ". "+Gtranslate("Please change currencies and try again."), Gtranslate("OK"),1)
                else:
                    QuestionBox("The versions do not match. Please make sure you are up to date. Otherwise, please let the moderator know so the order can be removed.", "OK")
                return False
            if c['ordernumber']==address:
                if "BM-" in c['Market Data']['Preferred']:
                    if self.EnableBitmessage.isChecked():
                        BitAddr=GetfromCfg("#BitMessage#")
                    else:
                        QuestionBox("Bitmessage is currently disabled. Please enable it in order to continue.", "OK")
                        return False
                if "@" in c['Market Data']['Preferred']:
                    if self.EnableEmail.isChecked():
                        if MyEmail==" " or MyEmail=="":
                            if "BM-" not in c['Market Data']['Preferred'] or not self.EnableBitmessage.isChecked():
                                BitAddr=" "
                        else:
                            BitAddr=MyEmail
                    else:#We will go ahead and offer them in Bitmessage if they use both
                        if ", " not in c['Market Data']['Preferred']:#This is a private offer most likely
                            QuestionBox("Email is currently disabled. Please enable it in order to continue.", "OK")
                            return False
                if BitAddr==" " or BitAddr=="":
                    QuestionBox("Error loading return address. Please check their preferred contact method. Make sure that you are able to contact them and that your Bitmessage and/or Email address are loaded.", "OK")
                    return False
            if apicontract=={}:
                window.ContractAmount.setText(str(Decimal(c['amount'])/Decimal(1e8)))
                window.InstantAmount.setText(str(Decimal(c['instantamount'])/Decimal(1e8)))
                window.YouDeposit.setText(str(Decimal(c['mydeposit'])/Decimal(1e8)))
                window.TheyDeposit.setText(str(Decimal(c['theirdeposit'])/Decimal(1e8)))
                window.ContractTime.setText(str(c['timeout']))
                window.ContractFee.setText(str(Decimal(c['fee'])/Decimal(1e8)))
                window.DescriptionBox.setText(c['Details']['description'])
                if c['Details']['image']!="":
                    window.ImageBox.setText(str("Image Attached"))
                GlobalImage=c['Details']['image']
                GlobalID=""
                #window.ImageBox.setText(str(c['Details']['image']))
                if "I pay this" in c['whopays']:
                    window.WhoPays.setCurrentIndex(0)
                else:
                    window.WhoPays.setCurrentIndex(1)
                if "I am" in c['instantwhopays']:
                    window.InstantWhoPays.setCurrentIndex(0)
                else:
                    window.InstantWhoPays.setCurrentIndex(1)
                window.DaysMultiplier.setCurrentIndex(1)#change to hours
            else:
                amount=str(Decimal(c['amount'])/Decimal(1e8))
                instantamount=str(Decimal(c['instantamount'])/Decimal(1e8))
                mydeposit=str(Decimal(c['mydeposit'])/Decimal(1e8))
                theirdeposit=str(Decimal(c['theirdeposit'])/Decimal(1e8))
                timeout=str(c['timeout'])
                fee=str(Decimal(c['fee'])/Decimal(1e8))
                Description=c['Details']
                if "I pay this" in c['whopays']:
                    whopays=0
                else:
                    whopays=1
                if "I am" in c['instantwhopays']:
                    instantwhopays=0
                else:
                    instantwhopays=1
                daysorhours=1
            if fnd==1:
                tempcon=json_deep_copy(c,1)
        balance = int(Decimal(balance)*Decimal(1e8)) #We use Decimal to be extra sure there are no slip ups between conversions
        if apicontract=={}:
            amount = str(self.ContractAmount.text())
            instantamount = str(self.InstantAmount.text())
            mydeposit = str(self.YouDeposit.text())
            theirdeposit = str(self.TheyDeposit.text())
        #Convert online only if asked
        usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap, 0)                     
        if "$" in amount or "$" in instantamount or "$" in mydeposit or "$" in theirdeposit:
            if CoinMarketCap==" ":
                usd,btc=GetMarketValue(CoinSelect['name'])
            if "$" in amount:
                amount=str((Decimal(amount.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
            if usd=="":
                QuestionBox("Exchange rate not loaded yet. Please wait or convert the rate manually.", "OK")
                return False
            else:
                QuestionBox(Gtranslate("Please confirm the exchange rate online:")+"\n"+"USD:"+usd+"->"+CoinSelect['name']+"\nBTC:"+btc+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this. Otherwise, you may simply send the coins without denominating in dollars. If you are price tracking and do not agree with the rate posted, you might want to try again later."), Gtranslate("OK"),1)
        if "$" in instantamount:
            instantamount=str((Decimal(instantamount.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
        if "$" in mydeposit:
            mydeposit=str((Decimal(mydeposit.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
        if "$" in theirdeposit:
            theirdeposit=str((Decimal(theirdeposit.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
        if apicontract=={}:#Api counters may be an exception since it does not use field data
            window.ContractAmount.setText(amount)
            window.InstantAmount.setText(instantamount)
            window.YouDeposit.setText(mydeposit)
            window.TheyDeposit.setText(theirdeposit)

            timeout = str(self.ContractTime.text())
            fee = str(self.ContractFee.text())
            daysorhours = self.DaysMultiplier.currentIndex()

            whopays = self.WhoPays.currentIndex()
            instantwhopays = self.InstantWhoPays.currentIndex()

            image=GlobalImage
            desc=strOUT(strIN(self.DescriptionBox.toPlainText()))
            Description={}
            Description['image']=image
            Description['description']=desc
            Description['pastebin']=GlobalID

        if daysorhours==0:daysorhours="Days"
        if daysorhours==1:daysorhours="Hours"

        if whopays==0:whopays="I pay this amount"
        if whopays==1:whopays="The other party pays this amount"

        if instantwhopays==0:instantwhopays="I am depositing this/broadcasting"
        if instantwhopays==1:instantwhopays="They are depositing this/broadcasting"

        #There is a locking system to prevent people spamming the deal and sending advanced bitmessages to confuse the system. So it is turned based offer system. Only new offers can replace a locked counter.
        Counter=0
        if "Counter: " in address:#Ok a counter offer is being sent
            address=address.replace("Counter: ", "")
            for c in MyContracts:
                if c['ordernumber']==address:
                    if "BM-" in c['TheirBMAddress']:
                        if self.EnableBitmessage.isChecked():
                            BitAddr=GetfromCfg("#BitMessage#")
                        else:
                            QuestionBox("Bitmessage is currently disabled. Please enable it in order to continue.", "OK")
                            return False
                    if "@" in c['TheirBMAddress']:
                        if self.EnableEmail.isChecked():
                            BitAddr=MyEmail
                        else:
                            QuestionBox("Email is currently disabled. Please enable it in order to continue.", "OK")
                            return False
                    if BitAddr==" " or BitAddr=="":
                        QuestionBox("Error loading return address. Please check their preferred contact method. Make sure that you are able to contact them and that your Bitmessage and/or Email address are loaded.", "OK")
                        return False
                    Counter=1

        if "Counter Market: " in address:
            if str(instantamount)!="" and str(instantamount)!="0":
                QuestionBox("Instant refund is disabled in market orders. Please create your counter-offer again without this set.", " OK ")
                self.InstantAmount.setText("")
                window.InstantWhoPays.setCurrentIndex(0)
                return False
            address=address.replace("Counter Market: ","")
            pos=-1
            for c in MyContracts:
                if c['ordernumber']==address:
                    if 'MCount' in c['Process']:
                        Counter=1
                        marketreply=1
                        if (CoinSelect['HaloName'] + " " + clientversion) != c['version']:
                            QuestionBox(Gtranslate("You must load the correct currency, this order only accepts contracts in ") + c['version'] + ". "+Gtranslate("Please change currencies and try again."), Gtranslate("OK"),1)
                            return False
                        if c['ordernumber']==address:
                            if "BM-" in c['Market Data']['Preferred']:
                                if self.EnableBitmessage.isChecked():
                                    BitAddr=GetfromCfg("#BitMessage#")
                                else:
                                    QuestionBox("Bitmessage is currently disabled. Please enable it in order to continue.", "OK")
                                    return False
                            if "@" in c['Market Data']['Preferred']:
                                if self.EnableEmail.isChecked():
                                    if MyEmail==" " or MyEmail=="":
                                        if "BM-" not in c['Market Data']['Preferred'] or not self.EnableBitmessage.isChecked():
                                            BitAddr=" "
                                    else:                                    
                                        BitAddr=MyEmail
                                else:
                                    if ", " not in c['Market Data']['Preferred']:#This is a private offer most likely
                                        QuestionBox("Email is currently disabled. Please enable it in order to continue.", "OK")
                                        return False                                    
                            if BitAddr==" " or BitAddr=="":
                                QuestionBox("Error loading return address. Please check their preferred contact method. Make sure that you are able to contact them and that your Bitmessage and/or Email address are loaded.", "OK")
                                return False
                        for o in OnOrders:
                            if 'ordernumber' in o:
                                if o['ordernumber']==c['oldordernumber']:
                                    for inp in o['inputs']:
                                        if inp not in ContOrder:
                                            ContOrder.append(inp)
                                            ContOrdernumber=c['oldordernumber']
                            if 'oldordernumber' in o:
                                if o['oldordernumber']==c['oldordernumber']:
                                    for inp in o['inputs']:
                                        if inp not in ContOrder:
                                            ContOrder.append(inp)
                                            ContOrdernumber=c['oldordernumber']
            for c in Markets['Orders']:
                if c['ordernumber']==address:#ok lets populate the form(even if the party changes this data it will not do any good. Invalid data will just make escrow not fund both parties know what needs to be signed
                    if multisig==c['theiraddress']:
                        QuestionBox("You can not counter your own order.", "OK")
                        return False
                    if c['Market Data']['Template']=='Barter':
                        if Decimal(amount)!=Decimal(".0001"):
                            QuestionBox("Barter contracts must have an amount of 10000 satoshis, you cannot change the amount.", "OK")
                            return False
                        if whopays!=c['whopays']:
                            QuestionBox("You can not change who pays on a barter contract.", "OK")
                            return False
                    Counter=1
                    marketreply=1
                    if (CoinSelect['HaloName'] + " " + clientversion) != c['version']:
                        QuestionBox(Gtranslate("You must load the correct currency, this order only accepts contracts in")+" " + c['version'] + ". "+Gtranslate("Please change currencies and try again."), Gtranslate("OK"),1)
                        return False
                    if c['ordernumber']==address:
                        if "BM-" in c['Market Data']['Preferred']:
                            if self.EnableBitmessage.isChecked():
                                BitAddr=GetfromCfg("#BitMessage#")
                            else:
                                QuestionBox("Bitmessage is currently disabled. Please enable it or use encrypted email instead.", "OK")
                                return False
                        if "@" in c['Market Data']['Preferred']:
                            if self.EnableEmail.isChecked():
                                if MyEmail==" " or MyEmail=="":
                                    if "BM-" not in c['Market Data']['Preferred'] or not self.EnableBitmessage.isChecked():
                                        BitAddr=" "
                                else:                                   
                                    BitAddr=MyEmail
                            else:#We will go ahead and offer them in Bitmessage if they use both
                                if ", " not in c['Market Data']['Preferred']:#This is a private offer most likely
                                    QuestionBox("Email is currently disabled. Please enable it in order to continue.", "OK")
                                    return False
                        if BitAddr==" " or BitAddr=="":
                            QuestionBox("Error loading return address. Please check their preferred contact method. Make sure that you are able to contact them and that your Bitmessage and/or Email address are loaded.", "OK")
                            return False
                    tempcon=json_deep_copy(c,1)

        valid=0
        instant = 0
        #Below we check for seemingly valid inputs and we correct to a satoshi amount and absolute values
        #people who edit the counter lock will fail this test
        testaddr=address.replace(".","")
        testaddr=testaddr.replace("-","")
        if re.match("^[A-Za-z0-9@_+~|]*$", testaddr):
            valid=1
        if valid==1:
            pass
        else:
            QuestionBox("The address is not correct please make sure it contains no spaces or unusual characters.", "OK")
            return False
        try:
            float(amount)
        except ValueError:
            QuestionBox("The amount is not a valid number.", "OK")
            return False
        if instantamount == "" or instantamount == "0":
            pass
        else:
            instant = 1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                QuestionBox("Instant refund is disabled for pegged coins.", "OK")
                return
            try:
                float(instantamount)
            except ValueError:
                QuestionBox("The instant amount is not a valid number.", "OK")
                return False
        try:
            float(fee)
        except ValueError:
            QuestionBox("The fee requested is not a valid number.", "OK")
            return False
        try:
            float(mydeposit)
        except ValueError:
            QuestionBox("The deposit is not a valid number.", "OK")
            return False
        try:
            float(theirdeposit)
        except ValueError:
            QuestionBox("The deposit is not a valid number.", "OK")
            return False
        try:
            float(timeout)
        except ValueError:
            QuestionBox("The time limit must be a valid number.", "OK")
            return False
        amount = int(abs(Decimal(amount)*Decimal(1e8)))
        if instant == 1:
            instantamount = int(abs(Decimal(instantamount)*Decimal(1e8)))
            if instantamount < 5500:
                QuestionBox("The refund is below the minimum of 5500 satoshis.", "OK")
                return False
        mydeposit = int(abs(Decimal(mydeposit)*Decimal(1e8)))
        theirdeposit = int(abs(Decimal(theirdeposit)*Decimal(1e8)))
        if amount < 5500:
            QuestionBox("The amount is below the minimum of 5500 satoshis.", "OK")
            return False
        if mydeposit < 5500 and mydeposit != 0 and theirdeposit > 0:
            QuestionBox("Your deposit is below the minimum of 5500 satoshis.", "OK")
            return False
        if mydeposit==0 and whopays=="I pay this amount":
            QuestionBox("Your deposit is below the minimum of 5500 satoshis. If you want to be a guarantor, then you must pay a deposit.", "OK")
            return False
        if theirdeposit==0 and whopays=="The other party pays this amount":
            QuestionBox("Their deposit is below the minimum of 5500 satoshis. If you want them to be a guarantor, they must also pay a deposit.", "OK")
            return False
        if theirdeposit < 5500 and theirdeposit !=0 and mydeposit > 0:
            QuestionBox("Their deposit is below the minimum of 5500 satoshis.", "OK")
            return False
        if mydeposit==0 or theirdeposit==0:
            if instant==1:
                QuestionBox("You must not have an instant refund with a guarantor contract. Both parties must deposit.", "OK")
                return False
        timeout = int(abs(Decimal(timeout)))
        if "Days" in daysorhours:
            timeout = timeout * 24
        fee = int(abs(Decimal(fee)*Decimal(1e8)))
        if timeout == 0:
            QuestionBox("A time limit is reqired for contracts!", "OK")
        ipay=0
        if instant == 1:
            if "I am depositing this" in instantwhopays:
                ipay+=instantamount
        ipay+=mydeposit
        #Checking available balance after unconfirmed contracts/orders
        balance2=0
        if len(Spendable)<1 and mydeposit!=0:
            QuestionBox("The history is not up to date or there are no available inputs. Please refresh internet connection or check your balance.", "OK")
            self.Tabs.setCurrentIndex(3)
            return False
        if len(Spendable)==1 and mydeposit!=0 and apicontract=={}:
            mbox = QuestionBox("You only have one input. We recommend breaking for change, dividing your balance into smaller pieces. For more information on how coins work like cash, please read the documentation. Would you like to break for change now?", " Yes ", " No ")
            if mbox != 1:
                self.Tabs.setCurrentIndex(1)
                window.BitPayTo.setText(str(multisig))
                window.BitAmount.setText(str("0.0001"))
                QuestionBox("Please review the information to confirm the address is your own. To break for change, you simply make a payment to yourself. When ready, simply click 'Send'.", "OK")
                return False
        if mydeposit!=0:
            SpendThis=list(FilterSpendable(OnOrders,Spendable,1))#Let us not worry about time locks which may get declined later
            TestSpend=list(FilterSpendable(OnOrders,Spendable))
            test1=0
            test2=0
            for i in SpendThis:
                test1+=i['value']
            for i in TestSpend:
                test2+=i['value']                            
            test1 = Decimal(test1)/Decimal(1e8)
            test2 = Decimal(test2)/Decimal(1e8)
            if test1!=test2:
                mbox=0
                if not exoticnotify:
                    mbox=QuestionBox(Gtranslate("Please note, time locked and exotic transactions are not used in contracts due to the time sensitive nature of some of these inputs. You are getting this notification because some inputs were filtered. If you would like the exotic inputs to be made available to this contract you simply need to spend them by sending some coins to yourself. The amount of funds not being considered for this transaction totals: ") + str(Decimal(test2)-Decimal(test1)), " OK ", " Break for change and free up some of the inputs ", " Don't show this message again. ", 1)
                if mbox == 1:
                    self.Tabs.setCurrentIndex(1)
                    window.BitPayTo.setText(str(multisig))
                    window.BitAmount.setText(str("0.0001"))
                    QuestionBox("Please review the information to confirm the address is your own. To break for change, you simply make a payment to yourself. When ready, simply click 'Send'.", "OK")
                    return False                    
                if mbox==2:
                    exoticnotify=True
        else:
            SpendThis=[]
        for i in SpendThis:
            balance2+=i['value']
        if "I pay this amount" in whopays:
            ipay+=amount

        #Need to filter the Spendable list and perhaps return if there is nothing available
        #Spendable and OnOrders
        #Lets stay consistent and make change whenever we can especially now that we may need the inputs
        #Lets estimate the fees
        f=0
        #The fees below will go to temporary account
        if instant !=0:#We will have to split a fee here
            f+=.5
        f+=1#For completion or cancellation request and funding escrow both of which are split (doubles as temporary account refund)
        f+=1#Sending to temporary
        if theirdeposit==0:#We need to cover their fee since it is no longer split
            f+=1

        if ipay+fee*f > balance and ContOrder == [] and mydeposit!=0:
            QuestionBox("Not enough funds!", "OK")
            return False

        difference=0
        #We need to check for input conflicts at every stage
        youshouldclear=0
        if ipay+difference+fee*f+5500 > balance2 and mydeposit!=0:
            skp=0
            orgSpendThis=list(SpendThis)
            SpendThis=[]#Lets try and use what was reserved on the original order first.
            balance3=0
            for ord1 in ContOrder:
                if ord1 not in SpendThis:
                    SpendThis.append(ord1)
                    balance3+=ord1['value']
                    if ipay+difference+fee*f+5500 > balance3:
                        continue
                    else:
                        skp=1
                        break
            if skp==0:
                #SpendThis=list(FilterSpendable(OnOrders,Spendable))
                for ord1 in orgSpendThis:
                    if ord1 not in SpendThis:
                        SpendThis.append(ord1)
                        balance3+=ord1['value']
                        if ipay+difference+fee*f+5500 > balance3:
                            continue
                        else:
                            skp=1
                            break
            if skp==0:
                QuestionBox("The reserved inputs on the outgoing orders will exceed the balance. Please check your available balance and complete/cancel your unconfirmed orders.", "OK")
                return False
            else:
                balance2=balance3
                youshouldclear=1
        #Offer fee and estimate from satoshis will just be deducted later if applicable. Above we can calculate the fees almost exactly
        if mydeposit!=0:
            try:
                inputs,outputs,Total = MakeChange (SpendThis, ipay+fee*f, multisig, 0, 1)
            except:
                traceback.print_exc()
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    future,liquid=self.BufferCheck(SpendThis, 1)
                    if liquid>=ipay+fee*f and liquid-future<ipay+fee*f:
                        tmpamt=ipay+fee*f
                        QuestionBox(Gtranslate('You do not have enough premium liquidity to enter into this contract. Because the supply rate can change during negotiations, users usually set a buffer aside as change to account for this. This guarantees that merchants receive quality coins and that the escrow process is smooth. This also means a users total balance should always have a little extra than needed for contracts.\n\nLiquid Balance: ')+str(Decimal(liquid)/Decimal(1e8))+Gtranslate('\nSubpremium(coins that may freeze soon): ')+str(Decimal(future)/Decimal(1e8))+Gtranslate('\nContract Amount: ')+str(Decimal(tmpamt)/Decimal(1e8)), Gtranslate(' OK '),1)
                        return False
                QuestionBox("Not enough available funds!", " OK ")
                return False
        else:
            inputs=[]
            outputs=[]
            Total=0
        #Fee calculation
        count=0
        mybytes=1500 # A buffer for the fee
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            mybytes*=2
        for myin in inputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:
                mybytes+=360#Double the signatures this seemed like a good rule of thumb
        for myout in outputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:
                mybytes+=34
        mybytes=int(round(mybytes,-3))
        mybytes=mybytes*10#Convert from kb to satoshi
        if BitHaloClient == True:#Bitcoin is extremely slow for large transactions, we need to really raise the fee
            mybytes=mybytes*2
        if mybytes>(int(fee)) and mydeposit!=0:
            res=QuestionBox(Gtranslate("The fee is not high enough to cover the inputs. The fee will be raised to the recommended level.\n\nRecommended Fee:")+"\n" + str(Decimal(mybytes+5000)/Decimal(1e8)), Gtranslate("OK"), Gtranslate("Cancel"),1)
            if res==1:
                return False
            else:
                difference=int(mybytes)-int(fee)+5000 #Add a SECOND buffer
                if ipay+difference+fee*f > balance and ContOrder == [] and mydeposit!=0:
                    QuestionBox("Not enough funds!", "OK")
                    return False
                #We have to repeat this process
                youshouldclear=0
                if ipay+difference+fee*f+5500 > balance2 and mydeposit!=0:
                    skp=0
                    orgSpendThis=list(SpendThis)
                    SpendThis=[]#Lets try and use what was reserved on the original order first.
                    balance3=0
                    for ord1 in ContOrder:
                        if ord1 not in SpendThis:
                            SpendThis.append(ord1)
                            balance3+=ord1['value']
                            if ipay+difference+fee*f+5500 > balance3:
                                continue
                            else:
                                skp=1
                                break
                    if skp==0:
                        #SpendThis=list(FilterSpendable(OnOrders,Spendable))
                        for ord1 in orgSpendThis:
                            if ord1 not in SpendThis:
                                SpendThis.append(ord1)
                                balance3+=ord1['value']
                                if ipay+difference+fee*f+5500 > balance3:
                                    continue
                                else:
                                    skp=1
                                    break
                    if skp==0:
                        QuestionBox("The reserved inputs on the outgoing orders will exceed the balance. Please check your available balance and complete/cancel your unconfirmed orders.", "OK")
                        return False
                    else:
                        balance2=balance3
                        youshouldclear=1
                try:
                    inputs,outputs,Total = MakeChange (SpendThis, ipay+difference+fee*f, multisig, 0, 1)#Make our new inputs
                except:
                    traceback.print_exc()
                    if 'pegging' in CoinSelect and CoinSelect['pegging']:
                        future,liquid=self.BufferCheck(SpendThis, 1)
                        if liquid>=ipay+difference+fee*f and liquid-future<ipay+difference+fee*f:
                            tmpamt=ipay+difference+fee*f
                            QuestionBox(Gtranslate('You do not have enough premium liquidity to enter into this contract. Because the supply rate can change during negotiations, users usually set a buffer aside as change to account for this. This guarantees that merchants receive quality coins and that the escrow process is smooth. This also means a users total balance should always have a little extra than needed for contracts.\n\nLiquid Balance: ')+str(Decimal(liquid)/Decimal(1e8))+Gtranslate('\nSubpremium(coins that may freeze soon): ')+str(Decimal(future)/Decimal(1e8))+Gtranslate('\nContract Amount: ')+str(Decimal(tmpamt)/Decimal(1e8)), Gtranslate(' OK '),1)
                            return False
                    QuestionBox("Not enough available funds!", " OK ")
                    return False
                #New inputs MAY have been added to cover the fee. We need to also COMPARE to the old fee
        #Final Fee Calculation Or Reject
        count=0
        mybytes=1500 # A buffer for the fee
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            mybytes*=2
        for myin in inputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:            
                mybytes+=360#Double the signatures this seemed like a good rule of thumb
        for myout in outputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:
                mybytes+=34
        mybytes2=mybytes
        mybytes=int(round(mybytes,-3))
        mybytes=mybytes*10#Convert from kb to satoshi
        if BitHaloClient == True:#Bitcoin is extremely slow for large transactions, we need to really raise the fee
            mybytes=mybytes*2
        if mybytes>(int(fee)+difference) and mydeposit!=0:
            res=QuestionBox(Gtranslate("The fee is not high enough to cover the inputs. It's possible you have many small inputs. Please break for change or increase the fee and try again."), Gtranslate("OK"), Gtranslate("Cancel"),1)
            return False
        if BitHaloClient == True:#Lets see if the fee is high enough for the network traffic
            if int(fee)/int(mybytes2)<int(btcfeekb):
                recommended=str(((Decimal(btcfeekb)*Decimal(mybytes2))+10000)/Decimal(1e8))
                res=QuestionBox(Gtranslate("The fee is not high enough for a fast confirmation in the Bitcoin network. It's possible you have many small inputs or that the network is experiencing high traffic. Please raise the fee to the recommended amount of satoshis per kilobyte.\n\nCurrent Satoshis/KB:\n")+str(int(fee)/int(mybytes2))+Gtranslate("\n\nRecommended Satoshis/KB:\n")+str(btcfeekb)+Gtranslate("\n\nRecommended minimum fee:\n")+recommended, Gtranslate("OK"),1)
                return False            
        if ContOrder == [] and mydeposit!=0:
            if ipay+difference+fee*f > balance - 5500 or ipay+difference+fee*f > balance2 - 5500:
                QuestionBox("The change on available inputs would be lower than the anti-dust minimum of 5500 satoshis. Try adding funds or free up some inputs.", "OK")
                return False

        if address == multisig:
            QuestionBox("You can not create a contract with yourself.", "OK")
            return False
        #Timestamp
        global timestamp
        timest=timestamp
        #Lets add the information for this order so that it does not get spent twice
        Order = {}
        if mydeposit!=0:
            CTotal=str(Decimal(Total)/Decimal(1e8)-Decimal(ipay)/Decimal(1e8)-Decimal(fee+difference)/Decimal(1e8))
        else:
            CTotal="0"
        if instant == 0:
            instantamount = 0
            instantwhopays = ""
        Order['Details']=Description
        Order['inputs']=inputs
        Order['mychange']=outputs
        Order['mychangetotal']=CTotal
        Order['mydeposit']=mydeposit
        Order['whopays']=whopays
        Order['instantwhopays']=instantwhopays
        Order['instantamount']=instantamount
        Order['theirdeposit']=theirdeposit
        Order['timeout']=timeout
        Order['amount']=amount
        Order['fee']=fee
        Order['type']="CONTRACT"
        Order['total']=Total
        Order['status']="offer"
        Order['version']=CoinSelect['HaloName'] + " " + clientversion
        Order['timestamp']=timest
        if Counter == 0 and Accept == 0:
            Order['theiraddress']=multisig#We will change this later for ourselves when we receive their address upon confirmation
            Order['ordernumber']=os.urandom(16).encode('hex')#If its a counter we already have this number
            Order['status']="offer"
            Order['version']=CoinSelect['HaloName'] + " " + clientversion
            Order['lock']="0" #This will start a lock so that your contracts are tightly controlled from manipulation. Its turn based. First digit states you are number one and the second digit says its their turn
        #On a counter everything needs to be redone so we may as well just perform this all again
        priv = sha256(str(os.urandom(256)+SALT))
        pub = privtopub(priv)
        priv2 = sha256(str(os.urandom(256)+SALT))
        pub2 = privtopub(priv2) #For temporary multisig
        Order['mypublic']=pub
        if Accept==1:
            mbox = QuestionBox(Gtranslate("Accepting Order Number: ") + address + "\n"+Gtranslate("Purchase Amount: ") + str(Decimal(amount)/Decimal(1e8)) + "\n"+Gtranslate("Who Pays: ") + Gtranslate(str(whopays)) +"\n"+Gtranslate("Total Fee(estimate): ") + str((Decimal(fee)*Decimal(f)+Decimal(difference))/Decimal(1e8)) + "\n"+Gtranslate("My Deposit: ") + str(Decimal(mydeposit)/Decimal(1e8)) + "\n"+Gtranslate("They Deposit: ") + str(Decimal(theirdeposit)/Decimal(1e8)) + "\n"+Gtranslate("Time Limit: ") + str(timeout) + " "+Gtranslate("hours") + "\n"+Gtranslate("Instant Refund: ") + str(Decimal(instantamount)/Decimal(1e8)) + "\n"+Gtranslate("Who pays: ") + Gtranslate(str(instantwhopays)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + Gtranslate("\nChange: ") + str(CTotal) + "\n\n"+Gtranslate("Please confirm the details.\n\nNote:\nMake sure everything is correct. All offers are final.\nMake sure you are familiar with the strategies and processes."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
        else:
            mbox = QuestionBox(Gtranslate("Sending Contract To: ") + address + "\n"+Gtranslate("Purchase Amount: ") + str(Decimal(amount)/Decimal(1e8)) + "\n"+Gtranslate("Who Pays: ") + Gtranslate(str(whopays)) +"\n"+Gtranslate("Total Fee(estimate): ") + str((Decimal(fee)*Decimal(f)+Decimal(difference))/Decimal(1e8)) + "\n"+Gtranslate("My Deposit: ") + str(Decimal(mydeposit)/Decimal(1e8)) + "\n"+Gtranslate("They Deposit: ") + str(Decimal(theirdeposit)/Decimal(1e8)) + "\n"+Gtranslate("Time Limit: ") + str(timeout) +" "+ Gtranslate("hours") + "\n"+Gtranslate("Instant Refund: ") + str(Decimal(instantamount)/Decimal(1e8)) + "\n"+Gtranslate("Who pays: ") + Gtranslate(str(instantwhopays)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + Gtranslate("\nChange: ") + str(CTotal) + "\n\n"+Gtranslate("Please confirm the details.\n\nNote:\nMake sure everything is correct. All offers are final.\nMake sure you are familiar with the strategies and processes."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
        if mbox == 1:
            return False
        #Now we need to make the multisig and generate the first txid(if not now, when?). Besides we need to sign tx1 in advance so escrow gets funding in one step
        #(We may want to store the password in a buffer too. This way, only the program knows it during runtime and we can safely protect temporary and escrow keys. Then again in case of emergencies who would sign for Bob?)
        tempaccount,tempsig=create_multisig_from_publics(pub,pub2)#To avoid the headache I am adding the keys in a "predictable order"
        Order['mytemp']=tempaccount
        out={'value':int(ipay+(fee*f)-fee),'address':tempaccount}#We deduct one fee and everything goes to temporary except the change which comes back to us.
        outputs.insert(0,out)
        #Ok lets get the transaction id and the raw need to make sure order works and do we need password in advance?
        AmFirst=AmIFirst(PrivKeyFiledir1,PrivKeyFilename1)
        #Which key signs first?
        splashthis=0
        if apicontract=={}:
            splashthis=1          
        if AmFirst==1:
            sigs,result,privk=create_sig_for_redemption(inputs,outputs, PrivKeyFilename1, PrivKeyFiledir1, timest, privme=1, splashme=splashthis, unlockthis=lockme)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False
            sigs2,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename2, PrivKeyFiledir2, timest, splashme=splashthis, unlockthis=lockme)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False
        else:
            sigs,result,privk=create_sig_for_redemption(inputs,outputs, PrivKeyFilename2, PrivKeyFiledir2, timest, privme=1, splashme=splashthis, unlockthis=lockme)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False
            sigs2,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename1, PrivKeyFiledir1, timest, splashme=splashthis, unlockthis=lockme)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False
        #Encrypt private key within order for extra backup. This protects both parties in case of data loss
        Order['myencrypted']=password.EncryptWithAES(privk,priv+priv2)
        #Ok this is getting exciting... lets broadcast!        
        if mydeposit!=0:
            if apicontract=={}:            
                NetSplash(1,0,0, checkwait=1)            
            if AmFirst==1:
                tx,result=broadcast_to_network(sigs,sigs2,inputs,outputs,PrivKeyFilename1, timest, 1)
            else:
                tx,result=broadcast_to_network(sigs2,sigs,inputs,outputs,PrivKeyFilename1, timest, 1)
        else:
            tx="00000000"
            result="Success!"
        if apicontract=={}: 
            NetSplash(0,0,0)            
        if BitAddr==" " or BitAddr == "":
            QuestionBox("Your return address is not loaded.", "OK")
            return False
        if tempcon!={}:
            MyContracts.append(json_deep_copy(tempcon,1))
            try:
                if tempcon['Market Data']['Private']==2:
                    i=0
                    for ord1 in Markets['Orders']:
                        if ord1['ordernumber']==tempcon['ordernumber']:
                            Markets['Orders'].pop(i)
                            break
                        i+=1
            except:
                print "Exception removing private market order"
        if Accept == 0:
            Order['tx1']=txhash(tx)
            Order['tx1raw']=tx
        else: #Hooray!! We accepted an offer! Lets sign everything
            Order['tx2']=txhash(tx)
            Order['tx2raw']=tx
            pos3=-1
            match2=0
            for co in MyContracts:
                pos3+=1
                if co['ordernumber']==address:#Ok lets start adding things
                    if co['Process']=="Accept" or "Making" in co['Process'] or "Broadcast" in co['Process'] or co['status']!="offer":#It got accepted or changed. We should not proceed.
                        QuestionBox("Failed! The order status has changed.", "OK")
                        return False
                    if co['timestamp']>timest:#We may not have synchronized fully yet so just use the higher timestamp
                        timest=co['timestamp']
                    timest+=30
                    match2=1
                    AccOrder = {}#The things we send them go here
                    #Generate escrow and let them know we sign first
                    if CurrentBlock !=0:
                        MyContracts[pos3]['currentblock']=CurrentBlock
                    Order['currentblock']=MyContracts[pos3]['currentblock']
                    Order['ordernumber']=co['ordernumber']
                    if 'Market Data' in co:
                        AccOrder['Market Data']={}
                    AccOrder['theiraddress']=multisig#Need to send them our address... we only have theirs
                    AccOrder['ordernumber']=co['ordernumber']
                    AccOrder['Command']='Send'
                    AccOrder['MyBMAddress']=MyContracts[pos3]['MyBMAddress']
                    AccOrder['TheirBMAddress']=co['TheirBMAddress']
                    AccOrder['Process']='Accept'
                    AccOrder['tx2']=txhash(tx)
                    AccOrder['timestamp']=timest
                    AccOrder['theirpublic']=pub
                    AccOrder['theirpublic2']=pub2
                    AccOrder['theirtemp']=tempaccount
                    escrowacc,escrowsig=create_multisig_from_publics(Order['mypublic'],co['theirpublic'])
                    AccOrder['escrow']=escrowacc
                    AccOrder['firstsign']="them"
                    AccOrder['theirencrypted']=Order['myencrypted']
                    #We make the temporary funding on our own. So if they sign something else it won't fund
                    #Because we make the escrow with a brand new key its impossible to be tricked with bogus info
                    fundinputs=[]
                    fundoutputs=[]
                    theirs={}
                    mine={}
                    theirtotal=0
                    mytotal=0
                    theirtotal+=co['theirdeposit']
                    mytotal+=co['mydeposit']
                    if "I pay this" in co['whopays']:
                        mytotal+=amount
                    else:
                        theirtotal+=amount
                    if "I am" in co['instantwhopays']:
                        mytotal+=instantamount
                    else:
                        theirtotal+=instantamount
                    #Ok lets calculate fees it should be even
                    f=0
                    if co['instantamount'] !=0:#We will have to split a fee here
                        f+=.5
                    f+=1#For completion or cancellation request and funding escrow both of which are split (doubles as temporary account refund)
                    if mytotal!=0:
                        if theirtotal==0:
                            f+=1
                        mytotal+=int(co['fee']*f)#They spent one funding temporary
                    else:
                        f+=1
                    if theirtotal!=0:
                        theirtotal+=int(co['fee']*f)#They spent one funding temporary
                    theirs['output']=unicode(str(co['tx1'])+":0")#Using insert above it should always be vout 0
                    theirs['value']=theirtotal
                    theirs['address']=co['theirtemp']
                    mine['output']=unicode(str(txhash(tx))+":0")
                    mine['value']=mytotal
                    mine['address']=tempaccount
                    if mytotal!=0:
                        fundinputs.append(mine)
                    if theirtotal!=0:
                        fundinputs.append(theirs)
                    if co['instantamount'] !=0:#If there is a refund, we do not want to depend on its transaction id for expirations so we split it
                        escrowout={'value':int(co['mydeposit']+co['theirdeposit']+co['amount']+co['fee']),'address':str(escrowacc)}#What we all pay and a fee to release
                        instantout={'value':int(co['fee']+co['instantamount']),'address':str(escrowacc)}#Now if they screw up the id, they will have to get our permission to sign again
                        fundoutputs.append(escrowout)
                        fundoutputs.append(instantout)
                    else:
                        escrowout={'value':int(theirtotal+mytotal-co['fee']),'address':str(escrowacc)}#its all one input
                        fundoutputs.append(escrowout)
                    #Here we make the tx and sign manually
                    if BitHaloClient == True:
                        tmptx = pybit.transaction.mktx(fundinputs,fundoutputs)
                    else:
                        tmptx = mktx(timest, fundinputs,fundoutputs)
                    sigs7=[]
                    try:
                        if mytotal!=0:
                            if BitHaloClient == True:
                                sigg=pybit.transaction.multisign(tmptx.decode('hex'),0,tempsig.decode('hex'),priv)
                                sigs7.append(sigg)
                                sigg=pybit.transaction.multisign(tmptx.decode('hex'),0,tempsig.decode('hex'),priv2)
                                sigs7.append(sigg)
                            else:
                                sigg=multisign(tmptx.decode('hex'),0,tempsig.decode('hex'),priv)
                                sigs7.append(sigg)
                                sigg=multisign(tmptx.decode('hex'),0,tempsig.decode('hex'),priv2)
                                sigs7.append(sigg)
                    except:
                        QuestionBox("The escrow signature was rejected!", "OK")
                        return False
                    AccOrder['tx3theirsig']=sigs7
                    if theirtotal==0:#We won't send them our sig, and can send the txid as well.
                        AccOrder['tx3theirsig']=[]
                        tx3,result=broadcast_contract_to_network(fundinputs,fundoutputs,[],MyContracts[pos3]['theirpublic'],"",pub,pub2,sigs7, timest,1)
                        AccOrder['tx3']=txhash(tx3)
                    if BitHaloClient == True:
                        AccOrder['theirversion']="BitHalo " + clientversion
                    else:
                        AccOrder['theirversion']=CoinSelect['HaloName'] + " " + clientversion
                    MyContracts[pos3]['timestamp']=timest
                    MyContracts[pos3]['status']="offer"
                    MyContracts[pos3]['theirversion']=MyContracts[pos3]['version']
                    MyContracts[pos3]['version']=AccOrder['theirversion']
                    MyContracts[pos3]['instantwhopays']=instantwhopays#Make sure they didnt send bogus info by saving what was in the form
                    MyContracts[pos3]['instantamount']=instantamount
                    MyContracts[pos3]['Process']='Accept'
                    MyContracts[pos3]['mytemp']=tempaccount
                    MyContracts[pos3]['mytotal']=mytotal#Lets start keeping track... it makes life easier
                    MyContracts[pos3]['theirtotal']=theirtotal
                    MyContracts[pos3]['tx3mysig']=sigs7
                    MyContracts[pos3]['lock']="0"
                    MyContracts[pos3]['firstsign']="me"
                    MyContracts[pos3]['escrow']=escrowacc
                    MyContracts[pos3]['inputs']=inputs
                    MyContracts[pos3]['mychange']=outputs
                    MyContracts[pos3]['mychangetotal']=CTotal
                    MyContracts[pos3]['total']=Total
                    MyContracts[pos3]['tx2raw']=tx
                    MyContracts[pos3]['tx2']=txhash(tx)
                    MyContracts[pos3]['mypublic']=pub
                    MyContracts[pos3]['mypublic2']=pub2
                    MyContracts[pos3]['myprivate']=priv
                    MyContracts[pos3]['myprivate2']=priv2
                    MyContracts[pos3]['myencrypted']=Order['myencrypted']
                    MyContracts[pos3]['Details']=Description
                    if marketreply==1:
                        orig=0
                        neword=MyContracts[pos3]['ordernumber']#The ACCEPTED order number (before it gets changed)
                        if 'oldordernumber' not in MyContracts[pos3]:
                            orig=1
                            MyContracts[pos3]['oldordernumber']=MyContracts[pos3]['ordernumber']
                        AccOrder['oldordernumber']=MyContracts[pos3]['ordernumber']
                        MyContracts[pos3]['ordernumber']=os.urandom(16).encode('hex')
                        AccOrder['ordernumber']=MyContracts[pos3]['ordernumber']
                        Order['ordernumber']=AccOrder['ordernumber']
                        AccOrder['Process']="Market Accept"
                        MyContracts[pos3]['Process']="Market Accept"
                        if orig==1:
                            MyContracts[pos3]['MyBMAddress']=GetfromCfg("#BitMessage#")
                            AccOrder['MyBMAddress']=MyContracts[pos3]['MyBMAddress']
                            if "@" in MyContracts[pos3]['Market Data']['Preferred']:
                                if self.EnableEmail.isChecked():
                                    BitAddr=MyEmail
                                    if BitAddr != "" and BitAddr != " ":
                                        if ", " in MyContracts[pos3]['Market Data']['Preferred']:
                                            MyContracts[pos3]['TheirBMAddress']=MyContracts[pos3]['Market Data']['Preferred'].split(", ")[1]
                                        else:
                                            MyContracts[pos3]['TheirBMAddress']=MyContracts[pos3]['Market Data']['Preferred']
                                        MyContracts[pos3]['MyBMAddress']=MyEmail
                                        AccOrder['MyBMAddress']=MyEmail
                                        AccOrder['TheirBMAddress']=MyContracts[pos3]['TheirBMAddress']
                        if Templates.reply2!={}:#This is api/autoaccept
                            AccOrder['Market Data']['reply']=json_deep_copy(Templates.reply2,1)
                        else:#These are manual acceptances this is important to realize the reply is only changed manually and reset before assignment
                            AccOrder['Market Data']['reply']=json_deep_copy(Templates.reply,1)
                            if 'resume' in Templates.reply:
                                MyContracts[pos3]['Market Data']['resume']=Templates.reply['resume']
                            if 'selected' in Templates.reply:
                                MyContracts[pos3]['Market Data']['selected']=Templates.reply['selected']
                                if MyContracts[pos3]['Market Data']['Template']=="Buy Coins":
                                    if 'Profiles' not in MyContracts[pos3]['Market Data']:
                                        MyContracts[pos3]['Market Data']['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
                                    MyContracts[pos3]['Market Data']['Profiles'][Templates.reply['selected']][0]=Templates.reply['Profiles'][Templates.reply['selected']][0]
                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                            MyContracts[pos3]['Market Data']['reply']['pegsupply']=Spendable[0]['liquidity']['supply']
                        AccOrder=ModerationCheck(multisig, privk, AccOrder)
                        if mytotal!=0:
                            OnOrders.append(MyContracts[pos3])
                        UpdateQuantity(MyContracts[pos3])
                        myorder="Unconfirmed contract: " + str(MyContracts[pos3]['ordernumber'])
                        if 'dontclear' not in MyContracts[pos3]['Market Data'] or youshouldclear ==1:
                            leng=len(MyContracts)
                            i=0
                            oldord=MyContracts[pos3]['oldordernumber']
                            #The accepted order has a new process so its safe. We also let the market know the order that was accepted and its number
                            while i<leng:
                                next1=1
                                if MyContracts[i]['Process']=="Market Order":
                                    if MyContracts[i]['ordernumber']==oldord:
                                        DeleteOrder(MyContracts[i]['ordernumber'])
                                        RemoveFromMarket(MyContracts[i],neword)
                                        next1=0
                                if MyContracts[i]['Process']=="Market Offer" or "MCount" in MyContracts[i]['Process']:
                                    if MyContracts[i]['oldordernumber']==oldord:
                                        DeleteOrder(MyContracts[i]['ordernumber'])
                                        next1=0
                                if next1==0:
                                    leng-=1
                                    DeleteContract(i)
                                else:
                                    i+=1
                        #May want to consider the spam filter again here
                        #All we did above was generate temporary funding information and we need to hold it. (We might not even submit it to the network)
                        BitQueue.append(AccOrder)
                        SaveQueue()
                        SaveContracts()
                        window.HistorylistWidget.addItem(str(myorder))
                        if apicontract=={}:
                            window.ClearPage()
                    else:
                        if mytotal!=0:
                            OnOrders.append(MyContracts[pos3])#All we did above was generate temporary funding information and we need to hold it. (We might not even submit it to the network)
                        BitQueue.append(AccOrder)
                        SaveQueue()
                        myorder="Unconfirmed contract: " + str(MyContracts[pos3]['ordernumber'])
                        window.HistorylistWidget.addItem(str(myorder))
                        if apicontract=={}:
                            window.ClearPage()
            if match2==0:#ummm they edited the field
                QuestionBox("The order number was not found. Please refrain from editing the address field during a counter. Also, check and make sure the original order still exists.", "OK")
                return False
            if apicontract=={}:
                self.Tabs.setCurrentIndex(5)
            return True
        if Counter == 1:
            pos=-1
            match2=0
            for c in MyContracts:
                pos+=1
                if c['ordernumber']==address:#Ok a match
                    if c['Process']=="Accept" or "Making" in c['Process'] or "Broadcast" in c['Process'] or c['status']!="offer":#It got accepted or changed. We should not proceed.
                        QuestionBox("Failed! The order status has changed.", "OK")
                        return False
                    match2=1
                    MyContracts[pos]['Details']=Description
                    MyContracts[pos]['mytemp']=tempaccount
                    MyContracts[pos]['inputs']=inputs
                    MyContracts[pos]['timestamp']=timest
                    MyContracts[pos]['mychange']=outputs
                    MyContracts[pos]['mychangetotal']=CTotal
                    MyContracts[pos]['mydeposit']=mydeposit
                    MyContracts[pos]['whopays']=whopays
                    MyContracts[pos]['instantwhopays']=instantwhopays
                    MyContracts[pos]['instantamount']=instantamount
                    MyContracts[pos]['theirdeposit']=theirdeposit
                    MyContracts[pos]['timeout']=timeout
                    MyContracts[pos]['amount']=amount
                    MyContracts[pos]['fee']=fee
                    MyContracts[pos]['type']="CONTRACT"
                    MyContracts[pos]['total']=Total
                    MyContracts[pos]['tx1raw']=tx
                    MyContracts[pos]['tx1']=txhash(tx)
                    MyContracts[pos]['theiraddress']=multisig
                    MyContracts[pos]['mytemp']=tempaccount
                    if 'Counter' in c['Process']:
                        c['Process']=c['Process'].replace('Counter',"")
                        st="Counter"
                        st+=str(int(c['Process'])+1)
                        MyContracts[pos]['Process']=st
                        MyContracts[pos]['lock']='0'
                    if c['Process']=='Received':#Its the first offer they need our actual address if they dont have it already
                        MyContracts[pos]['Process']='Counter0'#First counter
                        MyContracts[pos]['lock']='0'
                    MyContracts[pos]['MyBMAddress']=MyContracts[pos]['MyBMAddress']
                    MyContracts[pos]['mypublic']=pub
                    MyContracts[pos]['mypublic2']=pub2
                    MyContracts[pos]['myprivate']=priv
                    MyContracts[pos]['myprivate2']=priv2
                    MyContracts[pos]['myencrypted']=Order['myencrypted']
                    if CurrentBlock !=0:
                        MyContracts[pos]['currentblock']=CurrentBlock
                    if 'MCount' in c['Process']:
                        MyContracts[pos]['Process']="MCount"+str(int(c['Process'].replace('MCount',""))+1)
                        MyOrd=os.urandom(16).encode('hex')+"##"+MyContracts[pos]['ordernumber']
                        MyContracts[pos]['lock']='0'
                    if c['Process']=="Market Order":
                        MyContracts[pos]['Market Data']['oldordernumber']=MyContracts[pos]['ordernumber']
                        MyContracts[pos]['oldordernumber']=MyContracts[pos]['ordernumber']
                        MyOrd=os.urandom(16).encode('hex')
                        MyContracts[pos]['ordernumber']=MyOrd
                        MyContracts[pos]['Process']="MCount0"
                        MyContracts[pos]['lock']='0'
                        MyContracts[pos]['MyBMAddress']=GetfromCfg("#BitMessage#")
                        if "@" in MyContracts[pos]['Market Data']['Preferred']:
                            if self.EnableEmail.isChecked():
                                BitAddr=MyEmail
                                if BitAddr != "" and BitAddr != " ":
                                    if ", " in MyContracts[pos]['Market Data']['Preferred']:
                                        MyContracts[pos]['TheirBMAddress']=MyContracts[pos]['Market Data']['Preferred'].split(", ")[1]
                                    else:                                    
                                        MyContracts[pos]['TheirBMAddress']=MyContracts[pos]['Market Data']['Preferred']
                                    MyContracts[pos]['MyBMAddress']=MyEmail
                    if marketreply==1:
                        MyContracts[pos]['Market Data']['reply']=json_deep_copy(Templates.reply,1)
                        if 'pegging' in CoinSelect and CoinSelect['pegging']:
                            MyContracts[pos]['Market Data']['reply']['pegsupply']=Spendable[0]['liquidity']['supply']
                            MyContracts[pos]['Market Data']['pegsupply']=Spendable[0]['liquidity']['supply']
                        #Importing replies
                        if 'mymailing' in Templates.reply:
                            MyContracts[pos]['Market Data']['mymailing']=Templates.reply['mymailing']
                            try:
                                MyContracts[pos]['Market Data']['reply'].pop('mymailing')#This is only for our personal reference
                            except:
                                pass
                        if 'barteritems' in Templates.reply:
                            MyContracts[pos]['Market Data']['barteritems']=Templates.reply['barteritems']
                        if 'service' in Templates.reply:
                            MyContracts[pos]['Market Data']['service']=Templates.reply['service']
                        if 'resume' in Templates.reply:
                            MyContracts[pos]['Market Data']['resume']=Templates.reply['resume']
                        if 'requirereport' in Templates.reply:
                            MyContracts[pos]['Market Data']['requirereport']=Templates.reply['requirereport']
                        if 'selected' in Templates.reply:
                            MyContracts[pos]['Market Data']['selected']=Templates.reply['selected']
                            if MyContracts[pos]['Market Data']['Template']=="Buy Coins":
                                if 'Profiles' not in MyContracts[pos]['Market Data']:
                                    MyContracts[pos]['Market Data']['Profiles']={'Bank':[],'WU':[],'MG':[],"Cash":[],"Other":[],"Card":[],"Mail":[], "Contact":[]}
                                MyContracts[pos]['Market Data']['Profiles'][Templates.reply['selected']][0]=Templates.reply['Profiles'][Templates.reply['selected']][0]
                        if theirdeposit>0 and mydeposit>0:
                            if theirdeposit==mydeposit and Decimal(mydeposit)>=Decimal(amount) and Decimal(mydeposit)<=Decimal(amount*2):
                                MyContracts[pos]['Market Data']['style']="Double Deposit"
                            else:
                                MyContracts[pos]['Market Data']['style']="Custom Deposit"
                            if amount==10000 and theirdeposit==mydeposit:
                                MyContracts[pos]['Market Data']['style']="Barter"
                            if amount==10000 and theirdeposit!=mydeposit:
                                MyContracts[pos]['Market Data']['style']="Custom Barter"
                            if instantamount!=0:
                                MyContracts[pos]['Market Data']['style']+=", Instant Refund"
                        else:
                            if amount>0:
                                if theirdeposit==0 and "I pay this" in whopays and mydeposit>0:
                                    MyContracts[pos]['Market Data']['style']="Guarantor"
                                if mydeposit==0 and "The other" in whopays and theirdeposit>0:
                                    MyContracts[pos]['Market Data']['style']="Guarantor"
                        #MyContracts[pos]=ModerationCheck(multisig, privk,cc)
                        if MyContracts[pos]==False:
                            return False
                        accord=json_deep_copy(MyContracts[pos],1)
                        accord['ordernumber']=MyOrd
                        Step1(accord, privk)
                        if apicontract=={}:
                            GlobalImage=""
                            GlobalID=""
                    else:
                        Step1(MyContracts[pos])
                        if apicontract=={}:
                            GlobalImage=""
                            GlobalID=""
                    myorder="Unconfirmed contract: " + str(MyContracts[pos]['ordernumber'])
                    window.HistorylistWidget.addItem(str(myorder))
                    if apicontract=={}:
                        window.ClearPage()
                    if mydeposit!=0:
                        new=list(FilterSpendable(OnOrders,SpendThis))#If we used new inputs because we were running out, don't add the same inputs twice
                        OnOrders.append(MyContracts[pos])
                    if youshouldclear==1:
                        if new !=[]:#We are using a new input that wasnt on OnOrders and not reused from our original order
                            newtotal=0
                            for n in new:
                                newtotal+=n['value']
                            OnOrders[-1]['oldtotal']=OnOrders[-1]['total']
                            OnOrders[-1]['total']=newtotal
                            OnOrders[-1]['oldmychangetotal']=OnOrders[-1]['mychangetotal']
                        else:
                            OnOrders[-1]['oldtotal']=OnOrders[-1]['total']
                            OnOrders[-1]['total']=0
                            OnOrders[-1]['oldmychangetotal']=OnOrders[-1]['mychangetotal']
                            OnOrders[-1]['mychangetotal']='0'
                        x=0
                        for con in MyContracts:
                            if con['ordernumber']==ContOrdernumber or 'oldordernumber' in con and con['oldordernumber']==ContOrdernumber:
                                if 'dontclear' in MyContracts[x]['Market Data']:
                                    MyContracts[x]['Market Data'].pop('dontclear')
                            x+=1
            if match2==0:#ummm they edited the field
                QuestionBox("The order number was not found. Please refrain from editing the address field during a counter. Also, check and make sure the original order still exists.", "OK")
                return False
            if apicontract=={}:
                self.Tabs.setCurrentIndex(5)            
            return True
        if marketorder==1:
            data={}
            data=Templates.Data
            if data=={}:
                QuestionBox("Template not loaded for market offer. Please submit the form again.", "OK")
                return False
            data['Preferred']=PreferredMarketAddress
            if window.DisableSpamFilter.isChecked():
                pass
            else:
                pass
                #data['Preferred']=multisig
            data['date']=ConvertDate(HaloTime,0)
            data['style']="Custom"
            data['Payment Method']=CoinSelect['name']
            data['Market Address']=address
            if theirdeposit>0 and mydeposit>0:
                if theirdeposit==mydeposit and Decimal(mydeposit)>=Decimal(amount) and Decimal(mydeposit)<=Decimal(amount*2):
                    data['style']="Double Deposit"
                else:
                    data['style']="Custom Deposit"
                if amount==10000 and theirdeposit==mydeposit:
                    data['style']="Barter"
                if amount==10000 and theirdeposit!=mydeposit:
                    data['style']="Custom Barter"
                if instantamount!=0:
                    data['style']+=", Instant Refund"
            else:
                if amount>0:
                    if theirdeposit==0 and "I pay this" in whopays and mydeposit>0:
                        data['style']="Guarantor"
                    if mydeposit==0 and "The other" in whopays and theirdeposit>0:
                        data['style']="Guarantor"
        if "BM-" in address or "@" in address:#they must be wanting to send through Bitmessage/Email directly so we can skip the encrypted message
            Order['Command']='Send'
            Order['tx1']=txhash(tx)
            Order['tx1raw']=tx
            Order['MyBMAddress']=BitAddr
            Order['TheirBMAddress']=address
            Order['Process']='Offer'
            Order['mypublic2']=pub2
            Order['myprivate']=priv
            Order['myprivate2']=priv2
            if CurrentBlock !=0:
                Order['currentblock']=CurrentBlock#This is so that if a deal is ignored for too long it gets deleted automatically. We update this each step of the way
            else:
                Order['currentblock']=9999999999999999#Ok this one is not expiring
            if marketorder==1:
                Order['Market Data']=data
                Order['Process']='Market Order'
                Order=ModerationCheck(multisig, privk, Order)
                if Order==False:
                    return False
            MyContracts.append(Order)
            if mydeposit!=0:
                OnOrders.append(Order)
            myorder="Unconfirmed contract: " + str(Order['ordernumber'])
            window.HistorylistWidget.addItem(str(myorder))
            #Now we tell them our Bitcoin address for emergencies
            Order['theiraddress']=multisig
            if apicontract=={}:
                window.ClearPage()
                GlobalImage=""
                GlobalID=""
            if marketorder==1:
                Step1(Order,privk)
            else:
                Step1(Order)
            if apicontract=={}:
                self.Tabs.setCurrentIndex(5)
            return True#And it did not cost us anything to send but our inputs are reserved
        if apicontract=={}:
            GlobalImage=""
            GlobalID=""
        encryptthis = BitAddr
        #Send the satoshi contact request
        hexoutputs=MakeCipherOutputs(encryptthis)
        txoutputs=[]
        tmpout={}
        #Adding their output
        satoshis=0
        out={'value':5500,'address':address}
        txoutputs.append(out)
        satoshis+=5500
        #Getting ready to make the message tx
        for addr in  hexoutputs:
            tmpout={}
            tmpout['value']=5500#this can be more or less depending on amount set in most clients for anti-spam. Small amounts should get into the blockchain but currently there is a lot of people who are not confirming amounts below 5500 satoshis. Also, electrum servers may reject certain transactions.
            satoshis+=5500
            tmpout['address']=addr
            txoutputs.append(tmpout)
        tmporder=[]
        tmporder.append(Order)#We need to not spend any of the reserved inputs above if we plan on sending encrypted message
        SpendThis=FilterSpendable(tmporder,SpendThis)
        balance2=0
        for i in SpendThis:
            balance2+=i['value']
        if satoshis+fee > balance or satoshis+fee > balance2:
            QuestionBox("Not enough funds/inputs to send encrypted message! Try adding funds and breaking it into change by sending a transaction to yourself or another.", "OK")
            return False
        if satoshis+fee!=balance or satoshis+fee!=balance2:#Ok its less than the full balance...how much less?
            if satoshis+fee > balance - 5500 or satoshis+fee > balance2 - 5500:
                QuestionBox("The change on available inputs would be lower than the anti-dust minimum of 5500 satoshis. Try adding funds or free up some inputs.", "OK")
                return False
        #Need to (eventually) have a function that filters the balance based on confirmed orders and filter the outputs that were spent. Check for the confirmations and then remove once one of the inputs gets seen as spent.
        try:
            inputs,outputs,Total = MakeChange (SpendThis, satoshis+fee, multisig, 0)#This is an encrypted message so we don't use more inputs than needed
        except:
            traceback.print_exc()
            QuestionBox("Not enough available funds for encrypted message!", " OK ")
            return False
        count=0
        mybytes=1500 # A buffer for the fee
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            mybytes*=2
        for myin in inputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:
                mybytes+=360#Double the signatures this seemed like a good rule of thumb
        for myout in outputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:
                mybytes+=34
        mybytes2=mybytes
        mybytes=int(round(mybytes,-3))
        mybytes=mybytes*10#Convert from kb to satoshi
        if BitHaloClient == True:#Bitcoin is extremely slow for large transactions, we need to really raise the fee
            mybytes=mybytes*2
        if BitHaloClient ==  False:
            if mybytes>(int(fee)):
                QuestionBox(Gtranslate("The fee is not high enough to cover the inputs. Please consider sending coins to yourself to consolidate change or raise the fee to the recommended level.\n\nRecommended Fee:\n") + str(Decimal(mybytes)/Decimal(1e8)), Gtranslate("OK"),1)
                return False
        else:
            if mybytes>(int(fee)):
                QuestionBox(Gtranslate("The fee may not be high enough to cover the inputs. Please consider sending coins to yourself to consolidate change or raise the fee to the recommended level. You may proceed, however consider raising the fee.\n\nRecommended Fee:\n") + str(Decimal(mybytes)/Decimal(1e8)), Gtranslate("OK"),1)
        if BitHaloClient == True:#Lets see if the fee is high enough for the network traffic
            if int(fee)/int(mybytes2)<int(btcfeekb):
                recommended=str(((Decimal(btcfeekb)*Decimal(mybytes2))+10000)/Decimal(1e8))
                res=QuestionBox(Gtranslate("The fee is not high enough for a fast confirmation in the Bitcoin network. It's possible you have many small inputs or that the network is experiencing high traffic. Please raise the fee to the recommended amount of satoshis per kilobyte.\n\nCurrent Satoshis/KB:\n")+str(int(fee)/int(mybytes2))+Gtranslate("\n\nRecommended Satoshis/KB:\n")+str(btcfeekb)+Gtranslate("\n\nRecommended minimum fee:\n")+recommended, Gtranslate("OK"),1)
                return False
        timest=timestamp
        #Our change and inputs
        for outp in outputs:
            txoutputs.append(outp)
        mbox = QuestionBox(Gtranslate("Encypted Message" + "\nAddress: ") + address + "\n"+Gtranslate("Amount: ") + str(Decimal(satoshis)/Decimal(1e8)) + "\n"+Gtranslate("Fee: ") + str(Decimal(fee)/Decimal(1e8)) + "\n"+Gtranslate("Total: ") + str(Decimal(satoshis)/Decimal(1e8)+Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + "\n"+Gtranslate("Change: ") + str(Decimal(Total)/Decimal(1e8)-Decimal(satoshis)/Decimal(1e8)-Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Please confirm the details.\n\nNote:\nEach message costs a different amount. Depending on how much information is being sent."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
        if mbox == 1:
            return False
        sigs,result=create_sig_for_redemption(inputs,txoutputs, PrivKeyFilename1, PrivKeyFiledir1, timest, splashme=splashthis, unlockthis=lockme)
        if result == False:
            QuestionBox("Incorrect password.", "OK")
            return False
        sigs2,result=create_sig_for_redemption(inputs,txoutputs, PrivKeyFilename2, PrivKeyFiledir2, timest, splashme=splashthis, unlockthis=lockme)
        if result == False:
            QuestionBox("Incorrect password.", "OK")
            return False
        #Ok this is getting exciting... lets broadcast!
        busy=0
        spme=0
        if apicontract=={}:
            spme=1
            #busy=NetSplash(1)
        if busy==0:        
            txE,result=broadcast_to_network(sigs,sigs2,inputs,txoutputs,PrivKeyFilename1, timest, splashme=spme)
        else:
            #busy=NetSplash(1)
            result="TX rejected"
        #If it fails the first time maybe the keys were loaded in a different order. So lets just send again.
        if "TX rejected" in str(result):
            if busy==0:
                txE,result=broadcast_to_network(sigs2,sigs,inputs,txoutputs,PrivKeyFilename1, timest, splashme=spme)
            else:
                result="TX rejected: Network busy, try again later."            
        #if apicontract=={}:
        #    NetSplash(0)
        if "TX rejected" in str(result):
            QuestionBox(str(result), Gtranslate("OK"),1)
            updatesomething = 1            
            return False
        else:#Great! Lets add this order and do whatever else we need to do REMEMBER TO ADD THE UNCONFIRMED ORDERS AS WELL TO EVERY FUNCTION(even the satoshis)
            #Lets add sensitive data here and keep it in our orders
            Order['MyBMAddress']=BitAddr
            Order['tx1']=txhash(tx)
            Order['tx1raw']=tx
            Order['Process']='Encrypted Message'
            Order['ordernumber']=txhash(txE) #Lets change this to txid so there is no confusion as to which order was sent/received
            Order['mypublic2']=pub2
            Order['myprivate']=priv
            Order['myprivate2']=priv2
            #Order['tmp']=privk
            if CurrentBlock !=0:
                Order['currentblock']=CurrentBlock#This is so that if a deal is ignored for too long it gets deleted automatically
            else:
                Order['currentblock']=9999999999999999#Ok this one is not expiring
            if marketorder==1:
                Order['Market Data']=data
                #Order['Process']='Market Order'
                Order=ModerationCheck(multisig, privk, Order)
                if Order==False:
                    QuestionBox("Order verification failed", "OK")
                    return False
            MyContracts.append(Order)
            OnOrders.append(Order)
            myorder="Unconfirmed contract: " + str(Order['ordernumber'])
            window.HistorylistWidget.addItem(str(myorder))
            if apicontract=={}:
                window.ClearPage()
                GlobalImage=""
                GlobalID=""
        #We add an order that will never be cleared until the inputs are no longer available! Once this happens, we add it to the menu... we allow them to clear it at their own risk
        NewOrder={}
        NewOrder['type']="SPENT"
        NewOrder['total']=Total
        NewOrder['change']=str(Decimal(Total)/Decimal(1e8)-Decimal(satoshis)/Decimal(1e8)-Decimal(fee)/Decimal(1e8))
        NewOrder['currentblock']=CurrentBlock
        NewOrder['Confirmation TXID']=txhash(txE)
        NewOrder['ordernumber']=os.urandom(16).encode('hex')
        NewOrder['inputs']=inputs
        NewOrder['output']=txoutputs
        OnOrders.append(NewOrder)
        myorder="Spent coins! Waiting for confirmations(click here if the order never confirms):      Order number:  " + NewOrder['ordernumber'] + "   Confirmation TXID: " + NewOrder['Confirmation TXID']
        window.HistorylistWidget.addItem(str(myorder))
        QuestionBox(str(txhash(txE))+Gtranslate("\nSuccess! It may take a moment to reflect in your balance.") , Gtranslate("OK"),1)
        updatesomething = 1
        if apicontract=={}:
            self.Tabs.setCurrentIndex(5)
        return True

    def Documentation(self):
        try:
            subprocess.Popen('Documentation.doc', shell=True)
        except:
            QuestionBox("The doc file did not open. However, it is located in your main Halo folder. Try opening it manually or download it from our website.", "OK")
    def Explain(self, Explainme):
        ExplanationWindow.stackedWidget.setCurrentIndex(Explainme)
        ExplanationWindow.show()
    def CopyAddress(self):
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        try:
            if CoinSelect['moderngui']==0:
                x=str(window.MyAddress.text()).split("ADDRESS:")[1].strip()
            else:
                x=str(window.ReceiveBitcoins.receiveCoinAddressLineEdit.text()).strip()
        except:
            x=multisig
        clipboard = app.clipboard()
        clipboard.setText(str(x))
    def CopyBMAddress(self):
        if self.DisableSpamFilter.isChecked():
            pass
        else:
            mbox = QuestionBox("The spam filter is enabled, so if you wish to receive contracts to this address then you will have to disable it. Continue anyway?", " Yes ", " No ")
            if mbox == 1:
                return
        baddr=GetfromCfg("#BitMessage#")
        clipboard = app.clipboard()
        clipboard.setText(str(baddr))
    def HistoryClick(self, item):
        global OnOrders,updatesomething, timestamp, CurrentBlock, AdvanceArray, HistoryDetail, changearray, minedarray, Spendable
        #value = self.HistorylistWidget.currentItem().text()

        t=str(item.text())
        if "Spent coins! Waiting for confirmations(click here if the order never confirms): " in t or "Staked coins! (click for options)" in t:
            if "Staked coins! (click for options)" in t:                
                WStakeList.populate()
                WStakeList.show()
                return
            t=t.replace("Spent coins! Waiting for confirmations(click here if the order never confirms):      Order number:  ","")
            matchObj = re.match( r'(.*?) (  Confirmation TXID:) (.*)', str(t), re.M|re.I)
            ordernumber=str(matchObj.group(1))
            txid=str(matchObj.group(3)).strip()
            mbox = QuestionBox("You have spent coins, please wait until it confirms on the network.", " OK ", " Clear from history ")                
            if mbox == 0:
                return
            mbox = QuestionBox(Gtranslate("Warning! This is usually not a good idea and can result in future transactions being declined forcing a rescan. This will clear the following inputs from this computers history. The only reason you would do this is if the order never confirmed. It can also happen if the TXID gets changed in the mining process. It is recommended you wait for it to clear automatically.") + "\nOrder # " + ordernumber + "\nTXID: " + txid, Gtranslate(" Clear from history "), Gtranslate(" Okay, I will wait "),1)
            if mbox == 1:
                return
            #Ok they want to clear it... lets find the order in spendable and remove it
            updatesomething=1
            DeleteOrder(str(ordernumber))
        if "Frozen Coins:" in t:
            if 'Spendable:' in t:
                txid=str(t.split("Transaction ID: ")[1].split("\tSpendable: ")[0])
                meaning=translate_script(NEWTxidLookup[txid]['script'])
                mbox = QuestionBox(meaning['description'], " OK ", 1)
            else:
                txid=str(t.split("Transaction ID: ")[1])
                for s in Spendable:
                    if s['output']==txid:
                        h=(s['liquidity']['frozen']-(timestamp-43200))/60/60
                        if h==0:
                            h=1                        
                        mbox = QuestionBox("These funds are frozen! They can not be moved until " + str(h) + " hours.", " OK ", 1)
                        break
            return
        if "Assured Destruction" in t or "Switch" in t:
            multisig,multiscript=create_multisig_address(PrivKeyFilename1)
            txid=str(t.split("Transaction ID: ")[1].split("\tSpendable: ")[0])
            meaning=translate_script(NEWTxidLookup[txid]['script'])                       
            if "(password protected)" in t:
                text, ok = QtGui.QInputDialog.getText(self, "Halo", Gtranslate('Please enter the password to unlock this payment:'))
                text=str(text)
                pw=1                                                        
                if meaning['before']==multisig and meaning['hashbefore']!="":
                    skippw=0
                    if CoinSelect['checksequenceverify']==True:
                        if meaning['timestamp']<timestamp:#Time is up, this password won't help us
                            skippw=1
                    if skippw==0:#If we know this password we can spend it
                        if hash160(text)==meaning['hashbefore']:#Match!
                            AdvanceArray['hashpasswords'][meaning['hashbefore']]=text
                            pw=0
                if meaning['destination']==multisig and meaning['hashafter']!="":
                    if pw==1:
                        if hash160(text)==meaning['hashafter']:#Match!
                            AdvanceArray['hashpasswords'][meaning['hashafter']]=text
                            pw=0                            
                if pw==1:
                    mbox = QuestionBox("Incorrect password, please try again.", " OK ")
                    return
                else:
                    mbox = QuestionBox("Success! Transaction unlocked. Answer to hash puzzle is now stored in memory.", " OK ")
                    return                    
            elif "(expired)" in t:
                mbox = QuestionBox("This transaction is expired. You may review the details to the transaction and confirm that the time has run out and it is not possible to spend it. It is always a good idea to double check to ensure the timestamp is accurate. Then you can clear the transaction from your account.", " Let me review the details first ", " Clear the transaction ", " Cancel ")
                if mbox==2:
                    return
                if mbox==0:
                    mbox = QuestionBox(meaning['description'], " OK ", 1)
                mbox = QuestionBox("Are you sure you would like to clear this expired transaction?", " Yes ", " No ", " Clear these automatically in the future ")
                if mbox==0:
                    if txid not in AdvanceArray[multisig]['ignorelist']:
                        AdvanceArray[multisig]['ignorelist'].append(txid)
                if mbox==1:
                    return
                if mbox==2:
                    if txid not in AdvanceArray[multisig]['ignorelist']:
                        AdvanceArray[multisig]['ignorelist'].append(txid)                    
                    AdvanceArray['autoclearexpired']=1
            elif '(click here to investigate)' in t:
                txid2, vout = txid.split(":")
                mbox = QuestionBox(Gtranslate("You can check the Transaction ID of this specific input by looking at the 'Output Index Number' to see if it has been spent. You can check using online block explorers such as https://chainz.cryptoid.info/\n\n")+"Transaction ID:\n"+txid2+"\n\nOutput Index Number:\n"+vout, " Copy Transaction ID ", " I have made my conclusion ", " Cancel ")
                if mbox==0:
                    clipboard = app.clipboard()
                    clipboard.setText(str(txid))
                if mbox==1:
                    mbox = QuestionBox("Has this input been spent and would you like to clear it from your account or is this input spendable? Please make sure you know the answer to this question before proceeding.", " Clear this input ", " This input can be spent. ", " Cancel ")
                    if mbox==0:
                        if txid not in AdvanceArray[multisig]['ignorelist']:
                            AdvanceArray[multisig]['ignorelist'].append(txid)
                            AdvanceArray[multisig]['investigate'].pop(txid)
                            QuestionBox("This conflicting input will now be ignored.", "OK")                            
                    if mbox==1:
                        QuestionBox("This input can now be spent again.", "OK")
                        AdvanceArray[multisig]['investigate'].pop(txid)

            else:                
                mbox = QuestionBox(meaning['description'], " OK ", 1) 
        if "Pay To Email(click for options): " in t:
            t=t.replace("Pay To Email(click for options): ","")
            multisig,multiscript=create_multisig_address(PrivKeyFilename1)
            o=-1
            for order in OnOrders:
                o+=1
                if order['type']=="History" or order['type']=="Spendable":
                    continue
                if order['ordernumber']==str(t):
                    mbox = QuestionBox("If the Pay To Email has not been redeemed, you may wait a week and the client will automatically return it to your account. If it is password protected, it must be done manually. Do you wish cancel your Pay To Email?", " Yes ", " No ")
                    if mbox == 1:
                        return
                    if order['currentblock']==0 and CurrentBlock > 11:
                        OnOrders[o]['currentblock']=CurrentBlock-140
                    if order['currentblock']+144<CurrentBlock:#It must be at least one day to get a refund
                        priv = password.DecryptWithAES("Halo Master", order['priv'])
                        if "PASSWORDPROTECTED:" in priv:
                            text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Enter the password for this private key:'), QtGui.QLineEdit.Password)
                            try:
                                priv=priv.replace("PASSWORDPROTECTED:","")
                                priv = password.DecryptWithAES(str(text), priv)
                            except:
                                QuestionBox("Incorrect Password.", "OK")
                                return
                        try:
                            if BitHaloClient == True:
                                tmptx = pybit.transaction.mktx([{'output':str(order['Confirmation TXID'])+":0",'value':int(order['amount']),'address':str(multisig)}],[{'value':(int(order['amount'])-int(order['fee'])),'address':str(multisig)}])
                            else:
                                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                                    #Get liquidity
                                    try:
                                        busy=NetSplash(1, checkwait=1)
                                        if TestnetPeg:
                                            liquid, reserve=ThePeg.checktransaction(str(order['Confirmation TXID'])+":0")
                                        else:
                                            fractions=BLK.getfractions(str(order['Confirmation TXID'])+":0")
                                            liquid, reserve=ThePeg.formatfractions(fractions, multisig, int(order['amount']))
                                        if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                                            QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before trying to spend.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                                            return False
                                        combined=ThePeg.checkliquidity(liquid,reserve)
                                        if combined==False:
                                            float('a')
                                        liq=json_deep_copy(combined)
                                        NetSplash(0)
                                    except:
                                        NetSplash(0)
                                        traceback.print_exc()
                                        QuestionBox("Transaction lookup failed. Software is busy, please try again.", " OK ")
                                        return
                                    ltot=liq['ltotal']
                                    rtot=liq['rtotal']
                                    ftot=0
                                    #For now, we just freeze a buffer if we are close to a rate change
                                    if ThePeg.Pegdatabase['blockcount'] % ThePeg.interval < 10 or ThePeg.Pegdatabase['blockcount'] % ThePeg.interval > ThePeg.interval-10:
                                        ftot=liq['nfreeze']
                                    ltot-=ftot                                                                         
                                    rtot+=ftot
                                    if ltot==0:
                                        p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':(int(order['amount'])-int(order['fee'])),'script':address_to_script(multisig)}]
                                    else:
                                        p2mouts=[]
                                        if rtot!=0:
                                            p2mouts=[{'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**F**1'))/2)).encode('hex')+hexlify('**F**1')},{'value':int(rtot),'script':address_to_script(multisig)}]
                                        p2mouts.append({'value':(int(order['amount'])-int(order['fee'])-int(rtot)),'script':address_to_script(multisig)})
                                    tmptx = mktx_script(timestamp,[{'output':str(order['Confirmation TXID'])+":0",'value':int(order['amount']),'address':str(multisig)}],p2mouts)
                                else:
                                    tmptx = mktx(timestamp,[{'output':str(order['Confirmation TXID'])+":0",'value':int(order['amount']),'address':str(multisig)}],[{'value':(int(order['amount'])-int(order['fee'])),'address':str(multisig)}])
                            tx = signall(tmptx,priv)
                            nsp=0
                            if BitHaloClient:
                                rspns = sendBTCtx(tx)
                            else:
                                try:
                                    busy=NetSplash(1, checkwait=1)
                                    nsp=1                                
                                    rspns = BLK.sendrawtransaction(tx)                                    
                                except:
                                    NetSplash(0)
                                    rspns = "TX rejected"
                            if "TX rejected" in str(rspns):
                                QuestionBox(str(rspns), "OK")
                                print float("A")
                                return
                            QuestionBox(str(txhash(tx))+Gtranslate("\nSuccess! It may take a moment to reflect in your balance."), Gtranslate("OK"),1)
                            AdvanceArray['clearnotxid']=1
                            OnOrders.pop(o)
                            if nsp==1:
                                NetSplash(0)
                            updatesomething=1
                            hist={}
                            hist['Amount']=str(dropzeros((Decimal(order['amount'])/Decimal(1e8)),1))
                            hist['Details']=order
                            hist['Details']['date']=ConvertDate(HaloTime,0)
                            hist['Details']['Pending']=False
                            hist['Type']="Pay To Email"
                            hist['Label']=''
                            if multisig not in HistoryDetail:
                                HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
                                try:
                                    hist['Details']['Redeemed']=1
                                    if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
                                        HistoryDetail[multisig]=[hist]
                                    else:
                                        HistoryDetail[multisig].insert(0,hist)
                                    PopulateHistory()
                                except:
                                    traceback.print_exc()
                            return
                        except:
                            mbox = QuestionBox("There was an error redeeming the input. Would you like to clear the order?", " Yes ", " No ")
                            if mbox == 1:
                                return
                            AdvanceArray['clearnotxid']=1
                            OnOrders.pop(o)
                            updatesomething=1
                            return
                    else:
                        QuestionBox("You must wait at least 24 hours(144 Bitcoin Blocks) to cancel to give the counter-party a chance to redeem the order.", "OK")
                        return
        if "Unconfirmed order(click for options): " in t:
            t=t.replace("Unconfirmed order(click for options): ","")
            o=-1
            for order in OnOrders:
                o+=1
                if order['type']=="History" or order['type']=="Spendable":
                    continue
                if order['ordernumber']==str(t):
                    mbox = QuestionBox(Gtranslate("This will clear the following order from this computers history:\n") + "\n"+Gtranslate("Address: ") + order['address'] + "\n"+Gtranslate("Total: ") + str(Decimal(order['total'])/Decimal(1e8)) + "\n"+Gtranslate("Order # ") + order['ordernumber'], Gtranslate(" Okay "), Gtranslate(" Cancel "),1)
                    if mbox == 1:
                        return
                    mbox = QuestionBox("If you are on a joint account, it is recommended you don't cancel especially if you already sent the two-step spend to its second location. Are you sure you wish to proceed?", " Yes ", " No ")
                    if mbox == 1:
                        return
                    OnOrders.pop(o)
                    updatesomething=1
                    return
        if "Show change" in t:
            WChangeList.CL.clear()
            for i in changearray:
                WChangeList.CL.addItem(i)
            WChangeList.show()
        if "Show mined" in t:
            WChangeList.CL.clear()
            for i in minedarray:
                WChangeList.CL.addItem(i)
            WChangeList.show()            

    def EncryptKeyfile(self):
        EncryptPrivateKey()

    def SendNormal(self, apicontract="", mode=1):
        global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, updatesomething, timestamp, MyEmail, WatchListQueue, CoinMarketCap, SALT, btcfeekb, myblockcount
        global SilenceUI, exoticnotify, AdvanceArray
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        if apicontract=="":
            apicontract={}
        Password=""
        if keysconnected == "0":
            QuestionBox("No keys connected!", "OK")
            return False, "No keys connected!"
        usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)

        balance=GetfromCfg("#prevbalance#")
        balance = int(Decimal(balance)*Decimal(1e8)) #We use Decimal to be extra sure there are no slip ups between conversions
        address = str(self.BitPayTo.text())#Was toPlainText from the old text edit until i switched to line edit
        amount = str(self.BitAmount.text())
        fee = str(self.BitFee.text())
        if apicontract!={}:
            if 'ui' not in apicontract:
                SilenceUI=1
            address=str(apicontract['address'])
            amount=str(apicontract['amount'])
            fee=str(apicontract['fee'])
        orgamount=amount
        if "$" in amount:
            if CoinMarketCap==" ":
                usd,btc=GetMarketValue(CoinSelect['name'])
            if usd=="":
                QuestionBox("Exchange rate not loaded yet. Please wait or convert the rate manually.", "OK")
                return False, "Exchange rate not loaded yet. Please wait or convert the rate manually."
            else:
                QuestionBox(Gtranslate("Please confirm the exchange rate online:\n")+"USD:"+usd+"->"+CoinSelect['name']+"\nBTC:"+btc+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this. Otherwise, you may simply send the coins normally."), Gtranslate("OK"),1)
        if "@" in address and "," in address:
            QuestionBox("Can not pay multiple email addresses simultaneously!", "OK")
            return False, "Can not pay multiple email addresses simultaneously!"
        if "$" in fee:
            QuestionBox("Fee must be in satoshis not dollars!", "OK")
            return False, "Fee must be in satoshis not dollars!"
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:
                QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before trying to spend.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                return False, "Peg database not in sync."
        valid=0
        timest=timestamp
        address=address.replace(" ","")
        amount=amount.replace(" ","")
        adarray, amtarray=ParseMultipay(address,amount)
        if amtarray != []:
            if "Script:" in address or "6a" in address[:2] or "Mint:" in address or "Freeze:" in address:
                QuestionBox("Can not pay multiple addresses and scripts simultaneously.", "OK")
                return False, "Can not pay multiple addresses and scripts simultaneously."
            if 'Move Reserve:' in address or 'Voluntary Freeze:' in address:
                QuestionBox("Can not pay multiple addresses on this type of transaction.", "OK")
                return False, "Can not pay multiple addresses on this type of transaction."
            amount=0
            myps=0
            for amt in amtarray:
                if "$" in amt:
                    amt=str((Decimal(amt.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
                    amtarray[myps]=amt
                amount += int(abs(Decimal(amt)*Decimal(1e8)))
                myps+=1
        if amtarray == []:
            if "$" in amount:
                amount=str((Decimal(amount.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
            amount = int(abs(Decimal(amount)*Decimal(1e8)))
        #Below we check for seemingly valid inputs and we correct to a satoshi amount and absolute values
        testaddr=address
        testaddr=testaddr.replace(".","")
        testaddr=testaddr.replace("-","")
        if re.match("^[A-Za-z0-9,@_+~|]*$", testaddr):
            valid=1
        SCRIPT=0
        NotifyTHIS=[]
        bridgetx=0
        bridgedata={'network':'','pool':[0]*1200,'txid':'','to':''}
        if testaddr[:2]=="6a" or testaddr[:14]=="MoveReserve:6a":
            valid=1
            SCRIPT=1
            testthis=testaddr.replace("MoveReserve:","")
            thisisgood=0
            for bridged in ThePeg.Pegdatabase['bridgedb']['bridges']:
                if translate_script(testthis)['message'][5:][:64]==txhash(bridged['n'])[:64]:
                    bridgedata['network']=bridged['n']
                    bridgedata['to']=translate_script(testthis)['message'][5:][64:]
                    if "0x" not in bridgedata['to'] or " " in bridgedata['to']:
                        QuestionBox("The address does not appear to be valid!", " OK ")
                        return False, "The address does not appear to be valid!"
                    try:
                        test=int(bridgedata['to'], 16)
                    except:
                        QuestionBox("The address does not appear to be valid!", " OK ")
                        return False, "The address does not appear to be valid!"
                    thisisgood=1
                    bridgetx=1
                    break
            if thisisgood!=1:
                QuestionBox("The bridge network name was not valid!", " OK ")
                return False, "The bridge network name was not valid!"
            if ThePeg.Pegdatabase['bridgeactive']==False:
                QuestionBox("The bridge is currently deactivated, please try again later.", " OK ")
                return False, "The bridge is currently deactivated, please try again later."
        if "Script:" in testaddr:
            valid=1
            SCRIPT=1
            try:
                address=address.replace("Script:", "")
                notify=""
                if ":" in address:
                    address, notify= address.split(":")
                meaning=translate_script(address)
                if meaning['type']!="Notary/Burn":
                    testme=ConvertScriptToOuts(address)#We can't afford to miscommunicate the script
                    testme=DecodeScriptFromOuts(testme)
                    if testme['script']!=address:
                        float('a')                    
                    if meaning['type']=="Freeze":
                        if 'by Halo' not in meaning['destination']:
                            NotifyTHIS.append(meaning['destination'])
                    if meaning['type']=="Assured Destruction":
                        NotifyTHIS.append(meaning['before'])
                    if meaning['type']=="Switch":
                        NotifyTHIS.append(meaning['before'])
                        NotifyTHIS.append(meaning['destination'])
                else:                    
                    if meaning!={}:
                        if notify!="":
                            NotifyTHIS.append(notify)        
                    else:
                        float('a')                
            except:
                QuestionBox("Script is not valid!", "OK")
                return False, "Script is not valid!"
        special=0
        mintthis=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if "MoveReserve:" in testaddr:
                valid=1
                address=address.replace("MoveReserve:", "")
                special=1
            if "VoluntaryFreeze:" in testaddr:
                valid=1
                address=address.replace("VoluntaryFreeze:", "")
                special=2
            if "Mint:" in testaddr:
                valid=1
                address=address.replace("Mint:", "")                
                mintthis=ast.literal_eval(address)
                address=mintthis['a']
                tot=0
                for val in mintthis['r']:
                    tot += int(val)
                tot -= int(abs(Decimal(fee)*Decimal(1e8)))
                if tot != amount:
                    QuestionBox("Amount is incorrect", "OK")
                    return False, "Amount is incorrect"
                if address != multisig:
                    QuestionBox("The address is incorrect. You are not the recipient of this mint.", "OK")
                    return False, "Amount is incorrect"
        if valid==1:
            if "Script:" not in testaddr and "@" not in address and amtarray == [] and bridgetx == 0:
                try:
                    b58check_to_hex(address)
                except:
                    QuestionBox("Address is incorrect or contains spaces!", "OK")
                    return False, "Address is incorrect or contains spaces!"
        else:
            QuestionBox("Address is incorrect or contains spaces!", "OK")
            return False, "Address is incorrect or contains spaces!"
        try:
            float(amount)
        except ValueError:            
            return False, "Invaid amount"
        try:
            float(fee)
        except ValueError:
            return False, "Invalid fee"
        fee = int(abs(Decimal(fee)*Decimal(1e8)))
        if "@" in address:#Add one fee here so the recipient gets the exact amount
            amount+=fee#For BitHalo this can get excessive, probably adjust later
            QuestionBox(Gtranslate("The amount has been adjusted to cover the fee for the second transaction in 'Pay To Email'.\nNew Total: "+str(Decimal(amount)/Decimal(1e8))), "OK") 
        feenotify=0
        apifee=0
        if apicontract!={} and amtarray==[] and "@" not in address:#In case extra burn outputs are used for messages for contracts            
            if 'burn' in apicontract:
                apifee=5560+5599
            amount+=apifee
            if apifee!=0:
                feenotify=1
        if SCRIPT==1:
            xfee=0
            if NotifyTHIS!=[]:
                if meaning['type']!="Notary/Burn":
                    xfee=5577*len(NotifyTHIS)
                    moreouts=ConvertScriptToOuts(address)
                    if moreouts!=[]:
                        xfee+=11154*len(moreouts)
                else:
                    xfee+=5560
            amount+=xfee
            if xfee!=0:
                feenotify=1               
        #Checking available balance after unconfirmed contracts/orders
        global Spendable
        if len(Spendable)<1 and mintthis == 0:
            QuestionBox("The history is not up to date or there are no inputs available. Please wait or refresh the internet connection.", "OK")
            if apicontract=={}:
                self.Tabs.setCurrentIndex(3)
            return False, "The history is not up to date or there are no inputs available. Please wait or refresh the internet connection."
        balance2=0        
        #This can be seen in every spending function. It simply filters out open orders from what is truly available
        exoticfilter=0
        if special==0:
            SpendThis=list(FilterSpendable(OnOrders,Spendable))
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if special!=0 or bridgetx==1:
                exoticfilter=1
                SpendThis=list(FilterSpendable(OnOrders,Spendable,1))#Let us not worry about time locks which may get declined later
                TestSpend=list(FilterSpendable(OnOrders,Spendable))
                test1=0
                test2=0
                for i in SpendThis:
                    test1+=i['value']
                for i in TestSpend:
                    test2+=i['value']                            
                test1 = Decimal(test1)/Decimal(1e8)
                test2 = Decimal(test2)/Decimal(1e8)
                if test1!=test2:
                    mbox=0
                    if not exoticnotify:
                        mbox=QuestionBox(Gtranslate("Please note, time locked and exotic transactions are not spendable in this type of transfer. You are getting this notification because some inputs were filtered. If you would like the exotic inputs to be made available to this contract you simply need to spend them by sending some coins to yourself. The amount of funds not being considered for this transaction totals: ") + str(Decimal(test2)-Decimal(test1)), " OK ", " Break for change and free up some of the inputs ", " Don't show this message again. ", 1)
                    if mbox == 1:
                        self.Tabs.setCurrentIndex(1)
                        window.BitPayTo.setText(str(multisig))
                        window.BitAmount.setText(str("0.0001"))
                        QuestionBox("Please review the information to confirm the address is your own. To break for change, you simply make a payment to yourself. When ready, simply click 'Send'.", "OK")
                        return False, "User is going to make change."
                    if mbox==2:
                        exoticnotify=True
        #Spendable and OnOrders
        #Making change from the magic change function
        maxinputs=25
        if apifee!=0:#For the peg we will maximize liquidity by not making extra change on escrow payments
            maxinputs=0
        askedaboutpremium=0
        sfee=0
        rating=''
        try:
            if mintthis == 0:
                inputs,outputs,Total = MakeChange (SpendThis, amount+fee, multisig, maxinputs, 0, special)
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    if special==0:
                        rating=self.RateLiquid(inputs)
                        askme=1
                        if TestnetPeg and multisig not in ThePeg.whitelist:
                            askme=0
                        if rating < ThePeg.subpremiumrating and askedaboutpremium==0 and askme==1:
                            askedaboutpremium=1
                            res=QuestionBox(Gtranslate('Please note, you are sending subpremium coins. That means the coins are set to freeze soon and are not fully liquid. Although you may proceed, if you are sending these coins as a payment it is recommended to send coins that are more liquid. Do you still wish to continue?\n\nLiquidity Rating: ')+str(Decimal(rating)), Gtranslate(' OK '), Gtranslate(' Cancel '),1)
                            if res==1:
                                return False, "Funds not liquid enough."
                    else:
                        if len(Spendable)==1 and apicontract=={} and askedaboutpremium==0:
                            askedaboutpremium=1
                            mbox = QuestionBox("You only have one input. We recommend breaking for change, dividing your balance into smaller pieces. This will also increase the chances of a consecutive stake reward. For more information on how coins work like cash, please read the documentation. Would you like to break for change now?", " Yes ", " No ")
                            if mbox != 1:
                                self.Tabs.setCurrentIndex(1)
                                window.BitPayTo.setText(str(multisig))
                                window.BitAmount.setText(str("0.0001"))
                                QuestionBox("Please review the information to confirm the address is your own. To break for change, you simply make a payment to yourself. When ready, simply click 'Send'.", "OK")
                                return False, "The user has chosen to break for change."
        except:
            traceback.print_exc()
            QuestionBox("Not enough available funds!", "OK")
            return False, "Not enough available funds!"
        try:
            if mintthis != 0:
                feenotify=1
                balance2=amount+fee
                Total=amount+fee
                amt2 = amount
                mintdata="**Y**"+str(mintthis)
                outputs=[]
                while(len(mintdata)>0):
                    outputs.append({'value':5777,'script':MakeCipherOutputs(mintdata[:244], 1)[0]})
                    mintdata=mintdata.replace(mintdata[:244],'')
                    amt2 -= 5777
                    amount += 5777
                    fee -= 5777
                if amt2 < 5000 or fee < 5000:
                    float('a')
                outputs.insert(0,{'value':amt2,'address':address})
                found=0
                for bridged in ThePeg.Pegdatabase['bridgedb']['bridges']:
                    if mintthis['w']==txhash(bridged['n'])[:64]:
                        found=1
                        break
                if found == 0:
                    traceback.print_exc()
                vpos=0
                for val in mintthis['r']:
                    mintthis['r'][vpos]=int(mintthis['r'][vpos])
                    vpos+=1
                thetxid = txhash(str([mintthis['w'],int(mintthis['n']),mintthis['f'],mintthis['a'],int(mintthis['s']),mintthis['r']]))+":0"
                inputs=[{'output':thetxid,'value':balance2,'address':address}]
                #print str(inputs) + "\n\n" + str(outputs) + "\n"
        except:
            traceback.print_exc()
            QuestionBox("Minting receipt was not valid", "OK")
            return False, "Minting receipt was not valid"
        if apicontract!={} and fee==0:#If we are using the API we can ask for automatic adjustment of the fee by setting it to zero
            count=0
            mybytes=1500 # A buffer for the fee
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes*=2
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                outfee=ThePeg.pegfeeperinput/10
            else:
                outfee=34
            for amt in amtarray:
                mybytes+=outfee
            for myin in inputs:
                count+=1
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    mybytes+=ThePeg.pegfeeperinput/10
                else:
                    mybytes+=360#Double the signatures this seemed like a good rule of thumb
            for myout in outputs:
                count+=1
                mybytes+=outfee
            if SCRIPT==1:
                if NotifyTHIS!=[]:
                    mybytes+=outfee*len(NotifyTHIS)#Fee for notification
                    if meaning['type']!="Notary/Burn":
                        moreouts=ConvertScriptToOuts(address)
                        if moreouts!=[]:
                            mybytes+=outfee*len(moreouts)
            if apicontract!={}:#In case extra burn outputs are used for messages for contracts
                if 'burn' in apicontract:
                    mybytes+=outfee*2
            mybytes2=mybytes
            mybytes+=500#Just giving the automatic adjustment more strength
            mybytes=int(round(mybytes,-3))
            mybytes=mybytes*10#Convert from kb to satoshi
            if BitHaloClient == True:#Bitcoin is extremely slow for large transactions, we need to really raise the fee
                mybytes=mybytes*2
                #Even though Bitcoin traffic can stall transactions, we do not adjust the fee based on the information
                #from the web because that would not be secure. Any adjustment should be manual.
            else:
                mybytes=mybytes*2#We can pay higher fees in BitBay anyways
            fee=mybytes
            try:
                inputs,outputs,Total = MakeChange (SpendThis, amount+fee, multisig, maxinputs, 0, special)
                #Eventually we might want to have users send premium only for payments to employees
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    if special==0:
                        rating=self.RateLiquid(inputs)
                        askme=1
                        if TestnetPeg and multisig not in ThePeg.whitelist:
                            askme=0
                        if rating < ThePeg.subpremiumrating and askedaboutpremium==0 and askme==1:
                            askedaboutpremium=1
                            res=QuestionBox(Gtranslate('Please note, you are sending subpremium coins. That means the coins are set to freeze soon and are not fully liquid. Although you may proceed, if you are sending these coins as a payment it is recommended to send coins that are more liquid. Do you still wish to continue?\n\nLiquidity Rating: ')+str(Decimal(rating)), Gtranslate(' OK '), Gtranslate(' Cancel '),1)
                            if res==1:
                                return False, "Funds not liquid enough."
            except:
                traceback.print_exc()
                QuestionBox("Not enough available funds!", "OK")
                return False, "Not enough available funds!"
        #Check to see if we need to add notifications.
        nfee=0
        addthese=[]
        for i in inputs:#Exotic inputs should notify the counter-party to avoid double spend attempts
            if i['output'] in NEWTxidLookup:
                try:
                    if NEWTxidLookup[i['output']]['txid']==i['output']:
                        meaning2=translate_script(NEWTxidLookup[i['output']]['script'])
                        if meaning2 != {}:
                            if 'before' in meaning2:
                                if meaning2['before'] != multisig:                               
                                    addthese.append({'value':5579,'address':meaning2['before']})
                                    nfee+=5579
                                if meaning2['destination'] != multisig:
                                    addthese.append({'value':5579,'address':meaning2['destination']})
                                    nfee+=5579
                except:
                    print "Could not find exotic input"
        if addthese != []:
            amount+=nfee
            feenotify=1
            SpendThis=list(FilterSpendable(OnOrders,Spendable))
            try:
                inputs,outputs,Total = MakeChange (SpendThis, amount+fee, multisig, maxinputs, 0, special)
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    if special==0:
                        rating=self.RateLiquid(inputs)
                        askme=1
                        if TestnetPeg and multisig not in ThePeg.whitelist:
                            askme=0
                        if rating < ThePeg.subpremiumrating and askedaboutpremium==0 and askme==1:
                            askedaboutpremium=1
                            res=QuestionBox(Gtranslate('Please note, you are sending subpremium coins. That means the coins are set to freeze soon and are not fully liquid. Although you may proceed, if you are sending these coins as a payment it is recommended to send coins that are more liquid. Do you still wish to continue?\n\nLiquidity Rating: ')+str(Decimal(rating)), Gtranslate(' OK '), Gtranslate(' Cancel '),1)
                            if res==1:
                                return False, "Funds not liquid enough."
            except:
                traceback.print_exc()
                QuestionBox(Gtranslate("The amount has been adjusted to add a few notifications on the blockchain.\nNew Total: "+str(Decimal(amount)/Decimal(1e8))), "OK")
                QuestionBox("Not enough available funds!", "OK")
                return False, "Not enough available funds!"
            for o in addthese:
                outputs.append(o)
        if rating!='':
            rating="\nLiquidity Rating: "+str(int(rating))
        else:
            if 'pegging' in CoinSelect and CoinSelect['pegging'] and mintthis == 0:
                try:
                    rating=self.RateLiquid(inputs)
                    rating="\nLiquidity Rating: "+str(int(rating))
                except:
                    traceback.print_exc()
        if apicontract!={}:#In case extra burn outputs are used for messages for contracts
            if 'burn' in apicontract:
                if len(apicontract['burn'])>20:#Maximum is 40 bytes
                    return False, "Burn length is more than 20 characters"
                burntext=hexlify(apicontract['burn'])
                hexleng=num_to_var_int((len(burntext)/2)).encode('hex')
                for addy in apicontract['notify']:
                    outputs.append({'value':5599,'script':str("6a"+hexleng+burntext)})
                    outputs.append({'value':5560,'address':addy})
        if feenotify==1:
            QuestionBox(Gtranslate("The amount has been adjusted to add a few notifications on the blockchain.\nNew Total: "+str(Decimal(amount)/Decimal(1e8))), "OK")
        for i in SpendThis:
            balance2+=i['value']
        passthis=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            passthis=1
        if amount+fee > balance and passthis==0:
            QuestionBox("Not enough funds!", "OK")
            return False, "Not enough funds!"
        if amount+fee > balance2:
            QuestionBox("The inputs on the outgoing orders will exceed the balance. Please check your available balance and complete/cancel your unconfirmed orders.", "OK")
            return False, "The inputs on the outgoing orders will exceed the balance. Please check your available balance and complete/cancel your unconfirmed orders."
        checkdust=0
        if amount+fee!=balance and passthis==0:
            if amount+fee > balance - 5500:
                checkdust=1
        if amount+fee!=balance2:#Ok its less than the full balance...how much less?
            if amount+fee > balance2 - 5500:
                checkdust=1
        if checkdust==1:
            QuestionBox("The change on available inputs would be lower than the anti-dust minimum of 5500 satoshis. Try adding funds, increase fees or free up some inputs.", "OK")
            return False, "The change on available inputs would be lower than the anti-dust minimum of 5500 satoshis. Try adding funds, increase fees or free up some inputs."
        if keysconnected == "1":
            mbox = QuestionBox("Only one key connected. Please connect both keys or use the Two Step Send option below with 'Create Signature File'.\n\nWould you like to perform a Two Step Send instead?", " Yes ", " No ")
            if mbox == 1:
                return False, "Only one key connected."
            if apicontract=={}:
                self.TwoStepSendpt1()
            return False, "Only one key connected."
        outindex=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            for i in outputs:
                if i['value']==5590:
                    sfee+=5590
            if special!=0:
                outs1=[]
                outs2=[]
                if special==1:
                    ftype="F"
                if special==2:
                    ftype="V"
                theamt=amount
                theamt=theamt-apifee-nfee
                sfee+=nfee
                sfee+=apifee
                batch=0
                if bridgetx==1:
                    outs1.append({'value':theamt, 'script':address})
                    theamt=0
                    outindex=1
                else:
                    for i in inputs:
                        if i['value']<theamt:
                            #Batch the amounts since consecutive stakes are more common over 50k coins
                            #Also for users who receive donations or small payments it's important to avoid accidental bloat of the chain
                            batch+=i['value']
                            if batch>4999900000000:
                                outs1.append({'value':batch, 'address':address})
                                batch=0
                            theamt-=i['value']
                        else:
                            outs1.append({'value':theamt+batch, 'address':address})
                            batch=0
                            theamt=0
                            break
                if batch > 0 or theamt > 0:
                    print str(SpendThis)
                    QuestionBox("Not enough funds!","OK")
                    return False, "Not enough funds!"
                inx=len(outs1)
                for i in outs1:
                    sfee+=5590
                    outs2.append({'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**'+str(ftype)+'**'+str(inx)))/2)).encode('hex')+hexlify('**'+str(ftype)+'**'+str(inx))})
                    inx+=1
                inx=0
                for i in outs2:
                    outputs.insert(inx, i)
                    inx+=1
                for i in outs1:
                    outputs.insert(inx, i)
                    inx+=1
        count=0
        mybytes=1500 # A buffer for the fee
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            mybytes*=2
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            outfee=ThePeg.pegfeeperinput/10
        else:
            outfee=34
        for amt in amtarray:
            mybytes+=outfee
        for myin in inputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:            
                mybytes+=360#Double the signatures this seemed like a good rule of thumb
        for myout in outputs:
            count+=1
            mybytes+=outfee
        if SCRIPT==1:
            if NotifyTHIS!=[]:
                mybytes+=outfee*len(NotifyTHIS)#Fee for notification
                if meaning['type']!="Notary/Burn":
                    moreouts=ConvertScriptToOuts(address)
                    if moreouts!=[]:
                        mybytes+=outfee*len(moreouts)
        if apicontract!={}:#In case extra burn outputs are used for messages for contracts
            if 'burn' in apicontract:
                mybytes+=outfee*2
        mybytes2=mybytes
        mybytes=int(round(mybytes,-3))
        mybytes=mybytes*10#Convert from kb to satoshi
        mybytes+=sfee
        if BitHaloClient == True:#Bitcoin is extremely slow for large transactions, we need to really raise the fee
            mybytes=mybytes*2
        if BitHaloClient ==  False:
            if mybytes>(int(fee)):
                print str(fee)
                QuestionBox(Gtranslate("The fee is not high enough to cover the inputs.\n\nRecommended Fee:\n") + str(Decimal(mybytes)/Decimal(1e8)), Gtranslate("OK"),1)
                return False, "The fee is not high enough to cover the inputs.\n\nRecommended Fee:\n" + str(Decimal(mybytes)/Decimal(1e8))
        else:
            if mybytes>(int(fee)):
                QuestionBox(Gtranslate("The fee may not be high enough to cover the inputs. You may proceed, however consider raising the fee.\n\nRecommended Fee:\n") + str(Decimal(mybytes)/Decimal(1e8)), Gtranslate("OK"),1)
        if BitHaloClient == True:#Lets see if the fee is high enough for the network traffic
            if int(fee)/int(mybytes2)<int(btcfeekb):
                recommended=str(((Decimal(btcfeekb)*Decimal(mybytes2))+10000)/Decimal(1e8))
                res=QuestionBox(Gtranslate("The fee is not high enough for a fast confirmation in the Bitcoin network. It's possible you have many small inputs or that the network is experiencing high traffic. Please raise the fee to the recommended amount of satoshis per kilobyte.\n\nCurrent Satoshis/KB:\n")+str(int(fee)/int(mybytes2))+Gtranslate("\n\nRecommended Satoshis/KB:\n")+str(btcfeekb)+Gtranslate("\n\nRecommended minimum fee:\n")+recommended, Gtranslate("OK"),1)
                return False, "The fee is not high enough for a fast confirmation in the Bitcoin network." + "\nRecommended minimum fee:\n" + recommended
        condaddr=address
        if SCRIPT==1 and bridgetx==0:
            if meaning['type']!="Notary/Burn":
                if BitHaloClient==False:
                    condaddr = scriptaddr(address.decode('hex'))
                else:
                    condaddr = pybit.transaction.scriptaddr(address.decode('hex'))
            else:
                if Decimal(orgamount)==Decimal("0.0001"):
                    res=QuestionBox("Notary/Burn will cost you 0.0001 coins, would you like to proceed?", "Yes", "No")
                    if res==1:
                        return False, ""
                else:
                    QuestionBox("Incorrect amount! Notary costs 0.0001 coins. Please fix the amount before proceeding.", "OK")
                    return False, "Incorrect amount! Notary costs 0.0001 coins. Please fix the amount before proceeding."
        #Adding their output
        providers=['@gmail','@hotmail','@outlook','@aol.com']
        if amtarray==[]:
            if "@" in address:
                if MyEmail==" " or MyEmail=="":
                    QuestionBox("No return Email address loaded. Please set one up.", "OK")
                    return False, "No return Email address loaded. Please set one up."
                fn=0
                for p in providers:
                    if p in address:
                        fn=1
                if fn==0:
                    mbox = QuestionBox("Their email isn't in the list of supported imap providers. You can continue if you wish. However, in order for them to spend the email in Halo, they will need to send the email to a supported imap address(such as Gmail). The supported email providers are listed in the help box of the 'Receive Tab'.\n\nDo you wish to continue?", " Yes ", " No ")
                    if mbox == 1:
                        return False, "Their email isn't in the list of supported imap providers."
                content=""
                QuestionBox("The funds will be sent to a temporary address. If the counter-party never claims the funds, you can redeem them in the history panel.", "OK")
                priv=sha256(str(os.urandom(256)+SALT))
                pub=privtopub(priv)
                if BitHaloClient == True:
                    tmpaddr = pubtoaddr(pub)
                else:
                    tmpaddr = pubtoaddr(pub, 25)
                out={'value':amount-apifee-nfee,'address':tmpaddr}
                outputs.insert(0,out)
                P2MWindow.initwindow()
                res=P2MWindow.exec_()
                if res==0:
                    return False, "Pay to email canceled"
                #We get a password for the pay to email. I tried hiding it in a jpeg. However most email providers don't allow inline images. I would have to do it as a mime. So for now, its just encrypted data
                if Password=="":
                    if P2MWindow.checkBox.checkState() == 2:
                        text, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Enter the password for this payment:'), QtGui.QLineEdit.Password)
                        text1, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Confirm the password for this payment:'), QtGui.QLineEdit.Password)
                        if str(text) == "":
                            return False, ""
                        if text != text1:
                            QuestionBox("The passwords typed did not match try again.", "OK")
                            return False, "Passwords did not match"
                        key = str(text)
                        Password = password.EncryptWithAES(key, priv)
                        Password = "PASSWORDPROTECTED:"+Password
                        QuestionBox("Please alert the counter-party of this password so they can unlock the funds.", "OK")
                try:
                    message=str(P2MWindow.textEdit.toPlainText())
                except:
                    QuestionBox("Personal messages to email addresses must not use foreign characters.","OK")
                    return False, "Personal messages to email addresses must not use foreign characters."
                message=str(message)
                if message != "":
                    message += "<br /><br />"
                if Password != "":
                    im2 = password.EncryptWithAES("Halo Master", Password)
                else:
                    im2 = password.EncryptWithAES("Halo Master", priv)
                nm=CoinSelect['name']
                if CoinSelect['name'] != "BitBay":
                    nm+="s"
                content= message+"You have received a payment of "+str(dropzeros((Decimal(amount)/Decimal(1e8))-(Decimal(fee)/Decimal(1e8)),1))+" "+nm+"! Please do not delete this email.<br \>If you are new to Cryptocurrency, somebody may have sent you these coins as a 'Tip'. If you were expecting a payment then please open " + CoinSelect['HaloName'] + ".<br \>Make sure you have this specific email account loaded into Halo to redeem the coins. If the coins are password protected, please ask the counter-party<br \>for the password. If you have not yet downloaded "+CoinSelect['HaloName'] + " then please do so here...<br \><br \>"
                content+="<a href='"+CoinSelect['website']+"'>"+CoinSelect['website']+"</a ><br \><br \>"
                ordernumber=os.urandom(16).encode('hex')
            else:
                if SCRIPT==1 and bridgetx==0:
                    if meaning['type']!="Notary/Burn":
                        out={'value':amount-xfee-apifee-nfee,'address':condaddr}
                    else:
                        out={'value':amount-xfee-apifee-nfee,'script':address}                  
                else:
                    if bridgetx==0:
                        out={'value':amount-apifee-nfee,'address':address}
                    else:
                        out={'value':amount-apifee-nfee,'script':address}
                if special==0:
                    outindex=len(outputs)
                    if mintthis == 0:
                        outputs.append(out)
                if NotifyTHIS!=[]:
                    if meaning['type']!="Notary/Burn":
                        outputs.append({'value':5577,'address':NotifyTHIS[0]})
                        if len(NotifyTHIS)==2:
                            outputs.append({'value':5577,'address':NotifyTHIS[1]})
                        moreouts=ConvertScriptToOuts(address)
                        for myout in moreouts:
                            outputs.append(myout)
                    else:
                        outputs.append({'value':5560,'address':NotifyTHIS[0]})
        pos=0
        for amt in amtarray:
            try:
                b58check_to_hex(adarray[pos])
                out={'value':int(abs(Decimal(amtarray[pos])*Decimal(1e8))),'address':adarray[pos]}
                outputs.append(out)
                pos+=1
            except:
                QuestionBox("One of the addresses or amounts you entered was invalid.", "OK")
                return False, "One of the addresses or amounts you entered was invalid."
        pass #print "Making the tx was a success!\n",inputs,"\n",outputs
        feeperbyte=QtCore.QString("")
        if BitHaloClient==True:#To deal with backlog, we should let users know their fee per byte
            feeperbyte=QtCore.QString("\n"+Gtranslate("Fee per byte: ") + str(int(fee/mybytes2)) + Gtranslate(" (estimated)"))           
        if amtarray==[]:
            mbox = QuestionBox(Gtranslate('Instant Send') + "\n"+Gtranslate("Address: ") + condaddr + "\n"+Gtranslate("Amount: ") + str(Decimal(amount)/Decimal(1e8)) + "\n"+Gtranslate("Fee: ") + str(Decimal(fee)/Decimal(1e8)) + feeperbyte + rating + "\n"+Gtranslate("Total: ") + str(Decimal(amount)/Decimal(1e8)+Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + "\n"+Gtranslate("Change: ") + str(Decimal(Total)/Decimal(1e8)-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Please confirm the details.\n\nNote:\nCoins works just like cash. For more information\non how Halo manages change please read the\ndocumentation from the help menu."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
        else:
            mbox = QuestionBox(Gtranslate('Instant Send') + "\n"+Gtranslate("Address: ") + condaddr + "\n"+Gtranslate("Amount: ") + str(orgamount) + "\n"+Gtranslate("Fee: ") + str(Decimal(fee)/Decimal(1e8)) + feeperbyte + rating + "\n"+Gtranslate("Total: ") + str(Decimal(amount)/Decimal(1e8)+Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + "\n"+Gtranslate("Change: ") + str(Decimal(Total)/Decimal(1e8)-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Please confirm the details.\n\nNote:\nCoins works just like cash. For more information\non how Halo manages change please read the\ndocumentation from the help menu."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
        if mbox == 1:
            return False, ""
        AmFirst=AmIFirst(PrivKeyFiledir1,PrivKeyFilename1)
        #{"asm" : "OP_RETURN 636861726c6579206c6f766573206865696469","hex" : "6a13636861726c6579206c6f766573206865696469","type" : "nulldata"}
        mtmp=""
        if SCRIPT==1 or apicontract!={} or special!=0 or bridgetx==1 or mintthis != 0:
            mtmp=mktx_script(timest,inputs,outputs)
        splashy=1
        lockit=lockforspending
        skipmybroadcast=0
        if apicontract!={}:
            if 'nosplash' in apicontract:
                splashy=0
            if 'unlock' in apicontract:
                lockit=""
            skipmybroadcast=1
            if 'broadcast' in apicontract:
                skipmybroadcast=0

        #Which key signs first?
        if AmFirst==1:
            sigs,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename1, PrivKeyFiledir1, timest, tmptx=mtmp, splashme=splashy, unlockthis=lockit)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False, "Incorrect password."
            sigs2,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename2, PrivKeyFiledir2, timest, tmptx=mtmp, splashme=splashy, unlockthis=lockit)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False, "Incorrect password."
        else:
            sigs,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename2, PrivKeyFiledir2, timest, tmptx=mtmp, splashme=splashy, unlockthis=lockit)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False, "Incorrect password."
            sigs2,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename1, PrivKeyFiledir1, timest, tmptx=mtmp, splashme=splashy, unlockthis=lockit)
            if result == False:
                QuestionBox("Incorrect password.", "OK")
                return False, "Incorrect password."
        #Ok this is getting exciting... lets broadcast!
        busy=0
        #if splashy==1:
        #    busy=NetSplash(1)
        if busy==0:
            if AmFirst==1:
                tx,result=broadcast_to_network(sigs,sigs2,inputs,outputs,PrivKeyFilename1, timest, skipbroadcast=skipmybroadcast, tx=mtmp, splashme=splashy)
            else:
                tx,result=broadcast_to_network(sigs2,sigs,inputs,outputs,PrivKeyFilename1, timest, skipbroadcast=skipmybroadcast, tx=mtmp, splashme=splashy)
        else:
            print "Network busy, try again later"
            result="TX rejected: Network busy, try again later."
        if bridgetx==1:
            bridgedata['txid']=txhash(tx)+":"+str(outindex)
            if ThePeg.testthis==1:
                if 'bridgetx' not in AdvanceArray:
                    AdvanceArray['bridgetx']={}
                if 'bridgecheck' not in AdvanceArray:
                    AdvanceArray['bridgecheck']=[]
                try:
                    AdvanceArray['bridgecheck'].append(bridgedata['txid'])
                    AdvanceArray['bridgetx'][bridgedata['txid']]={'pool':[0]*1200} #calculate this later
                except:
                    traceback.print_exc()
            #if ThePeg.testthis==1:
            #    try:
            #        #NOTE: In practice don't perform these actions here. This is only for testing purposes
            #        busy=NetSplash(1)
            #        res2,stuff,somefees=ThePeg.checktransaction(tx, returnliquid=1)
            #        NetSplash(0)
            #        xpos=0
            #        while xpos < 1200:
            #            bridgedata['pool'][xpos]=stuff['txout'][bridgedata['txid']]['pool'][str(xpos)]
            #            xpos+=1
            #        if bridgedata['txid'] not in ThePeg.Pegdatabase['txidreference']:
            #            ThePeg.Pegdatabase['txidreference'][bridgedata['txid']]=ThePeg.Pegdatabase['merklenonceTX'] #For easy reference finding a TX
            #            ThePeg.Pegdatabase['merklelist'][str(ThePeg.Pegdatabase['merklenonceTX'])]['transactions'].append(copy.deepcopy(bridgedata))
            #        AdvanceArray['bridgetx'][bridgedata['txid']]={'pool':copy.deepcopy(bridgedata['pool'])}
            #    except:
            #        traceback.print_exc()
            #        try:
            #            if bridgedata['txid'] not in ThePeg.Pegdatabase['txidreference']:
            #                ThePeg.Pegdatabase['txidreference'][bridgedata['txid']]=ThePeg.Pegdatabase['merklenonceTX'] #For easy reference finding a TX
            #                ThePeg.Pegdatabase['merklelist'][str(ThePeg.Pegdatabase['merklenonceTX'])]['transactions'].append(copy.deepcopy(bridgedata))
            #            AdvanceArray['bridgecheck'].append(bridgedata['txid'])
            #            AdvanceArray['bridgetx'][bridgedata['txid']]={'pool':[0]*1200}
            #        except:
            #            traceback.print_exc()
            #        print "Pool data not saved"

        #if splashy==1:
        #    NetSplash(0)
        if "TX rejected" in str(result):
            QuestionBox(str(result), Gtranslate("OK"),1)
            return False, str(result)
        else:
            print str(result)
            NewOrder={}
            #Both regular expenses and pay to email still wait on the same change.
            NewOrder['type']="SPENT"
            NewOrder['ordernumber']=os.urandom(16).encode('hex')
            NewOrder['total']=Total
            NewOrder['change']=str(Decimal(Total)/Decimal(1e8)-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8))
            NewOrder['currentblock']=CurrentBlock
            NewOrder['Confirmation TXID']=txhash(tx)

            NewOrder['inputs']=inputs
            NewOrder['output']=outputs
            NewOrder['amount']=amount
            NewOrder['fee']=fee
            NewOrder['address']=condaddr
            if SCRIPT==1:
                NewOrder['script']=address
            if bridgetx==1:
                NewOrder['script']=address.replace("MoveReserve:","")
                NewOrder['script']=address.replace("VoluntaryFreeze:","")
                NewOrder['bridge']=True
            NewOrder['timestamp']=timest
            NewOrder['version']=CoinSelect['HaloName'] + " " + clientversion
            OnOrders.append(NewOrder)
            if "@" in address:
                NewOrder2=json_deep_copy(NewOrder,1)
                NewOrder2['type']="PAY TO EMAIL"
                NewOrder2['Redeemed']=0
                NewOrder2['Temporary Address']=tmpaddr
                if BitHaloClient==False:
                    WatchlistQueue.append("0"+tmpaddr)
                NewOrder2['priv']=im2
                NewOrder2['ordernumber']=ordernumber
                NewOrder2['theiraddress']=MyEmail
                NewOrder2['change']=str("0")
                NewOrder2['total']=amount
                OnOrders.append(NewOrder2)
            hist={}
            hist['Amount']=str(dropzeros((Decimal(amount)/Decimal(1e8)),1))
            if "@" not in address:
                hist['Details']=NewOrder
            else:
                hist['Details']=NewOrder2
            hist['Details']['date']=ConvertDate(HaloTime,0)
            hist['Details']['Pending']=True
            if rating!='':
                hist['Details']['rating']=rating.split(": ")[1]
            if multisig==address:
                hist['Type']="Change"
            else:
                if "@" in address:
                    Reply={}
                    hist['Amount']="-"+str(dropzeros((Decimal(amount)/Decimal(1e8)),1))
                    NewOrder2['MyBMAddress']=MyEmail
                    NewOrder2['TheirBMAddress']=address
                    t=password.EncryptWithAES("Halo Master", str(NewOrder2))
                    content2=""
                    content2+="<br \><br \>DATA:"+str(t)
                    content2+="***"+ordernumber+"###<br \>"
                    content2+="This is a Halo Pay to Email, please do not delete, there is coins hidden inside this email."
                    #Encode into the chose image
                    try:
                        rawimg=StringIO.StringIO(base64.b64decode(P2MWindow.b64img))
                        im=Image.open(rawimg)
                        rawout=StringIO.StringIO()
                        im2=stepic.encode(im, content2)
                        im2.save(rawout,"BMP")#It must be lossless PNG or BMP. BMP works well with the pyzmail library
                        b64= base64.b64encode(rawout.getvalue())
                        #b64="============================================================================================"+b64+"============================================================================================"
                        Reply['Data']=content
                        Reply['b64img']=b64
                        Reply['MyBMAddress']=MyEmail
                        Reply['TheirBMAddress']=address
                        Reply['Command']='Send'
                        BitQueue.append(Reply)
                        SaveQueue()
                        hist['Type']="Pay To Email"
                        rawimg.close()
                        rawout.close()
                        rawout=""
                        rawimg=""
                    except:
                        rawout.close()
                        rawimg.close()
                        rawout=""
                        rawimg=""
                        QuestionBox("There was an error encoding the coins into your selected image. Please choose a different image. Images should not be small and be high enough resolution and quality to encode the data. You can redeem this payment yourself in 24 hours in the history panel.", "OK")
                else:
                    hist['Type']="Spent"
            hist['Label']=''
            global HistoryDetail
            if multisig not in HistoryDetail:
                HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
            if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
                HistoryDetail[multisig]=[hist]
            else:
                HistoryDetail[multisig].insert(0,hist)
            if SCRIPT==1:
                if bridgetx==0:
                    if meaning['type']=="Notary/Burn":
                        hist2=copy.deepcopy(hist)
                        hist2['Type']="Notary/Burn"
                        hist2['script']=address
                        hist2['notify']=notify
                        AddToHistory(txhash(tx), "", multisig, str(Decimal(amount)/Decimal(1e8)), hist2['Type'], hist2)
                else:
                    hist2=copy.deepcopy(hist)
                    hist2['Type']="Bridge"
                    hist2['script']=address.replace("MoveReserve:","")
                    hist2['bridgedata']=copy.deepcopy(bridgedata)
                    hist2['bridgedata'].pop('pool')
                    AddToHistory(txhash(tx), "", multisig, str(Decimal(amount)/Decimal(1e8)), hist2['Type'], hist2)
            PopulateHistory()
            myorder="Spent coins! Waiting for confirmations(click here if the order never confirms):      Order number:  " + NewOrder['ordernumber'] + "   Confirmation TXID: " + NewOrder['Confirmation TXID']
            window.HistorylistWidget.addItem(str(myorder))
            QuestionBox(str(txhash(tx))+Gtranslate("\nSuccess! It may take a moment to reflect in your balance."), Gtranslate("OK"),1)
            if bridgetx==1:
                QuestionBox("You have sent a bridged transaction to another network. This is a two step process and it may take up to a day for this transaction to confirm. After a day you should attempt to redeem the transaction by clicking on it where it says 'Bridge' in the history panel and following the instructions."," OK ")
            updatesomething = 1
            return tx, "Success!"

    def TwoStepSendpt1(self):
        global Spendable, OnOrders, updatesomething
        global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected, BitHaloClient, MyEmail
        global timestamp, CurrentBlock, clientversion, CoinSelect, btcfeekb, exoticnotify
        timest=timestamp
        if keysconnected == "0":
            QuestionBox("No keys connected!", "OK")
            return False
        balance=GetfromCfg("#prevbalance#")
        balance = int(Decimal(balance)*Decimal(1e8)) #We use Decimal to be extra sure there are no slip ups between conversions
        address = str(self.BitPayTo.text())
        amount = str(self.BitAmount.text())
        fee = str(self.BitFee.text())
        if "@" in address and "," in address:
            return False
        orgamount=amount
        valid=0
        address=address.replace(" ","")
        amount=amount.replace(" ","")
        usd,btc=GetMarketValue(CoinSelect['name'],CoinMarketCap,0)
        if "$" in amount:
            if CoinMarketCap==" ":
                usd,btc=GetMarketValue(CoinSelect['name'])
            if usd=="":
                QuestionBox("Exchange rate not loaded yet. Please wait or convert the rate manually.", "OK")
                return False
            else:
                QuestionBox(Gtranslate("Please confirm the exchange rate online:\n")+"USD:"+usd+"->"+CoinSelect['name']+"\nBTC:"+btc+"->"+CoinSelect['name']+"\n\n\n"+Gtranslate("Halo calculates the exchange rate for you online. However, rates can change and certain sites may not always be accurate or reliable. Make sure you independently confirm this. Otherwise, you may simply send the coins normally."), Gtranslate("OK"),1)
        adarray, amtarray=ParseMultipay(address,amount)
        if amtarray != []:
            if 'Move Reserve:' in address or 'Voluntary Freeze:' in address:
                QuestionBox("Can not pay multiple addresses on this type of transaction.", "OK")
                return False
            if "Script:" in address or "6a" in address[:2] or "Mint:" in address or "Freeze:" in address:
                QuestionBox("Can not pay scripts on this type of transaction.", "OK")
                return False
            amount=0
            myps=0
            for amt in amtarray:
                if "$" in amt:
                    amt=str((Decimal(amt.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
                    amtarray[myps]=amt
                amount += int(abs(Decimal(amt)*Decimal(1e8)))
                myps+=1
        if "Mint:" in address:
            QuestionBox("Currently this feature is only supported with both keys loaded.", "OK")
            return False
        if amtarray == []:
            if "$" in amount:
                amount=str((Decimal(amount.replace("$",""))/Decimal(usd)).quantize(Decimal('.00000001')))
            amount = int(abs(Decimal(amount)*Decimal(1e8)))
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if ThePeg.Pegdatabase['blockcount']<myblockcount-1:                
                QuestionBox(Gtranslate("Please wait for the peg database to finish synchronizing before trying to spend.\n\nPeg block count:\n")+str(ThePeg.Pegdatabase['blockcount']-1)+Gtranslate("\n\nBlockchain block count:\n")+str(myblockcount), Gtranslate("OK"),1)
                return False
        #Below we check for seemingly valid inputs and we correct to a satoshi amount and absolute values
        testaddr=address
        testaddr=testaddr.replace(".","")
        if "@" in testaddr:
            QuestionBox("You need both keys loaded to use Pay To Email!", "OK")
            return False
        if testaddr[:2]=="6a" or testaddr[:14]=="MoveReserve:6a":
            testthis=testaddr.replace("MoveReserve:","")
            try:
                for bridged in ThePeg.Pegdatabase['bridgedb']['bridges']:
                    if translate_script(testthis)['message'][5:][:64]==txhash(bridged['n'])[:64]:
                        QuestionBox("You need both keys loaded to use the bridge!", " OK ")
                        return False
            except:
                QuestionBox("Address is incorrect or contains spaces!", "OK")
                return False
        special=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if "MoveReserve:" in testaddr:
                special=1
                address=address.replace("MoveReserve:")
                testaddr=address
            if "VoluntaryFreeze:" in testaddr:
                special=2
                address=address.replace("VoluntaryFreeze:")
                testaddr=address
        if "Script:" in testaddr:
            QuestionBox("You need both keys loaded to use Exotic Spending or Notary!", "OK")
            return False
        if re.match("^[A-Za-z0-9,]*$", testaddr):
            valid=1
        if valid==1:
            if "Script:" not in testaddr and "@" not in address and amtarray == []:
                try:
                    b58check_to_hex(address)
                except:
                    QuestionBox("Address is incorrect or contains spaces!", "OK")
                    return False
        else:
            QuestionBox("Address is incorrect or contains spaces!", "OK")
            return False
        try:
            float(amount)
        except ValueError:
            pass #print "Not a number!"
            return False
        try:
            float(fee)
        except ValueError:
            pass #print "Not a number!"
            return False
        fee = int(abs(Decimal(fee)*Decimal(1e8)))
        #Checking available balance after unconfirmed contracts/orders
        global Spendable
        if len(Spendable)<1:
            QuestionBox("The history is not up to date or there are no inputs available. Please wait or refresh the internet connection.", "OK")
            self.Tabs.setCurrentIndex(3)
            return False
        balance2=0
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        exoticfilter=0
        if special==0:
            SpendThis=list(FilterSpendable(OnOrders,Spendable))
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if special!=0:
                exoticfilter=1
                SpendThis=list(FilterSpendable(OnOrders,Spendable,1))#Let us not worry about time locks which may get declined later
                TestSpend=list(FilterSpendable(OnOrders,Spendable))
                test1=0
                test2=0
                for i in SpendThis:
                    test1+=i['value']
                for i in TestSpend:
                    test2+=i['value']                            
                test1 = Decimal(test1)/Decimal(1e8)
                test2 = Decimal(test2)/Decimal(1e8)
                if test1!=test2:
                    mbox=0
                    if not exoticnotify:
                        mbox=QuestionBox(Gtranslate("Please note, time locked and exotic transactions are not spendable in this type of transfer. You are getting this notification because some inputs were filtered. If you would like the exotic inputs to be made available to this contract you simply need to spend them by sending some coins to yourself. The amount of funds not being considered for this transaction totals: ") + str(Decimal(test2)-Decimal(test1)), " OK ", " Break for change and free up some of the inputs ", " Don't show this message again. ", 1)
                    if mbox == 1:
                        self.Tabs.setCurrentIndex(1)
                        window.BitPayTo.setText(str(multisig))
                        window.BitAmount.setText(str("0.0001"))
                        QuestionBox("Please review the information to confirm the address is your own. To break for change, you simply make a payment to yourself. When ready, simply click 'Send'.", "OK")
                        return False
                    if mbox==2:
                        exoticnotify=True
        #Spendable and OnOrders
        #Making change from the magic change function
        maxinputs=25
        askedaboutpremium=0
        sfee=0
        rating=''
        try:
            inputs,outputs,Total = MakeChange (SpendThis, amount+fee, multisig, maxinputs, 0, special)
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                if special==0:
                    rating=self.RateLiquid(inputs)
                    askme=1
                    if TestnetPeg and multisig not in ThePeg.whitelist:
                        askme=0
                    if rating < ThePeg.subpremiumrating and askedaboutpremium==0 and askme==1:
                        askedaboutpremium=1
                        res=QuestionBox(Gtranslate('Please note, you are sending subpremium coins. That means the coins are set to freeze soon and are not fully liquid. Although you may proceed, if you are sending these coins as a payment it is recommended to send coins that are more liquid. Do you still wish to continue?\n\nLiquidity Rating: ')+str(Decimal(rating)), Gtranslate(' OK '), Gtranslate(' Cancel '),1)
                        if res==1:
                            return False
                else:
                    if len(Spendable)==1 and apicontract=={} and askedaboutpremium==0:
                        askedaboutpremium=1
                        mbox = QuestionBox("You only have one input. We recommend breaking for change, dividing your balance into smaller pieces. This will also increase the chances of a consecutive stake reward. For more information on how coins work like cash, please read the documentation. Would you like to break for change now?", " Yes ", " No ")
                        if mbox != 1:
                            self.Tabs.setCurrentIndex(1)
                            window.BitPayTo.setText(str(multisig))
                            window.BitAmount.setText(str("0.0001"))
                            QuestionBox("Please review the information to confirm the address is your own. To break for change, you simply make a payment to yourself. When ready, simply click 'Send'.", "OK")
                            return False
        except:
            traceback.print_exc()
            QuestionBox("Not enough available funds!", "OK")
            return False
        #Check to see if we need to add notifications.
        nfee=0
        feenotify=0
        addthese=[]
        for i in inputs:
            if i['output'] in NEWTxidLookup:
                try:
                    if NEWTxidLookup[i['output']]['txid']==i['output']:
                        meaning2=translate_script(NEWTxidLookup[i['script']])
                        if meaning2 != {}:
                            if meaning2['before'] != multisig:                               
                                addthese.append({'value':5579,'address':meaning2['before']})
                                nfee+=5579
                            if meaning2['destination'] != multisig:
                                addthese.append({'value':5579,'address':meaning2['destination']})
                                nfee+=5579
                except:
                    print "Not enough information on input"
        if addthese != []:
            print "FEE ADJUSTMENT:", nfee
            amount+=nfee
            feenotify=1
            SpendThis=list(FilterSpendable(OnOrders,Spendable))
            try:
                inputs,outputs,Total = MakeChange (SpendThis, amount+fee, multisig, maxinputs, 0, special)
                if 'pegging' in CoinSelect and CoinSelect['pegging']:
                    if special==0:
                        rating=self.RateLiquid(inputs)
                        askme=1
                        if TestnetPeg and multisig not in ThePeg.whitelist:
                            askme=0
                        if rating < ThePeg.subpremiumrating and askedaboutpremium==0 and askme==1:
                            askedaboutpremium=1
                            res=QuestionBox(Gtranslate('Please note, you are sending subpremium coins. That means the coins are set to freeze soon and are not fully liquid. Although you may proceed, if you are sending these coins as a payment it is recommended to send coins that are more liquid. Do you still wish to continue?\n\nLiquidity Rating: ')+str(Decimal(rating)), Gtranslate(' OK '), Gtranslate(' Cancel '),1)
                            if res==1:
                                return False
            except:
                traceback.print_exc()
                QuestionBox(Gtranslate("The amount has been adjusted to add a few notifications on the blockchain.\nNew Total: "+str(Decimal(amount)/Decimal(1e8))), "OK")        
                QuestionBox("Not enough available funds!", "OK")
                return False            
            for o in addthese:
                outputs.append(o)
        if rating!='':
            rating="\nLiquidity Rating: "+str(int(rating))
        else:
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                try:
                    rating=self.RateLiquid(inputs)
                    rating="\nLiquidity Rating: "+str(int(rating))
                except:
                    traceback.print_exc()
        if feenotify==1:
            QuestionBox(Gtranslate("The amount has been adjusted to add a few notifications on the blockchain.\nNew Total: "+str(Decimal(amount)/Decimal(1e8))), "OK")        

        for i in SpendThis:
            balance2+=i['value']
        passthis=0
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            passthis=1
        if amount+fee > balance and passthis==0:
            QuestionBox("Not enough funds!", "OK")
            return False
        if amount+fee > balance2:
            QuestionBox("The inputs on the outgoing orders will exceed the balance. Please check your available balance and complete/cancel your unconfirmed orders.", "OK")
            return False
        checkdust=0
        if amount+fee!=balance and passthis==0:
            if amount+fee > balance - 5500:
                checkdust=1
        if amount+fee!=balance2:#Ok its less than the full balance...how much less?
            if amount+fee > balance2 - 5500:
                checkdust=1
        if checkdust==1:
            QuestionBox("The change on available inputs would be lower than the anti-dust minimum of 5500 satoshis. Try adding funds, increasing fees or free up some inputs.", "OK")
            return False
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            if special!=0:
                outs1=[]
                outs2=[]
                if special==1:
                    ftype="F"
                if special==2:
                    ftype="V"
                theamt=amount
                theamt-=nfee
                batch=0
                for i in inputs:
                    if i['value']<theamt:
                        #Batch the amounts since consecutive stakes are more common over 50k coins
                        #Also for users who receive donations or small payments it's important to avoid accidental bloat of the chain
                        batch+=i['value']
                        if batch>4999900000000:
                            outs1.append({'value':batch, 'address':address})
                            batch=0
                        theamt-=i['value']
                    else:
                        outs1.append({'value':theamt+batch, 'address':address})
                        batch=0
                        theamt=0
                        break
                if batch > 0 or theamt > 0:
                    print str(SpendThis)
                    QuestionBox("Not enough funds!","OK")
                    return False
                inx=len(outs1)
                for i in outs1:
                    sfee+=5590
                    outs2.append({'value':5590,'script':"6a"+num_to_var_int((len(hexlify('**'+str(ftype)+'**'+str(inx)))/2)).encode('hex')+hexlify('**'+str(ftype)+'**'+str(inx))})
                    inx+=1
                inx=0
                for i in outs2:
                    outputs.insert(inx, i)
                    inx+=1
                for i in outs1:
                    outputs.insert(inx, i)
                    inx+=1   
        count=0
        mybytes=1500 # A buffer for the fee
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            outfee=ThePeg.pegfeeperinput/10
            mybytes*=2
        else:
            outfee=34
        for amt in amtarray:
            mybytes+=outfee
        for myin in inputs:
            count+=1
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                mybytes+=ThePeg.pegfeeperinput/10
            else:            
                mybytes+=360#Double the signatures this seemed like a good rule of thumb for p2sh
        for myout in outputs:
            count+=1
            mybytes+=outfee
        mybytes2=mybytes
        mybytes=int(round(mybytes,-3))
        mybytes=mybytes*10#Convert from kb to satoshi
        mybytes+=sfee
        if BitHaloClient == True:#Bitcoin is extremely slow for large transactions, we need to really raise the fee
            mybytes=mybytes*2
        if BitHaloClient ==  False:
            if mybytes>(int(fee)):
                QuestionBox(Gtranslate("The fee is not high enough to cover the inputs.\n\nRecommended Fee:\n") + str(Decimal(mybytes)/Decimal(1e8)), Gtranslate("OK"),1)
                return False
        else:
            if mybytes>(int(fee)):
                QuestionBox(Gtranslate("The fee may not be high enough to cover the inputs. You may proceed, however consider raising the fee.\n\nRecommended Fee:\n") + str(Decimal(mybytes)/Decimal(1e8)), Gtranslate("OK"),1)
        if BitHaloClient == True:#Lets see if the fee is high enough for the network traffic
            if int(fee)/int(mybytes2)<int(btcfeekb):
                recommended=str(((Decimal(btcfeekb)*Decimal(mybytes2))+10000)/Decimal(1e8))
                res=QuestionBox(Gtranslate("The fee is not high enough for a fast confirmation in the Bitcoin network. It's possible you have many small inputs or that the network is experiencing high traffic. Please raise the fee to the recommended amount of satoshis per kilobyte.\n\nCurrent Satoshis/KB:\n")+str(int(fee)/int(mybytes2))+Gtranslate("\n\nRecommended Satoshis/KB:\n")+str(btcfeekb)+Gtranslate("\n\nRecommended minimum fee:\n")+recommended, Gtranslate("OK"),1)
                return False        
        #Lets add the information for this order so that it does not get spent twice.
        Order = {}
        Order['inputs']=inputs
        Order['total']=Total
        Order['change']=str(Decimal(Total)/Decimal(1e8)-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8))
        Order['amount']=amount
        Order['fee']=fee
        Order['address']=address
        Order['type']="2STEP"
        Order['ordernumber']=os.urandom(16).encode('hex')
        Order['version']=CoinSelect['HaloName'] + " " + clientversion
        Order['timestamp']=timest
        if special!=0:
            Order['special']=special
        #Adding their output
        if amtarray==[]:
            out={'value':amount-nfee,'address':address}
            if special==0:
                outputs.append(out)
        pos=0
        for amt in amtarray:
            try:
                b58check_to_hex(adarray[pos])
                out={'value':int(abs(Decimal(amtarray[pos])*Decimal(1e8))),'address':adarray[pos]}
                outputs.append(out)
                pos+=1
            except:
                QuestionBox("One of the addresses or amounts you entered was invalid.", "OK")
                return False
        Order['outputs']=outputs

        QuestionBox("During 2 step sends you want to make sure it does not interfere with contract negotiations. If multiple computers are involved, make sure they share the same contracts file or try to perform all your contracts from the same location.", "OK")
        if amtarray==[]:
            mbox = QuestionBox(Gtranslate("2-Step Send") + "\n"+Gtranslate("Address: ") + address + "\n"+Gtranslate("Amount: ") + str(Decimal(amount)/Decimal(1e8)) + "\n"+Gtranslate("Fee: ") + str(Decimal(fee)/Decimal(1e8)) + rating + "\n"+Gtranslate("Total: ") + str(Decimal(amount)/Decimal(1e8)+Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + "\n"+Gtranslate("Change: ") + str(Decimal(Total)/Decimal(1e8)-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8)) + Gtranslate("\n\nPlease confirm the details.\n\nNote:\nCoins works just like cash. For more information\non how Halo manages change please read the\ndocumentation from the help menu."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
        else:
            mbox = QuestionBox(Gtranslate("2-Step Send") + "\n"+Gtranslate("Address: ") + address + "\n"+Gtranslate("Amount: ") + str(orgamount) + "\n"+Gtranslate("Fee: ") + str(Decimal(fee)/Decimal(1e8)) + rating + "\n"+Gtranslate("Total: ") + str(Decimal(amount)/Decimal(1e8)+Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + "\n"+Gtranslate("Change: ") + str(Decimal(Total)/Decimal(1e8)-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8)) + Gtranslate("\n\nPlease confirm the details.\n\nNote:\nCoins works just like cash. For more information\non how Halo manages change please read the\ndocumentation from the help menu."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
        if mbox == 1:
            return False
        mtmp=""
        if special!=0:
            mtmp=mktx_script(timest,inputs,outputs)
        sigs,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename1, PrivKeyFiledir1, timest, tmptx=mtmp, splashme=1, unlockthis=lockforspending)
        if result == False:
            QuestionBox("Incorrect password.", "OK")
            return False
        ForwardEmail=""
        manual=0
        if multisig in AdvanceArray:
            if 'ForwardEmail' not in AdvanceArray[multisig]:
                AdvanceArray[multisig]['ForwardEmail']=""
            if AdvanceArray[multisig]['ForwardEmail']!="":
                ForwardEmail=AdvanceArray[multisig]['ForwardEmail']
                    #Want to make sure forward email isnt self, prompt for saving sig file manually or sending to email
        if ForwardEmail=="":
            ForwardEmail, ok = QtGui.QInputDialog.getText(window, "Halo", Gtranslate('Please enter the Email or Bitmessage address. Or click cancel to save the file and send manually.'))
            ForwardEmail=str(ForwardEmail)
            if str(ForwardEmail)=="":
                manual=1
        else:
            mbox = QuestionBox(Gtranslate("Click OK to continue and automatically send to ")+ForwardEmail+Gtranslate(" or click Cancel to save the signature file and send manually."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
            if mbox == 1:
                manual=1
        if manual==1:
            privpath1 = QtGui.QFileDialog.getSaveFileName(window,Gtranslate("Choose a location to save your signature file."),MacDir()+"signature1.sig","Signature File (*.sig)")
            if str(privpath1)=="":
                return False
            with open(str(privpath1),'a+') as f:
                f.close()
                pass
            with open(str(privpath1),'w') as f:
                f.write("SEND THIS SIGNATURE FILE TO YOUR 2ND PARTY/LOCATION VIA EMAIL/ETC TO COMPLETE THE TRANSACTION.\n")
                f.write(str(sigs)+'\n')
                f.write(str(Order)+'\n')
                f.flush()
                os.fsync(f)
                f.close()
        else:
            Reply={}
            Reply['Order']=Order
            Reply['sigs']=sigs
            Reply['ordernumber']=Order['ordernumber']
            Reply['type']="CONTRACT"
            Reply['status']="Joint 2 Step"

            Reply['Process']='2Step'
            Reply['version']=CoinSelect['HaloName'] + " " + clientversion
            Reply['currentblock']=CurrentBlock

            GetEmailGlobals()
            BitAddr=GetfromCfg("#BitMessage#")
            if "@" in ForwardEmail:
                if MyEmail=="" or MyEmail==" ":
                    QuestionBox("No email loaded! Please try reloading your email.", "OK")
                    return False
                Reply['MyBMAddress']=MyEmail
            else:
                if "BM-" not in BitAddr:
                    QuestionBox("Incorrect Address!", "OK")
                    return False
                Reply['MyBMAddress']=BitAddr
            Reply['TheirBMAddress']=str(ForwardEmail)
            Reply['BitHaloClient']=BitHaloClient
            Reply['Command']='Send'
            BitQueue.append(Reply)
            SaveQueue()
        OnOrders.append(Order)
        #Add to the history panel
        hist={}
        hist['Amount']=str(dropzeros((Decimal(amount)/Decimal(1e8)),1))
        hist['Details']=Order
        hist['Details']['date']=ConvertDate(HaloTime,0)
        hist['Details']['Pending']=True
        if rating!='':
            hist['Details']['rating']=rating.split(": ")[1]
        hist['Type']="Two Step"
        hist['Label']=''
        global HistoryDetail
        if multisig not in HistoryDetail:
            HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
        if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
            HistoryDetail[multisig]=[hist]
        else:
            HistoryDetail[multisig].insert(0,hist)
        PopulateHistory()

        myorder="Unconfirmed order(click for options): " + str(Order['ordernumber'])
        window.HistorylistWidget.addItem(str(myorder))
        updatesomething = 1
        return True

    def TwoStepSendpt2(self, MyOrder=None):
        global Spendable, OnOrders, updatesomething
        global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected
        if MyOrder==None:
            MyOrder={}
        if keysconnected == "0":
            QuestionBox("No keys connected!", "OK")
            return False
        rating=''
        auto=0
        mch=0
        balance=GetfromCfg("#prevbalance#")
        balance = int(Decimal(balance)*Decimal(1e8)) #We use Decimal to be extra sure there are no slip ups between conversions
        if MyOrder==False:
            MyOrder={}
        if MyOrder=={}:
            privpath1 = QtGui.QFileDialog.getOpenFileName(window,Gtranslate("Please locate and open your signature file."),MacDir()+"signature1.sig","Signature File (*.sig)")
            if str(privpath1)=="":
                return False
            data=[]
            with open(str(privpath1),'r') as fi:
                data=fi.readlines()
                fi.close()
            sigs2=json_deep_copy(data[1].strip(),1)
            Order=json_deep_copy(data[2].strip(),1)
        else:
            i=0
            for c in MyContracts:
                if c['ordernumber']==MyOrder['ordernumber']:
                    mch=1
                    break
                i+=1
            if mch==0:
                return False
            Order=MyOrder['Order']
            sigs2=MyOrder['sigs']
            print MyOrder['ordernumber']
            if 'auto' in MyOrder:
                auto=MyOrder['auto']
                if MyOrder['auto']==1:
                    MyContracts[i]['auto']=0
                    if keysconnected == "1":
                        p,res=DecryptPrivateKey(PrivKeyFilename1, PrivKeyFiledir1,"1")
                        if res=="2":
                            return False
                    if keysconnected == "2":
                        p,res=DecryptPrivateKey(PrivKeyFilename1, PrivKeyFiledir1,"1")
                        if res=="2":
                            return False
                        p,res2=DecryptPrivateKey(PrivKeyFilename2, PrivKeyFiledir2,"1")
                        if res2=="2":
                            return False
        address = Order['address']
        amount = Order['amount']
        fee = Order['fee']
        valid=0
        #Below we check for seemingly valid inputs and we correct to a satoshi amount and absolute values
        testaddr=address
        testaddr=testaddr.replace(".","")
        if "@" in testaddr:
            QuestionBox("You need both keys loaded to use Pay To Email!", "OK")
            return False
        if "Script:" in testaddr:
            QuestionBox("You need both keys loaded to use Exotic Spending!", "OK")
            return False                  
        if re.match("^[A-Za-z0-9,]*$", testaddr):
            valid=1
        if valid==1:
            if "Script:" not in testaddr and "@" not in testaddr:
                try:
                    b58check_to_hex(address)
                except:
                    QuestionBox("Address is incorrect or contains spaces!", "OK")
                    return False
        else:
            return False
        try:
            float(amount)
        except ValueError:
            pass #print "Not a number!"
            return False
        try:
            float(fee)
        except ValueError:
            pass #print "Not a number!"
            return False
        multisig,multiscript=create_multisig_address(PrivKeyFilename1)
        inputs=Order['inputs']
        outputs=Order['outputs']
        timest=Order['timestamp']
        Total=Order['total']
        samecomputer=0
        pos=0
        for o in OnOrders:
            if o['type']=="History" or o['type']=="Spendable":
                continue
            if o['ordernumber']==Order['ordernumber']:#They must be signing from the same client they sent from
                samecomputer=1
                break
            pos+=1
            for input1 in o['inputs']:
                for input2 in Order['inputs']:
                    if input1==input2:
                        if auto==0:
                            QuestionBox("The order conflicts with another order or contract. Please check your computers/orders/clients and try again.", "OK")
                        return False
        if samecomputer==0:
            #Checking available balance after unconfirmed contracts/orders
            global Spendable
            if len(Spendable)<1:
                if  auto==0:
                    QuestionBox("The history is not up to date or there are no available inputs. Please wait or refresh the internet connection.", "OK")
                self.Tabs.setCurrentIndex(3)
                return False
            balance2=0
            SpendThis=list(FilterSpendable(OnOrders,Spendable))
            for i in SpendThis:
                balance2+=i['value']
            passthis=0
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                passthis=1
            if amount+fee > balance and passthis==0:
                if auto==0:
                    QuestionBox("Not enough funds!", "OK")
                return False
            if amount+fee > balance2:
                if auto==0:
                    QuestionBox("The inputs on the outgoing orders will exceed the balance. Please check your available balance and complete/cancel your unconfirmed orders.", "OK")
                return False
            checkdust=0
            if amount+fee!=balance and passthis==0:
                if amount+fee > balance - 5500:
                    checkdust=1
            if amount+fee!=balance2:#Ok its less than the full balance...how much less?
                if amount+fee > balance2 - 5500:
                    checkdust=1
            if checkdust==1:
                if auto==0:
                    QuestionBox("The change on available inputs would be lower than the anti-dust minimum of 5500 satoshis. Try adding funds or free up some inputs.", "OK")
                return False
        #If its a different computer or something is wrong then BlackHalo will see an input that is no longer available and report it
        SpendThis=list(FilterSpendable(OnOrders,Spendable))
        for input1 in Order['inputs']:
            match=0
            for s in SpendThis:
                if s['output']==input1['output']:
                    match=1
            if match==0 and samecomputer!=1:#One of the inputs is missing or we are sending from a different computer
                if auto==0:
                    QuestionBox("One of the inputs to this order is no longer available or not spendable. First check that you have no exotic spend inputs or password protected inputs that require your attention in the history panel. Also make sure you complete 2 step sending before starting new orders. Try to avoid creating conflicting orders on seperate computers. Please check your computers/orders/clients and try again.", "OK")
                return False
        if rating!='':
            rating="\nLiquidity Rating: "+str(int(rating))
        else:
            if 'pegging' in CoinSelect and CoinSelect['pegging']:
                try:
                    rating=self.RateLiquid(inputs)
                    rating="\nLiquidity Rating: "+str(int(rating))
                except:
                    traceback.print_exc()
        if auto==0:
            mbox = QuestionBox(Gtranslate("2-Step Send") + "\n"+Gtranslate("Address: ") + address + "\n"+Gtranslate("Amount: ") + str(Decimal(amount)/Decimal(1e8)) + "\n"+Gtranslate("Fee: ") + str(Decimal(fee)/Decimal(1e8)) + "\n"+Gtranslate("Total: ") + str(Decimal(amount)/Decimal(1e8)+Decimal(fee)/Decimal(1e8)) + "\n\n"+Gtranslate("Change Address: ") + str(multisig) + "\n"+Gtranslate("Change: ") + str(Decimal(Total)/Decimal(1e8)-Decimal(amount)/Decimal(1e8)-Decimal(fee)/Decimal(1e8)) + Gtranslate("\n\nPlease confirm the details.\n\nNote:\nCoins work just like cash. For more information\non how Halo manages change please read the\ndocumentation from the help menu."), Gtranslate(" OK "), Gtranslate(" Cancel "),1)
            if mbox == 1:
                return False
        mtmp=""
        if 'special' in Order:
            if Order['special']!=0:
                mtmp=mktx_script(timest,inputs,outputs)
        #Lets get that other signature
        splashthis=0
        if MyOrder=={}:
            splashthis=1
        if keysconnected == "1":
            sigs,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename1, PrivKeyFiledir1, timest, tmptx=mtmp, splashme=splashthis, unlockthis=lockforspending)
        if keysconnected == "2":
            sigs,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename2, PrivKeyFiledir2, timest, tmptx=mtmp, splashme=splashthis, unlockthis=lockforspending)
            if set(sigs)==set(sigs2):#They are doing something weird like switching keys around and signing from the same computer
                sigs,result=create_sig_for_redemption(inputs,outputs, PrivKeyFilename1, PrivKeyFiledir1, timest, tmptx=mtmp, splashme=splashthis, unlockthis=lockforspending)
        if result == False:
            if auto==0:
                QuestionBox("Incorrect password.", "OK")
            return False
        pass #print "Signing was a success:", sigs,sigs2,inputs,outputs
        #Ok this is getting exciting... lets broadcast!
        busy=0
        #if MyOrder=={}:
        #    busy=NetSplash(1)
        if busy==0:
            tx,result=broadcast_to_network(sigs2,sigs,inputs,outputs,PrivKeyFilename1, timest, tx=mtmp, splashme=splashthis)
            #If this fails, we may need to apply the sigs in another order. They have to be applied in the order the account was created... its just easier to guess
            if "TX rejected" in str(result) and "Network busy, try again later." not in str(result):
                tx,result=broadcast_to_network(sigs,sigs2,inputs,outputs,PrivKeyFilename1, timest, tx=mtmp, splashme=splashthis)
        else:
            result="TX rejected: Network busy, try again later."
        #if MyOrder=={}:
        #    NetSplash(0)            
        if "TX rejected" in str(result):
            if auto==0:
                QuestionBox(str(result), Gtranslate("OK"),1)
            return False
        else:
            NewOrder={}
            NewOrder['type']="SPENT"
            NewOrder['total']=Total
            NewOrder['change']=Order['change']
            NewOrder['currentblock']=CurrentBlock
            NewOrder['Confirmation TXID']=txhash(tx)
            NewOrder['ordernumber']=os.urandom(16).encode('hex')
            NewOrder['inputs']=inputs
            NewOrder['output']=outputs
            NewOrder['amount']=amount
            NewOrder['fee']=fee
            NewOrder['address']=address
            NewOrder['timestamp']=timest
            NewOrder['version']=CoinSelect['HaloName'] + " " + clientversion
            OnOrders.append(NewOrder)

            hist={}
            hist['Amount']=str(dropzeros((Decimal(amount)/Decimal(1e8)),1))
            hist['Details']=NewOrder
            hist['Details']['date']=ConvertDate(HaloTime,0)
            hist['Details']['Pending']=False
            if rating!='':
                hist['Details']['rating']=rating.split(": ")[1]
            hist['Type']="Two Step"
            hist['Label']=''
            global HistoryDetail
            if multisig not in HistoryDetail:
                HistoryDetail[multisig]=[{'Label':'','Type':'','Amount':'','Details':''}]
            if HistoryDetail[multisig]==[{'Label':'','Type':'','Amount':'','Details':''}]:
                HistoryDetail[multisig]=[hist]
            else:
                HistoryDetail[multisig].insert(0,hist)
            PopulateHistory()

            myorder="Spent coins! Waiting for confirmations(click here if the order never confirms):      Order number:  " + NewOrder['ordernumber'] + "   Confirmation TXID: " + NewOrder['Confirmation TXID']
            window.HistorylistWidget.addItem(str(myorder))
            if samecomputer == 1:
                OnOrders.pop(pos)
            if auto==0:
                QuestionBox(str(txhash(tx))+Gtranslate("\nSuccess! It may take a moment to reflect in your balance."), Gtranslate("OK"),1)
            if mch==1 and auto==1:
                DeleteContract(i)
            SaveContracts()
            return True

    def activate(self,reason ):
        if reason==2:
            self.show()
    def __icon_activated(self, reason):
        if reason == QtGui.QSystemTrayIcon.Trigger:
            self.show()
    def closeEvent(self, event):
        global MacWine
        app.setActiveWindow(window)
        CloseEvent=GetfromCfg("#CloseEvent#")
        if CloseEvent=="0":
            if MacWine==0:#It's not our wine build, give option for system tray
                event.ignore()
                mbox = QuestionBox("The default for this button is to minimize to the system tray. However, if you prefer to change the behavior of this button to exit Halo when clicked, then you may choose now.", " Minimize to system tray(default) " , " Exit Halo ")
                if mbox == 1:
                    UpdateCfg('#CloseEvent#',"2")
                else:
                    UpdateCfg('#CloseEvent#',"1")
                return
        HideWindows()
        if CloseEvent=="1":
            event.accept()
            self.icon.show()
            self.hide()
        else:
            event.ignore()
            self.ExitHalo()
    def Donate(self):
        self.Tabs.setCurrentIndex(1)
        msig, mscript = create_multisig_from_publics("040643fda0973ee136eb85dabee148c179dbfa377df21211a6b5657c5f7a1cd4c0c58c42676b79e49ca1c82b95b75ea09055441f3754f4d44b1040d2bd568d2d12","04a8520df18acb120a269a1f70d0c8752d5005dc563408147a3ad4033e2314d8be319af3ae67e2aea8b2e3c73f41025de53eedea97cb2f2fce7492e441753c3317")
        if BitHaloClient==True:
            self.BitPayTo.setText(msig)
        else:
            self.BitPayTo.setText(msig)
    def OpenWallet(self):
        OpenWallet()
    def Website(self):
        webbrowser.open(CoinSelect['website'])
    def NewWallet(self):
        global mycfg, PrivKeyFilename1, PrivKeyFilename2, PrivKeyFiledir1, PrivKeyFiledir2, keysconnected
        global updatesomething
        result=NewWallet()
    def BackUpWallet(self):
        BackupWallet()
    def ExitHalo(self):
        #We do a clean exit with a global.
        global downloadThread, bitmessThread, blackcoindThread, RunPython, ThePeg, FileSave, RPC, DontExit, rescanning, BitMHalo, debug, MacWine, Exiting, BitMRPC, BlackUnspent, BridgeDriver, TheBridgeThread
        #We need to clear the clipboard because if it has lots of data it can crash on exit
        Exiting=1
        clipboard = app.clipboard()
        clipboard.clear()
        if rescanning != 0:
            mbox = QuestionBox("You are in the middle of rescanning the blockchain, it's recommended that you wait. Are you sure you want to exit?", " Yes ", " No ")
            if mbox == 1:
                return
        res=GetfromCfg("#ExitDuringContracts#")
        if res=="0" or res=="2":
            found=0
            for c in MyContracts:
                found=1
            if found==1:
                mbox = QuestionBox("You are in the middle of negotiations, it is recommended that you keep the program open as much as possible during Pending Offers and Open Contracts. This way, you can stay in communication with the other parties. Are you sure you want to exit?", " Yes ", " No ")
                if mbox == 1:
                    return
                mbox = QuestionBox("Would you like to prevent Halo from showing this message in the future?", " Yes ", " No ")
                if mbox == 1:
                    UpdateCfg('#ExitDuringContracts#',"2")
                else:
                    UpdateCfg('#ExitDuringContracts#',"1")
        if str(self.exitvar)!="exit":
            OutboxWindow.populate()
            if OutboxWindow.CL.count()>0:
                mbox = QuestionBox("There is still messages in the outbox that are being sent. It is recommended that you wait. Are you sure you want to exit before Halo finishes sending?", " Yes ", " No ")
                if mbox == 1:
                    OutboxWindow.show()
                    return
            #If anything freezes here check the locks            
            if AdvanceArray['MySettings']['ClearLocation']:
                UpdateCfg('#PrivKeyFilename1#',"")
                UpdateCfg('#PrivKeyFilename2#',"")
                UpdateCfg('#PrivKeyFiledir1#',"")
                UpdateCfg('#PrivKeyFiledir2#',"")
                UpdateCfg('#keysconnected#',"0")
                time.sleep(.2)
            while "1" in str(DontExit) or ThePeg.writing==1:
                time.sleep(.1)
            SaveContracts()
            SaveOtherdata()
            SaveQueue()
            time.sleep(.11)
            while "1" in str(DontExit) or ThePeg.writing==1:
                time.sleep(.1)
        window.hide()
        downloadThread.stop()
        bitmessThread.stop()
        blackcoindThread.stop()
        RPC.stop()
        FileSave.stop()
        RunPython.stop()
        TheBridgeThread.stop()
        if ThePeg.exchangerunning:
            print "Shutting down exchange..."
            ThePeg.stopexchange=1
            tick=0
            while ThePeg.amrunning:
                time.sleep(1)
                tick+=1
                if tick==120:
                    print "The Peg Thread is taking too long to quit, will force exit."
                    break
            print "Success!"
        ThePeg.stop()
        downloadThread.exit()
        bitmessThread.exit()
        blackcoindThread.exit()
        RPC.exit()
        FileSave.exit()
        RunPython.exit()
        TheBridgeThread.exit()
        try:
            if debug != 0:
                sys.stdout = sys.__stdout__
                sys.stderr = sys.__stderr__
                with open("debug.txt",'w') as f:
                    for d in debug.content:
                        f.write(str(d))
                    f.flush()
                    os.fsync(f)
                    f.close()
        except:
            traceback.print_exc()
        try:            
            if BridgeDriver != "":
                BridgeDriver.quit()
        except:
            print "Exception closing bridge subprocess"
        try:
            BitMRPC = xmlrpclib.ServerProxy('http://localhost:8878')
            try:
                socket.setdefaulttimeout(10)
            except:
                print "Socket timeout not set"
            BitMRPC.ExitBitmessage("password")
            try:
                socket.setdefaulttimeout(None) 
            except:
                pass
            print "Success!"
        except:
            print "Could not connect to Bitmessage for clean exit. "        
        try:
            tick=0
            while BitMHalo.poll() == None:
                time.sleep(1)
                tick+=1
                if tick==30:
                    print "Bitmessage is taking too long to quit, will force exit."
                    break
            print "Bitmessage has closed successfully!"
        except:
            traceback.print_exc()        
        self.icon.hide()
        try:
            kill_subprocesses()
        except:
            pass
        try:
            if os.name == 'nt':
                os.system('taskkill /f /im BitMHalo.exe')
        except:
            try:
                subprocess.call("c:\\windows\\system32\\taskkill.exe /im BitMHalo.exe /f")
            except:
                try:
                    os.system("tskill BitMHalo")
                except:
                    pass
        if os.name == 'nt' and MacWine == 0:
            try:
                os.remove(os.path.join(application_path,"HaloTemp.tmp"))
            except:
                pass
        
        if 'pegging' in CoinSelect and CoinSelect['pegging']:
            try:
                with open(os.path.join(application_path,"liquiditydata.dat"),'wb') as f:
                    f.write(bsonjs.loads(json.dumps({'1':BlackUnspent},cls=DecimalEncoder)))
                    f.flush()
                    os.fsync(f)
                    f.close()
            except:
                pass
        #One of the reasons for crashing on exit, is the forced exit of BitMHalo. So it's best to wait for a few seconds.
        #Eventually the code should be modified for a clean exit of BitMHalo by sending it a message via RPC
        time.sleep(1)
        try:
            sys.stdout.flush()
            sys.stdout.close()
        except:
            pass
        gc.collect()        
        #If memory leaks happen you can collect all the variables with pympler or get the major ones and make them "None"
        sys.exit()
        try:            
            os._exit(0)#This does bypass memory cleanup however so sys.exit is also used
        except:
            pass
        exit()
        try:
            sys.exit(app.exec_())
        except:
            pass
    def DynamicPegInfo(self):
        res=QuestionBox("There is several useful PDF files located in the install directory which explain the dynamic peg. You may also access them from this menu. For more information and frequently asked questions, visit the official site, forums, blog or community social media outlets.", "Visual Reference", "Introduction", "Cancel")
        if res==0:
            try:
                subprocess.Popen('bitbay-dynamic-peg-visual-reference.pdf', shell=True)
            except:
                QuestionBox("The PDF file did not open. However, it is located in your main Halo folder. Try opening it manually or download it from our website.", "OK")
        if res==1:
            try:
                subprocess.Popen('bitbay-dynamic-peg-intro.pdf', shell=True)
            except:
                QuestionBox("The PDF file did not open. However, it is located in your main Halo folder. Try opening it manually or download it from our website.", "OK")
    def AboutUs(self):
        QuestionBox("Halo v"+str(clientversion)+"\nOpen Source", "OK",1)
        #\nGNU General Public License\nMIT The MIT License

#NOTES
"""#Key: # is a probable task ## Symbolizes a good idea or a note"""
##For now, we only do reputation txid logging when using daemon. This prevents a large download queue in BitHalo, wallets don't unlock to sign with original key for tx3 which may totally change on counters.
##Force guarantors to unlock their wallets and sign tx3. We could also give the option for BitHalo to run full nodes instead of bogging with downloads(if they want rep data).
##To make reputation system more concrete, we could check tx1 and tx2 during submission or signatures for valid public key to match given identity. Could also give the possibility for unconfirmed reputation data

##In order to make this code API ready input boxes need a way to send data, check UI silence defaults and functions need return statements. Potentially seperate some logic and deobfuscate some useful functions. List examples.
##For the peg remember to have a way of handling time locked inputs which might conflict with freezing rules or potentially interfere with switches (try to not send frozen funds to timelocks)
##Client speed is greatly effected by images sent in the email as text in private offers, has the new UI updating in Scanmessages fixed this?
##Unconfirmed in BitHalo somehow ended up in Spendable, wait more confirmations?
##Users who use Wine build and save files manually might make them not well read by Windows if saved in Mac

##ONCE Halo becomes multicoin, is it better to use CoinSelect instead of BitHaloClient so transactions don't get confused(and magic byte)
##In order to manually add nodes into Bitmessage, we need follow the logic in defaultKnownNodes.py and helper_bootstrap.py to edit
##Since we already created a custom data directory in PyBitmessage. it would be easy to add a node based on a file or added API command
##In class_receiveDataThread.py nodes are added like this... shared.knownNodes[recaddrStream][peerFromAddrMessage] = (timeSomeoneElseReceivedMessageFromThisNode)
##Also, if its multicoin, addresses will be the same for similar magic bytes. So need to modify all of that.
##Consider timing off current blockchain in use instead of bitcoin since its more resilliant to server hacks(or perhaps both)
##Possibly wait for more confirmations when broadcasting (for better security on double spend confusion)
##Consider sending new contact address in Escrow in case of emergency (encrypted message) OR Allow changing of their contact info

##Eventually give the ability to activate a setting to allow users to not have to put up the money until a counter offer.
##Will want to unlock and implement features for BitHalo when the software is complete
##It could be made possible to look at and validate the chain of title for Notarized Objects and allow forms of transfer
##Consider basic atomic trades through the market between Halo coins.
##For atomic trade remember to add a OP_SIZE check for hashes so the script doesn't get too big
##82+hexlen(16)+16+87 then ensure that the utf-8 length is always 16
##might need to change requests to version 2.11.1 if we get handshake issues

##Give way to load backup from logs(other than copy+paste)
##Change denominations and anti-dust minimum etc in settings?
##Hindi font is missing in some windows 10 can fonts be loaded into the software?
##change from ast.literal_eval to json.loads for speed concerns, make sure extremely large dictionaries can be read
##change to a database system so this can scale
##The code may need a refactor to make it more modular
##In order to scale the code the accounts need to be a combination of things that are spendable. This way a server can manage many accounts
##Will eventually want a server version of this software managing multiple accounts and contracts able to take requests from multiple users to sign
##Once a refactor happens and accounts are modular, a server could interact with users asking for signatures when needed
##If a server can monitor accounts then the client side could be full JavaScript and we could have a web version of this. Also, users could backup via their personal email.
##A Bitmessage relay would greatly improve the feel of the markets
##Some people want fancier graphics so it would be cool to enhance them at some point
##Potentially upgrade pybitcointools for new curve
##If segwit ever changes requirements for transactions we would have to update our libraries
##Bug to watch out for is once the history query didn't return a list but the txid being queried
##Linux bug where the system tray icon doesn't change away from BitHalo icon
##2 Step in escrows? Can it be done without changing advanced commitments? Or does it always cash out.
##Allow users to change the password of a key file
##Speed up sync with online explorers

#Verify Inputs and signatures for Contracts before broadcast(double check)
#NightTrader microtrader or simple atomic trade? Or consolidate site to show how to do this in Halo (to not lose brand)
#Python contracts using exec with instructions of simple unobfuscated variables

##Possibly reset spending form
##Markets UI should not list every order if it could possibly hang the UI (assuming 10,000 orders or something). Breaking things into sections for hanging UI perhaps!?
##To switch from the modern skin to the classic one, let users restart the software for original Halo style for BitBay

##Should we detect sender in BitMHalo for foreign gmail? should we really skip all folder if there are filters?
##Some more ideas: Email bouncers, Make a bet/derivative, Games, Backing, Shareholders and Voting, Hedging and Multipool (Multipool with multisig and time locks?), Trading notarized object
##Update whitepaper possibly add fund and forget, malleability fix, anonymous checklocktimeverify and atomic double deposit.
##To possibly improve Bitmessage, consider burn, whitelist and adding custom known nodes, consider new ports and timelocks
##Bitmessage could forgo the POW method with timelocked funds per kilobyte
##Is it possible to compartmentalize Bitmessage with whitelist or something to scale it

##Clean code and redundancy, refactor
##Give attachment instead of inline option for Pay to Email. This way bitmap can be downloaded/imported manually
##Perhaps add markdown options for more graphics, styling and images on offers
##Allow for emailing keys to self as backup? Or even emailing contracts.dat on occasion?
##Add how contracts encrypt the keys to the counter-party which is useful for recovery options
##Move all files up one directory to keep it cleaner
##Add 6a instead of obscure burn address or make burn like bitcoin eater?
##Fees on pay to email not covered by sender and receiver uses old fee paid(perhaps ask them to add another minimum fee?)
##Consider encoding in bytes for efficient blockchain messaging. Some serialize function perhaps? Or perhaps serialized key names? Compress values?
##If we still have problems with bittmp or messages.dat crashing then consider better method of handling large data or inbox cleanup (why does it break?)
##Instead of broadcasting completion blindly, check the account itself and the txids... check txids for result to see if cancelled or confirmed
##Outbox for failed emails has not always worked out. Perhaps stall Bitmessage if an email fails and/or send an api command alerting the Halo client
##Eventually see if we can use the removeaddress command to update wallet.dat after close of escrow?
##Can possibly speed up loading by not checking all wallets in wallet.dat and only check the ones in our contracts and main account
##Possibly discover seed nodes by Bitmessage broadcast!?
##Perhaps give an anonymous broadcast option leveraging Bitmessage!? You could check mempool to see if others have done it yet.
##Make it so rates are only autoaccepted within 30 minute time frame? Detect time by time of message receipt
##See if we can check rates based on a range within a timeframe to see if it was within it
##Might need counters to INCREASE fee in the future versions or at least for their first transaction especially in bids and counters. You can also use minimum fee.
##Possibly have change management check for a large and well distributed amount of inputs and have criteria for when it's okay not to search for inputs to subdivide
##At some point consider using cython, numba, numpy or scipy for some opertaions and test parts of code to see where speed can be increased

##Potential issue in tendo caused Halo to not start once: Traceback (most recent call last): File "C:\Python27\lib\site-packages\tendo\singleton.py"...
##line 42, in __init__  self.lockfile, os.O_CREAT | os.O_EXCL | os.O_RDWR) OSError: [Errno 17] File exists: 'c:\\users\\david\\appdata\\local\\temp\\C-BitBay-BlackHalo2-.lock'
##execs and dialogs can hang the gui... although they are forced to respond, its possible to put a timeout on execs and default to cancel which is usually 1
##For muting the GUI it's probably good to be more consistent with default options so API can use the same silencing value for all the functions.
##non hex digit found during extension change (maybe Linux) causing keys to not be loadable
##QWebView can be converted to textBrowser if we decide to not allow html in descriptions. Still java and other things are disabled
##should normal send auto adjust fees?
##QuestionBox detects for integers, could just explicitly define the variable
##Can load font as resource for cross-platform? https://forum.qt.io/topic/3962/cross-platform-and-font-sizes/11
##Find and replace for font tip: (myQLabel.*\n.*\n.*\n.*\n.*)(self.*setStyleSheet)    replaced with:   $1#$2
##It is possible Bitmessage will have to be updated eventually for better performance
##If updating Bitmessage is needed look at branches such as https://github.com/mailchuck/PyBitmessage/releases/tag/v0.5.8
##If updating Bitmessage COMPARE: class api shared cleaner bitmhalo helperstartup pyelliptic -- - archive new bm files, check compatible pyinstaller. Test exhaustively if decision is made to port -- CHANGE: sleeptill = int(time.time()) + 2.5*24*60*60
##Foreign emails take longer to load since BitMHalo will not skip folders
##One way to tag emails for more ability to clean old emails is to put some extra data in before encrypting
##Its possible in the future to add the automatic GTranslate option to ATemplates. First would need to change any functions that reads the text of selections
##if time permits, rewrite documentation and as a pdf and possibly with training videos?
##Is there any way to restore jpeg plugin cross-platform without the DLL not loading? The command is QPlugin = QtCore.QPluginLoader("C:/BitBay/imageformats/qjpeg4.dll") followed by QPlugin.load()
##It might be possible to fix jpeg plugin by upgrading to PyQt5 however this is unclear, For now we convert to PNG. No cache is stored yet although it can be considered in the future or limit the number of orders displayed at once
##optipng -o7 -strip "all" Strips out profiles for libpng warning however it changes the png so best to ignore or find a way to mute it
##We let people spend when not fully synchronized by a fraction but perhaps we should require them to be within a few blocks
##We should probably also check for a lot of nodes before spending so transactions don't hang. Allow for easy resubmit in pending transactions.
##diskcache 2.4.1 can be used for potentially enhanced memory performance or potentially a flush file cache program
##Eventually move to MongoDB or other database system such as Rocks/MongoRocks may need partial refactor.
##Require more than 1 confirmation or have a setting. This is also a potential solution for reorganizations on staking
##Eventually modify chain so it prunes old spent transactions and sets a checkpoint and let nodes know to accept the pruned chain making it more account driven give option to store everything for data analysis
##If pruning is used then seperate database would be needed for node reputation system. Also staking can be sharded by address and also shared between nodes based on power of node (benchmark the nodes).
##To speed up Mac Wine startup modify the config file by altering checkblocks and checklevel settings and maybe dbcache
##Timing could be done off of the blockchains block instead of Bitcoins block. Also some things don't default to timestamp timing when they could.
##The timestamp on bitbayd sometimes gets interfered with by the ISP on certain computers even when clock is correct. So to diagnose it makes sense to test by tethering to your phone.
##If it seems like sometimes changing text of special labels doesn't resize the font then try to trigger the event by resizing it
##Sound effect for successful stake? Perhaps add a staking icon? Perhaps staking calculator and time estimate
##WineSkin Mac clipboard doesn't copy on all systems.
##Possibly use Bitmessage relay server type for registering addresses for exotic spend... http://34.229.189.43:3000/api/v1/orders/
##https://github.com/chrisekelley/Bitbay-relay-server
##https://bitbay.blastforge.com/market/_all_docs?include_docs=true ... or paginated https://bitbay.blastforge.com/market/_all_docs?include_docs=true&limit=5&skip=5
##Eventually upgrade Bitmessage and pyelliptic library
##Maybe allow for switch accounts since we have exotic spend
##Possibly make/enable a transaction builder with input adding, output adding, sighash, and custom scripts with signing method for indefinite number of parties, and method to sign special scripts and description of sighashes/methods/etc
##There is some logic in the code for checksequenceverify however it's unclear if that can be made to be exclusive before expiry or only relative locktime. Could we fork to allow this option of exclusivity?
##If time allows, add the BitBay block explorer and allow for BitHalo style queries to the chain giving users a redundant option.
##Consider testing OP_CHECKSEQUENCEVERIFY  #https://github.com/lbryio/lbrycrd/commit/53e53a33c939949665f60d5eeb82abbb21f97128
##When requesting funds for shipping, it's better to put the funds in escrow instead of paying directly in a future update.
##We could make it easier to be able to save profiles as a contact 
##Because of the reputation system we could show more info like associated profiles
##Perhaps enable notifications when you get messages other accounts or encourage them to have email notifications
##Potentially make an open source installer. Also consider a way to check SHA hash possibly by signing during a setup script
##Make UI more interactive, with context menus, tips on hover, more immersive tables
##It might be a good idea to free up memory from time to time. Also remove sensitive variables from RAM.
##Consider integrating online order scrapers for bulk offers. For example the Amazon scraper my friend coded.
##Make option to add to DontRepopulate per account so multiple users can read the same market messages.
##allow blank exchange rate in other templates by moving ratecheck and reviewing effects
##Perhaps allow 'dontclear' on auctions or give the option so users can accept multiple winners
##Check the best bid in individual contracts to the market listing best bid
##Let users know when their offers are declined or canceled and clear
##Consider letting users remove contracts from the markets or orders if they don't load
##Eventually include notification about donating the stake and spam. Also some spam control.
##Automatic pairing suggestions for compatible orders
##Consider votes to go to 6a instead of burn addresses
##Potentially add SPV syncing options

##For the peg and escrow it's probably best to send a change buffer on the temporary transaction.
##Liquidity calculation does not deduct from pool when iterating outputs. This means the calculation will produce a slightly higher reserve balance.  Only applies if pools are used.
##If liquidity pools are used you might also do "batching" where pools must only happen at a fixed number of inputs to avoid unexpected changes to liquid distribution.
##Also it might be possible to use similar liquidity sharing system that exchanges use for the trades. This might be sharing liquidity from blocks or knowing the pool of the
##economy and their proportion to it. Although the design is complex, it may help a lot to "smooth" the rate of how fast funds move to reserve for all users.
##For perfectly accurate liquidity you need to check for a pool and remember the deduction. Then recalculate liquidity when inputs are chosen. Only applies if pools are used.
##Fund and forget is also a good peg option because it's less transactions so it can avoid the risk of rejection when sending temporary transaction
##For escrow it makes sense to increase confirmations for tx3 to make sure there was no reorganizations on the temporary transaction
##Peg software usually doesn't allow sending a small portion of coins near time where rate changes
##The interval for the peg to anticipate changes is within 10 blocks on either side and 25/10 for contracts
##Interesting feature to add to peg system would be to let users split liquidity or reserve at a specific supply to two outputs
##It may be interesting to look at sorting outputs to distribute reserve and liquid properly even though it will go in the pool
##For the special mktx_script function we should check previous nlocktime drafted and if it's the same make it higher
##It's possible to add reserve mixing for special reserve freeze transactions and function to predict the mix
##It would be useful to have trade rating API call where a trade between one or more users has it's liquidity rated
##Might want to have special accounts to let the exchanges combine reserve funds for easy mixing
##For exchange tracking we could consider forcing at least one trade before mixing the input
##Should probably add more folder permutations for Halo peg database
##Eventually consider more confirmations near peg supply change
##Peg exchange should have a function to trade all users liquidity during interval change. This should be coupled with
##a credit database in case it crashes. The trade goes from all users to the pool back to users for smooth trading experience and liquidity share.
##GUI freezes if exec a window after many days of staking. Consider a timed window that refreshes and self destructs

##Separate GUI from program logic, bring code to API level, make things more object oriented, potentially move bitmessage to main thread
##Even if bitmessage is in main thread without conflict, user messages must still be stored until successfully sent in the case of IMAP
##Better threading system can be used for IMAP and downloads.

##FOR TEMPLATE TRANSLATIONS: reference object names instead of selected text, or another solution is to translate other objects except ones that read text
##May need to double check the code for foreign language compatibility strIN in place of str and read all QT objects with strOUT

""" NOTES:
Bitmessage 2 day resending rule is modified by editing class_singleCleaner.py line 94
(216000 max age of object 60 hours) was being multiplied exponentially which can cause gaps and lose messages now we have a linear system

Bitmessage v0.6.1 is released. Potential to upgrade however API is very solid for now. So it is possible to upgrade.
https://github.com/Bitmessage/PyBitmessage/releases/

Fixed Bitmessage divide by zero in addressGenerator, it seems to work the same.

Also to build Halo cross platform, make sure you are using the latest version of all the libraries and Python

In the pybitcointools and pyblackcointools library the signature is deterministic based on the transaction and private key which is considered secure
Also we would like to take the moment to give credit to the pybitcointools devs for creating the library
"""

#Linux request bugs were fixed but upgrade of python in static build may eventually be needed: InsecurePlatformWarning: A true SSLContext object is not available. AND ALSO SSLError: [Errno bad ca_certs...
#The above issue was solved by... pip install pyopenssl ndg-httpsclient pyasn1 ... some SSL problems still persist on some systems.
#Another computer had a cacert.pem issue and this can be solved when catching it with os.environ['REQUESTS_CA_BUNDLE'] = "cacert.pem" and include the cacert.pem in Halo build
#maybe at some point would want to replace response.text with response.content.decode("utf8") to avoid "Memory error" bug from requests?!
#New SSL depreciated old Pyelliptic library. Can be fixed with this branch... pip install https://github.com/mfranciszkiewicz/pyelliptic/archive/1.5.10.tar.gz#egg=pyelliptic
#Neweset version of Bitmessage might fix Pyelliptic compatibility
#Need to find a better way to clean exit from Bitmessage

#Use chainz? Only works for balance, unspent api requires key.
#https://chainz.cryptoid.info/bay/api.dws?q=getbalance&a=bNgmCcxPKgQQqUe6rhNtbGWowMJFCuxjZ3
#For full index -addrindex is a potential source code upgrade but it may be buggy and bulky so for now keep as is
#On a fork or maybe in some rare cases with reorganizations transactions can get stuck in your wallet waiting to get into the mempool
#At some point it may be worth checking the mempool to see if the balance is conflicted
#Can get BitBay rates from https://bitbaymarket.github.io/ratedb/ and from https://bitbaymarket.github.io/ratedb/rates1k.json

#Sample locktime redeem
#https://chainz.cryptoid.info/blk/tx.dws?fa6f6ef022c83b31eede23f01b9cf99b7ad364b00b5117194bae45456ad284b9.htm

#Some things to send with counters and orders(reply) quick reference:
#All: Contact, Profiles, message(maybe), rates
#Coins: Buyer(rate(if tracking), universaltimestamp(timestamp), payment method(selected)), (reply with Payment Profile), service change on buy
#Sell/Buy: StartingBid, duration, countries, shipping, keepratio(on quantity), higherquantity, BestBid

#print str(hash_to_address(("55").decode('hex'),"Blackcoineateradios1")) #This is the way to generate the burn address for BitBay and BlackHalo

#It is possible to in some cases use chainz to notify in blocks of transactions that can be read to update balance
#Also to verify the unspent list against the chainz balance use an api call (with api key)
#example: https://chainz.cryptoid.info/bay/api.dws?q=unspent&active=bTuZboysrngsaqJvRj4db4CV2Qa21Q5Jcb&key=a6dd09e5b3fc

#More Ideas
##Identities could be registered using notary
##Multiple parties to joint accounts posting signatures to private channel for group?
##Tooltips for more user friendliness
##Online status for nodes? Node connection statistics (can we do this already with update frequency or forced update status?)
##Anonymous broadcast forwarding to the markets. Just need a way to prevent too many people submitting at once perhaps checking the mempool and perhaps even a pastebin?
##Because staking spends, we can take advantage of that for voting on forks
##Make staking more secure by having a disincentive for being dishonest about a block by having users sign the block they say is valid
##A blockchain pruning system would be a great way to keep the chain healthy. Potentially let small nodes share workload in staking pools.
##To make computation of blocks more random there is a lot of data online to assist. We can maybe even base it on other chains block hash.
##Sign txid to prevent malleability
##Allow disabling of bomb and checklocktimeverify in case one party disappears
##Perhaps make it so users can select conversion currency instead of USD
##Sidechains are a good way to scale a blockchain and do contracts. Contracts can also be Sandboxed referred to by hashes with a payload in the output.
##It's worth posting BitHalo to standard wikis for smart contracts since it was the worlds first contracting platform.

##If we get too much IP abuse force IP confirmation at server
##IP addresses for known nodes can be burnt later as can all of the above data for permanent storage but not required. Zmap also interesting.
##Also possible would be for mods to post that info every few days(or maybe even zmap)
##If needed for speed a server can be made with public keys as the account where verification is done before posting
##An application on the server maintains the market list and shares it when requested, perhaps holds reputation data as well or even does fast negotiation for NT
##https://www.pirateship.com/rates can help shippers to get lower costs. Drop shipping services should be recommended.

##Bitcoin Cash API... https://api.blocktrail.com/v1/bch/address/3P45R8RGmdLzjWgucp2X56eAexadNRrJTY/unspent-outputs?api_key=d807d2069364e506056dd36f915495430b141e80
##Blockdozer is similar API to https://blockexplorer.com/api-ref and you call it with this address... https://blockdozer.com/insight-api/


if __name__ == "__main__":
    if os.name == 'nt':
        sip.setdestroyonexit(False)
    app.processEvents()
    OpenCfg()
    OpenTranslations()
    mylang=GetfromCfg("#language#")
    if mylang=="0":
        ChangeLanguage(1)
    window = MyApp()    
    CustomForm = CustomTemplate()
    MarketWindow = WMarket()
    OutboxWindow = WOutbox()
    AdvancedWindow = AdvancedSettings()
    SetupWizard =  Wizard()
    MyDetails = WDetails()
    ExplanationWindow = Explanations()
    WinContracts = WContracts()
    WinContacts = WContacts()
    WindowHandshake = Handshake()
    WindowSent = WSend()
    WindowReceived = WReceived()
    WChangeList = ChangeList()
    WStakeList = StakeList()
    Templates=TemplateWindow()
    P2MWindow=PayToEmail()
    MySettings=Settings()
    AntiLogger=VirtualKeyboard()
    calcbrowser = QWebView()
    calcpage = QWebPage()
    calcmain_frame = QtGui.QDialog()
    Console=MyConsole()
    app.setActiveWindow(window)
    window.show()
    splash.hide()
    window.exitvar=""
    try:
        Loop()
    except:
        with open(os.path.join(application_path,"crashlog.dat"),'w') as f:
            log=str(traceback.format_exc())
            f.write(log)#It starts out as our turn
            f.flush()
            os.fsync(f)
            f.close()
        window.exitvar="exit"
        window.ExitHalo()
